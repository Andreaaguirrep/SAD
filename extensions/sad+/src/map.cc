// --------------------------------------------------------------
#include <iostream>
using std::istream;
using std::ostream;
using std::cout;
#include <cstdio>
using std::sprintf;
#include <cstdlib>
using std::atoi;
using std::exit;
#include <cstring>
using std::strstr;
#include <cmath>
using std::fabs;
using std::sqrt;

#include <map_double.h>
// Constructor


map_double::map_double(const map_double& x) 
{ 
   m=new double[N_cv];
   //   cout << " map copied to " << m << '\n';
   for(int i=0;i<N_cv;i++) m[i]=x.m[i];
   sv=x.sv;
}


map_double& map_double::operator=(const map_double& x)
{
   for(int i=0;i<N_cv;i++) {
      m[i]=x.m[i];}
   sv=x.sv;
   return *this;
}

map_double& map_double::operator=(double f)
{
   for(int i=0;i<N_cv;i++) m[i]=f;
   sv=1;
   return *this;
}

map_double& map_double::operator=(double* f)
{
   for(int i=0;i<N_cv;i++) m[i]=f[i];
   sv=1;
   return *this;
}

map_double map_double::operator+=(const map_double& x)
{
   for(int i=0;i<N_cv;i++) m[i]+=x.m[i];;
   return *this;
}   

map_double map_double::operator-=(const map_double& x)
{
   for(int i=0;i<N_cv;i++) m[i]-=x.m[i];
   return *this;
}

map_double operator+(const map_double& x,const map_double& y)
{
  map_double z;
  for(int i=0;i<N_cv;i++) z.m[i]=x.m[i]+y.m[i];
  z.sv=1;
  return z;
}

map_double operator-(const map_double& x,const map_double& y)
{
  map_double z;
  for(int i=0;i<N_cv;i++) z.m[i]=x.m[i]-y.m[i];
  z.sv=1;
  return z;
}

map_double operator*(double f,const map_double& x)
{
  map_double z;
  for(int i=0;i<N_cv;i++) z.m[i]=f*x.m[i];
  z.sv=1;
  return z;
}

map_double operator*(const map_double& x,double f)
{
  map_double z;
  for(int i=0;i<N_cv;i++) z.m[i]=f*x.m[i];
  z.sv=1;
  return z;
}

int is_survive(map_double& x)
{
  if(x.m[0]*x.m[0]+x.m[1]*x.m[1]>=0.01) {
    x.sv=0;
    return 0;
  }
  return 1;
}

/*void map_double::dBase(void)
{
   for(int i=0;i<N_cv;i++) DUnit(m[i],i,1.); sv=1;
}

void map_double::dBase(double f)
{
   for(int i=0;i<N_cv;i++) DUnit(m[i],i,f); sv=1;
}

void map_double::dBase(const double* f)
{
   for(int i=0;i<N_cv;i++) DUnit(m[i],i,f[i]); sv=1;
}


void map_double::NBase(void)
{
   for(int i=0;i<N_cv;i++) NUnit(m[i],i,1.); sv=1;
}
*/

ostream& operator<<(ostream& s,map_double& x)
{
//  s << '{';
  for(int i=0;i<N_cv/2;i++) {
    if(i!=0) s << " ";
    s << x.m[i] << " " << x.m[i+N_cv/2];
  }
  s << ' ' << (int)x.sv << "\n";
  return s;
}

void MathListOut(map_double& x)
{
//  cout.precision(10);
  cout << '{';
  for(int i=0;i<N_cv/2;i++) {
    if(i!=0) cout << ", ";
    cout << x[i] << ", " << x[i+N_cv/2];
  }
  cout << "}\n";
}


// --------------------------------------------------------------
#include <map_da.h>
// Constructor


map_da::map_da(const map_da& x) 
{ 
   m=new da[N_cv];
   //   cout<< " map copied to " << m << '\n';
   for(int i=0;i<N_cv;i++) m[i]=x.m[i];
}

map_da::map_da(const matrix& x)
{
  int i;
  m=new da[N_cv];
//   cout << " map is generated by matrix " << m;
  int Ncv2=N_cv/2;
  int Nvr2=N_var/2;
  if(getNr(x)!=N_cv || getNc(x)!=N_cv) {
    cout << "Error  matrix is not N_cv*N_cv \n" 
      << getNr(x) << "X" << getNc(x);
    exit(1);
  }
  for(i=0;i<N_cv;i++) {
    m[i]=0.;}
  for(i=0;i<N_cv;i+=2) {
    for(int j=0;j<N_cv;j+=2) {
      (m[i/2]).Dcin(j/2,m_element(x,i,j));
      (m[i/2]).Dcin(j/2+Nvr2,m_element(x,i,j+1));
      (m[i/2+Ncv2]).Dcin(j/2,m_element(x,i+1,j));
      (m[i/2+Ncv2]).Dcin(j/2+Nvr2,m_element(x,i+1,j+1));
    }
  }
}

map_da& map_da::operator=(const map_da& x)
{
   for(int i=0;i<N_cv;i++) {
      m[i]=x.m[i];}
   return *this;
}

map_da& map_da::operator=(const matrix& x)
{
   int Ncv2=N_cv/2;
   int Nvr2=N_var/2;
   int i;
   if(getNr(x)!=N_cv || getNc(x)!=N_cv) {
      cout << "Error  matrix is not N_cv*N_cv \n" 
           << getNr(x) << "X" << getNc(x);
      exit(1);
   }
   for(i=0;i<N_cv;i++) {
      m[i]=0.;}
   for(i=0;i<N_cv;i+=2) {
      for(int j=0;j<N_cv;j+=2) {
	 (m[i/2]).Dcin(j/2,m_element(x,i,j));
	 (m[i/2]).Dcin(j/2+Nvr2,m_element(x,i,j+1));
	 (m[i/2+Ncv2]).Dcin(j/2,m_element(x,i+1,j));
	 (m[i/2+Ncv2]).Dcin(j/2+Nvr2,m_element(x,i+1,j+1));
      }
   }
   return *this;
}
map_da& map_da::operator=(double f)
{
   for(int i=0;i<N_cv;i++) m[i]=f;
//   for(int i=0;i<N_cv;i++) DUnit(m[i],i,1.);
   return *this;
}

matrix lin_da(const map_da& x)
{
   int Nvr2=N_var/2;
   int Ncv2=N_cv/2;
   matrix z(N_cv,N_cv);

   for(int i=0;i<N_cv;i+=2) {
      for(int j=0;j<N_cv;j+=2) {
	 z.ci(i*N_cv+j,(x.m[i/2]).lin_da(j/2));
	 z.ci(i*N_cv+j+1,(x.m[i/2]).lin_da(j/2+Nvr2));
	 z.ci((i+1)*N_cv+j,(x.m[i/2+Ncv2]).lin_da(j/2));
	 z.ci((i+1)*N_cv+j+1,(x.m[i/2+Ncv2]).lin_da(j/2+Nvr2));
      }
   }
   return z;
}

map_da map_da::operator+=(const map_da& x)
{
   for(int i=0;i<N_cv;i++) m[i]+=x.m[i];
   return *this;
}   

map_da map_da::operator-=(const map_da& x)
{
   for(int i=0;i<N_cv;i++) m[i]-=x.m[i];
   return *this;
}


void map_da::dBase(void)
{
   for(int i=0;i<N_cv;i++) DUnit(m[i],i,1.);
}

void map_da::dBase(double f)
{
   for(int i=0;i<N_cv;i++) DUnit(m[i],i,f);
}

void map_da::dBase(const double* f)
{
   for(int i=0;i<N_cv;i++) DUnit(m[i],i,f[i]);
}


void map_da::NBase(void)
{
   for(int i=0;i<N_cv;i++) NUnit(m[i],i,1.);
}



void map_da::print(const char* ss)
{
   char s[80];
   cout << "\n\n -------- vector print out -------- : " << ss << "\n\n";
   for(int i=0;i<N_cv;i++) {
      sprintf(s," %d-th canonical variable vector",i);
      m[i].daprint(s);
      //      xprint(s,m[i]); 
   }
}
static char label[7]="xyzpqe";
ostream& operator<<(ostream& s,const map_da& x)
{
   s << "\n\n ------ map_da print out ------------ \n";
   for(int i=0;i<N_cv/2;i++) {
      s << "\n" << label[i] << "=";
      s << x.m[i];
      s << "\n" << label[i+N_cv/2] << "=";
      s << x.m[i+N_cv/2];
   }
   return s;
}

istream& operator>>(istream& s,map_da& x)
{
   cout << "\n\n ------ map_da read  ------------ \n\n";
   char buf[256],dlim;
   int readerr=0;
   int icv;
   x=0.;
   do {
      s.get(buf,255,'=');	if(!s) readerr=1;
      s.get(dlim);		if(!s) readerr=1;
      if(strstr(buf,"x")!=NULL) {
	 icv=atoi(buf+1);
	 s >> x.m[icv];		if(!s) readerr=1;
      }
   } while(!s.eof() && !readerr);
   if(readerr && !s.eof()) { cout << "DA map read error\n"; exit(1);}

   return s;
}

map_da operator*(const map_da& x,const matrix& T)
{
   map_da y(T),z;
//   y.print("map_gen");
//   z=x*y;
   z=concatenate(x,y,1);
//   z.print("concatenation");
   return z;
}


map_da operator*(matrix& T,const map_da& x)
{
  map_da z;
  z=0.;
  int Ncv2=N_cv/2;

  for(int i=0;i<N_cv;i+=2) {
    for(int j=0;j<N_cv;j+=2) {
      z.m[i/2]+=T[i][j]*x.m[j/2]+T[i][j+1]*x.m[j/2+Ncv2];
      z.m[i/2+Ncv2]+=T[i+1][j]*x.m[j/2]
	+T[i+1][j+1]*x.m[j/2+Ncv2];
    }
  }
  return z;
}

map_da Sym_trans(const map_da& x,const matrix& y)
{
   map_da z;
   matrix S(N_cv,N_cv);
   S.Symp();
   z=-((matrix)S*Transpose(y)*S)*x*y;
   return z;
}
// --------------------------------------------------------------
#include <map_c_da.h>
// Constructor


map_c_da::map_c_da(const map_c_da& x) 
{ 
   m=new c_da[N_cv];
   cout<< " map copied to " << m << '\n';
   for(int i=0;i<N_cv;i++) m[i]=x.m[i];
}


map_c_da& map_c_da::operator=(const map_c_da& x)
{
   for(int i=0;i<N_cv;i++) {
      m[i]=x.m[i];}
   return *this;
}

map_c_da& map_c_da::operator=(double f)
{
   for(int i=0;i<N_cv;i++) m[i]=f;
   return *this;
}

map_c_da map_c_da::operator+=(const map_c_da& x)
{
   for(int i=0;i<N_cv;i++) m[i]+=x.m[i];
   return *this;
}   

map_c_da map_c_da::operator-=(const map_c_da& x)
{
   for(int i=0;i<N_cv;i++) m[i]-=x.m[i];
   return *this;
}


void map_c_da::dBase(void)
{
   for(int i=0;i<N_cv;i++) DUnit(m[i],i,1.);
}

void map_c_da::dBase(double f)
{
   for(int i=0;i<N_cv;i++) DUnit(m[i],i,f);
}

void map_c_da::dBase(const double* f)
{
   for(int i=0;i<N_cv;i++) DUnit(m[i],i,f[i]);
}

void map_c_da::NBase(void)
{
   int N_vr2=N_var/2;
   int N_cv2=N_cv/2;
   da hp,hm,z;
   double sqrt_2i=1./sqrt(2.);
   z=0.;
 
   for(int i=0;i<N_cv2;i++) {
      hp.dBase(i,1.);
      hm.dBase(i+N_vr2,1.);
      m[i]=c_da((hp+hm)*sqrt_2i,z);
      m[i+N_cv2]=c_da(z,(hm-hp)*sqrt_2i);
   }
}

void map_c_da::NiBase(void)
{
   int N_vr2=N_var/2;
   int N_cv2=N_cv/2;
   double sqrt_2i=1./sqrt(2.);
   
   for(int i=0;i<N_cv2;i++) {
      NUnit(m[i],i,sqrt_2i,i+N_vr2,sqrt_2i);
      NUnit(m[i+N_cv2],i,sqrt_2i,i+N_vr2,-sqrt_2i);
   }
}


ostream& operator<<(ostream& s,const map_c_da& x)
{
   cout << "\n\n ------ map_c_da print out ------------ \n\n";
   for(int i=0;i<N_cv;i++) {
      cout << i << "-th canonical variable" << x.m[i];
   }
   return s;
}


void map_c_da::print(const char* ss)
{
   char s[80];
   cout << "\n\n -------- vector print out -------- : " << ss << "\n\n";
   for(int i=0;i<N_cv;i++) {
      sprintf(s," %d-th canonical variable vector",i);
      xprint(s,m[i]); 
   }
}

// --------------------------------------------------------------
#include <map_p_da.h>
// Constructor


map_p_da::map_p_da(const map_p_da& x) 
{ 
   m=new p_da[N_cv];
   cout<< " map copied to " << m << '\n';
   for(int i=0;i<N_cv;i++) m[i]=x.m[i];
}


map_p_da& map_p_da::operator=(const map_p_da& x)
{
   for(int i=0;i<N_cv;i++) {
      m[i]=x.m[i];}
   return *this;
}

map_p_da& map_p_da::operator=(double f)
{
   for(int i=0;i<N_cv;i++) m[i]=f;
   return *this;
}

map_p_da map_p_da::operator+=(const map_p_da& x)
{
   for(int i=0;i<N_cv;i++) m[i]+=x.m[i];
   return *this;
}   

map_p_da map_p_da::operator-=(const map_p_da& x)
{
   for(int i=0;i<N_cv;i++) m[i]-=x.m[i];
   return *this;
}


void map_p_da::dBase(void)
{
   for(int i=0;i<N_cv;i++) DUnit(m[i],i,1.);
}

void map_p_da::dBase(double f)
{
   for(int i=0;i<N_cv;i++) DUnit(m[i],i,f);
}

void map_p_da::dBase(const double* f)
{
   for(int i=0;i<N_cv;i++) DUnit(m[i],i,f[i]);
}


void map_p_da::NBase(void)
{
   for(int i=0;i<N_cv;i++) NUnit(m[i],i,1.);
}



ostream& operator<<(ostream& s,const map_p_da& x)
{
   cout << "\n\n ------ map_da print out ------------ \n\n";
   for(int i=0;i<N_cv;i++) {
      cout << i << "-th canonical variable" << x.m[i];
   }
   return s;
}


