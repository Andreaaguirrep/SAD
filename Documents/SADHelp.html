<HEAD>
<TITLE>
</TITLE>
<STYLE>
eqs img{
  display: inline;
  vertical-align: center;
  white-space:nowrap;
  font-size:0;
}
</STYLE>
</HEAD>
<BODY>
<CENTER><H2>Welcome to SAD/FFS & SADScript
</H2></CENTER>
<CENTER> SAD/FFS SADScript Version: 1.1.10.8.1k64,      Updated: 01/11/2022</CENTER>

<PRE> Please use browser's search to find an item.

 The FFS commands are shown in uppercases. The minimum abbreviated form of each command is enclosed
in (). Each command can be shorten down to that. The optional arguments for the commands are usually
shown in [].
 The notation ===> reads "equivalent to" below.</PRE>
<A HREF="http://acc-physics.kek.jp/SAD/">
<H4>
<img SRC="SADHelp_img/SAD.jpg" ALIGN="middle" ALT="SAD" WIDTH=90></A>
Back to SAD Home Page</H4>
<A HREF="example/design_example.html">
<H4>
SAD/FFS Examples</H4></A>
<HR>
<PRE>
<A HREF=#L1> </A>
   <A HREF=#L2>ABORT</A>
   <A HREF=#L3>APPEND(APP)</A>
   <A HREF=#L4>ATTRIBUTE(ATTR)</A>
   <A HREF=#L5>beam-line</A>
      <A HREF=#L6>beam-line-functions</A>
         <A HREF=#L7>BeamLine</A>
         <A HREF=#L8>BeamLineName</A>
         <A HREF=#L9>ExtractBeamLine</A>
         <A HREF=#L10>PrintBeamLine</A>
         <A HREF=#L11>WriteBeamLine</A>
      <A HREF=#L12>orientation-of-an-element</A>
   <A HREF=#L13>BEAMSIZE(BEAM)</A>
   <A HREF=#L14>BYE</A>
   <A HREF=#L15>character-string</A>
      <A HREF=#L16>FromCharacterCode</A>
      <A HREF=#L17>StringFill</A>
      <A HREF=#L18>StringJoin</A>
      <A HREF=#L19>StringLength</A>
      <A HREF=#L20>StringMatchQ</A>
      <A HREF=#L21>StringPart</A>
      <A HREF=#L22>StringPosition</A>
      <A HREF=#L23>StringReplace</A>
      <A HREF=#L24>StringTrim</A>
      <A HREF=#L25>Symbol</A>
      <A HREF=#L26>ToCharacterCode</A>
      <A HREF=#L27>ToExpression</A>
      <A HREF=#L28>ToString</A>
   <A HREF=#L29>command-syntax</A>
   <A HREF=#L30>components</A>
   <A HREF=#L31>constants</A>
   <A HREF=#L32>CALCULATE(CAL)</A>
   <A HREF=#L33>CHROMATICITY(CHRO)</A>
   <A HREF=#L34>CLOSE(CLO)</A>
   <A HREF=#L35>COUPLE(COUP)</A>
   <A HREF=#L36>data-structure</A>
      <A HREF=#L37>Extract</A>
      <A HREF=#L38>Head</A>
      <A HREF=#L39>Length</A>
      <A HREF=#L40>List</A>
      <A HREF=#L41>Part</A>
   <A HREF=#L42>defining-functions</A>
   <A HREF=#L43>dynamics</A>
      <A HREF=#L44>independent-variable</A>
      <A HREF=#L45>Lagrangean</A>
      <A HREF=#L46>Hamiltonian</A>
         <A HREF=#L47>2nd-order-Hamiltonian</A>
            <A HREF=#L48>solution-H2</A>
            <A HREF=#L49>solution-dH</A>
      <A HREF=#L50>remarks-on-dynamics</A>
      <A HREF=#L51>x-y-coupling</A>
      <A HREF=#L52>extended-Twiss-parameters</A>
         <A HREF=#L53>definitions</A>
      <A HREF=#L54>synchrotron-radiation</A>
      <A HREF=#L55>equilibrium-beam-envelope</A>
   <A HREF=#L56>DISPLAY(DISP)</A>
      <A HREF=#L57>ACCELERATION(A)</A>
      <A HREF=#L58>ALL</A>
      <A HREF=#L59>BEAM(B)</A>
      <A HREF=#L60>DREFERENCE(DRE)</A>
      <A HREF=#L61>DUMPOPTICS(D)</A>
      <A HREF=#L62>GAMMA(GA)</A>
      <A HREF=#L63>GEOMETRY(G)</A>
      <A HREF=#L64>OGEOMETRY(OG)</A>
      <A HREF=#L65>ORBIT(O)</A>
      <A HREF=#L66>pattern-string</A>
      <A HREF=#L67>PHYSICAL(P)</A>
      <A HREF=#L68>region</A>
      <A HREF=#L69>REFERENCE(RE)</A>
      <A HREF=#L70>RMATRIX(R)</A>
      <A HREF=#L71>Z</A>
   <A HREF=#L72>DRAW</A>
      <A HREF=#L73>Draw$Option</A>
   <A HREF=#L74>DUMP</A>
   <A HREF=#L75>elements</A>
      <A HREF=#L76>APERT</A>
      <A HREF=#L77>BEND</A>
         <A HREF=#L78>AE1</A>
         <A HREF=#L79>AE2</A>
         <A HREF=#L80>ANGLE</A>
         <A HREF=#L81>DISFRIN</A>
         <A HREF=#L82>DISRAD</A>
         <A HREF=#L83>DROTATE</A>
         <A HREF=#L84>DX</A>
         <A HREF=#L85>DY</A>
         <A HREF=#L86>E1</A>
         <A HREF=#L87>E2</A>
         <A HREF=#L88>F1</A>
         <A HREF=#L89>FB1</A>
         <A HREF=#L90>FB2</A>
         <A HREF=#L91>FRINGE</A>
         <A HREF=#L92>K0</A>
         <A HREF=#L93>K1</A>
         <A HREF=#L94>L</A>
         <A HREF=#L95>ROTATE</A>
         <A HREF=#L96>transformation:BEND</A>
      <A HREF=#L97>CAVI</A>
         <A HREF=#L98>DISFRIN</A>
         <A HREF=#L99>DPHI</A>
         <A HREF=#L100>DVOLT</A>
         <A HREF=#L101>DX</A>
         <A HREF=#L102>DY</A>
         <A HREF=#L103>FREQ</A>
         <A HREF=#L104>HARM</A>
         <A HREF=#L105>L</A>
         <A HREF=#L106>PHI</A>
         <A HREF=#L107>ROTATE</A>
         <A HREF=#L108>V02</A>
         <A HREF=#L109>V1</A>
         <A HREF=#L110>V11</A>
         <A HREF=#L111>VOLT</A>
      <A HREF=#L112>COORD</A>
      <A HREF=#L113>default-keyword</A>
      <A HREF=#L114>DECA</A>
         <A HREF=#L115>DISFRIN</A>
         <A HREF=#L116>DISRAD</A>
         <A HREF=#L117>DX</A>
         <A HREF=#L118>DY</A>
         <A HREF=#L119>K4</A>
         <A HREF=#L120>L</A>
         <A HREF=#L121>ROTATE</A>
         <A HREF=#L122>transformation:THIN</A>
      <A HREF=#L123>DODECA</A>
         <A HREF=#L124>DISFRIN</A>
         <A HREF=#L125>DISRAD</A>
         <A HREF=#L126>DX</A>
         <A HREF=#L127>DY</A>
         <A HREF=#L128>K5</A>
         <A HREF=#L129>L</A>
         <A HREF=#L130>ROTATE</A>
         <A HREF=#L131>transformation:THIN</A>
      <A HREF=#L132>DRIFT</A>
         <A HREF=#L133>L</A>
         <A HREF=#L134>RADIUS</A>
         <A HREF=#L135>transformation:DRIFT</A>
      <A HREF=#L136>keywords</A>
      <A HREF=#L137>MARK</A>
         <A HREF=#L138>OFFSET</A>
      <A HREF=#L139>MULT</A>
         <A HREF=#L140>K0</A>
         <A HREF=#L141>SK0</A>
         <A HREF=#L142>K1</A>
         <A HREF=#L143>SK1</A>
         <A HREF=#L144>K2</A>
         <A HREF=#L145>SK2</A>
         <A HREF=#L146>K3</A>
         <A HREF=#L147>SK3</A>
         <A HREF=#L148>K4</A>
         <A HREF=#L149>SK4</A>
         <A HREF=#L150>K5</A>
         <A HREF=#L151>SK5</A>
         <A HREF=#L152>K6</A>
         <A HREF=#L153>SK6</A>
         <A HREF=#L154>K7</A>
         <A HREF=#L155>SK7</A>
         <A HREF=#L156>K8</A>
         <A HREF=#L157>SK8</A>
         <A HREF=#L158>K9</A>
         <A HREF=#L159>SK9</A>
         <A HREF=#L160>K10</A>
         <A HREF=#L161>SK10</A>
         <A HREF=#L162>K11</A>
         <A HREF=#L163>SK11</A>
         <A HREF=#L164>K12</A>
         <A HREF=#L165>SK12</A>
         <A HREF=#L166>K13</A>
         <A HREF=#L167>SK13</A>
         <A HREF=#L168>K14</A>
         <A HREF=#L169>SK14</A>
         <A HREF=#L170>K15</A>
         <A HREF=#L171>SK15</A>
         <A HREF=#L172>K16</A>
         <A HREF=#L173>SK16</A>
         <A HREF=#L174>K17</A>
         <A HREF=#L175>SK17</A>
         <A HREF=#L176>K18</A>
         <A HREF=#L177>SK18</A>
         <A HREF=#L178>K19</A>
         <A HREF=#L179>SK19</A>
         <A HREF=#L180>K20</A>
         <A HREF=#L181>SK20</A>
         <A HREF=#L182>K21</A>
         <A HREF=#L183>SK21</A>
         <A HREF=#L184>AE1</A>
         <A HREF=#L185>AE2</A>
         <A HREF=#L186>ANGLE</A>
         <A HREF=#L187>DISFRIN</A>
         <A HREF=#L188>DISRAD</A>
         <A HREF=#L189>DPHI</A>
         <A HREF=#L190>DVOLT</A>
         <A HREF=#L191>E1</A>
         <A HREF=#L192>E2</A>
         <A HREF=#L193>F1</A>
         <A HREF=#L194>F2</A>
         <A HREF=#L195>FB1</A>
         <A HREF=#L196>FB2</A>
         <A HREF=#L197>FREQ</A>
         <A HREF=#L198>FRINGE</A>
         <A HREF=#L199>HARM</A>
         <A HREF=#L200>L</A>
         <A HREF=#L201>misalignments</A>
         <A HREF=#L202>multipole_with_nonzero_ANGLE</A>
         <A HREF=#L203>PHI</A>
         <A HREF=#L204>RADIUS</A>
         <A HREF=#L205>VOLT</A>
      <A HREF=#L206>OCT</A>
         <A HREF=#L207>DISFRIN</A>
         <A HREF=#L208>DISRAD</A>
         <A HREF=#L209>DX</A>
         <A HREF=#L210>DY</A>
         <A HREF=#L211>K3</A>
         <A HREF=#L212>L</A>
         <A HREF=#L213>ROTATE</A>
         <A HREF=#L214>transformation:THIN</A>
      <A HREF=#L215>QUAD</A>
         <A HREF=#L216>DISFRIN</A>
         <A HREF=#L217>DISRAD</A>
         <A HREF=#L218>DX</A>
         <A HREF=#L219>DY</A>
         <A HREF=#L220>F1</A>
         <A HREF=#L221>F2</A>
         <A HREF=#L222>FRINGE</A>
         <A HREF=#L223>K1</A>
         <A HREF=#L224>L</A>
         <A HREF=#L225>ROTATE</A>
         <A HREF=#L226>transformation:QUAD</A>
      <A HREF=#L227>SEXT</A>
         <A HREF=#L228>DISFRIN</A>
         <A HREF=#L229>DISRAD</A>
         <A HREF=#L230>DX</A>
         <A HREF=#L231>DY</A>
         <A HREF=#L232>K2</A>
         <A HREF=#L233>L</A>
         <A HREF=#L234>ROTATE</A>
         <A HREF=#L235>transformation:THIN</A>
      <A HREF=#L236>SOL</A>
         <A HREF=#L237>BOUND</A>
         <A HREF=#L238>BZ</A>
         <A HREF=#L239>DISFRIN</A>
         <A HREF=#L240>DPX</A>
         <A HREF=#L241>DPY</A>
         <A HREF=#L242>DX</A>
         <A HREF=#L243>DY</A>
         <A HREF=#L244>F1</A>
         <A HREF=#L245>GEO</A>
   <A HREF=#L246>expression</A>
      <A HREF=#L247>(-)</A>
      <A HREF=#L248>(/)</A>
      <A HREF=#L249>AddTo(+=)</A>
      <A HREF=#L250>Alternatives(|)</A>
      <A HREF=#L251>And(&&)</A>
      <A HREF=#L252>Apply (@@)</A>
      <A HREF=#L253>CompoundExpression(;)</A>
      <A HREF=#L254>Decrement(--)</A>
      <A HREF=#L255>DivideBy(/=)</A>
      <A HREF=#L256>Dot(.)</A>
      <A HREF=#L257>Equal(==)</A>
      <A HREF=#L258>Function(&)</A>
      <A HREF=#L259>Greater(>)</A>
      <A HREF=#L260>GreaterEqual(>= or =>)</A>
      <A HREF=#L261>Increment(++)</A>
      <A HREF=#L262>Less(<)</A>
      <A HREF=#L263>LessEqual(<= or =<)</A>
      <A HREF=#L264>List({})</A>
      <A HREF=#L265>Map (/@)</A>
      <A HREF=#L266>MapAll(//@)</A>
      <A HREF=#L267>Member(@)</A>
      <A HREF=#L268>MessageName(::)</A>
      <A HREF=#L269>Not(~)</A>
      <A HREF=#L270>Or(||)</A>
      <A HREF=#L271>Part([[]])</A>
      <A HREF=#L272>PatternTest(?)</A>
      <A HREF=#L273>Plus(+)</A>
      <A HREF=#L274>Power(^)</A>
      <A HREF=#L275>Repeated(..)</A>
      <A HREF=#L276>RepeatedNull(...)</A>
      <A HREF=#L277>ReplaceAll(/.)</A>
      <A HREF=#L278>ReplaceRepeated(//.)</A>
      <A HREF=#L279>Rule(->)</A>
      <A HREF=#L280>RuleDelayed(:>)</A>
      <A HREF=#L281>SameQ(===)</A>
      <A HREF=#L282>Sequence([])</A>
      <A HREF=#L283>Set(=)</A>
      <A HREF=#L284>SetDelayed(:=)</A>
      <A HREF=#L285>StringJoin (//)</A>
      <A HREF=#L286>SubtractFrom(-=)</A>
      <A HREF=#L287>TagSet(/:)</A>
      <A HREF=#L288>Times(*)</A>
      <A HREF=#L289>TimesBy(*=)</A>
      <A HREF=#L290>Unequal(<>)</A>
      <A HREF=#L291>UnsameQ(<=>)</A>
      <A HREF=#L292>Unset(=.)</A>
   <A HREF=#L293>ELSE</A>
   <A HREF=#L294>ELSEIF</A>
   <A HREF=#L295>EMITTANCE(EMIT)</A>
   <A HREF=#L296>END</A>
   <A HREF=#L297>ENDIF</A>
   <A HREF=#L298>EXECUTE(EXEC)</A>
   <A HREF=#L299>EXPAND</A>
   <A HREF=#L300>flags</A>
      <A HREF=#L301>ABSW</A>
      <A HREF=#L302>BIPOL</A>
      <A HREF=#L303>CALC4D</A>
      <A HREF=#L304>CALC6D</A>
      <A HREF=#L305>CELL</A>
      <A HREF=#L306>CMPLOT</A>
      <A HREF=#L307>COD</A>
      <A HREF=#L308>CODPLOT</A>
      <A HREF=#L309>CONV</A>
      <A HREF=#L310>CONVCASE</A>
      <A HREF=#L311>DAMPONLY</A>
      <A HREF=#L312>DAPERT</A>
      <A HREF=#L313>DIFFRES</A>
      <A HREF=#L314>ECHO</A>
      <A HREF=#L315>EMIOUT</A>
      <A HREF=#L316>FFSPRMPT</A>
      <A HREF=#L317>FIXSEED</A>
      <A HREF=#L318>FLUC</A>
      <A HREF=#L319>GAUSS</A>
      <A HREF=#L320>GEOCAL</A>
      <A HREF=#L321>GEOFIX</A>
      <A HREF=#L322>HALFRES</A>
      <A HREF=#L323>IDEAL</A>
      <A HREF=#L324>INS</A>
      <A HREF=#L325>INTRA</A>
      <A HREF=#L326>INTRES</A>
      <A HREF=#L327>JITTER</A>
      <A HREF=#L328>LOG</A>
      <A HREF=#L329>LOSSMAP</A>
      <A HREF=#L330>LWAKE</A>
      <A HREF=#L331>MOVESEED</A>
      <A HREF=#L332>PHOTONS</A>
      <A HREF=#L333>POL</A>
      <A HREF=#L334>PRSVCASE</A>
      <A HREF=#L335>PSPAC</A>
      <A HREF=#L336>QUIET</A>
      <A HREF=#L337>RAD</A>
      <A HREF=#L338>RADCOD</A>
      <A HREF=#L339>RADLIGHT</A>
      <A HREF=#L340>RADPOL</A>
      <A HREF=#L341>RADTAPER</A>
      <A HREF=#L342>REAL</A>
      <A HREF=#L343>RELW</A>
      <A HREF=#L344>RFSW</A>
      <A HREF=#L345>RING</A>
      <A HREF=#L346>SELFCOD</A>
      <A HREF=#L347>SORG</A>
      <A HREF=#L348>SPAC</A>
      <A HREF=#L349>STABLE</A>
      <A HREF=#L350>SUMRES</A>
      <A HREF=#L351>SUS</A>
      <A HREF=#L352>TRPT</A>
      <A HREF=#L353>TWAKE</A>
      <A HREF=#L354>UNIFORM</A>
      <A HREF=#L355>UNIPOL</A>
      <A HREF=#L356>UNSTABLE</A>
      <A HREF=#L357>WSPAC</A>
   <A HREF=#L358>functions</A>
      <A HREF=#L359>Data-Manipulation</A>
         <A HREF=#L360>Fit</A>
         <A HREF=#L361>FitEmit</A>
         <A HREF=#L362>FitGaussian</A>
         <A HREF=#L363>NIntegrate</A>
         <A HREF=#L364>PolynomialFit</A>
         <A HREF=#L365>Spline</A>
      <A HREF=#L366>DownhillSimplex</A>
      <A HREF=#L367>functional-operations</A>
         <A HREF=#L368>Apply</A>
         <A HREF=#L369>Cases</A>
         <A HREF=#L370>DeleteCases</A>
         <A HREF=#L371>Difference</A>
         <A HREF=#L372>FixedPoint</A>
         <A HREF=#L373>FixedPointList</A>
         <A HREF=#L374>level-spec</A>
         <A HREF=#L375>Map</A>
         <A HREF=#L376>MapThread</A>
         <A HREF=#L377>Position</A>
         <A HREF=#L378>Scan</A>
         <A HREF=#L379>ScanThread</A>
         <A HREF=#L380>SelectCases</A>
         <A HREF=#L381>SwitchCases</A>
         <A HREF=#L382>Thread</A>
      <A HREF=#L383>FFS-dedicated-functions</A>
         <A HREF=#L384>AccelerateParticles</A>
         <A HREF=#L385>BeamMatrix</A>
         <A HREF=#L386>DynamicApertureSurvey</A>
         <A HREF=#L387>Element</A>
            <A HREF=#L388>key-strings:Element</A>
         <A HREF=#L389>Emittance</A>
         <A HREF=#L390>ExternalMap</A>
            <A HREF=#L391>CompiledMap</A>
         <A HREF=#L392>FFS</A>
         <A HREF=#L393>FFS$SHOW</A>
         <A HREF=#L394>FitValue</A>
         <A HREF=#L395>FitWeight</A>
         <A HREF=#L396>GaussianCoulomb</A>
         <A HREF=#L397>GeoBase</A>
         <A HREF=#L398>LINE</A>
            <A HREF=#L399>key-strings:LINE</A>
         <A HREF=#L400>OptimizeOptics</A>
         <A HREF=#L401>OrbitGeo</A>
         <A HREF=#L402>RadiationField</A>
         <A HREF=#L403>RadiationSpectrum</A>
         <A HREF=#L404>SetElement</A>
         <A HREF=#L405>SurvivedParticles</A>
         <A HREF=#L406>SymplecticJ</A>
         <A HREF=#L407>SynchroBetaEmittance</A>
         <A HREF=#L408>TouschekLifetime</A>
         <A HREF=#L409>TrackParticles</A>
         <A HREF=#L410>Twiss</A>
         <A HREF=#L411>VariableRange</A>
         <A HREF=#L412>VariableWeight</A>
         <A HREF=#L413>WakeFunction</A>
      <A HREF=#L414>Graphics</A>
         <A HREF=#L415>BeamPlot</A>
         <A HREF=#L416>ColumnPlot</A>
         <A HREF=#L417>FitPlot</A>
         <A HREF=#L418>GeometryPlot</A>
         <A HREF=#L419>HistoPlot</A>
         <A HREF=#L420>ListContourPlot</A>
         <A HREF=#L421>ListDensityPlot</A>
         <A HREF=#L422>ListPlot</A>
         <A HREF=#L423>OpticsPlot</A>
         <A HREF=#L424>Plot</A>
      <A HREF=#L425>Input/Output</A>
         <A HREF=#L426>$FORM</A>
         <A HREF=#L427>$Input</A>
         <A HREF=#L428>$Output</A>
         <A HREF=#L429>Close</A>
         <A HREF=#L430>OpenAppend</A>
         <A HREF=#L431>OpenRead</A>
         <A HREF=#L432>OpenWrite</A>
         <A HREF=#L433>PageWidth</A>
         <A HREF=#L434>Print</A>
         <A HREF=#L435>Read</A>
         <A HREF=#L436>ReadString</A>
         <A HREF=#L437>StandardForm</A>
         <A HREF=#L438>StringToStream</A>
         <A HREF=#L439>Write</A>
         <A HREF=#L440>WriteString</A>
      <A HREF=#L441>Multiprocessing</A>
         <A HREF=#L442>Fork</A>
         <A HREF=#L443>OpenShared</A>
         <A HREF=#L444>Shared</A>
         <A HREF=#L445>SharedSize</A>
      <A HREF=#L446>Object-oriented-programing</A>
         <A HREF=#L447>Class</A>
      <A HREF=#L448>Random-number-functions</A>
         <A HREF=#L449>Random</A>
         <A HREF=#L450>GaussRandom</A>
         <A HREF=#L451>ParabolaRandom</A>
         <A HREF=#L452>SeedRandom</A>
         <A HREF=#L453>ListRandom</A>
      <A HREF=#L454>System-interface</A>
         <A HREF=#L455>System</A>
         <A HREF=#L456>TemporaryName</A>
      <A HREF=#L457>Utilities</A>
         <A HREF=#L458>DateString</A>
         <A HREF=#L459>MemoryCheck</A>
         <A HREF=#L460>TimeUsed</A>
         <A HREF=#L461>Timing</A>
         <A HREF=#L462>TracePrint</A>
   <A HREF=#L463>FIT</A>
   <A HREF=#L464>FITPOINTS(FITP)</A>
   <A HREF=#L465>FIX</A>
   <A HREF=#L466>FREE</A>
      <A HREF=#L467>default-keyword</A>
   <A HREF=#L468>geometric-functions</A>
   <A HREF=#L469>GO</A>
   <A HREF=#L470>IF</A>
   <A HREF=#L471>INPUT(IN)</A>
   <A HREF=#L472>machine-error-commands</A>
   <A HREF=#L473>matching-function-commands</A>
   <A HREF=#L474>multi-turn-tracking</A>
   <A HREF=#L475>MATRIX(MAT)</A>
   <A HREF=#L476>MEASURE(MEA)</A>
   <A HREF=#L477>off-momentum-matching</A>
   <A HREF=#L478>optical-functions</A>
   <A HREF=#L479>ORG</A>
   <A HREF=#L480>OUTPUT(OUT)</A>
   <A HREF=#L481>pattern</A>
      <A HREF=#L482>MatchQ</A>
   <A HREF=#L483>physical-constants</A>
   <A HREF=#L484>PRINT(PRI)</A>
   <A HREF=#L485>QUIT</A>
   <A HREF=#L486>RADINT</A>
   <A HREF=#L487>READ</A>
   <A HREF=#L488>RECOVER(REC)</A>
   <A HREF=#L489>REFERENCE(REF)</A>
      <A HREF=#L490>reference-optics</A>
   <A HREF=#L491>REJECT(REJ)</A>
   <A HREF=#L492>RENUMBER(RENUM)</A>
   <A HREF=#L493>REPEAT(REP)</A>
   <A HREF=#L494>RESET</A>
   <A HREF=#L495>RESUME(RES)</A>
   <A HREF=#L496>REVERSE(REV)</A>
   <A HREF=#L497>set-value-of-element</A>
      <A HREF=#L498>keywords</A>
      <A HREF=#L499>default-keyword</A>
   <A HREF=#L500>special-variables</A>
      <A HREF=#L501>$Line</A>
      <A HREF=#L502>CASE</A>
      <A HREF=#L503>CHARGE</A>
      <A HREF=#L504>CONVERGENCE</A>
      <A HREF=#L505>DAPWIDTH</A>
      <A HREF=#L506>DP</A>
      <A HREF=#L507>DP0</A>
      <A HREF=#L508>DTSYNCH</A>
      <A HREF=#L509>EFFRFFREQ</A>
      <A HREF=#L510>EFFVC</A>
      <A HREF=#L511>EFFVCRATIO</A>
      <A HREF=#L512>ElementValues</A>
      <A HREF=#L513>EMITX</A>
      <A HREF=#L514>EMITXE</A>
      <A HREF=#L515>EMITY</A>
      <A HREF=#L516>EMITYE</A>
      <A HREF=#L517>EMITZ</A>
      <A HREF=#L518>EMITZE</A>
      <A HREF=#L519>ExponentOfResidual</A>
      <A HREF=#L520>FFS$NumericalDerivative</A>
      <A HREF=#L521>FitFunction</A>
      <A HREF=#L522>FSHIFT</A>
      <A HREF=#L523>GCUT</A>
      <A HREF=#L524>InitialOrbits</A>
      <A HREF=#L525>LOSSAMPL</A>
      <A HREF=#L526>LOSSDZ</A>
      <A HREF=#L527>MatchingAmplitude</A>
      <A HREF=#L528>MatchingResidual</A>
      <A HREF=#L529>MASS</A>
      <A HREF=#L530>MINCOUP</A>
      <A HREF=#L531>MOMENTUM</A>
      <A HREF=#L532>NBUNCH</A>
      <A HREF=#L533>NetResidual</A>
      <A HREF=#L534>NP</A>
      <A HREF=#L535>NPARA</A>
      <A HREF=#L536>OffMomentumWeight</A>
      <A HREF=#L537>OMEGA0</A>
      <A HREF=#L538>OpticsEpilog</A>
      <A HREF=#L539>OpticsProlog</A>
      <A HREF=#L540>PBUNCH</A>
      <A HREF=#L541>PhotonList</A>
      <A HREF=#L542>PHICAV</A>
      <A HREF=#L543>SIGE</A>
      <A HREF=#L544>SIGZ</A>
      <A HREF=#L545>SpeedOfLight</A>
      <A HREF=#L546>StabilityLevel</A>
      <A HREF=#L547>TITLE</A>
   <A HREF=#L548>SAVE</A>
   <A HREF=#L549>SEED</A>
   <A HREF=#L550>SHOW</A>
   <A HREF=#L551>SPLIT</A>
   <A HREF=#L552>STATUS(STAT)</A>
   <A HREF=#L553>STOP</A>
   <A HREF=#L554>SUSPEND(SUSP)</A>
   <A HREF=#L555>TERMINATE(TERM)</A>
   <A HREF=#L556>TYPE(T)</A>
   <A HREF=#L557>UNTIL</A>
   <A HREF=#L558>USE</A>
   <A HREF=#L559>VARIABLES(VAR)</A>
   <A HREF=#L560>VARY</A>
   <A HREF=#L561>VISIT</A>
   <A HREF=#L562>wildcards</A>
</PRE><HR>
<H3><A NAME=L1>
 </A></H3>
<PRE>
</PRE>
<H3><A NAME=L2>
ABORT</A></H3>
<PRE>If[{},Help2HTML`oA$["Terminates SAD immediately."],
 p$1147=1+p$1147[[1,2]];p1$1147=StringPosition["Terminates SAD immediately."[p$1147,-1],">::",1];
  p1$1147=If[p1$1147==={},27,-2+p$1147+p1$1147[[1,1]]];
  neq=Which["Terminates SAD immediately."[p$1147,4+p$1147]==="Text[",lx$1147:=Help2HTML`oa$;p$1147=5+p$1147;p1$1147-=1;
     p2$1147=5+p1$1147;p0$1147=-9+p$1147;
     If[(pe$1147=StringPosition["Terminates SAD immediately."[p$1147,-2],";;;"])<=>{},{Max[0,-1+
         ToExpression["Terminates SAD immediately."[p$1147+pe$1147[[1,2]],p1$1147]]],
        p1$1147=-2+p$1147+pe$1147[[1,1]]}[[
       1]],
      0],
    1,lx$1147:=Help2HTML`o9$;p2$1147=4+p1$1147;p0$1147=-4+p$1147;0];
  If[(equ$1147=Help2HTML`o8$["Terminates SAD immediately."[p$1147,p1$1147]])===Undefined,
   equ$1147="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["Terminates SAD immediately."[p$1147,p1$1147]]=equ$1147;LaTeX`ob$+=neq,
     --LaTeX`ob$;With[{lx$1147},out$1147=lx$1147@Typeset["Terminates SAD immediately."[p$1147,p1$1147],Format->Help2HTML`oB$];
        System["mv -f "//out$1147//" "//equ$1147]];
      Exit[]]];
   "Terminates SAD immediately."[1,Max[p0$1147,0]]//"<img  class=\"eqs\" SRC=\""//equ$1147//"\" />"//
   Help2HTML`oy$["Terminates SAD immediately."[p2$1147,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L553>STOP</A> <A HREF=#L485>QUIT</A> <A HREF=#L548>SAVE</A> <A HREF=#L558>USE</A> <A HREF=#L561>VISIT</A> <A HREF=#L14>BYE</A></PRE>
<H3><A NAME=L3>
APPEND(APP)</A></H3>
<PRE>If[{},
Help2HTML`oA$["APP {filename | file-number} switches the output stream to the specified file or the file number. The output is app\
ended to the existing file."],
p$1150=1+p$1150[[1,2]];p1$1150=StringPosition["APP {filename | file-number} switches the output stream to the specified file or th\
e file number. The output is appended to the existing file."[p$1150,-1],">::",1];
   p1$1150=If[p1$1150==={},142,-2+p$1150+p1$1150[[1,1]]];
neq=Which["APP {filename | file-number} switches the output stream to the specified file or the file number. The output is appende\
d to the existing file."[p$1150,4+p$1150]==="Text[",
    lx$1150:=Help2HTML`oa$;p$1150=5+p$1150;p1$1150-=1;p2$1150=5+p1$1150;p0$1150=-9+p$1150;
If[(pe$1150=StringPosition["APP {filename | file-number} switches the output stream to the specified file or the file number. The \
output is appended to the existing file."[p$1150,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["APP {filename | file-number} switches the output stream to the specified file or the file number. The output is a\
ppended to the existing file."[p$1150+pe$1150[[1,2]],p1$1150]]],
        p1$1150=-2+p$1150+pe$1150[[1,1]]}[[
       1]],
      0],
    1,lx$1150:=Help2HTML`o9$;p2$1150=4+p1$1150;p0$1150=-4+p$1150;0];
  If[(equ$1150=
Help2HTML`o8$["APP {filename | file-number} switches the output stream to the specified file or the file number. The output is app\
ended to the existing file."[p$1150,p1$1150]])===
    Undefined,
equ$1150="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["APP {filename | file-number} switches the ou\
tput stream to the specified file or the file number. The output is appended to the existing file."[p$1150,p1$1150]]=
       equ$1150;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1150},out$1150=lx$1150@Typeset["APP {filename | file-number} switches the output stream to the specified file or the file\
 number. The output is appended to the existing file."[p$1150,p1$1150],Format->Help2HTML`oB$];
        System["mv -f "//out$1150//" "//equ$1150]];
      Exit[]]];
   "APP {filename | file-number} switches the output stream to the specified file or the file number. The output is appended to th\
e existing file."[1,Max[p0$1150,0]]//"<img  class=\"eqs\" SRC=\""//equ$1150//"\" />"//
Help2HTML`oy$["APP {filename | file-number} switches the output stream to the specified file or the file number. The output is app\
ended to the existing file."[p2$1150,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L555>TERMINATE(TERM)</A> <A HREF=#L34>CLOSE(CLO)</A> <A HREF=#L471>INPUT(IN)</A> <A HREF=#L487>READ</A> <A HREF=#L480>OUTPUT(OUT)</A> <A HREF=#L296>END</A></PRE>
<H3><A NAME=L4>
ATTRIBUTE(ATTR)</A></H3>
<PRE>If[{},
Help2HTML`oA$["Usage: ATTR element-pattern\n\nprints out the current value, minimum and maximum values, COUPLEd element and its co\
efficient for elements which match the element-pattern."],
p$1153=1+p$1153[[1,2]];p1$1153=StringPosition["Usage: ATTR element-pattern\n\nprints out the current value, minimum and maximum va\
lues, COUPLEd element and its coefficient for elements which match the element-pattern."[p$1153,-1],">::",1];
   p1$1153=If[p1$1153==={},168,-2+p$1153+p1$1153[[1,1]]];
neq=Which["Usage: ATTR element-pattern\n\nprints out the current value, minimum and maximum values, COUPLEd element and its coeffi\
cient for elements which match the element-pattern."[p$1153,4+p$1153]==="Text[",
    lx$1153:=Help2HTML`oa$;p$1153=5+p$1153;p1$1153-=1;p2$1153=5+p1$1153;p0$1153=-9+p$1153;
If[(pe$1153=StringPosition["Usage: ATTR element-pattern\n\nprints out the current value, minimum and maximum values, COUPLEd eleme\
nt and its coefficient for elements which match the element-pattern."[p$1153,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Usage: ATTR element-pattern\n\nprints out the current value, minimum and maximum values, COUPLEd element and its \
coefficient for elements which match the element-pattern."[p$1153+pe$1153[[1,2]],p1$1153]]],
        p1$1153=-2+p$1153+pe$1153[[1,1]]}[[
       1]],
      0],
    1,lx$1153:=Help2HTML`o9$;p2$1153=4+p1$1153;p0$1153=-4+p$1153;0];
  If[(equ$1153=
Help2HTML`o8$["Usage: ATTR element-pattern\n\nprints out the current value, minimum and maximum values, COUPLEd element and its co\
efficient for elements which match the element-pattern."[p$1153,p1$1153]])===
    Undefined,
equ$1153="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Usage: ATTR element-pattern\n\nprints out th\
e current value, minimum and maximum values, COUPLEd element and its coefficient for elements which match the element-pattern."[p
         $1153,p1$1153]]=
       equ$1153;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1153},out$1153=lx$1153@Typeset["Usage: ATTR element-pattern\n\nprints out the current value, minimum and maximum values, \
COUPLEd element and its coefficient for elements which match the element-pattern."[p$1153,p1$1153],Format->Help2HTML`oB$];
        System["mv -f "//out$1153//" "//equ$1153]];
      Exit[]]];
   "Usage: ATTR element-pattern\n\nprints out the current value, minimum and maximum values, COUPLEd element and its coefficient f\
or elements which match the element-pattern."[1,Max[p0$1153,0]]//"<img  class=\"eqs\" SRC=\""//equ$1153//"\" />"//
Help2HTML`oy$["Usage: ATTR element-pattern\n\nprints out the current value, minimum and maximum values, COUPLEd element and its co\
efficient for elements which match the element-pattern."[p2$1153,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L35>COUPLE(COUP)</A> <A HREF=#L497>set-value-of-element</A> <A HREF=#L562>wildcards</A></PRE>
<H3><A NAME=L5>
beam-line</A></H3>
<PRE>If[{},
Help2HTML`oA$[" A beam line is defined in the MAIN level by LINE command as:\n\n   LINE a = ( [n1*][-]l1 [ [n2*]l2 ...] ) [b = ( .\
.. )];\n\nwhere l1, l2 are either an element or a line. n1, n2 are positive integers to repeat the same element. An optional negat\
ive sign in fromt of element means the negative orientation of the element of the line. A negative orientation of a line is inheri\
ted by its elements.\n The first element of a beam line must be a MARK element, if it is used by FFS, USE, VISIT.\n Please do not \
confuse the LINE command in the MAIN level with the LINE function in FFS.\n A beam line can be accessed within FFS via beam-line-f\
unctions as shown below."],
p$1156=1+p$1156[[1,2]];p1$1156=StringPosition[" A beam line is defined in the MAIN level by LINE command as:\n\n   LINE a = ( [n1*\
][-]l1 [ [n2*]l2 ...] ) [b = ( ... )];\n\nwhere l1, l2 are either an element or a line. n1, n2 are positive integers to repeat the\
 same element. An optional negative sign in fromt of element means the negative orientation of the element of the line. A negative\
 orientation of a line is inherited by its elements.\n The first element of a beam line must be a MARK element, if it is used by F\
FS, USE, VISIT.\n Please do not confuse the LINE command in the MAIN level with the LINE function in FFS.\n A beam line can be acc\
essed within FFS via beam-line-functions as shown below."[p$1156,-1],">::",1];
   p1$1156=If[p1$1156==={},652,-2+p$1156+p1$1156[[1,1]]];
neq=Which[" A beam line is defined in the MAIN level by LINE command as:\n\n   LINE a = ( [n1*][-]l1 [ [n2*]l2 ...] ) [b = ( ... )\
];\n\nwhere l1, l2 are either an element or a line. n1, n2 are positive integers to repeat the same element. An optional negative \
sign in fromt of element means the negative orientation of the element of the line. A negative orientation of a line is inherited \
by its elements.\n The first element of a beam line must be a MARK element, if it is used by FFS, USE, VISIT.\n Please do not conf\
use the LINE command in the MAIN level with the LINE function in FFS.\n A beam line can be accessed within FFS via beam-line-funct\
ions as shown below."[p$1156,4+p$1156]==="Text[",
    lx$1156:=Help2HTML`oa$;p$1156=5+p$1156;p1$1156-=1;p2$1156=5+p1$1156;p0$1156=-9+p$1156;
If[(pe$1156=StringPosition[" A beam line is defined in the MAIN level by LINE command as:\n\n   LINE a = ( [n1*][-]l1 [ [n2*]l2 ..\
.] ) [b = ( ... )];\n\nwhere l1, l2 are either an element or a line. n1, n2 are positive integers to repeat the same element. An o\
ptional negative sign in fromt of element means the negative orientation of the element of the line. A negative orientation of a l\
ine is inherited by its elements.\n The first element of a beam line must be a MARK element, if it is used by FFS, USE, VISIT.\n P\
lease do not confuse the LINE command in the MAIN level with the LINE function in FFS.\n A beam line can be accessed within FFS vi\
a beam-line-functions as shown below."[p$1156,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression[" A beam line is defined in the MAIN level by LINE command as:\n\n   LINE a = ( [n1*][-]l1 [ [n2*]l2 ...] ) [b = (\
 ... )];\n\nwhere l1, l2 are either an element or a line. n1, n2 are positive integers to repeat the same element. An optional neg\
ative sign in fromt of element means the negative orientation of the element of the line. A negative orientation of a line is inhe\
rited by its elements.\n The first element of a beam line must be a MARK element, if it is used by FFS, USE, VISIT.\n Please do no\
t confuse the LINE command in the MAIN level with the LINE function in FFS.\n A beam line can be accessed within FFS via beam-line\
-functions as shown below."[p$1156+pe$1156[[1,2]],p1$1156]]],
        p1$1156=-2+p$1156+pe$1156[[1,1]]}[[
       1]],
      0],
    1,lx$1156:=Help2HTML`o9$;p2$1156=4+p1$1156;p0$1156=-4+p$1156;0];
  If[(equ$1156=
Help2HTML`o8$[" A beam line is defined in the MAIN level by LINE command as:\n\n   LINE a = ( [n1*][-]l1 [ [n2*]l2 ...] ) [b = ( .\
.. )];\n\nwhere l1, l2 are either an element or a line. n1, n2 are positive integers to repeat the same element. An optional negat\
ive sign in fromt of element means the negative orientation of the element of the line. A negative orientation of a line is inheri\
ted by its elements.\n The first element of a beam line must be a MARK element, if it is used by FFS, USE, VISIT.\n Please do not \
confuse the LINE command in the MAIN level with the LINE function in FFS.\n A beam line can be accessed within FFS via beam-line-f\
unctions as shown below."[p$1156,p1$1156]])===
    Undefined,
equ$1156="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[" A beam line is defined in the MAIN level by\
 LINE command as:\n\n   LINE a = ( [n1*][-]l1 [ [n2*]l2 ...] ) [b = ( ... )];\n\nwhere l1, l2 are either an element or a line. n1,\
 n2 are positive integers to repeat the same element. An optional negative sign in fromt of element means the negative orientation\
 of the element of the line. A negative orientation of a line is inherited by its elements.\n The first element of a beam line mus\
t be a MARK element, if it is used by FFS, USE, VISIT.\n Please do not confuse the LINE command in the MAIN level with the LINE fu\
nction in FFS.\n A beam line can be accessed within FFS via beam-line-functions as shown below."[p$1156,p1$1156]]=
       equ$1156;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1156},out$1156=lx$1156@Typeset[" A beam line is defined in the MAIN level by LINE command as:\n\n   LINE a = ( [n1*][-]l1\
 [ [n2*]l2 ...] ) [b = ( ... )];\n\nwhere l1, l2 are either an element or a line. n1, n2 are positive integers to repeat the same \
element. An optional negative sign in fromt of element means the negative orientation of the element of the line. A negative orien\
tation of a line is inherited by its elements.\n The first element of a beam line must be a MARK element, if it is used by FFS, US\
E, VISIT.\n Please do not confuse the LINE command in the MAIN level with the LINE function in FFS.\n A beam line can be accessed \
within FFS via beam-line-functions as shown below."[p$1156,p1$1156],Format->Help2HTML`oB$];
        System["mv -f "//out$1156//" "//equ$1156]];
      Exit[]]];
   " A beam line is defined in the MAIN level by LINE command as:\n\n   LINE a = ( [n1*][-]l1 [ [n2*]l2 ...] ) [b = ( ... )];\n\nw\
here l1, l2 are either an element or a line. n1, n2 are positive integers to repeat the same element. An optional negative sign in\
 fromt of element means the negative orientation of the element of the line. A negative orientation of a line is inherited by its \
elements.\n The first element of a beam line must be a MARK element, if it is used by FFS, USE, VISIT.\n Please do not confuse the\
 LINE command in the MAIN level with the LINE function in FFS.\n A beam line can be accessed within FFS via beam-line-functions as\
 shown below."[1,Max[p0$1156,0]]//"<img  class=\"eqs\" SRC=\""//equ$1156//"\" />"//
Help2HTML`oy$[" A beam line is defined in the MAIN level by LINE command as:\n\n   LINE a = ( [n1*][-]l1 [ [n2*]l2 ...] ) [b = ( .\
.. )];\n\nwhere l1, l2 are either an element or a line. n1, n2 are positive integers to repeat the same element. An optional negat\
ive sign in fromt of element means the negative orientation of the element of the line. A negative orientation of a line is inheri\
ted by its elements.\n The first element of a beam line must be a MARK element, if it is used by FFS, USE, VISIT.\n Please do not \
confuse the LINE command in the MAIN level with the LINE function in FFS.\n A beam line can be accessed within FFS via beam-line-f\
unctions as shown below."[p2$1156,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L75>elements</A> <A HREF=#L12>orientation-of-an-element</A> <A HREF=#L558>USE</A> <A HREF=#L561>VISIT</A></PRE>
<UL>
<LI>
<H3><A NAME=L6>
beam-line-functions</A></H3>
<PRE>If[{},Help2HTML`oA$["Functions/objects to construct/edit beam lines and elements in FFS."],
 p$1159=1+p$1159[[1,2]];p1$1159=StringPosition["Functions/objects to construct/edit beam lines and elements in FFS."[p$1159,-1],
    ">::",1];
   p1$1159=If[p1$1159==={},67,-2+p$1159+p1$1159[[1,1]]];
  neq=Which["Functions/objects to construct/edit beam lines and elements in FFS."[p$1159,4+p$1159]==="Text[",
    lx$1159:=Help2HTML`oa$;p$1159=5+p$1159;p1$1159-=1;p2$1159=5+p1$1159;p0$1159=-9+p$1159;
     If[(pe$1159=StringPosition["Functions/objects to construct/edit beam lines and elements in FFS."[p$1159,-2],";;;"])<=>{},
      {Max[0,-1+ToExpression["Functions/objects to construct/edit beam lines and elements in FFS."[p$1159+pe$1159[[1,2]],p1$1159]]
        ],p1$1159=-2+p$1159+pe$1159[[1,1]]}[[
       1]],
      0],
    1,lx$1159:=Help2HTML`o9$;p2$1159=4+p1$1159;p0$1159=-4+p$1159;0];
  If[(equ$1159=Help2HTML`o8$["Functions/objects to construct/edit beam lines and elements in FFS."[p$1159,p1$1159]])===Undefined,
   equ$1159="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["Functions/objects to construct/edit beam lines and elements in FFS."[p$1159,p1$1159]]=equ$1159;
      LaTeX`ob$+=neq,
     --LaTeX`ob$;With[{lx$1159},out$1159=lx$1159@Typeset["Functions/objects to construct/edit beam lines and elements in FFS."[p
           $1159,p1$1159],Format->Help2HTML`oB$];
        System["mv -f "//out$1159//" "//equ$1159]];
      Exit[]]];
   "Functions/objects to construct/edit beam lines and elements in FFS."[1,Max[p0$1159,0]]//"<img  class=\"eqs\" SRC=\""//
   equ$1159//"\" />"//Help2HTML`oy$["Functions/objects to construct/edit beam lines and elements in FFS."[p2$1159,-1]]
]</PRE>
<UL>
<LI>
<H3><A NAME=L7>
BeamLine</A></H3>
<PRE>If[{},
Help2HTML`oA$["Usage: BeamLine[e1, e2, ...];\n\nwhere e1, e2 has a form of\n\n   [ - ][ n* ] x ,\n\nwith x being one of\n\n1) a na\
me (either a symbol or a character string) of an element defined in MAIN.\n2) a name (either a symbol or a character string) of a \
LINE defined in MAIN.\n3) a BeamLine object.\n\nAn optional negative sign specifies the direction and a number n the repetition nu\
mber in the same way as MAIN. A BeamLine object is automatically expanded to the lowest level whenever it is evaluated. Editing of\
 BeamLine can be done using any List-handling functions such as Join, Insert, Delete, etc. of FFS.\n\n A BeamLine object can be us\
ed for FFS calculation when it is used as the\nargument of USE or VISIT commands:\n\nExamples:\n1) USE BeamLine[IP,QF,QD]\n2) aaa=\
ExtractBeamLine[];\n   USE Join[aaa,-aaa]\n\n In these cases the new beam line becomes a new LINE in the MAIN level, with a name w\
hich is created automatically."],
p$1161=1+p$1161[[1,2]];p1$1161=StringPosition["Usage: BeamLine[e1, e2, ...];\n\nwhere e1, e2 has a form of\n\n   [ - ][ n* ] x ,\n\
\nwith x being one of\n\n1) a name (either a symbol or a character string) of an element defined in MAIN.\n2) a name (either a sym\
bol or a character string) of a LINE defined in MAIN.\n3) a BeamLine object.\n\nAn optional negative sign specifies the direction \
and a number n the repetition number in the same way as MAIN. A BeamLine object is automatically expanded to the lowest level when\
ever it is evaluated. Editing of BeamLine can be done using any List-handling functions such as Join, Insert, Delete, etc. of FFS.\
\n\n A BeamLine object can be used for FFS calculation when it is used as the\nargument of USE or VISIT commands:\n\nExamples:\n1)\
 USE BeamLine[IP,QF,QD]\n2) aaa=ExtractBeamLine[];\n   USE Join[aaa,-aaa]\n\n In these cases the new beam line becomes a new LINE \
in the MAIN level, with a name which is created automatically."[p$1161,-1],">::",1];
   p1$1161=If[p1$1161==={},903,-2+p$1161+p1$1161[[1,1]]];
neq=Which["Usage: BeamLine[e1, e2, ...];\n\nwhere e1, e2 has a form of\n\n   [ - ][ n* ] x ,\n\nwith x being one of\n\n1) a name (\
either a symbol or a character string) of an element defined in MAIN.\n2) a name (either a symbol or a character string) of a LINE\
 defined in MAIN.\n3) a BeamLine object.\n\nAn optional negative sign specifies the direction and a number n the repetition number\
 in the same way as MAIN. A BeamLine object is automatically expanded to the lowest level whenever it is evaluated. Editing of Bea\
mLine can be done using any List-handling functions such as Join, Insert, Delete, etc. of FFS.\n\n A BeamLine object can be used f\
or FFS calculation when it is used as the\nargument of USE or VISIT commands:\n\nExamples:\n1) USE BeamLine[IP,QF,QD]\n2) aaa=Extr\
actBeamLine[];\n   USE Join[aaa,-aaa]\n\n In these cases the new beam line becomes a new LINE in the MAIN level, with a name which\
 is created automatically."[p$1161,4+p$1161]==="Text[",
    lx$1161:=Help2HTML`oa$;p$1161=5+p$1161;p1$1161-=1;p2$1161=5+p1$1161;p0$1161=-9+p$1161;
If[(pe$1161=StringPosition["Usage: BeamLine[e1, e2, ...];\n\nwhere e1, e2 has a form of\n\n   [ - ][ n* ] x ,\n\nwith x being one \
of\n\n1) a name (either a symbol or a character string) of an element defined in MAIN.\n2) a name (either a symbol or a character \
string) of a LINE defined in MAIN.\n3) a BeamLine object.\n\nAn optional negative sign specifies the direction and a number n the \
repetition number in the same way as MAIN. A BeamLine object is automatically expanded to the lowest level whenever it is evaluate\
d. Editing of BeamLine can be done using any List-handling functions such as Join, Insert, Delete, etc. of FFS.\n\n A BeamLine obj\
ect can be used for FFS calculation when it is used as the\nargument of USE or VISIT commands:\n\nExamples:\n1) USE BeamLine[IP,QF\
,QD]\n2) aaa=ExtractBeamLine[];\n   USE Join[aaa,-aaa]\n\n In these cases the new beam line becomes a new LINE in the MAIN level, \
with a name which is created automatically."[p$1161,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Usage: BeamLine[e1, e2, ...];\n\nwhere e1, e2 has a form of\n\n   [ - ][ n* ] x ,\n\nwith x being one of\n\n1) a \
name (either a symbol or a character string) of an element defined in MAIN.\n2) a name (either a symbol or a character string) of \
a LINE defined in MAIN.\n3) a BeamLine object.\n\nAn optional negative sign specifies the direction and a number n the repetition \
number in the same way as MAIN. A BeamLine object is automatically expanded to the lowest level whenever it is evaluated. Editing \
of BeamLine can be done using any List-handling functions such as Join, Insert, Delete, etc. of FFS.\n\n A BeamLine object can be \
used for FFS calculation when it is used as the\nargument of USE or VISIT commands:\n\nExamples:\n1) USE BeamLine[IP,QF,QD]\n2) aa\
a=ExtractBeamLine[];\n   USE Join[aaa,-aaa]\n\n In these cases the new beam line becomes a new LINE in the MAIN level, with a name\
 which is created automatically."[p$1161+pe$1161[[1,2]],p1$1161]]],
        p1$1161=-2+p$1161+pe$1161[[1,1]]}[[
       1]],
      0],
    1,lx$1161:=Help2HTML`o9$;p2$1161=4+p1$1161;p0$1161=-4+p$1161;0];
  If[(equ$1161=
Help2HTML`o8$["Usage: BeamLine[e1, e2, ...];\n\nwhere e1, e2 has a form of\n\n   [ - ][ n* ] x ,\n\nwith x being one of\n\n1) a na\
me (either a symbol or a character string) of an element defined in MAIN.\n2) a name (either a symbol or a character string) of a \
LINE defined in MAIN.\n3) a BeamLine object.\n\nAn optional negative sign specifies the direction and a number n the repetition nu\
mber in the same way as MAIN. A BeamLine object is automatically expanded to the lowest level whenever it is evaluated. Editing of\
 BeamLine can be done using any List-handling functions such as Join, Insert, Delete, etc. of FFS.\n\n A BeamLine object can be us\
ed for FFS calculation when it is used as the\nargument of USE or VISIT commands:\n\nExamples:\n1) USE BeamLine[IP,QF,QD]\n2) aaa=\
ExtractBeamLine[];\n   USE Join[aaa,-aaa]\n\n In these cases the new beam line becomes a new LINE in the MAIN level, with a name w\
hich is created automatically."[p$1161,p1$1161]])===
    Undefined,
equ$1161="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Usage: BeamLine[e1, e2, ...];\n\nwhere e1, e\
2 has a form of\n\n   [ - ][ n* ] x ,\n\nwith x being one of\n\n1) a name (either a symbol or a character string) of an element de\
fined in MAIN.\n2) a name (either a symbol or a character string) of a LINE defined in MAIN.\n3) a BeamLine object.\n\nAn optional\
 negative sign specifies the direction and a number n the repetition number in the same way as MAIN. A BeamLine object is automati\
cally expanded to the lowest level whenever it is evaluated. Editing of BeamLine can be done using any List-handling functions suc\
h as Join, Insert, Delete, etc. of FFS.\n\n A BeamLine object can be used for FFS calculation when it is used as the\nargument of \
USE or VISIT commands:\n\nExamples:\n1) USE BeamLine[IP,QF,QD]\n2) aaa=ExtractBeamLine[];\n   USE Join[aaa,-aaa]\n\n In these case\
s the new beam line becomes a new LINE in the MAIN level, with a name which is created automatically."[p$1161,p1$1161]]=
       equ$1161;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1161},out$1161=lx$1161@Typeset["Usage: BeamLine[e1, e2, ...];\n\nwhere e1, e2 has a form of\n\n   [ - ][ n* ] x ,\n\nwith\
 x being one of\n\n1) a name (either a symbol or a character string) of an element defined in MAIN.\n2) a name (either a symbol or\
 a character string) of a LINE defined in MAIN.\n3) a BeamLine object.\n\nAn optional negative sign specifies the direction and a \
number n the repetition number in the same way as MAIN. A BeamLine object is automatically expanded to the lowest level whenever i\
t is evaluated. Editing of BeamLine can be done using any List-handling functions such as Join, Insert, Delete, etc. of FFS.\n\n A\
 BeamLine object can be used for FFS calculation when it is used as the\nargument of USE or VISIT commands:\n\nExamples:\n1) USE B\
eamLine[IP,QF,QD]\n2) aaa=ExtractBeamLine[];\n   USE Join[aaa,-aaa]\n\n In these cases the new beam line becomes a new LINE in the\
 MAIN level, with a name which is created automatically."[p$1161,p1$1161],Format->Help2HTML`oB$];
        System["mv -f "//out$1161//" "//equ$1161]];
      Exit[]]];
   "Usage: BeamLine[e1, e2, ...];\n\nwhere e1, e2 has a form of\n\n   [ - ][ n* ] x ,\n\nwith x being one of\n\n1) a name (either \
a symbol or a character string) of an element defined in MAIN.\n2) a name (either a symbol or a character string) of a LINE define\
d in MAIN.\n3) a BeamLine object.\n\nAn optional negative sign specifies the direction and a number n the repetition number in the\
 same way as MAIN. A BeamLine object is automatically expanded to the lowest level whenever it is evaluated. Editing of BeamLine c\
an be done using any List-handling functions such as Join, Insert, Delete, etc. of FFS.\n\n A BeamLine object can be used for FFS \
calculation when it is used as the\nargument of USE or VISIT commands:\n\nExamples:\n1) USE BeamLine[IP,QF,QD]\n2) aaa=ExtractBeam\
Line[];\n   USE Join[aaa,-aaa]\n\n In these cases the new beam line becomes a new LINE in the MAIN level, with a name which is cre\
ated automatically."[1,Max[p0$1161,0]]//"<img  class=\"eqs\" SRC=\""//equ$1161//"\" />"//
Help2HTML`oy$["Usage: BeamLine[e1, e2, ...];\n\nwhere e1, e2 has a form of\n\n   [ - ][ n* ] x ,\n\nwith x being one of\n\n1) a na\
me (either a symbol or a character string) of an element defined in MAIN.\n2) a name (either a symbol or a character string) of a \
LINE defined in MAIN.\n3) a BeamLine object.\n\nAn optional negative sign specifies the direction and a number n the repetition nu\
mber in the same way as MAIN. A BeamLine object is automatically expanded to the lowest level whenever it is evaluated. Editing of\
 BeamLine can be done using any List-handling functions such as Join, Insert, Delete, etc. of FFS.\n\n A BeamLine object can be us\
ed for FFS calculation when it is used as the\nargument of USE or VISIT commands:\n\nExamples:\n1) USE BeamLine[IP,QF,QD]\n2) aaa=\
ExtractBeamLine[];\n   USE Join[aaa,-aaa]\n\n In these cases the new beam line becomes a new LINE in the MAIN level, with a name w\
hich is created automatically."[p2$1161,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L9>ExtractBeamLine</A> <A HREF=#L10>PrintBeamLine</A> <A HREF=#L11>WriteBeamLine</A> <A HREF=#L12>orientation-of-an-element</A> <A HREF=#L558>USE</A> <A HREF=#L561>VISIT</A></PRE>
<LI>
<H3><A NAME=L8>
BeamLineName</A></H3>
<PRE>If[{},
Help2HTML`oA$["BeamLineName[] returns the name of the current beam line. If a BeamLine object is used by USE or VISIT, the new bea\
m line becomes a new LINE in the MAIN level, with a name which is created automatically."],
 p$1164=1+p$1164[[1,2]];p1$1164=StringPosition["BeamLineName[] returns the name of the current beam line. If a BeamLine object is \
used by USE or VISIT, the new beam line becomes a new LINE in the MAIN level, with a name which is created automatically."[p$1164,
     -1],
    ">::",1];
   p1$1164=If[p1$1164==={},203,-2+p$1164+p1$1164[[1,1]]];
neq=Which["BeamLineName[] returns the name of the current beam line. If a BeamLine object is used by USE or VISIT, the new beam li\
ne becomes a new LINE in the MAIN level, with a name which is created automatically."[p$1164,4+p$1164]==="Text[",
    lx$1164:=Help2HTML`oa$;p$1164=5+p$1164;p1$1164-=1;p2$1164=5+p1$1164;p0$1164=-9+p$1164;
If[(pe$1164=StringPosition["BeamLineName[] returns the name of the current beam line. If a BeamLine object is used by USE or VISIT\
, the new beam line becomes a new LINE in the MAIN level, with a name which is created automatically."[p$1164,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["BeamLineName[] returns the name of the current beam line. If a BeamLine object is used by USE or VISIT, the new b\
eam line becomes a new LINE in the MAIN level, with a name which is created automatically."[p$1164+pe$1164[[1,2]],p1$1164]]],
        p1$1164=-2+p$1164+pe$1164[[1,1]]}[[
       1]],
      0],
    1,lx$1164:=Help2HTML`o9$;p2$1164=4+p1$1164;p0$1164=-4+p$1164;0];
  If[(equ$1164=
Help2HTML`o8$["BeamLineName[] returns the name of the current beam line. If a BeamLine object is used by USE or VISIT, the new bea\
m line becomes a new LINE in the MAIN level, with a name which is created automatically."[p$1164,p1$1164]])===
    Undefined,
equ$1164="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["BeamLineName[] returns the name of the curre\
nt beam line. If a BeamLine object is used by USE or VISIT, the new beam line becomes a new LINE in the MAIN level, with a name wh\
ich is created automatically."[p$1164,p1$1164]]=
       equ$1164;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1164},out$1164=lx$1164@Typeset["BeamLineName[] returns the name of the current beam line. If a BeamLine object is used by\
 USE or VISIT, the new beam line becomes a new LINE in the MAIN level, with a name which is created automatically."[p$1164,p1$1164
           ],Format->Help2HTML`oB$];
        System["mv -f "//out$1164//" "//equ$1164]];
      Exit[]]];
   "BeamLineName[] returns the name of the current beam line. If a BeamLine object is used by USE or VISIT, the new beam line beco\
mes a new LINE in the MAIN level, with a name which is created automatically."[1,Max[p0$1164,0]]//"<img  class=\"eqs\" SRC=\""//
   equ$1164//"\" />"//
Help2HTML`oy$["BeamLineName[] returns the name of the current beam line. If a BeamLine object is used by USE or VISIT, the new bea\
m line becomes a new LINE in the MAIN level, with a name which is created automatically."[p2$1164,-1]]
]</PRE>
<LI>
<H3><A NAME=L9>
ExtractBeamLine</A></H3>
<PRE>If[{},
Help2HTML`oA$["Usage: ExtractBeamLine[line]\n\nreturns a BeamLine object which represents the expanded form of line which has been\
 defined in MAIN. If line is omitted, the current line is assumed."],
p$1166=1+p$1166[[1,2]];p1$1166=StringPosition["Usage: ExtractBeamLine[line]\n\nreturns a BeamLine object which represents the expa\
nded form of line which has been defined in MAIN. If line is omitted, the current line is assumed."[p$1166,-1],">::",1];
   p1$1166=If[p1$1166==={},179,-2+p$1166+p1$1166[[1,1]]];
neq=Which["Usage: ExtractBeamLine[line]\n\nreturns a BeamLine object which represents the expanded form of line which has been def\
ined in MAIN. If line is omitted, the current line is assumed."[p$1166,4+p$1166]==="Text[",
    lx$1166:=Help2HTML`oa$;p$1166=5+p$1166;p1$1166-=1;p2$1166=5+p1$1166;p0$1166=-9+p$1166;
If[(pe$1166=StringPosition["Usage: ExtractBeamLine[line]\n\nreturns a BeamLine object which represents the expanded form of line w\
hich has been defined in MAIN. If line is omitted, the current line is assumed."[p$1166,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Usage: ExtractBeamLine[line]\n\nreturns a BeamLine object which represents the expanded form of line which has be\
en defined in MAIN. If line is omitted, the current line is assumed."[p$1166+pe$1166[[1,2]],p1$1166]]],
        p1$1166=-2+p$1166+pe$1166[[1,1]]}[[
       1]],
      0],
    1,lx$1166:=Help2HTML`o9$;p2$1166=4+p1$1166;p0$1166=-4+p$1166;0];
  If[(equ$1166=
Help2HTML`o8$["Usage: ExtractBeamLine[line]\n\nreturns a BeamLine object which represents the expanded form of line which has been\
 defined in MAIN. If line is omitted, the current line is assumed."[p$1166,p1$1166]])===
    Undefined,
equ$1166="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Usage: ExtractBeamLine[line]\n\nreturns a Be\
amLine object which represents the expanded form of line which has been defined in MAIN. If line is omitted, the current line is a\
ssumed."[p$1166,p1$1166]]=
       equ$1166;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1166},out$1166=lx$1166@Typeset["Usage: ExtractBeamLine[line]\n\nreturns a BeamLine object which represents the expanded f\
orm of line which has been defined in MAIN. If line is omitted, the current line is assumed."[p$1166,p1$1166],
          Format->Help2HTML`oB$];
        System["mv -f "//out$1166//" "//equ$1166]];
      Exit[]]];
   "Usage: ExtractBeamLine[line]\n\nreturns a BeamLine object which represents the expanded form of line which has been defined in\
 MAIN. If line is omitted, the current line is assumed."[1,Max[p0$1166,0]]//"<img  class=\"eqs\" SRC=\""//equ$1166//"\" />"//
   Help2HTML`oy$["Usage: ExtractBeamLine[line]\n\nreturns a BeamLine object which represents the expanded form of line which has b\
een defined in MAIN. If line is omitted, the current line is assumed."[p2$1166,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L7>BeamLine</A> <A HREF=#L10>PrintBeamLine</A> <A HREF=#L11>WriteBeamLine</A> <A HREF=#L558>USE</A> <A HREF=#L561>VISIT</A></PRE>
<LI>
<H3><A NAME=L10>
PrintBeamLine</A></H3>
<PRE>If[{},
Help2HTML`oA$["Usage: PrintBeamLine[b1,.. ,option]\n\nwrites the BeamLine b1,.. to stdout. If b1.. is omitted the current beam lin\
e is assumed. If Format->\"MAIN\" is given, it writes in the MAIN-input format. If Name->{name1,..} is given, names of BeamLines a\
re also written. The number of Name must be not smaller than number of BeamLines."],
p$1169=1+p$1169[[1,2]];p1$1169=StringPosition["Usage: PrintBeamLine[b1,.. ,option]\n\nwrites the BeamLine b1,.. to stdout. If b1..\
 is omitted the current beam line is assumed. If Format->\"MAIN\" is given, it writes in the MAIN-input format. If Name->{name1,..\
} is given, names of BeamLines are also written. The number of Name must be not smaller than number of BeamLines."[p$1169,-1],
    ">::",1];
   p1$1169=If[p1$1169==={},322,-2+p$1169+p1$1169[[1,1]]];
neq=Which["Usage: PrintBeamLine[b1,.. ,option]\n\nwrites the BeamLine b1,.. to stdout. If b1.. is omitted the current beam line is\
 assumed. If Format->\"MAIN\" is given, it writes in the MAIN-input format. If Name->{name1,..} is given, names of BeamLines are a\
lso written. The number of Name must be not smaller than number of BeamLines."[p$1169,4+p$1169]==="Text[",
    lx$1169:=Help2HTML`oa$;p$1169=5+p$1169;p1$1169-=1;p2$1169=5+p1$1169;p0$1169=-9+p$1169;
If[(pe$1169=StringPosition["Usage: PrintBeamLine[b1,.. ,option]\n\nwrites the BeamLine b1,.. to stdout. If b1.. is omitted the cur\
rent beam line is assumed. If Format->\"MAIN\" is given, it writes in the MAIN-input format. If Name->{name1,..} is given, names o\
f BeamLines are also written. The number of Name must be not smaller than number of BeamLines."[p$1169,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Usage: PrintBeamLine[b1,.. ,option]\n\nwrites the BeamLine b1,.. to stdout. If b1.. is omitted the current beam l\
ine is assumed. If Format->\"MAIN\" is given, it writes in the MAIN-input format. If Name->{name1,..} is given, names of BeamLines\
 are also written. The number of Name must be not smaller than number of BeamLines."[p$1169+pe$1169[[1,2]],p1$1169]]],
        p1$1169=-2+p$1169+pe$1169[[1,1]]}[[
       1]],
      0],
    1,lx$1169:=Help2HTML`o9$;p2$1169=4+p1$1169;p0$1169=-4+p$1169;0];
  If[(equ$1169=
Help2HTML`o8$["Usage: PrintBeamLine[b1,.. ,option]\n\nwrites the BeamLine b1,.. to stdout. If b1.. is omitted the current beam lin\
e is assumed. If Format->\"MAIN\" is given, it writes in the MAIN-input format. If Name->{name1,..} is given, names of BeamLines a\
re also written. The number of Name must be not smaller than number of BeamLines."[p$1169,p1$1169]])===
    Undefined,
equ$1169="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Usage: PrintBeamLine[b1,.. ,option]\n\nwrite\
s the BeamLine b1,.. to stdout. If b1.. is omitted the current beam line is assumed. If Format->\"MAIN\" is given, it writes in th\
e MAIN-input format. If Name->{name1,..} is given, names of BeamLines are also written. The number of Name must be not smaller tha\
n number of BeamLines."[p$1169,p1$1169]]=
       equ$1169;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1169},out$1169=lx$1169@Typeset["Usage: PrintBeamLine[b1,.. ,option]\n\nwrites the BeamLine b1,.. to stdout. If b1.. is om\
itted the current beam line is assumed. If Format->\"MAIN\" is given, it writes in the MAIN-input format. If Name->{name1,..} is g\
iven, names of BeamLines are also written. The number of Name must be not smaller than number of BeamLines."[p$1169,p1$1169],
          Format->Help2HTML`oB$];
        System["mv -f "//out$1169//" "//equ$1169]];
      Exit[]]];
   "Usage: PrintBeamLine[b1,.. ,option]\n\nwrites the BeamLine b1,.. to stdout. If b1.. is omitted the current beam line is assume\
d. If Format->\"MAIN\" is given, it writes in the MAIN-input format. If Name->{name1,..} is given, names of BeamLines are also wri\
tten. The number of Name must be not smaller than number of BeamLines."[1,Max[p0$1169,0]]//"<img  class=\"eqs\" SRC=\""//equ$1169//
   "\" />"//
Help2HTML`oy$["Usage: PrintBeamLine[b1,.. ,option]\n\nwrites the BeamLine b1,.. to stdout. If b1.. is omitted the current beam lin\
e is assumed. If Format->\"MAIN\" is given, it writes in the MAIN-input format. If Name->{name1,..} is given, names of BeamLines a\
re also written. The number of Name must be not smaller than number of BeamLines."[p2$1169,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L7>BeamLine</A> <A HREF=#L9>ExtractBeamLine</A> <A HREF=#L11>WriteBeamLine</A> <A HREF=#L558>USE</A> <A HREF=#L561>VISIT</A></PRE>
<LI>
<H3><A NAME=L11>
WriteBeamLine</A></H3>
<PRE>If[{},
Help2HTML`oA$["Usage: WriteBeamLine[f, b1,.. ,option]\n\nwrites the BeamLine b1,.. to file f. If b1.. is omitted the current beam \
line is assumed. If Format->\"MAIN\" is given, it writes in the MAIN-input format. If Name->{name1,..} is given, names of BeamLine\
s are also written. The number of Name must be not smaller than number of BeamLines."],
 p$1172=1+p$1172[[1,2]];p1$1172=StringPosition["Usage: WriteBeamLine[f, b1,.. ,option]\n\nwrites the BeamLine b1,.. to file f. If \
b1.. is omitted the current beam line is assumed. If Format->\"MAIN\" is given, it writes in the MAIN-input format. If Name->{name\
1,..} is given, names of BeamLines are also written. The number of Name must be not smaller than number of BeamLines."[p$1172,-1],
    ">::",1];
   p1$1172=If[p1$1172==={},325,-2+p$1172+p1$1172[[1,1]]];
neq=Which["Usage: WriteBeamLine[f, b1,.. ,option]\n\nwrites the BeamLine b1,.. to file f. If b1.. is omitted the current beam line\
 is assumed. If Format->\"MAIN\" is given, it writes in the MAIN-input format. If Name->{name1,..} is given, names of BeamLines ar\
e also written. The number of Name must be not smaller than number of BeamLines."[p$1172,4+p$1172]==="Text[",
    lx$1172:=Help2HTML`oa$;p$1172=5+p$1172;p1$1172-=1;p2$1172=5+p1$1172;p0$1172=-9+p$1172;
If[(pe$1172=StringPosition["Usage: WriteBeamLine[f, b1,.. ,option]\n\nwrites the BeamLine b1,.. to file f. If b1.. is omitted the \
current beam line is assumed. If Format->\"MAIN\" is given, it writes in the MAIN-input format. If Name->{name1,..} is given, name\
s of BeamLines are also written. The number of Name must be not smaller than number of BeamLines."[p$1172,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Usage: WriteBeamLine[f, b1,.. ,option]\n\nwrites the BeamLine b1,.. to file f. If b1.. is omitted the current bea\
m line is assumed. If Format->\"MAIN\" is given, it writes in the MAIN-input format. If Name->{name1,..} is given, names of BeamLi\
nes are also written. The number of Name must be not smaller than number of BeamLines."[p$1172+pe$1172[[1,2]],p1$1172]]],
        p1$1172=-2+p$1172+pe$1172[[1,1]]}[[
       1]],
      0],
    1,lx$1172:=Help2HTML`o9$;p2$1172=4+p1$1172;p0$1172=-4+p$1172;0];
  If[(equ$1172=
Help2HTML`o8$["Usage: WriteBeamLine[f, b1,.. ,option]\n\nwrites the BeamLine b1,.. to file f. If b1.. is omitted the current beam \
line is assumed. If Format->\"MAIN\" is given, it writes in the MAIN-input format. If Name->{name1,..} is given, names of BeamLine\
s are also written. The number of Name must be not smaller than number of BeamLines."[p$1172,p1$1172]])===
    Undefined,
equ$1172="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Usage: WriteBeamLine[f, b1,.. ,option]\n\nwr\
ites the BeamLine b1,.. to file f. If b1.. is omitted the current beam line is assumed. If Format->\"MAIN\" is given, it writes in\
 the MAIN-input format. If Name->{name1,..} is given, names of BeamLines are also written. The number of Name must be not smaller \
than number of BeamLines."[p$1172,p1$1172]]=
       equ$1172;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1172},out$1172=lx$1172@Typeset["Usage: WriteBeamLine[f, b1,.. ,option]\n\nwrites the BeamLine b1,.. to file f. If b1.. is\
 omitted the current beam line is assumed. If Format->\"MAIN\" is given, it writes in the MAIN-input format. If Name->{name1,..} i\
s given, names of BeamLines are also written. The number of Name must be not smaller than number of BeamLines."[p$1172,p1$1172],
          Format->Help2HTML`oB$];
        System["mv -f "//out$1172//" "//equ$1172]];
      Exit[]]];
   "Usage: WriteBeamLine[f, b1,.. ,option]\n\nwrites the BeamLine b1,.. to file f. If b1.. is omitted the current beam line is ass\
umed. If Format->\"MAIN\" is given, it writes in the MAIN-input format. If Name->{name1,..} is given, names of BeamLines are also \
written. The number of Name must be not smaller than number of BeamLines."[1,Max[p0$1172,0]]//"<img  class=\"eqs\" SRC=\""//
   equ$1172//"\" />"//
Help2HTML`oy$["Usage: WriteBeamLine[f, b1,.. ,option]\n\nwrites the BeamLine b1,.. to file f. If b1.. is omitted the current beam \
line is assumed. If Format->\"MAIN\" is given, it writes in the MAIN-input format. If Name->{name1,..} is given, names of BeamLine\
s are also written. The number of Name must be not smaller than number of BeamLines."[p2$1172,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L7>BeamLine</A> <A HREF=#L9>ExtractBeamLine</A> <A HREF=#L10>PrintBeamLine</A> <A HREF=#L558>USE</A> <A HREF=#L561>VISIT</A></PRE>
</UL>
<LI>
<H3><A NAME=L12>
orientation-of-an-element</A></H3>
<PRE>If[{},
Help2HTML`oA$[" An element with negative orientation means a reversal of the element along the z-axis. Thus all magnets except for\
 a solenoid does not change the polarity. A solenoid changes the polarity. An RF cavity should change, however, it does not in the\
 current implementation. The edge angles and fringe parameters of the entrance and the exit swap.\n AX, AY, AZ, EPX, EPY, ZPX, ZPY\
, R2, R3 of a MARK element are reversed.\n The orientation is printed out by DISP. It can be accessed by LINE[\"DIR\"] . "],
 p$1175=1+p$1175[[1,2]];
p1$1175=StringPosition[" An element with negative orientation means a reversal of the element along the z-axis. Thus all magnets e\
xcept for a solenoid does not change the polarity. A solenoid changes the polarity. An RF cavity should change, however, it does n\
ot in the current implementation. The edge angles and fringe parameters of the entrance and the exit swap.\n AX, AY, AZ, EPX, EPY,\
 ZPX, ZPY, R2, R3 of a MARK element are reversed.\n The orientation is printed out by DISP. It can be accessed by LINE[\"DIR\"] . "
    [p$1175,-1],">::",1];
   p1$1175=If[p1$1175==={},492,-2+p$1175+p1$1175[[1,1]]];
neq=Which[" An element with negative orientation means a reversal of the element along the z-axis. Thus all magnets except for a s\
olenoid does not change the polarity. A solenoid changes the polarity. An RF cavity should change, however, it does not in the cur\
rent implementation. The edge angles and fringe parameters of the entrance and the exit swap.\n AX, AY, AZ, EPX, EPY, ZPX, ZPY, R2\
, R3 of a MARK element are reversed.\n The orientation is printed out by DISP. It can be accessed by LINE[\"DIR\"] . "[p$1175,
      4+p$1175]===
     "Text[",
lx$1175:=Help2HTML`oa$;p$1175=5+p$1175;p1$1175-=1;p2$1175=5+p1$1175;p0$1175=-9+p$1175;If[(pe$1175=StringPosition[" An element with\
 negative orientation means a reversal of the element along the z-axis. Thus all magnets except for a solenoid does not change the\
 polarity. A solenoid changes the polarity. An RF cavity should change, however, it does not in the current implementation. The ed\
ge angles and fringe parameters of the entrance and the exit swap.\n AX, AY, AZ, EPX, EPY, ZPX, ZPY, R2, R3 of a MARK element are \
reversed.\n The orientation is printed out by DISP. It can be accessed by LINE[\"DIR\"] . "[p$1175,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression[" An element with negative orientation means a reversal of the element along the z-axis. Thus all magnets except f\
or a solenoid does not change the polarity. A solenoid changes the polarity. An RF cavity should change, however, it does not in t\
he current implementation. The edge angles and fringe parameters of the entrance and the exit swap.\n AX, AY, AZ, EPX, EPY, ZPX, Z\
PY, R2, R3 of a MARK element are reversed.\n The orientation is printed out by DISP. It can be accessed by LINE[\"DIR\"] . "[p$1175
            +pe$1175[[1,2]],
           p1$1175]]],
        p1$1175=-2+p$1175+pe$1175[[1,1]]}[[
       1]],
      0],
    1,lx$1175:=Help2HTML`o9$;p2$1175=4+p1$1175;p0$1175=-4+p$1175;0];
  If[(equ$1175=
Help2HTML`o8$[" An element with negative orientation means a reversal of the element along the z-axis. Thus all magnets except for\
 a solenoid does not change the polarity. A solenoid changes the polarity. An RF cavity should change, however, it does not in the\
 current implementation. The edge angles and fringe parameters of the entrance and the exit swap.\n AX, AY, AZ, EPX, EPY, ZPX, ZPY\
, R2, R3 of a MARK element are reversed.\n The orientation is printed out by DISP. It can be accessed by LINE[\"DIR\"] . "[p$1175,
       p1$1175]])===
    Undefined,
equ$1175="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[" An element with negative orientation means \
a reversal of the element along the z-axis. Thus all magnets except for a solenoid does not change the polarity. A solenoid change\
s the polarity. An RF cavity should change, however, it does not in the current implementation. The edge angles and fringe paramet\
ers of the entrance and the exit swap.\n AX, AY, AZ, EPX, EPY, ZPX, ZPY, R2, R3 of a MARK element are reversed.\n The orientation \
is printed out by DISP. It can be accessed by LINE[\"DIR\"] . "[p$1175,p1$1175]]=
       equ$1175;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1175},out$1175=lx$1175@Typeset[" An element with negative orientation means a reversal of the element along the z-axis. T\
hus all magnets except for a solenoid does not change the polarity. A solenoid changes the polarity. An RF cavity should change, h\
owever, it does not in the current implementation. The edge angles and fringe parameters of the entrance and the exit swap.\n AX, \
AY, AZ, EPX, EPY, ZPX, ZPY, R2, R3 of a MARK element are reversed.\n The orientation is printed out by DISP. It can be accessed by\
 LINE[\"DIR\"] . "[p$1175,p1$1175],Format->Help2HTML`oB$];
        System["mv -f "//out$1175//" "//equ$1175]];
      Exit[]]];
   " An element with negative orientation means a reversal of the element along the z-axis. Thus all magnets except for a solenoid\
 does not change the polarity. A solenoid changes the polarity. An RF cavity should change, however, it does not in the current im\
plementation. The edge angles and fringe parameters of the entrance and the exit swap.\n AX, AY, AZ, EPX, EPY, ZPX, ZPY, R2, R3 of\
 a MARK element are reversed.\n The orientation is printed out by DISP. It can be accessed by LINE[\"DIR\"] . "[1,Max[p0$1175,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$1175//"\" />"//
Help2HTML`oy$[" An element with negative orientation means a reversal of the element along the z-axis. Thus all magnets except for\
 a solenoid does not change the polarity. A solenoid changes the polarity. An RF cavity should change, however, it does not in the\
 current implementation. The edge angles and fringe parameters of the entrance and the exit swap.\n AX, AY, AZ, EPX, EPY, ZPX, ZPY\
, R2, R3 of a MARK element are reversed.\n The orientation is printed out by DISP. It can be accessed by LINE[\"DIR\"] . "[p2$1175,
     -1]]
]</PRE>
<PRE>See also:
 <A HREF=#L5>beam-line</A> <A HREF=#L7>BeamLine</A> <A HREF=#L398>LINE</A></PRE>
</UL>
<H3><A NAME=L13>
BEAMSIZE(BEAM)</A></H3>
<PRE>If[{},
Help2HTML`oA$["Calculate the beam size with the current Twiss parameters. The calculation is in 5D and not correct if the synchrot\
ron motion is significant. Use EMITTANCE(EMIT) with CODPLOT for a 6D calculation.\n\nBEAMSIZE(BEAM) uses the minimum emittance tak\
ing MINCOUP into account: Max[EMITk, MINCOUP*(EMITX+EMITY)] (k=X,Y)."],
p$1178=1+p$1178[[1,2]];p1$1178=StringPosition["Calculate the beam size with the current Twiss parameters. The calculation is in 5D\
 and not correct if the synchrotron motion is significant. Use EMITTANCE(EMIT) with CODPLOT for a 6D calculation.\n\nBEAMSIZE(BEAM\
) uses the minimum emittance taking MINCOUP into account: Max[EMITk, MINCOUP*(EMITX+EMITY)] (k=X,Y)."[p$1178,-1],">::",1];
   p1$1178=If[p1$1178==={},311,-2+p$1178+p1$1178[[1,1]]];
neq=Which["Calculate the beam size with the current Twiss parameters. The calculation is in 5D and not correct if the synchrotron \
motion is significant. Use EMITTANCE(EMIT) with CODPLOT for a 6D calculation.\n\nBEAMSIZE(BEAM) uses the minimum emittance taking \
MINCOUP into account: Max[EMITk, MINCOUP*(EMITX+EMITY)] (k=X,Y)."[p$1178,4+p$1178]==="Text[",
    lx$1178:=Help2HTML`oa$;p$1178=5+p$1178;p1$1178-=1;p2$1178=5+p1$1178;p0$1178=-9+p$1178;
If[(pe$1178=StringPosition["Calculate the beam size with the current Twiss parameters. The calculation is in 5D and not correct if\
 the synchrotron motion is significant. Use EMITTANCE(EMIT) with CODPLOT for a 6D calculation.\n\nBEAMSIZE(BEAM) uses the minimum \
emittance taking MINCOUP into account: Max[EMITk, MINCOUP*(EMITX+EMITY)] (k=X,Y)."[p$1178,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Calculate the beam size with the current Twiss parameters. The calculation is in 5D and not correct if the synchr\
otron motion is significant. Use EMITTANCE(EMIT) with CODPLOT for a 6D calculation.\n\nBEAMSIZE(BEAM) uses the minimum emittance t\
aking MINCOUP into account: Max[EMITk, MINCOUP*(EMITX+EMITY)] (k=X,Y)."[p$1178+pe$1178[[1,2]],p1$1178]]],
        p1$1178=-2+p$1178+pe$1178[[1,1]]}[[
       1]],
      0],
    1,lx$1178:=Help2HTML`o9$;p2$1178=4+p1$1178;p0$1178=-4+p$1178;0];
  If[(equ$1178=
Help2HTML`o8$["Calculate the beam size with the current Twiss parameters. The calculation is in 5D and not correct if the synchrot\
ron motion is significant. Use EMITTANCE(EMIT) with CODPLOT for a 6D calculation.\n\nBEAMSIZE(BEAM) uses the minimum emittance tak\
ing MINCOUP into account: Max[EMITk, MINCOUP*(EMITX+EMITY)] (k=X,Y)."[p$1178,p1$1178]])===
    Undefined,
equ$1178="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Calculate the beam size with the current Twi\
ss parameters. The calculation is in 5D and not correct if the synchrotron motion is significant. Use EMITTANCE(EMIT) with CODPLOT\
 for a 6D calculation.\n\nBEAMSIZE(BEAM) uses the minimum emittance taking MINCOUP into account: Max[EMITk, MINCOUP*(EMITX+EMITY)]\
 (k=X,Y)."[p$1178,p1$1178]]=
       equ$1178;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1178},out$1178=lx$1178@Typeset["Calculate the beam size with the current Twiss parameters. The calculation is in 5D and n\
ot correct if the synchrotron motion is significant. Use EMITTANCE(EMIT) with CODPLOT for a 6D calculation.\n\nBEAMSIZE(BEAM) uses\
 the minimum emittance taking MINCOUP into account: Max[EMITk, MINCOUP*(EMITX+EMITY)] (k=X,Y)."[p$1178,p1$1178],
          Format->Help2HTML`oB$];
        System["mv -f "//out$1178//" "//equ$1178]];
      Exit[]]];
   "Calculate the beam size with the current Twiss parameters. The calculation is in 5D and not correct if the synchrotron motion \
is significant. Use EMITTANCE(EMIT) with CODPLOT for a 6D calculation.\n\nBEAMSIZE(BEAM) uses the minimum emittance taking MINCOUP\
 into account: Max[EMITk, MINCOUP*(EMITX+EMITY)] (k=X,Y)."[1,Max[p0$1178,0]]//"<img  class=\"eqs\" SRC=\""//equ$1178//"\" />"//
   Help2HTML`oy$["Calculate the beam size with the current Twiss parameters. The calculation is in 5D and not correct if the synch\
rotron motion is significant. Use EMITTANCE(EMIT) with CODPLOT for a 6D calculation.\n\nBEAMSIZE(BEAM) uses the minimum emittance \
taking MINCOUP into account: Max[EMITk, MINCOUP*(EMITX+EMITY)] (k=X,Y)."[p2$1178,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L56>DISPLAY(DISP)</A> <A HREF=#L295>EMITTANCE(EMIT)</A> <A HREF=#L308>CODPLOT</A> <A HREF=#L530>MINCOUP</A></PRE>
<H3><A NAME=L14>
BYE</A></H3>
<PRE>If[{},
Help2HTML`oA$["Exits from the current beam line and returns to the original beam line where VISIT command was issued. All informat\
ion specific to the beam line, such as matching conditions are restored.\n   Note that BYE does neither SAVE the values of element\
s of the leaving beam line, nor RESET the values of elements of the returning beam line."],
 p$1181=1+p$1181[[1,2]];p1$1181=StringPosition["Exits from the current beam line and returns to the original beam line where VISIT\
 command was issued. All information specific to the beam line, such as matching conditions are restored.\n   Note that BYE does n\
either SAVE the values of elements of the leaving beam line, nor RESET the values of elements of the returning beam line."[p$1181,
     -1],
    ">::",1];
   p1$1181=If[p1$1181==={},332,-2+p$1181+p1$1181[[1,1]]];
neq=Which["Exits from the current beam line and returns to the original beam line where VISIT command was issued. All information \
specific to the beam line, such as matching conditions are restored.\n   Note that BYE does neither SAVE the values of elements of\
 the leaving beam line, nor RESET the values of elements of the returning beam line."[p$1181,4+p$1181]==="Text[",
    lx$1181:=Help2HTML`oa$;p$1181=5+p$1181;p1$1181-=1;p2$1181=5+p1$1181;p0$1181=-9+p$1181;
If[(pe$1181=StringPosition["Exits from the current beam line and returns to the original beam line where VISIT command was issued.\
 All information specific to the beam line, such as matching conditions are restored.\n   Note that BYE does neither SAVE the valu\
es of elements of the leaving beam line, nor RESET the values of elements of the returning beam line."[p$1181,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Exits from the current beam line and returns to the original beam line where VISIT command was issued. All inform\
ation specific to the beam line, such as matching conditions are restored.\n   Note that BYE does neither SAVE the values of eleme\
nts of the leaving beam line, nor RESET the values of elements of the returning beam line."[p$1181+pe$1181[[1,2]],p1$1181]]],
        p1$1181=-2+p$1181+pe$1181[[1,1]]}[[
       1]],
      0],
    1,lx$1181:=Help2HTML`o9$;p2$1181=4+p1$1181;p0$1181=-4+p$1181;0];
  If[(equ$1181=
Help2HTML`o8$["Exits from the current beam line and returns to the original beam line where VISIT command was issued. All informat\
ion specific to the beam line, such as matching conditions are restored.\n   Note that BYE does neither SAVE the values of element\
s of the leaving beam line, nor RESET the values of elements of the returning beam line."[p$1181,p1$1181]])===
    Undefined,
equ$1181="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Exits from the current beam line and returns\
 to the original beam line where VISIT command was issued. All information specific to the beam line, such as matching conditions \
are restored.\n   Note that BYE does neither SAVE the values of elements of the leaving beam line, nor RESET the values of element\
s of the returning beam line."[p$1181,p1$1181]]=
       equ$1181;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1181},out$1181=lx$1181@Typeset["Exits from the current beam line and returns to the original beam line where VISIT comman\
d was issued. All information specific to the beam line, such as matching conditions are restored.\n   Note that BYE does neither \
SAVE the values of elements of the leaving beam line, nor RESET the values of elements of the returning beam line."[p$1181,p1$1181
           ],Format->Help2HTML`oB$];
        System["mv -f "//out$1181//" "//equ$1181]];
      Exit[]]];
   "Exits from the current beam line and returns to the original beam line where VISIT command was issued. All information specifi\
c to the beam line, such as matching conditions are restored.\n   Note that BYE does neither SAVE the values of elements of the le\
aving beam line, nor RESET the values of elements of the returning beam line."[1,Max[p0$1181,0]]//"<img  class=\"eqs\" SRC=\""//
   equ$1181//"\" />"//
Help2HTML`oy$["Exits from the current beam line and returns to the original beam line where VISIT command was issued. All informat\
ion specific to the beam line, such as matching conditions are restored.\n   Note that BYE does neither SAVE the values of element\
s of the leaving beam line, nor RESET the values of elements of the returning beam line."[p2$1181,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L561>VISIT</A> <A HREF=#L558>USE</A> <A HREF=#L548>SAVE</A> <A HREF=#L494>RESET</A> <A HREF=#L553>STOP</A> <A HREF=#L485>QUIT</A> <A HREF=#L2>ABORT</A></PRE>
<H3><A NAME=L15>
character-string</A></H3>
<PRE>If[{},
Help2HTML`oA$[" A character-string is expressed by enclosing in \"\". Special characters are expressed using \\:\n\n\\n     new li\
ne\n\\r     carriage return\n\\t     tab\n\\\"     double quote\n\\\\     backslash\n\\nnn   a character whose octal code is nnn.\\
n\n If a character-string is written over multiple lines, \\ must be placed at the end of each line.\n The length of a character-s\
tring is limited to 2^31-1."],
p$1184=1+p$1184[[1,2]];p1$1184=StringPosition[" A character-string is expressed by enclosing in \"\". Special characters are expre\
ssed using \\:\n\n\\n     new line\n\\r     carriage return\n\\t     tab\n\\\"     double quote\n\\\\     backslash\n\\nnn   a cha\
racter whose octal code is nnn.\n\n If a character-string is written over multiple lines, \\ must be placed at the end of each lin\
e.\n The length of a character-string is limited to 2^31-1."[p$1184,-1],">::",1];
   p1$1184=If[p1$1184==={},380,-2+p$1184+p1$1184[[1,1]]];
neq=Which[" A character-string is expressed by enclosing in \"\". Special characters are expressed using \\:\n\n\\n     new line\n\
\\r     carriage return\n\\t     tab\n\\\"     double quote\n\\\\     backslash\n\\nnn   a character whose octal code is nnn.\n\n \
If a character-string is written over multiple lines, \\ must be placed at the end of each line.\n The length of a character-strin\
g is limited to 2^31-1."[p$1184,4+p$1184]==="Text[",
    lx$1184:=Help2HTML`oa$;p$1184=5+p$1184;p1$1184-=1;p2$1184=5+p1$1184;p0$1184=-9+p$1184;
If[(pe$1184=StringPosition[" A character-string is expressed by enclosing in \"\". Special characters are expressed using \\:\n\n\\
\n     new line\n\\r     carriage return\n\\t     tab\n\\\"     double quote\n\\\\     backslash\n\\nnn   a character whose octal \
code is nnn.\n\n If a character-string is written over multiple lines, \\ must be placed at the end of each line.\n The length of \
a character-string is limited to 2^31-1."[p$1184,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression[" A character-string is expressed by enclosing in \"\". Special characters are expressed using \\:\n\n\\n     new \
line\n\\r     carriage return\n\\t     tab\n\\\"     double quote\n\\\\     backslash\n\\nnn   a character whose octal code is nnn\
.\n\n If a character-string is written over multiple lines, \\ must be placed at the end of each line.\n The length of a character\
-string is limited to 2^31-1."[p$1184+pe$1184[[1,2]],p1$1184]]],
        p1$1184=-2+p$1184+pe$1184[[1,1]]}[[
       1]],
      0],
    1,lx$1184:=Help2HTML`o9$;p2$1184=4+p1$1184;p0$1184=-4+p$1184;0];
  If[(equ$1184=
Help2HTML`o8$[" A character-string is expressed by enclosing in \"\". Special characters are expressed using \\:\n\n\\n     new li\
ne\n\\r     carriage return\n\\t     tab\n\\\"     double quote\n\\\\     backslash\n\\nnn   a character whose octal code is nnn.\\
n\n If a character-string is written over multiple lines, \\ must be placed at the end of each line.\n The length of a character-s\
tring is limited to 2^31-1."[p$1184,p1$1184]])===
    Undefined,
equ$1184="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[" A character-string is expressed by enclosin\
g in \"\". Special characters are expressed using \\:\n\n\\n     new line\n\\r     carriage return\n\\t     tab\n\\\"     double q\
uote\n\\\\     backslash\n\\nnn   a character whose octal code is nnn.\n\n If a character-string is written over multiple lines, \\
\ must be placed at the end of each line.\n The length of a character-string is limited to 2^31-1."[p$1184,p1$1184]]=
       equ$1184;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1184},out$1184=lx$1184@Typeset[" A character-string is expressed by enclosing in \"\". Special characters are expressed u\
sing \\:\n\n\\n     new line\n\\r     carriage return\n\\t     tab\n\\\"     double quote\n\\\\     backslash\n\\nnn   a character\
 whose octal code is nnn.\n\n If a character-string is written over multiple lines, \\ must be placed at the end of each line.\n T\
he length of a character-string is limited to 2^31-1."[p$1184,p1$1184],Format->Help2HTML`oB$];
        System["mv -f "//out$1184//" "//equ$1184]];
      Exit[]]];
   " A character-string is expressed by enclosing in \"\". Special characters are expressed using \\:\n\n\\n     new line\n\\r    \
 carriage return\n\\t     tab\n\\\"     double quote\n\\\\     backslash\n\\nnn   a character whose octal code is nnn.\n\n If a ch\
aracter-string is written over multiple lines, \\ must be placed at the end of each line.\n The length of a character-string is li\
mited to 2^31-1."[1,Max[p0$1184,0]]//"<img  class=\"eqs\" SRC=\""//equ$1184//"\" />"//
Help2HTML`oy$[" A character-string is expressed by enclosing in \"\". Special characters are expressed using \\:\n\n\\n     new li\
ne\n\\r     carriage return\n\\t     tab\n\\\"     double quote\n\\\\     backslash\n\\nnn   a character whose octal code is nnn.\\
n\n If a character-string is written over multiple lines, \\ must be placed at the end of each line.\n The length of a character-s\
tring is limited to 2^31-1."[p2$1184,-1]]
]</PRE>
<UL>
<LI>
<H3><A NAME=L16>
FromCharacterCode</A></H3>
<PRE>If[{},
Help2HTML`oA$[" FromCharacterCode[r_Real] returns a character whose character code is r.\n FromCharacterCode[l_List] returns a cha\
racter-string whose character codes are l."],
p$1186=1+p$1186[[1,2]];p1$1186=StringPosition[" FromCharacterCode[r_Real] returns a character whose character code is r.\n FromCha\
racterCode[l_List] returns a character-string whose character codes are l."[p$1186,-1],">::",1];
   p1$1186=If[p1$1186==={},156,-2+p$1186+p1$1186[[1,1]]];
neq=Which[" FromCharacterCode[r_Real] returns a character whose character code is r.\n FromCharacterCode[l_List] returns a charact\
er-string whose character codes are l."[p$1186,4+p$1186]==="Text[",
    lx$1186:=Help2HTML`oa$;p$1186=5+p$1186;p1$1186-=1;p2$1186=5+p1$1186;p0$1186=-9+p$1186;
If[(pe$1186=StringPosition[" FromCharacterCode[r_Real] returns a character whose character code is r.\n FromCharacterCode[l_List] \
returns a character-string whose character codes are l."[p$1186,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression[" FromCharacterCode[r_Real] returns a character whose character code is r.\n FromCharacterCode[l_List] returns a c\
haracter-string whose character codes are l."[p$1186+pe$1186[[1,2]],p1$1186]]],
        p1$1186=-2+p$1186+pe$1186[[1,1]]}[[
       1]],
      0],
    1,lx$1186:=Help2HTML`o9$;p2$1186=4+p1$1186;p0$1186=-4+p$1186;0];
  If[(equ$1186=
Help2HTML`o8$[" FromCharacterCode[r_Real] returns a character whose character code is r.\n FromCharacterCode[l_List] returns a cha\
racter-string whose character codes are l."[p$1186,p1$1186]])===
    Undefined,
equ$1186="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[" FromCharacterCode[r_Real] returns a charact\
er whose character code is r.\n FromCharacterCode[l_List] returns a character-string whose character codes are l."[p$1186,p1$1186]
        ]=
       equ$1186;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1186},out$1186=lx$1186@Typeset[" FromCharacterCode[r_Real] returns a character whose character code is r.\n FromCharacter\
Code[l_List] returns a character-string whose character codes are l."[p$1186,p1$1186],Format->Help2HTML`oB$];
        System["mv -f "//out$1186//" "//equ$1186]];
      Exit[]]];
   " FromCharacterCode[r_Real] returns a character whose character code is r.\n FromCharacterCode[l_List] returns a character-stri\
ng whose character codes are l."[1,Max[p0$1186,0]]//"<img  class=\"eqs\" SRC=\""//equ$1186//"\" />"//
Help2HTML`oy$[" FromCharacterCode[r_Real] returns a character whose character code is r.\n FromCharacterCode[l_List] returns a cha\
racter-string whose character codes are l."[p2$1186,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L26>ToCharacterCode</A></PRE>
<LI>
<H3><A NAME=L17>
StringFill</A></H3>
<PRE>If[{},
Help2HTML`oA$[" StringFill[s, sf, n]  with strings s and sf, n > 0, returns (s//sf//sf...)[1,n] .\n StringFill[s, sf, -n] with str\
ings s and sf, n > 0, returns (...sf//sf//s)[-n,-1] ."],
p$1189=1+p$1189[[1,2]];p1$1189=StringPosition[" StringFill[s, sf, n]  with strings s and sf, n > 0, returns (s//sf//sf...)[1,n] .\\
n StringFill[s, sf, -n] with strings s and sf, n > 0, returns (...sf//sf//s)[-n,-1] ."[p$1189,-1],">::",1];
   p1$1189=If[p1$1189==={},167,-2+p$1189+p1$1189[[1,1]]];
neq=Which[" StringFill[s, sf, n]  with strings s and sf, n > 0, returns (s//sf//sf...)[1,n] .\n StringFill[s, sf, -n] with strings\
 s and sf, n > 0, returns (...sf//sf//s)[-n,-1] ."[p$1189,4+p$1189]==="Text[",
    lx$1189:=Help2HTML`oa$;p$1189=5+p$1189;p1$1189-=1;p2$1189=5+p1$1189;p0$1189=-9+p$1189;
If[(pe$1189=StringPosition[" StringFill[s, sf, n]  with strings s and sf, n > 0, returns (s//sf//sf...)[1,n] .\n StringFill[s, sf,\
 -n] with strings s and sf, n > 0, returns (...sf//sf//s)[-n,-1] ."[p$1189,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression[" StringFill[s, sf, n]  with strings s and sf, n > 0, returns (s//sf//sf...)[1,n] .\n StringFill[s, sf, -n] with s\
trings s and sf, n > 0, returns (...sf//sf//s)[-n,-1] ."[p$1189+pe$1189[[1,2]],p1$1189]]],
        p1$1189=-2+p$1189+pe$1189[[1,1]]}[[
       1]],
      0],
    1,lx$1189:=Help2HTML`o9$;p2$1189=4+p1$1189;p0$1189=-4+p$1189;0];
  If[(equ$1189=
Help2HTML`o8$[" StringFill[s, sf, n]  with strings s and sf, n > 0, returns (s//sf//sf...)[1,n] .\n StringFill[s, sf, -n] with str\
ings s and sf, n > 0, returns (...sf//sf//s)[-n,-1] ."[p$1189,p1$1189]])===
    Undefined,
equ$1189="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[" StringFill[s, sf, n]  with strings s and sf\
, n > 0, returns (s//sf//sf...)[1,n] .\n StringFill[s, sf, -n] with strings s and sf, n > 0, returns (...sf//sf//s)[-n,-1] ."[p
         $1189,p1$1189]]=
       equ$1189;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1189},out$1189=lx$1189@Typeset[" StringFill[s, sf, n]  with strings s and sf, n > 0, returns (s//sf//sf...)[1,n] .\n Stri\
ngFill[s, sf, -n] with strings s and sf, n > 0, returns (...sf//sf//s)[-n,-1] ."[p$1189,p1$1189],Format->Help2HTML`oB$];
        System["mv -f "//out$1189//" "//equ$1189]];
      Exit[]]];
   " StringFill[s, sf, n]  with strings s and sf, n > 0, returns (s//sf//sf...)[1,n] .\n StringFill[s, sf, -n] with strings s and \
sf, n > 0, returns (...sf//sf//s)[-n,-1] ."[1,Max[p0$1189,0]]//"<img  class=\"eqs\" SRC=\""//equ$1189//"\" />"//
Help2HTML`oy$[" StringFill[s, sf, n]  with strings s and sf, n > 0, returns (s//sf//sf...)[1,n] .\n StringFill[s, sf, -n] with str\
ings s and sf, n > 0, returns (...sf//sf//s)[-n,-1] ."[p2$1189,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L18>StringJoin</A> <A HREF=#L285>StringJoin (//)</A> <A HREF=#L21>StringPart</A></PRE>
<LI>
<H3><A NAME=L18>
StringJoin</A></H3>
<PRE>If[{},Help2HTML`oA$[" StringJoin[s1, s2, [,s3...]] ===> s1 // s2 [//s3...] concatenates strings s1, s2 [,s3...]."],
 p$1192=1+p$1192[[1,2]];
  p1$1192=StringPosition[" StringJoin[s1, s2, [,s3...]] ===> s1 // s2 [//s3...] concatenates strings s1, s2 [,s3...]."[p$1192,-1],
    ">::",1];
   p1$1192=If[p1$1192==={},91,-2+p$1192+p1$1192[[1,1]]];
  neq=Which[" StringJoin[s1, s2, [,s3...]] ===> s1 // s2 [//s3...] concatenates strings s1, s2 [,s3...]."[p$1192,4+p$1192]===
     "Text[",
    lx$1192:=Help2HTML`oa$;p$1192=5+p$1192;p1$1192-=1;p2$1192=5+p1$1192;p0$1192=-9+p$1192;If[(pe$1192=StringPosition[
         " StringJoin[s1, s2, [,s3...]] ===> s1 // s2 [//s3...] concatenates strings s1, s2 [,s3...]."[p$1192,-2],";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression[" StringJoin[s1, s2, [,s3...]] ===> s1 // s2 [//s3...] concatenates strings s1, s2 [,s3...]."[p$1192+pe
            $1192[[1,2]],
           p1$1192]]],
        p1$1192=-2+p$1192+pe$1192[[1,1]]}[[
       1]],
      0],
    1,lx$1192:=Help2HTML`o9$;p2$1192=4+p1$1192;p0$1192=-4+p$1192;0];
  If[(equ$1192=
     Help2HTML`o8$[" StringJoin[s1, s2, [,s3...]] ===> s1 // s2 [//s3...] concatenates strings s1, s2 [,s3...]."[p$1192,p1$1192]]
     )===
    Undefined,
   equ$1192="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        " StringJoin[s1, s2, [,s3...]] ===> s1 // s2 [//s3...] concatenates strings s1, s2 [,s3...]."[p$1192,p1$1192]]=
       equ$1192;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$1192},out$1192=lx$1192@Typeset[
          " StringJoin[s1, s2, [,s3...]] ===> s1 // s2 [//s3...] concatenates strings s1, s2 [,s3...]."[p$1192,p1$1192],
          Format->Help2HTML`oB$];
        System["mv -f "//out$1192//" "//equ$1192]];
      Exit[]]];
   " StringJoin[s1, s2, [,s3...]] ===> s1 // s2 [//s3...] concatenates strings s1, s2 [,s3...]."[1,Max[p0$1192,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$1192//"\" />"//
   Help2HTML`oy$[" StringJoin[s1, s2, [,s3...]] ===> s1 // s2 [//s3...] concatenates strings s1, s2 [,s3...]."[p2$1192,-1]]
 ]
</PRE>
<PRE>See also:
 <A HREF=#L285>StringJoin (//)</A></PRE>
<LI>
<H3><A NAME=L19>
StringLength</A></H3>
<PRE>If[{},Help2HTML`oA$[" StringLength[s] returns the length of string s."],
 p$1195=1+p$1195[[1,2]];p1$1195=StringPosition[" StringLength[s] returns the length of string s."[p$1195,-1],">::",1];
  p1$1195=If[p1$1195==={},48,-2+p$1195+p1$1195[[1,1]]];
  neq=Which[" StringLength[s] returns the length of string s."[p$1195,4+p$1195]==="Text[",
    lx$1195:=Help2HTML`oa$;p$1195=5+p$1195;p1$1195-=1;p2$1195=5+p1$1195;p0$1195=-9+p$1195;
     If[(pe$1195=StringPosition[" StringLength[s] returns the length of string s."[p$1195,-2],";;;"])<=>{},
      {Max[0,-1+ToExpression[" StringLength[s] returns the length of string s."[p$1195+pe$1195[[1,2]],p1$1195]]],
       p1$1195=-2+p$1195+pe$1195[[1,1]]}[[1]],
      0],
    1,lx$1195:=Help2HTML`o9$;p2$1195=4+p1$1195;p0$1195=-4+p$1195;0];
  If[(equ$1195=Help2HTML`o8$[" StringLength[s] returns the length of string s."[p$1195,p1$1195]])===Undefined,
   equ$1195="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$[" StringLength[s] returns the length of string s."[p$1195,p1$1195]]=equ$1195;LaTeX`ob$+=neq,
     --LaTeX`ob$;
      With[{lx$1195},out$1195=lx$1195@Typeset[" StringLength[s] returns the length of string s."[p$1195,p1$1195],Format->
           Help2HTML`oB$];
        System["mv -f "//out$1195//" "//equ$1195]];
      Exit[]]];
   " StringLength[s] returns the length of string s."[1,Max[p0$1195,0]]//"<img  class=\"eqs\" SRC=\""//equ$1195//"\" />"//
   Help2HTML`oy$[" StringLength[s] returns the length of string s."[p2$1195,-1]]
]</PRE>
<LI>
<H3><A NAME=L20>
StringMatchQ</A></H3>
<PRE>If[{},Help2HTML`oA$[" StringMatchQ[s, spat] returns True/False whether string s matches string-patten spat."],
 p$1197=1+p$1197[[1,2]];
  p1$1197=StringPosition[" StringMatchQ[s, spat] returns True/False whether string s matches string-patten spat."[p$1197,-1],">::",
    1];
   p1$1197=If[p1$1197==={},86,-2+p$1197+p1$1197[[1,1]]];
  neq=Which[" StringMatchQ[s, spat] returns True/False whether string s matches string-patten spat."[p$1197,4+p$1197]==="Text[",
    lx$1197:=Help2HTML`oa$;p$1197=5+p$1197;p1$1197-=1;p2$1197=5+p1$1197;p0$1197=-9+p$1197;
     If[(pe$1197=StringPosition[" StringMatchQ[s, spat] returns True/False whether string s matches string-patten spat."[p$1197,-2
          ],
         ";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression[" StringMatchQ[s, spat] returns True/False whether string s matches string-patten spat."[p$1197+pe$1197[[
             1,2]],
           p1$1197]]],
        p1$1197=-2+p$1197+pe$1197[[1,1]]}[[
       1]],
      0],
    1,lx$1197:=Help2HTML`o9$;p2$1197=4+p1$1197;p0$1197=-4+p$1197;0];
  If[(equ$1197=
     Help2HTML`o8$[" StringMatchQ[s, spat] returns True/False whether string s matches string-patten spat."[p$1197,p1$1197]])===
    Undefined,
   equ$1197="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        " StringMatchQ[s, spat] returns True/False whether string s matches string-patten spat."[p$1197,p1$1197]]=
       equ$1197;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$1197},out$1197=lx$1197@Typeset[
          " StringMatchQ[s, spat] returns True/False whether string s matches string-patten spat."[p$1197,p1$1197],
          Format->Help2HTML`oB$];
        System["mv -f "//out$1197//" "//equ$1197]];
      Exit[]]];
   " StringMatchQ[s, spat] returns True/False whether string s matches string-patten spat."[1,Max[p0$1197,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$1197//"\" />"//
   Help2HTML`oy$[" StringMatchQ[s, spat] returns True/False whether string s matches string-patten spat."[p2$1197,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L562>wildcards</A></PRE>
<LI>
<H3><A NAME=L21>
StringPart</A></H3>
<PRE>If[{},
Help2HTML`oA$[" s_String[n]      returns the n-th character in s.\n s_String[n1, n2] returns the substring from n1-th through n2-t\
h characters of s.\n\n If n1, n2 are negative, they count from the end of the string."],
 p$1200=1+p$1200[[1,2]];p1$1200=StringPosition[" s_String[n]      returns the n-th character in s.\n s_String[n1, n2] returns the \
substring from n1-th through n2-th characters of s.\n\n If n1, n2 are negative, they count from the end of the string."[p$1200,-1],
    ">::",1];
   p1$1200=If[p1$1200==={},197,-2+p$1200+p1$1200[[1,1]]];
neq=Which[" s_String[n]      returns the n-th character in s.\n s_String[n1, n2] returns the substring from n1-th through n2-th ch\
aracters of s.\n\n If n1, n2 are negative, they count from the end of the string."[p$1200,4+p$1200]==="Text[",
    lx$1200:=Help2HTML`oa$;p$1200=5+p$1200;p1$1200-=1;p2$1200=5+p1$1200;p0$1200=-9+p$1200;
If[(pe$1200=StringPosition[" s_String[n]      returns the n-th character in s.\n s_String[n1, n2] returns the substring from n1-th\
 through n2-th characters of s.\n\n If n1, n2 are negative, they count from the end of the string."[p$1200,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression[" s_String[n]      returns the n-th character in s.\n s_String[n1, n2] returns the substring from n1-th through n2\
-th characters of s.\n\n If n1, n2 are negative, they count from the end of the string."[p$1200+pe$1200[[1,2]],p1$1200]]],
        p1$1200=-2+p$1200+pe$1200[[1,1]]}[[
       1]],
      0],
    1,lx$1200:=Help2HTML`o9$;p2$1200=4+p1$1200;p0$1200=-4+p$1200;0];
  If[(equ$1200=
Help2HTML`o8$[" s_String[n]      returns the n-th character in s.\n s_String[n1, n2] returns the substring from n1-th through n2-t\
h characters of s.\n\n If n1, n2 are negative, they count from the end of the string."[p$1200,p1$1200]])===
    Undefined,
equ$1200="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[" s_String[n]      returns the n-th character\
 in s.\n s_String[n1, n2] returns the substring from n1-th through n2-th characters of s.\n\n If n1, n2 are negative, they count f\
rom the end of the string."[p$1200,p1$1200]]=
       equ$1200;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1200},out$1200=lx$1200@Typeset[" s_String[n]      returns the n-th character in s.\n s_String[n1, n2] returns the substri\
ng from n1-th through n2-th characters of s.\n\n If n1, n2 are negative, they count from the end of the string."[p$1200,p1$1200],
          Format->Help2HTML`oB$];
        System["mv -f "//out$1200//" "//equ$1200]];
      Exit[]]];
   " s_String[n]      returns the n-th character in s.\n s_String[n1, n2] returns the substring from n1-th through n2-th character\
s of s.\n\n If n1, n2 are negative, they count from the end of the string."[1,Max[p0$1200,0]]//"<img  class=\"eqs\" SRC=\""//
   equ$1200//"\" />"//
Help2HTML`oy$[" s_String[n]      returns the n-th character in s.\n s_String[n1, n2] returns the substring from n1-th through n2-t\
h characters of s.\n\n If n1, n2 are negative, they count from the end of the string."[p2$1200,-1]]
]</PRE>
<LI>
<H3><A NAME=L22>
StringPosition</A></H3>
<PRE>If[{},
Help2HTML`oA$[" StringPosition[s, subs] returns a list of positions of subs in string s.\n StringPosition[s, subs, n] returns a li\
st of first n positions of subs in string s.\n\nExample: StringPosition[\"abcbcbcbcb\",\"bcb\"] returns {{2,4},{4,6},{6,8},{8,10}}\
."],
p$1202=1+p$1202[[1,2]];p1$1202=StringPosition[" StringPosition[s, subs] returns a list of positions of subs in string s.\n StringP\
osition[s, subs, n] returns a list of first n positions of subs in string s.\n\nExample: StringPosition[\"abcbcbcbcb\",\"bcb\"] re\
turns {{2,4},{4,6},{6,8},{8,10}}."[p$1202,-1],">::",1];
   p1$1202=If[p1$1202==={},239,-2+p$1202+p1$1202[[1,1]]];
neq=Which[" StringPosition[s, subs] returns a list of positions of subs in string s.\n StringPosition[s, subs, n] returns a list o\
f first n positions of subs in string s.\n\nExample: StringPosition[\"abcbcbcbcb\",\"bcb\"] returns {{2,4},{4,6},{6,8},{8,10}}."[
      p$1202,4+p$1202]===
     "Text[",
lx$1202:=Help2HTML`oa$;p$1202=5+p$1202;p1$1202-=1;p2$1202=5+p1$1202;p0$1202=-9+p$1202;If[(pe$1202=StringPosition[" StringPosition[\
s, subs] returns a list of positions of subs in string s.\n StringPosition[s, subs, n] returns a list of first n positions of subs\
 in string s.\n\nExample: StringPosition[\"abcbcbcbcb\",\"bcb\"] returns {{2,4},{4,6},{6,8},{8,10}}."[p$1202,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression[" StringPosition[s, subs] returns a list of positions of subs in string s.\n StringPosition[s, subs, n] returns a \
list of first n positions of subs in string s.\n\nExample: StringPosition[\"abcbcbcbcb\",\"bcb\"] returns {{2,4},{4,6},{6,8},{8,10\
}}."[p$1202+pe$1202[[1,2]],p1$1202]]],
        p1$1202=-2+p$1202+pe$1202[[1,1]]}[[
       1]],
      0],
    1,lx$1202:=Help2HTML`o9$;p2$1202=4+p1$1202;p0$1202=-4+p$1202;0];
  If[(equ$1202=
Help2HTML`o8$[" StringPosition[s, subs] returns a list of positions of subs in string s.\n StringPosition[s, subs, n] returns a li\
st of first n positions of subs in string s.\n\nExample: StringPosition[\"abcbcbcbcb\",\"bcb\"] returns {{2,4},{4,6},{6,8},{8,10}}\
."[p$1202,p1$1202]])===
    Undefined,
equ$1202="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[" StringPosition[s, subs] returns a list of p\
ositions of subs in string s.\n StringPosition[s, subs, n] returns a list of first n positions of subs in string s.\n\nExample: St\
ringPosition[\"abcbcbcbcb\",\"bcb\"] returns {{2,4},{4,6},{6,8},{8,10}}."[p$1202,p1$1202]]=
       equ$1202;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1202},out$1202=lx$1202@Typeset[" StringPosition[s, subs] returns a list of positions of subs in string s.\n StringPositio\
n[s, subs, n] returns a list of first n positions of subs in string s.\n\nExample: StringPosition[\"abcbcbcbcb\",\"bcb\"] returns \
{{2,4},{4,6},{6,8},{8,10}}."[p$1202,p1$1202],Format->Help2HTML`oB$];
        System["mv -f "//out$1202//" "//equ$1202]];
      Exit[]]];
   " StringPosition[s, subs] returns a list of positions of subs in string s.\n StringPosition[s, subs, n] returns a list of first\
 n positions of subs in string s.\n\nExample: StringPosition[\"abcbcbcbcb\",\"bcb\"] returns {{2,4},{4,6},{6,8},{8,10}}."[1,
    Max[p0$1202,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$1202//"\" />"//
Help2HTML`oy$[" StringPosition[s, subs] returns a list of positions of subs in string s.\n StringPosition[s, subs, n] returns a li\
st of first n positions of subs in string s.\n\nExample: StringPosition[\"abcbcbcbcb\",\"bcb\"] returns {{2,4},{4,6},{6,8},{8,10}}\
."[p2$1202,-1]]
]</PRE>
<LI>
<H3><A NAME=L23>
StringReplace</A></H3>
<PRE>If[{},
Help2HTML`oA$[" StringReplace[s, rules] replaces the parts of string s accoding to rules, which is a Rule or a list of Rules:\n\n \
  StringReplace[\"abcbcbcbc\",\"bcb\"->\"xyx\"] ===> \"axyxcxyxc\"\n   StringReplace[\"abcbcbcbc\",{\"bcb\"->\"xy\",\"cbc\"->\"pqr\
s\"}] ===> \"axypqrsbc\" ."],
p$1204=1+p$1204[[1,2]];p1$1204=StringPosition[" StringReplace[s, rules] replaces the parts of string s accoding to rules, which is\
 a Rule or a list of Rules:\n\n   StringReplace[\"abcbcbcbc\",\"bcb\"->\"xyx\"] ===> \"axyxcxyxc\"\n   StringReplace[\"abcbcbcbc\"\
,{\"bcb\"->\"xy\",\"cbc\"->\"pqrs\"}] ===> \"axypqrsbc\" ."[p$1204,-1],">::",1];
   p1$1204=If[p1$1204==={},248,-2+p$1204+p1$1204[[1,1]]];
neq=Which[" StringReplace[s, rules] replaces the parts of string s accoding to rules, which is a Rule or a list of Rules:\n\n   St\
ringReplace[\"abcbcbcbc\",\"bcb\"->\"xyx\"] ===> \"axyxcxyxc\"\n   StringReplace[\"abcbcbcbc\",{\"bcb\"->\"xy\",\"cbc\"->\"pqrs\"}\
] ===> \"axypqrsbc\" ."[p$1204,4+p$1204]==="Text[",
    lx$1204:=Help2HTML`oa$;p$1204=5+p$1204;p1$1204-=1;p2$1204=5+p1$1204;p0$1204=-9+p$1204;
If[(pe$1204=StringPosition[" StringReplace[s, rules] replaces the parts of string s accoding to rules, which is a Rule or a list o\
f Rules:\n\n   StringReplace[\"abcbcbcbc\",\"bcb\"->\"xyx\"] ===> \"axyxcxyxc\"\n   StringReplace[\"abcbcbcbc\",{\"bcb\"->\"xy\",\\
"cbc\"->\"pqrs\"}] ===> \"axypqrsbc\" ."[p$1204,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression[" StringReplace[s, rules] replaces the parts of string s accoding to rules, which is a Rule or a list of Rules:\n\\
n   StringReplace[\"abcbcbcbc\",\"bcb\"->\"xyx\"] ===> \"axyxcxyxc\"\n   StringReplace[\"abcbcbcbc\",{\"bcb\"->\"xy\",\"cbc\"->\"p\
qrs\"}] ===> \"axypqrsbc\" ."[p$1204+pe$1204[[1,2]],p1$1204]]],
        p1$1204=-2+p$1204+pe$1204[[1,1]]}[[
       1]],
      0],
    1,lx$1204:=Help2HTML`o9$;p2$1204=4+p1$1204;p0$1204=-4+p$1204;0];
  If[(equ$1204=
Help2HTML`o8$[" StringReplace[s, rules] replaces the parts of string s accoding to rules, which is a Rule or a list of Rules:\n\n \
  StringReplace[\"abcbcbcbc\",\"bcb\"->\"xyx\"] ===> \"axyxcxyxc\"\n   StringReplace[\"abcbcbcbc\",{\"bcb\"->\"xy\",\"cbc\"->\"pqr\
s\"}] ===> \"axypqrsbc\" ."[p$1204,p1$1204]])===
    Undefined,
equ$1204="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[" StringReplace[s, rules] replaces the parts \
of string s accoding to rules, which is a Rule or a list of Rules:\n\n   StringReplace[\"abcbcbcbc\",\"bcb\"->\"xyx\"] ===> \"axyx\
cxyxc\"\n   StringReplace[\"abcbcbcbc\",{\"bcb\"->\"xy\",\"cbc\"->\"pqrs\"}] ===> \"axypqrsbc\" ."[p$1204,p1$1204]]=
       equ$1204;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1204},out$1204=lx$1204@Typeset[" StringReplace[s, rules] replaces the parts of string s accoding to rules, which is a Rul\
e or a list of Rules:\n\n   StringReplace[\"abcbcbcbc\",\"bcb\"->\"xyx\"] ===> \"axyxcxyxc\"\n   StringReplace[\"abcbcbcbc\",{\"bc\
b\"->\"xy\",\"cbc\"->\"pqrs\"}] ===> \"axypqrsbc\" ."[p$1204,p1$1204],Format->Help2HTML`oB$];
        System["mv -f "//out$1204//" "//equ$1204]];
      Exit[]]];
   " StringReplace[s, rules] replaces the parts of string s accoding to rules, which is a Rule or a list of Rules:\n\n   StringRep\
lace[\"abcbcbcbc\",\"bcb\"->\"xyx\"] ===> \"axyxcxyxc\"\n   StringReplace[\"abcbcbcbc\",{\"bcb\"->\"xy\",\"cbc\"->\"pqrs\"}] ===> \
\"axypqrsbc\" ."[1,Max[p0$1204,0]]//"<img  class=\"eqs\" SRC=\""//equ$1204//"\" />"//
Help2HTML`oy$[" StringReplace[s, rules] replaces the parts of string s accoding to rules, which is a Rule or a list of Rules:\n\n \
  StringReplace[\"abcbcbcbc\",\"bcb\"->\"xyx\"] ===> \"axyxcxyxc\"\n   StringReplace[\"abcbcbcbc\",{\"bcb\"->\"xy\",\"cbc\"->\"pqr\
s\"}] ===> \"axypqrsbc\" ."[p2$1204,-1]]
]</PRE>
<LI>
<H3><A NAME=L24>
StringTrim</A></H3>
<PRE>If[{},Help2HTML`oA$[" StringTrim[s] removes the leading and trailing spaces and tabs from s."],
 p$1206=1+p$1206[[1,2]];p1$1206=StringPosition[" StringTrim[s] removes the leading and trailing spaces and tabs from s."[p$1206,-1
     ],
    ">::",1];
   p1$1206=If[p1$1206==={},71,-2+p$1206+p1$1206[[1,1]]];
  neq=Which[" StringTrim[s] removes the leading and trailing spaces and tabs from s."[p$1206,4+p$1206]==="Text[",
    lx$1206:=Help2HTML`oa$;p$1206=5+p$1206;p1$1206-=1;p2$1206=5+p1$1206;p0$1206=-9+p$1206;
     If[(pe$1206=StringPosition[" StringTrim[s] removes the leading and trailing spaces and tabs from s."[p$1206,-2],";;;"])<=>{},
      {Max[0,
        -1+ToExpression[" StringTrim[s] removes the leading and trailing spaces and tabs from s."[p$1206+pe$1206[[1,2]],p1$1206]]],
       p1$1206=-2+p$1206+pe$1206[[1,1]]}[[1]],
      0],
    1,lx$1206:=Help2HTML`o9$;p2$1206=4+p1$1206;p0$1206=-4+p$1206;0];
  If[(equ$1206=Help2HTML`o8$[" StringTrim[s] removes the leading and trailing spaces and tabs from s."[p$1206,p1$1206]])===
    Undefined,
   equ$1206="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        " StringTrim[s] removes the leading and trailing spaces and tabs from s."[p$1206,p1$1206]]=
       equ$1206;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$1206},out$1206=lx$1206@Typeset[" StringTrim[s] removes the leading and trailing spaces and tabs from s."[p$1206,
           p1$1206],Format->Help2HTML`oB$];
        System["mv -f "//out$1206//" "//equ$1206]];
      Exit[]]];
   " StringTrim[s] removes the leading and trailing spaces and tabs from s."[1,Max[p0$1206,0]]//"<img  class=\"eqs\" SRC=\""//
   equ$1206//"\" />"//Help2HTML`oy$[" StringTrim[s] removes the leading and trailing spaces and tabs from s."[p2$1206,-1]]
]</PRE>
<LI>
<H3><A NAME=L25>
Symbol</A></H3>
<PRE>If[{},Help2HTML`oA$[" Symbol[s] returns a Symbol whose name is character-string s."],
 p$1208=1+p$1208[[1,2]];p1$1208=StringPosition[" Symbol[s] returns a Symbol whose name is character-string s."[p$1208,-1],">::",1];
  p1$1208=If[p1$1208==={},61,-2+p$1208+p1$1208[[1,1]]];
  neq=Which[" Symbol[s] returns a Symbol whose name is character-string s."[p$1208,4+p$1208]==="Text[",
    lx$1208:=Help2HTML`oa$;p$1208=5+p$1208;p1$1208-=1;p2$1208=5+p1$1208;p0$1208=-9+p$1208;
     If[(pe$1208=StringPosition[" Symbol[s] returns a Symbol whose name is character-string s."[p$1208,-2],";;;"])<=>{},
      {Max[0,-1+ToExpression[" Symbol[s] returns a Symbol whose name is character-string s."[p$1208+pe$1208[[1,2]],p1$1208]]],
       p1$1208=-2+p$1208+pe$1208[[1,1]]}[[1]],
      0],
    1,lx$1208:=Help2HTML`o9$;p2$1208=4+p1$1208;p0$1208=-4+p$1208;0];
  If[(equ$1208=Help2HTML`o8$[" Symbol[s] returns a Symbol whose name is character-string s."[p$1208,p1$1208]])===Undefined,
   equ$1208="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$[" Symbol[s] returns a Symbol whose name is character-string s."[p$1208,p1$1208]]=equ$1208;
      LaTeX`ob$+=neq,
     --LaTeX`ob$;With[{lx$1208},out$1208=lx$1208@Typeset[" Symbol[s] returns a Symbol whose name is character-string s."[p$1208,
           p1$1208],Format->Help2HTML`oB$];
        System["mv -f "//out$1208//" "//equ$1208]];
      Exit[]]];
   " Symbol[s] returns a Symbol whose name is character-string s."[1,Max[p0$1208,0]]//"<img  class=\"eqs\" SRC=\""//equ$1208//
   "\" />"//Help2HTML`oy$[" Symbol[s] returns a Symbol whose name is character-string s."[p2$1208,-1]]
]</PRE>
<LI>
<H3><A NAME=L26>
ToCharacterCode</A></H3>
<PRE>If[{},Help2HTML`oA$[" ToCharacterCode[s] returns the list of character codes of character-string s."],
 p$1210=1+p$1210[[1,2]];p1$1210=
   StringPosition[" ToCharacterCode[s] returns the list of character codes of character-string s."[p$1210,-1],">::",1];
  p1$1210=If[p1$1210==={},78,-2+p$1210+p1$1210[[1,1]]];
  neq=Which[" ToCharacterCode[s] returns the list of character codes of character-string s."[p$1210,4+p$1210]==="Text[",
    lx$1210:=Help2HTML`oa$;p$1210=5+p$1210;p1$1210-=1;p2$1210=5+p1$1210;p0$1210=-9+p$1210;
     If[(pe$1210=StringPosition[" ToCharacterCode[s] returns the list of character codes of character-string s."[p$1210,-2],";;;"]
        )<=>
       {},
      {Max[0,
        -1+ToExpression[" ToCharacterCode[s] returns the list of character codes of character-string s."[p$1210+pe$1210[[1,2]],
           p1$1210]]],
        p1$1210=-2+p$1210+pe$1210[[1,1]]}[[
       1]],
      0],
    1,lx$1210:=Help2HTML`o9$;p2$1210=4+p1$1210;p0$1210=-4+p$1210;0];
  If[(equ$1210=Help2HTML`o8$[" ToCharacterCode[s] returns the list of character codes of character-string s."[p$1210,p1$1210]])===
    Undefined,
   equ$1210="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        " ToCharacterCode[s] returns the list of character codes of character-string s."[p$1210,p1$1210]]=
       equ$1210;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$1210},out$1210=lx$1210@Typeset[" ToCharacterCode[s] returns the list of character codes of character-string s."[p
           $1210,p1$1210],Format->Help2HTML`oB$];
        System["mv -f "//out$1210//" "//equ$1210]];
      Exit[]]];
   " ToCharacterCode[s] returns the list of character codes of character-string s."[1,Max[p0$1210,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$1210//"\" />"//
   Help2HTML`oy$[" ToCharacterCode[s] returns the list of character codes of character-string s."[p2$1210,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L16>FromCharacterCode</A></PRE>
<LI>
<H3><A NAME=L27>
ToExpression</A></H3>
<PRE>If[{},Help2HTML`oA$[" ToExpression[s] converts a character-string s to an expression and evaluate it."],
 p$1213=1+p$1213[[1,2]];
  p1$1213=StringPosition[" ToExpression[s] converts a character-string s to an expression and evaluate it."[p$1213,-1],">::",1];
  p1$1213=If[p1$1213==={},80,-2+p$1213+p1$1213[[1,1]]];
  neq=Which[" ToExpression[s] converts a character-string s to an expression and evaluate it."[p$1213,4+p$1213]==="Text[",
    lx$1213:=Help2HTML`oa$;p$1213=5+p$1213;p1$1213-=1;p2$1213=5+p1$1213;p0$1213=-9+p$1213;
     If[(pe$1213=StringPosition[" ToExpression[s] converts a character-string s to an expression and evaluate it."[p$1213,-2],";;;"
         ])<=>
       {},
      {Max[0,
        -1+ToExpression[" ToExpression[s] converts a character-string s to an expression and evaluate it."[p$1213+pe$1213[[1,2]],
           p1$1213]]],
        p1$1213=-2+p$1213+pe$1213[[1,1]]}[[
       1]],
      0],
    1,lx$1213:=Help2HTML`o9$;p2$1213=4+p1$1213;p0$1213=-4+p$1213;0];
  If[(equ$1213=Help2HTML`o8$[" ToExpression[s] converts a character-string s to an expression and evaluate it."[p$1213,p1$1213]]
     )===
    Undefined,
   equ$1213="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        " ToExpression[s] converts a character-string s to an expression and evaluate it."[p$1213,p1$1213]]=
       equ$1213;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$1213},out$1213=lx$1213@Typeset[" ToExpression[s] converts a character-string s to an expression and evaluate it."[
           p$1213,p1$1213],Format->Help2HTML`oB$];
        System["mv -f "//out$1213//" "//equ$1213]];
      Exit[]]];
   " ToExpression[s] converts a character-string s to an expression and evaluate it."[1,Max[p0$1213,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$1213//"\" />"//
   Help2HTML`oy$[" ToExpression[s] converts a character-string s to an expression and evaluate it."[p2$1213,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L28>ToString</A></PRE>
<LI>
<H3><A NAME=L28>
ToString</A></H3>
<PRE>If[{},
Help2HTML`oA$[" ToString[expr] evaluates an expression expr, then converts to a character-string.\n ToString[expr, [FormatType ->]\
 form [, form1...]] converts expr using one or more formats form [,form1...]. Available formats are:\t\n\n InputForm special chara\
cters are quoted with \\.\n HoldForm converts expr without evaluation.\n StandardForm converts with the standard number format and\
 PageWidth.\n GenelicSymbolForm do not display the generation ($nnn) of local symbols for Module.\t"],
 p$1216=1+p$1216[[1,2]];p1$1216=
StringPosition[" ToString[expr] evaluates an expression expr, then converts to a character-string.\n ToString[expr, [FormatType ->\
] form [, form1...]] converts expr using one or more formats form [,form1...]. Available formats are:\t\n\n InputForm special char\
acters are quoted with \\.\n HoldForm converts expr without evaluation.\n StandardForm converts with the standard number format an\
d PageWidth.\n GenelicSymbolForm do not display the generation ($nnn) of local symbols for Module.\t"[p$1216,-1],">::",1];
   p1$1216=If[p1$1216==={},465,-2+p$1216+p1$1216[[1,1]]];
neq=Which[" ToString[expr] evaluates an expression expr, then converts to a character-string.\n ToString[expr, [FormatType ->] for\
m [, form1...]] converts expr using one or more formats form [,form1...]. Available formats are:\t\n\n InputForm special character\
s are quoted with \\.\n HoldForm converts expr without evaluation.\n StandardForm converts with the standard number format and Pag\
eWidth.\n GenelicSymbolForm do not display the generation ($nnn) of local symbols for Module.\t"[p$1216,4+p$1216]==="Text[",
    lx$1216:=Help2HTML`oa$;p$1216=5+p$1216;p1$1216-=1;p2$1216=5+p1$1216;p0$1216=-9+p$1216;
If[(pe$1216=StringPosition[" ToString[expr] evaluates an expression expr, then converts to a character-string.\n ToString[expr, [F\
ormatType ->] form [, form1...]] converts expr using one or more formats form [,form1...]. Available formats are:\t\n\n InputForm \
special characters are quoted with \\.\n HoldForm converts expr without evaluation.\n StandardForm converts with the standard numb\
er format and PageWidth.\n GenelicSymbolForm do not display the generation ($nnn) of local symbols for Module.\t"[p$1216,-2],";;;"]
        )<=>
       {},
      {Max[0,
-1+ToExpression[" ToString[expr] evaluates an expression expr, then converts to a character-string.\n ToString[expr, [FormatType -\
>] form [, form1...]] converts expr using one or more formats form [,form1...]. Available formats are:\t\n\n InputForm special cha\
racters are quoted with \\.\n HoldForm converts expr without evaluation.\n StandardForm converts with the standard number format a\
nd PageWidth.\n GenelicSymbolForm do not display the generation ($nnn) of local symbols for Module.\t"[p$1216+pe$1216[[1,2]],
           p1$1216]]],
        p1$1216=-2+p$1216+pe$1216[[1,1]]}[[
       1]],
      0],
    1,lx$1216:=Help2HTML`o9$;p2$1216=4+p1$1216;p0$1216=-4+p$1216;0];
  If[(equ$1216=
Help2HTML`o8$[" ToString[expr] evaluates an expression expr, then converts to a character-string.\n ToString[expr, [FormatType ->]\
 form [, form1...]] converts expr using one or more formats form [,form1...]. Available formats are:\t\n\n InputForm special chara\
cters are quoted with \\.\n HoldForm converts expr without evaluation.\n StandardForm converts with the standard number format and\
 PageWidth.\n GenelicSymbolForm do not display the generation ($nnn) of local symbols for Module.\t"[p$1216,p1$1216]])===
    Undefined,
equ$1216="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[" ToString[expr] evaluates an expression expr\
, then converts to a character-string.\n ToString[expr, [FormatType ->] form [, form1...]] converts expr using one or more formats\
 form [,form1...]. Available formats are:\t\n\n InputForm special characters are quoted with \\.\n HoldForm converts expr without \
evaluation.\n StandardForm converts with the standard number format and PageWidth.\n GenelicSymbolForm do not display the generati\
on ($nnn) of local symbols for Module.\t"[p$1216,p1$1216]]=
       equ$1216;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1216},out$1216=lx$1216@Typeset[" ToString[expr] evaluates an expression expr, then converts to a character-string.\n ToSt\
ring[expr, [FormatType ->] form [, form1...]] converts expr using one or more formats form [,form1...]. Available formats are:\t\n\
\n InputForm special characters are quoted with \\.\n HoldForm converts expr without evaluation.\n StandardForm converts with the \
standard number format and PageWidth.\n GenelicSymbolForm do not display the generation ($nnn) of local symbols for Module.\t"[p
           $1216,p1$1216],Format->Help2HTML`oB$];
        System["mv -f "//out$1216//" "//equ$1216]];
      Exit[]]];
   " ToString[expr] evaluates an expression expr, then converts to a character-string.\n ToString[expr, [FormatType ->] form [, fo\
rm1...]] converts expr using one or more formats form [,form1...]. Available formats are:\t\n\n InputForm special characters are q\
uoted with \\.\n HoldForm converts expr without evaluation.\n StandardForm converts with the standard number format and PageWidth.\
\n GenelicSymbolForm do not display the generation ($nnn) of local symbols for Module.\t"[1,Max[p0$1216,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$1216//"\" />"//
Help2HTML`oy$[" ToString[expr] evaluates an expression expr, then converts to a character-string.\n ToString[expr, [FormatType ->]\
 form [, form1...]] converts expr using one or more formats form [,form1...]. Available formats are:\t\n\n InputForm special chara\
cters are quoted with \\.\n HoldForm converts expr without evaluation.\n StandardForm converts with the standard number format and\
 PageWidth.\n GenelicSymbolForm do not display the generation ($nnn) of local symbols for Module.\t"[p2$1216,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L426>$FORM</A> <A HREF=#L433>PageWidth</A> <A HREF=#L437>StandardForm</A> Module <A HREF=#L27>ToExpression</A></PRE>
</UL>
<H3><A NAME=L29>
command-syntax</A></H3>
<PRE>If[{},
Help2HTML`oA$["The command syntax in FFS is\n\n     expression1 [param1..] [;] expression2..\t\n\n(1) The input is first evaluated\
 as an expression. If the expression returns a Symbol with the same name as the expression itself, it is interpreted as an FFS com\
mand, otherwise the returned value is printed out unless it is Null.\n(2) Each command takes succeeding its parameters if necessar\
y. A command with indefinite number of parameters can be terminated by semicolon. Most commands terminate itself at the end of lin\
e.\n(3) A line can be continued to the next line if a backslash is placed at the end of the line.\n(4) An expression continues to \
the next line if it is not closed in the line.\n(5) An exclamation mark comments out the rest of the line.\t\n\nExample: A command\
 line\n\n          QF* .1\n\nmeans the set-value-of-element command as unless the symbol QF has been defined otherwise. If QF has \
been defines as a number, such as QF=2.5, the above command line is interpreted as Times[QF,.1] then returns .25 ."],
 p$1219=1+p$1219[[1,2]];
p1$1219=StringPosition["The command syntax in FFS is\n\n     expression1 [param1..] [;] expression2..\t\n\n(1) The input is first \
evaluated as an expression. If the expression returns a Symbol with the same name as the expression itself, it is interpreted as a\
n FFS command, otherwise the returned value is printed out unless it is Null.\n(2) Each command takes succeeding its parameters if\
 necessary. A command with indefinite number of parameters can be terminated by semicolon. Most commands terminate itself at the e\
nd of line.\n(3) A line can be continued to the next line if a backslash is placed at the end of the line.\n(4) An expression cont\
inues to the next line if it is not closed in the line.\n(5) An exclamation mark comments out the rest of the line.\t\n\nExample: \
A command line\n\n          QF* .1\n\nmeans the set-value-of-element command as unless the symbol QF has been defined otherwise. I\
f QF has been defines as a number, such as QF=2.5, the above command line is interpreted as Times[QF,.1] then returns .25 ."[p$1219
     ,-1],
    ">::",1];
   p1$1219=If[p1$1219==={},993,-2+p$1219+p1$1219[[1,1]]];
neq=Which["The command syntax in FFS is\n\n     expression1 [param1..] [;] expression2..\t\n\n(1) The input is first evaluated as \
an expression. If the expression returns a Symbol with the same name as the expression itself, it is interpreted as an FFS command\
, otherwise the returned value is printed out unless it is Null.\n(2) Each command takes succeeding its parameters if necessary. A\
 command with indefinite number of parameters can be terminated by semicolon. Most commands terminate itself at the end of line.\n\
(3) A line can be continued to the next line if a backslash is placed at the end of the line.\n(4) An expression continues to the \
next line if it is not closed in the line.\n(5) An exclamation mark comments out the rest of the line.\t\n\nExample: A command lin\
e\n\n          QF* .1\n\nmeans the set-value-of-element command as unless the symbol QF has been defined otherwise. If QF has been\
 defines as a number, such as QF=2.5, the above command line is interpreted as Times[QF,.1] then returns .25 ."[p$1219,4+p$1219]===
     "Text[",
lx$1219:=Help2HTML`oa$;p$1219=5+p$1219;p1$1219-=1;p2$1219=5+p1$1219;p0$1219=-9+p$1219;If[(pe$1219=StringPosition["The command synt\
ax in FFS is\n\n     expression1 [param1..] [;] expression2..\t\n\n(1) The input is first evaluated as an expression. If the expre\
ssion returns a Symbol with the same name as the expression itself, it is interpreted as an FFS command, otherwise the returned va\
lue is printed out unless it is Null.\n(2) Each command takes succeeding its parameters if necessary. A command with indefinite nu\
mber of parameters can be terminated by semicolon. Most commands terminate itself at the end of line.\n(3) A line can be continued\
 to the next line if a backslash is placed at the end of the line.\n(4) An expression continues to the next line if it is not clos\
ed in the line.\n(5) An exclamation mark comments out the rest of the line.\t\n\nExample: A command line\n\n          QF* .1\n\nme\
ans the set-value-of-element command as unless the symbol QF has been defined otherwise. If QF has been defines as a number, such \
as QF=2.5, the above command line is interpreted as Times[QF,.1] then returns .25 ."[p$1219,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["The command syntax in FFS is\n\n     expression1 [param1..] [;] expression2..\t\n\n(1) The input is first evaluat\
ed as an expression. If the expression returns a Symbol with the same name as the expression itself, it is interpreted as an FFS c\
ommand, otherwise the returned value is printed out unless it is Null.\n(2) Each command takes succeeding its parameters if necess\
ary. A command with indefinite number of parameters can be terminated by semicolon. Most commands terminate itself at the end of l\
ine.\n(3) A line can be continued to the next line if a backslash is placed at the end of the line.\n(4) An expression continues t\
o the next line if it is not closed in the line.\n(5) An exclamation mark comments out the rest of the line.\t\n\nExample: A comma\
nd line\n\n          QF* .1\n\nmeans the set-value-of-element command as unless the symbol QF has been defined otherwise. If QF ha\
s been defines as a number, such as QF=2.5, the above command line is interpreted as Times[QF,.1] then returns .25 ."[p$1219+
            pe$1219[[1,2]],
           p1$1219]]],
        p1$1219=-2+p$1219+pe$1219[[1,1]]}[[
       1]],
      0],
    1,lx$1219:=Help2HTML`o9$;p2$1219=4+p1$1219;p0$1219=-4+p$1219;0];
  If[(equ$1219=
Help2HTML`o8$["The command syntax in FFS is\n\n     expression1 [param1..] [;] expression2..\t\n\n(1) The input is first evaluated\
 as an expression. If the expression returns a Symbol with the same name as the expression itself, it is interpreted as an FFS com\
mand, otherwise the returned value is printed out unless it is Null.\n(2) Each command takes succeeding its parameters if necessar\
y. A command with indefinite number of parameters can be terminated by semicolon. Most commands terminate itself at the end of lin\
e.\n(3) A line can be continued to the next line if a backslash is placed at the end of the line.\n(4) An expression continues to \
the next line if it is not closed in the line.\n(5) An exclamation mark comments out the rest of the line.\t\n\nExample: A command\
 line\n\n          QF* .1\n\nmeans the set-value-of-element command as unless the symbol QF has been defined otherwise. If QF has \
been defines as a number, such as QF=2.5, the above command line is interpreted as Times[QF,.1] then returns .25 ."[p$1219,p1$1219]
      ])===
    Undefined,
equ$1219="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["The command syntax in FFS is\n\n     express\
ion1 [param1..] [;] expression2..\t\n\n(1) The input is first evaluated as an expression. If the expression returns a Symbol with \
the same name as the expression itself, it is interpreted as an FFS command, otherwise the returned value is printed out unless it\
 is Null.\n(2) Each command takes succeeding its parameters if necessary. A command with indefinite number of parameters can be te\
rminated by semicolon. Most commands terminate itself at the end of line.\n(3) A line can be continued to the next line if a backs\
lash is placed at the end of the line.\n(4) An expression continues to the next line if it is not closed in the line.\n(5) An excl\
amation mark comments out the rest of the line.\t\n\nExample: A command line\n\n          QF* .1\n\nmeans the set-value-of-element\
 command as unless the symbol QF has been defined otherwise. If QF has been defines as a number, such as QF=2.5, the above command\
 line is interpreted as Times[QF,.1] then returns .25 ."[p$1219,p1$1219]]=
       equ$1219;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1219},out$1219=lx$1219@Typeset["The command syntax in FFS is\n\n     expression1 [param1..] [;] expression2..\t\n\n(1) Th\
e input is first evaluated as an expression. If the expression returns a Symbol with the same name as the expression itself, it is\
 interpreted as an FFS command, otherwise the returned value is printed out unless it is Null.\n(2) Each command takes succeeding \
its parameters if necessary. A command with indefinite number of parameters can be terminated by semicolon. Most commands terminat\
e itself at the end of line.\n(3) A line can be continued to the next line if a backslash is placed at the end of the line.\n(4) A\
n expression continues to the next line if it is not closed in the line.\n(5) An exclamation mark comments out the rest of the lin\
e.\t\n\nExample: A command line\n\n          QF* .1\n\nmeans the set-value-of-element command as unless the symbol QF has been def\
ined otherwise. If QF has been defines as a number, such as QF=2.5, the above command line is interpreted as Times[QF,.1] then ret\
urns .25 ."[p$1219,p1$1219],Format->Help2HTML`oB$];
        System["mv -f "//out$1219//" "//equ$1219]];
      Exit[]]];
   "The command syntax in FFS is\n\n     expression1 [param1..] [;] expression2..\t\n\n(1) The input is first evaluated as an expr\
ession. If the expression returns a Symbol with the same name as the expression itself, it is interpreted as an FFS command, other\
wise the returned value is printed out unless it is Null.\n(2) Each command takes succeeding its parameters if necessary. A comman\
d with indefinite number of parameters can be terminated by semicolon. Most commands terminate itself at the end of line.\n(3) A l\
ine can be continued to the next line if a backslash is placed at the end of the line.\n(4) An expression continues to the next li\
ne if it is not closed in the line.\n(5) An exclamation mark comments out the rest of the line.\t\n\nExample: A command line\n\n  \
        QF* .1\n\nmeans the set-value-of-element command as unless the symbol QF has been defined otherwise. If QF has been define\
s as a number, such as QF=2.5, the above command line is interpreted as Times[QF,.1] then returns .25 ."[1,Max[p0$1219,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$1219//"\" />"//
Help2HTML`oy$["The command syntax in FFS is\n\n     expression1 [param1..] [;] expression2..\t\n\n(1) The input is first evaluated\
 as an expression. If the expression returns a Symbol with the same name as the expression itself, it is interpreted as an FFS com\
mand, otherwise the returned value is printed out unless it is Null.\n(2) Each command takes succeeding its parameters if necessar\
y. A command with indefinite number of parameters can be terminated by semicolon. Most commands terminate itself at the end of lin\
e.\n(3) A line can be continued to the next line if a backslash is placed at the end of the line.\n(4) An expression continues to \
the next line if it is not closed in the line.\n(5) An exclamation mark comments out the rest of the line.\t\n\nExample: A command\
 line\n\n          QF* .1\n\nmeans the set-value-of-element command as unless the symbol QF has been defined otherwise. If QF has \
been defines as a number, such as QF=2.5, the above command line is interpreted as Times[QF,.1] then returns .25 ."[p2$1219,-1]]
 ]
</PRE>
<PRE>See also:
 <A HREF=#L246>expression</A> <A HREF=#L358>functions</A></PRE>
<H3><A NAME=L30>
components</A></H3>
<PRE>If[{},
Help2HTML`oA$["Components are the objects which consist the beam line. A component simulates an individual magnet, drift space, or\
 rf-cavity. The parameters of a component is specified the values in the corresponding element with the same name as the component\
, which simulates a power supply. Many components can be attached to the same element. Parameters of each component may deviate fr\
om the corresponding element if machine errors are given.\n   A component is specified with the form name[.order][{+-}offset], whe\
re name is the name of the component. The number order means the order-th component which belongs to name element, counted from th\
e beginning of the line starting from 1. Offset is a positive or negative number to specify the downstream or upstream components \
from the given component. If order is omitted, the first element is assumed, and if offset is omitted, zero is assumed. The order \
can be renumbererd by RENUMBER(RENUM).\n   The end of line is specified by $$$. The first component can be specified by ^^^."],
 p$1222=1+p$1222[[1,2]];
p1$1222=StringPosition["Components are the objects which consist the beam line. A component simulates an individual magnet, drift \
space, or rf-cavity. The parameters of a component is specified the values in the corresponding element with the same name as the \
component, which simulates a power supply. Many components can be attached to the same element. Parameters of each component may d\
eviate from the corresponding element if machine errors are given.\n   A component is specified with the form name[.order][{+-}off\
set], where name is the name of the component. The number order means the order-th component which belongs to name element, counte\
d from the beginning of the line starting from 1. Offset is a positive or negative number to specify the downstream or upstream co\
mponents from the given component. If order is omitted, the first element is assumed, and if offset is omitted, zero is assumed. T\
he order can be renumbererd by RENUMBER(RENUM).\n   The end of line is specified by $$$. The first component can be specified by ^\
^^."[p$1222,-1],">::",1];
   p1$1222=If[p1$1222==={},1017,-2+p$1222+p1$1222[[1,1]]];
neq=Which["Components are the objects which consist the beam line. A component simulates an individual magnet, drift space, or rf-\
cavity. The parameters of a component is specified the values in the corresponding element with the same name as the component, wh\
ich simulates a power supply. Many components can be attached to the same element. Parameters of each component may deviate from t\
he corresponding element if machine errors are given.\n   A component is specified with the form name[.order][{+-}offset], where n\
ame is the name of the component. The number order means the order-th component which belongs to name element, counted from the be\
ginning of the line starting from 1. Offset is a positive or negative number to specify the downstream or upstream components from\
 the given component. If order is omitted, the first element is assumed, and if offset is omitted, zero is assumed. The order can \
be renumbererd by RENUMBER(RENUM).\n   The end of line is specified by $$$. The first component can be specified by ^^^."[p$1222,
      4+p$1222]===
     "Text[",
lx$1222:=Help2HTML`oa$;p$1222=5+p$1222;p1$1222-=1;p2$1222=5+p1$1222;p0$1222=-9+p$1222;If[(pe$1222=StringPosition["Components are t\
he objects which consist the beam line. A component simulates an individual magnet, drift space, or rf-cavity. The parameters of a\
 component is specified the values in the corresponding element with the same name as the component, which simulates a power suppl\
y. Many components can be attached to the same element. Parameters of each component may deviate from the corresponding element if\
 machine errors are given.\n   A component is specified with the form name[.order][{+-}offset], where name is the name of the comp\
onent. The number order means the order-th component which belongs to name element, counted from the beginning of the line startin\
g from 1. Offset is a positive or negative number to specify the downstream or upstream components from the given component. If or\
der is omitted, the first element is assumed, and if offset is omitted, zero is assumed. The order can be renumbererd by RENUMBER(\
RENUM).\n   The end of line is specified by $$$. The first component can be specified by ^^^."[p$1222,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Components are the objects which consist the beam line. A component simulates an individual magnet, drift space, \
or rf-cavity. The parameters of a component is specified the values in the corresponding element with the same name as the compone\
nt, which simulates a power supply. Many components can be attached to the same element. Parameters of each component may deviate \
from the corresponding element if machine errors are given.\n   A component is specified with the form name[.order][{+-}offset], w\
here name is the name of the component. The number order means the order-th component which belongs to name element, counted from \
the beginning of the line starting from 1. Offset is a positive or negative number to specify the downstream or upstream component\
s from the given component. If order is omitted, the first element is assumed, and if offset is omitted, zero is assumed. The orde\
r can be renumbererd by RENUMBER(RENUM).\n   The end of line is specified by $$$. The first component can be specified by ^^^."[p
            $1222+pe$1222[[1,2]],
           p1$1222]]],
        p1$1222=-2+p$1222+pe$1222[[1,1]]}[[
       1]],
      0],
    1,lx$1222:=Help2HTML`o9$;p2$1222=4+p1$1222;p0$1222=-4+p$1222;0];
  If[(equ$1222=
Help2HTML`o8$["Components are the objects which consist the beam line. A component simulates an individual magnet, drift space, or\
 rf-cavity. The parameters of a component is specified the values in the corresponding element with the same name as the component\
, which simulates a power supply. Many components can be attached to the same element. Parameters of each component may deviate fr\
om the corresponding element if machine errors are given.\n   A component is specified with the form name[.order][{+-}offset], whe\
re name is the name of the component. The number order means the order-th component which belongs to name element, counted from th\
e beginning of the line starting from 1. Offset is a positive or negative number to specify the downstream or upstream components \
from the given component. If order is omitted, the first element is assumed, and if offset is omitted, zero is assumed. The order \
can be renumbererd by RENUMBER(RENUM).\n   The end of line is specified by $$$. The first component can be specified by ^^^."[p
       $1222,p1$1222]])===
    Undefined,
equ$1222="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Components are the objects which consist the\
 beam line. A component simulates an individual magnet, drift space, or rf-cavity. The parameters of a component is specified the \
values in the corresponding element with the same name as the component, which simulates a power supply. Many components can be at\
tached to the same element. Parameters of each component may deviate from the corresponding element if machine errors are given.\n\
   A component is specified with the form name[.order][{+-}offset], where name is the name of the component. The number order mean\
s the order-th component which belongs to name element, counted from the beginning of the line starting from 1. Offset is a positi\
ve or negative number to specify the downstream or upstream components from the given component. If order is omitted, the first el\
ement is assumed, and if offset is omitted, zero is assumed. The order can be renumbererd by RENUMBER(RENUM).\n   The end of line \
is specified by $$$. The first component can be specified by ^^^."[p$1222,p1$1222]]=
       equ$1222;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1222},out$1222=lx$1222@Typeset["Components are the objects which consist the beam line. A component simulates an individu\
al magnet, drift space, or rf-cavity. The parameters of a component is specified the values in the corresponding element with the \
same name as the component, which simulates a power supply. Many components can be attached to the same element. Parameters of eac\
h component may deviate from the corresponding element if machine errors are given.\n   A component is specified with the form nam\
e[.order][{+-}offset], where name is the name of the component. The number order means the order-th component which belongs to nam\
e element, counted from the beginning of the line starting from 1. Offset is a positive or negative number to specify the downstre\
am or upstream components from the given component. If order is omitted, the first element is assumed, and if offset is omitted, z\
ero is assumed. The order can be renumbererd by RENUMBER(RENUM).\n   The end of line is specified by $$$. The first component can \
be specified by ^^^."[p$1222,p1$1222],Format->Help2HTML`oB$];
        System["mv -f "//out$1222//" "//equ$1222]];
      Exit[]]];
   "Components are the objects which consist the beam line. A component simulates an individual magnet, drift space, or rf-cavity.\
 The parameters of a component is specified the values in the corresponding element with the same name as the component, which sim\
ulates a power supply. Many components can be attached to the same element. Parameters of each component may deviate from the corr\
esponding element if machine errors are given.\n   A component is specified with the form name[.order][{+-}offset], where name is \
the name of the component. The number order means the order-th component which belongs to name element, counted from the beginning\
 of the line starting from 1. Offset is a positive or negative number to specify the downstream or upstream components from the gi\
ven component. If order is omitted, the first element is assumed, and if offset is omitted, zero is assumed. The order can be renu\
mbererd by RENUMBER(RENUM).\n   The end of line is specified by $$$. The first component can be specified by ^^^."[1,
    Max[p0$1222,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$1222//"\" />"//
Help2HTML`oy$["Components are the objects which consist the beam line. A component simulates an individual magnet, drift space, or\
 rf-cavity. The parameters of a component is specified the values in the corresponding element with the same name as the component\
, which simulates a power supply. Many components can be attached to the same element. Parameters of each component may deviate fr\
om the corresponding element if machine errors are given.\n   A component is specified with the form name[.order][{+-}offset], whe\
re name is the name of the component. The number order means the order-th component which belongs to name element, counted from th\
e beginning of the line starting from 1. Offset is a positive or negative number to specify the downstream or upstream components \
from the given component. If order is omitted, the first element is assumed, and if offset is omitted, zero is assumed. The order \
can be renumbererd by RENUMBER(RENUM).\n   The end of line is specified by $$$. The first component can be specified by ^^^."[p2
     $1222,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L75>elements</A> <A HREF=#L492>RENUMBER(RENUM)</A></PRE>
<H3><A NAME=L31>
constants</A></H3>
<PRE>If[{},
Help2HTML`oA$["There are pre-defined special symbols for constants in FFS:\n\nsymbol         value\nTrue           1\nFalse       \
   0\nInfinity       INF\nINF            INF\nNaN            NaN\nPi             ArcSin[1]*2\nE              Exp[1]\nI            \
  Complex[0,1]\nDegree         Pi/180\nGoldenRatio    (1+Sqrt[5])/2\nEulerGamma     0.57721566490153286061"],
 p$1225=1+p$1225[[1,2]];
p1$1225=StringPosition["There are pre-defined special symbols for constants in FFS:\n\nsymbol         value\nTrue           1\nFal\
se          0\nInfinity       INF\nINF            INF\nNaN            NaN\nPi             ArcSin[1]*2\nE              Exp[1]\nI   \
           Complex[0,1]\nDegree         Pi/180\nGoldenRatio    (1+Sqrt[5])/2\nEulerGamma     0.57721566490153286061"[p$1225,-1],
    ">::",1];
   p1$1225=If[p1$1225==={},338,-2+p$1225+p1$1225[[1,1]]];
neq=Which["There are pre-defined special symbols for constants in FFS:\n\nsymbol         value\nTrue           1\nFalse          0\
\nInfinity       INF\nINF            INF\nNaN            NaN\nPi             ArcSin[1]*2\nE              Exp[1]\nI              Co\
mplex[0,1]\nDegree         Pi/180\nGoldenRatio    (1+Sqrt[5])/2\nEulerGamma     0.57721566490153286061"[p$1225,4+p$1225]==="Text[",
    lx$1225:=Help2HTML`oa$;p$1225=5+p$1225;p1$1225-=1;p2$1225=5+p1$1225;p0$1225=-9+p$1225;
If[(pe$1225=StringPosition["There are pre-defined special symbols for constants in FFS:\n\nsymbol         value\nTrue           1\\
nFalse          0\nInfinity       INF\nINF            INF\nNaN            NaN\nPi             ArcSin[1]*2\nE              Exp[1]\n\
I              Complex[0,1]\nDegree         Pi/180\nGoldenRatio    (1+Sqrt[5])/2\nEulerGamma     0.57721566490153286061"[p$1225,-2
          ],
         ";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["There are pre-defined special symbols for constants in FFS:\n\nsymbol         value\nTrue           1\nFalse     \
     0\nInfinity       INF\nINF            INF\nNaN            NaN\nPi             ArcSin[1]*2\nE              Exp[1]\nI          \
    Complex[0,1]\nDegree         Pi/180\nGoldenRatio    (1+Sqrt[5])/2\nEulerGamma     0.57721566490153286061"[p$1225+pe$1225[[1,2]]
            ,
           p1$1225]]],
        p1$1225=-2+p$1225+pe$1225[[1,1]]}[[
       1]],
      0],
    1,lx$1225:=Help2HTML`o9$;p2$1225=4+p1$1225;p0$1225=-4+p$1225;0];
  If[(equ$1225=
Help2HTML`o8$["There are pre-defined special symbols for constants in FFS:\n\nsymbol         value\nTrue           1\nFalse       \
   0\nInfinity       INF\nINF            INF\nNaN            NaN\nPi             ArcSin[1]*2\nE              Exp[1]\nI            \
  Complex[0,1]\nDegree         Pi/180\nGoldenRatio    (1+Sqrt[5])/2\nEulerGamma     0.57721566490153286061"[p$1225,p1$1225]])===
    Undefined,
equ$1225="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["There are pre-defined special symbols for co\
nstants in FFS:\n\nsymbol         value\nTrue           1\nFalse          0\nInfinity       INF\nINF            INF\nNaN          \
  NaN\nPi             ArcSin[1]*2\nE              Exp[1]\nI              Complex[0,1]\nDegree         Pi/180\nGoldenRatio    (1+Sq\
rt[5])/2\nEulerGamma     0.57721566490153286061"[p$1225,p1$1225]]=
       equ$1225;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1225},out$1225=lx$1225@Typeset["There are pre-defined special symbols for constants in FFS:\n\nsymbol         value\nTrue\
           1\nFalse          0\nInfinity       INF\nINF            INF\nNaN            NaN\nPi             ArcSin[1]*2\nE         \
     Exp[1]\nI              Complex[0,1]\nDegree         Pi/180\nGoldenRatio    (1+Sqrt[5])/2\nEulerGamma     0.577215664901532860\
61"[p$1225,p1$1225],Format->Help2HTML`oB$];
        System["mv -f "//out$1225//" "//equ$1225]];
      Exit[]]];
   "There are pre-defined special symbols for constants in FFS:\n\nsymbol         value\nTrue           1\nFalse          0\nInfin\
ity       INF\nINF            INF\nNaN            NaN\nPi             ArcSin[1]*2\nE              Exp[1]\nI              Complex[0\
,1]\nDegree         Pi/180\nGoldenRatio    (1+Sqrt[5])/2\nEulerGamma     0.57721566490153286061"[1,Max[p0$1225,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$1225//"\" />"//
Help2HTML`oy$["There are pre-defined special symbols for constants in FFS:\n\nsymbol         value\nTrue           1\nFalse       \
   0\nInfinity       INF\nINF            INF\nNaN            NaN\nPi             ArcSin[1]*2\nE              Exp[1]\nI            \
  Complex[0,1]\nDegree         Pi/180\nGoldenRatio    (1+Sqrt[5])/2\nEulerGamma     0.57721566490153286061"[p2$1225,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L500>special-variables</A> <A HREF=#L483>physical-constants</A> <A HREF=#L300>flags</A> <A HREF=#L246>expression</A></PRE>
<H3><A NAME=L32>
CALCULATE(CAL)</A></H3>
<PRE>If[{},
Help2HTML`oA$["Usage: (1) CAL [[NO]EXPAND]]\n       (2) CAL matching-function1[-] [matching-function2[-]..]\n \n(1) With no argume\
nt or with an option [NO]EXPAND, calculates the optics and the matching-functions using the current values of the components. It p\
rints out the values of the matching-functions specified either by the matching-function-commands or the second usage of CAL, as d\
escribed below. If an option EXPAND is given(default), it expands the beam line before the calculation. If NOEXPAND is given, it c\
alculates without any expansion.   FFS[\"CAL\"] and FFS[\"GO\"] returns the result as a list, whose format is\n\n   {dp, kind, res\
list, function-values},\n\nwhere\t\n\ndp:        a list contains dp/p0 .\nkind:      a list of kind of the orbit (usually 0, but 1\
 to 6 for the finite amplitude matching, see MatchingAmplitude).\nreslist:   a list of {residual, xstab, ystab}, where\t\n       r\
esidual: matching residual,\n       xstab:    True when the matrix is stable in X,\n       ystab:    True when the matrix is stabl\
e in Y, for each orbit.\n\nAbove are lists with length nf (== number of orbits).\n\nfunction-values: a list of length nc (== numbe\
r of calculated items). Each element has the form:\n\n       {component1, component2, function, list-of-values},\n\n       where\n\
\n       component1, component2: fit locations (see FIT).\n       function: name of the function (see matching-function-commands).\
\n       list-of-values: list of the value of the function for each orbit Length nf.\n       The central orbit comes at the Floor[\
(n+1)/2]-th element.\n\n(2) With matching-function names, sets the matching-functions at the current fit point to be printed out a\
fter calculation. If the matching-function is followed by a minus sign, it suppresses the print-out.\n\\nExample: CALC BX BY CAL"],
 p$1228=1+p$1228[[1,2]];
p1$1228=StringPosition["Usage: (1) CAL [[NO]EXPAND]]\n       (2) CAL matching-function1[-] [matching-function2[-]..]\n \n(1) With \
no argument or with an option [NO]EXPAND, calculates the optics and the matching-functions using the current values of the compone\
nts. It prints out the values of the matching-functions specified either by the matching-function-commands or the second usage of \
CAL, as described below. If an option EXPAND is given(default), it expands the beam line before the calculation. If NOEXPAND is gi\
ven, it calculates without any expansion.   FFS[\"CAL\"] and FFS[\"GO\"] returns the result as a list, whose format is\n\n   {dp, \
kind, reslist, function-values},\n\nwhere\t\n\ndp:        a list contains dp/p0 .\nkind:      a list of kind of the orbit (usually\
 0, but 1 to 6 for the finite amplitude matching, see MatchingAmplitude).\nreslist:   a list of {residual, xstab, ystab}, where\t\\
n       residual: matching residual,\n       xstab:    True when the matrix is stable in X,\n       ystab:    True when the matrix\
 is stable in Y, for each orbit.\n\nAbove are lists with length nf (== number of orbits).\n\nfunction-values: a list of length nc \
(== number of calculated items). Each element has the form:\n\n       {component1, component2, function, list-of-values},\n\n     \
  where\n\n       component1, component2: fit locations (see FIT).\n       function: name of the function (see matching-function-c\
ommands).\n       list-of-values: list of the value of the function for each orbit Length nf.\n       The central orbit comes at t\
he Floor[(n+1)/2]-th element.\n\n(2) With matching-function names, sets the matching-functions at the current fit point to be prin\
ted out after calculation. If the matching-function is followed by a minus sign, it suppresses the print-out.\n\\nExample: CALC BX\
 BY CAL"[p$1228,-1],">::",1];
   p1$1228=If[p1$1228==={},1766,-2+p$1228+p1$1228[[1,1]]];
neq=Which["Usage: (1) CAL [[NO]EXPAND]]\n       (2) CAL matching-function1[-] [matching-function2[-]..]\n \n(1) With no argument o\
r with an option [NO]EXPAND, calculates the optics and the matching-functions using the current values of the components. It print\
s out the values of the matching-functions specified either by the matching-function-commands or the second usage of CAL, as descr\
ibed below. If an option EXPAND is given(default), it expands the beam line before the calculation. If NOEXPAND is given, it calcu\
lates without any expansion.   FFS[\"CAL\"] and FFS[\"GO\"] returns the result as a list, whose format is\n\n   {dp, kind, reslist\
, function-values},\n\nwhere\t\n\ndp:        a list contains dp/p0 .\nkind:      a list of kind of the orbit (usually 0, but 1 to \
6 for the finite amplitude matching, see MatchingAmplitude).\nreslist:   a list of {residual, xstab, ystab}, where\t\n       resid\
ual: matching residual,\n       xstab:    True when the matrix is stable in X,\n       ystab:    True when the matrix is stable in\
 Y, for each orbit.\n\nAbove are lists with length nf (== number of orbits).\n\nfunction-values: a list of length nc (== number of\
 calculated items). Each element has the form:\n\n       {component1, component2, function, list-of-values},\n\n       where\n\n  \
     component1, component2: fit locations (see FIT).\n       function: name of the function (see matching-function-commands).\n  \
     list-of-values: list of the value of the function for each orbit Length nf.\n       The central orbit comes at the Floor[(n+1\
)/2]-th element.\n\n(2) With matching-function names, sets the matching-functions at the current fit point to be printed out after\
 calculation. If the matching-function is followed by a minus sign, it suppresses the print-out.\n\\nExample: CALC BX BY CAL"[p
      $1228,4+p$1228]===
     "Text[",
lx$1228:=Help2HTML`oa$;p$1228=5+p$1228;p1$1228-=1;p2$1228=5+p1$1228;p0$1228=-9+p$1228;If[(pe$1228=StringPosition["Usage: (1) CAL [\
[NO]EXPAND]]\n       (2) CAL matching-function1[-] [matching-function2[-]..]\n \n(1) With no argument or with an option [NO]EXPAND\
, calculates the optics and the matching-functions using the current values of the components. It prints out the values of the mat\
ching-functions specified either by the matching-function-commands or the second usage of CAL, as described below. If an option EX\
PAND is given(default), it expands the beam line before the calculation. If NOEXPAND is given, it calculates without any expansion\
.   FFS[\"CAL\"] and FFS[\"GO\"] returns the result as a list, whose format is\n\n   {dp, kind, reslist, function-values},\n\nwher\
e\t\n\ndp:        a list contains dp/p0 .\nkind:      a list of kind of the orbit (usually 0, but 1 to 6 for the finite amplitude \
matching, see MatchingAmplitude).\nreslist:   a list of {residual, xstab, ystab}, where\t\n       residual: matching residual,\n  \
     xstab:    True when the matrix is stable in X,\n       ystab:    True when the matrix is stable in Y, for each orbit.\n\nAbov\
e are lists with length nf (== number of orbits).\n\nfunction-values: a list of length nc (== number of calculated items). Each el\
ement has the form:\n\n       {component1, component2, function, list-of-values},\n\n       where\n\n       component1, component2\
: fit locations (see FIT).\n       function: name of the function (see matching-function-commands).\n       list-of-values: list o\
f the value of the function for each orbit Length nf.\n       The central orbit comes at the Floor[(n+1)/2]-th element.\n\n(2) Wit\
h matching-function names, sets the matching-functions at the current fit point to be printed out after calculation. If the matchi\
ng-function is followed by a minus sign, it suppresses the print-out.\n\\nExample: CALC BX BY CAL"[p$1228,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Usage: (1) CAL [[NO]EXPAND]]\n       (2) CAL matching-function1[-] [matching-function2[-]..]\n \n(1) With no argu\
ment or with an option [NO]EXPAND, calculates the optics and the matching-functions using the current values of the components. It\
 prints out the values of the matching-functions specified either by the matching-function-commands or the second usage of CAL, as\
 described below. If an option EXPAND is given(default), it expands the beam line before the calculation. If NOEXPAND is given, it\
 calculates without any expansion.   FFS[\"CAL\"] and FFS[\"GO\"] returns the result as a list, whose format is\n\n   {dp, kind, r\
eslist, function-values},\n\nwhere\t\n\ndp:        a list contains dp/p0 .\nkind:      a list of kind of the orbit (usually 0, but\
 1 to 6 for the finite amplitude matching, see MatchingAmplitude).\nreslist:   a list of {residual, xstab, ystab}, where\t\n      \
 residual: matching residual,\n       xstab:    True when the matrix is stable in X,\n       ystab:    True when the matrix is sta\
ble in Y, for each orbit.\n\nAbove are lists with length nf (== number of orbits).\n\nfunction-values: a list of length nc (== num\
ber of calculated items). Each element has the form:\n\n       {component1, component2, function, list-of-values},\n\n       where\
\n\n       component1, component2: fit locations (see FIT).\n       function: name of the function (see matching-function-commands\
).\n       list-of-values: list of the value of the function for each orbit Length nf.\n       The central orbit comes at the Floo\
r[(n+1)/2]-th element.\n\n(2) With matching-function names, sets the matching-functions at the current fit point to be printed out\
 after calculation. If the matching-function is followed by a minus sign, it suppresses the print-out.\n\\nExample: CALC BX BY CAL"
          [p$1228+pe$1228[[1,2]],p1$1228]]],
        p1$1228=-2+p$1228+pe$1228[[1,1]]}[[
       1]],
      0],
    1,lx$1228:=Help2HTML`o9$;p2$1228=4+p1$1228;p0$1228=-4+p$1228;0];
  If[(equ$1228=
Help2HTML`o8$["Usage: (1) CAL [[NO]EXPAND]]\n       (2) CAL matching-function1[-] [matching-function2[-]..]\n \n(1) With no argume\
nt or with an option [NO]EXPAND, calculates the optics and the matching-functions using the current values of the components. It p\
rints out the values of the matching-functions specified either by the matching-function-commands or the second usage of CAL, as d\
escribed below. If an option EXPAND is given(default), it expands the beam line before the calculation. If NOEXPAND is given, it c\
alculates without any expansion.   FFS[\"CAL\"] and FFS[\"GO\"] returns the result as a list, whose format is\n\n   {dp, kind, res\
list, function-values},\n\nwhere\t\n\ndp:        a list contains dp/p0 .\nkind:      a list of kind of the orbit (usually 0, but 1\
 to 6 for the finite amplitude matching, see MatchingAmplitude).\nreslist:   a list of {residual, xstab, ystab}, where\t\n       r\
esidual: matching residual,\n       xstab:    True when the matrix is stable in X,\n       ystab:    True when the matrix is stabl\
e in Y, for each orbit.\n\nAbove are lists with length nf (== number of orbits).\n\nfunction-values: a list of length nc (== numbe\
r of calculated items). Each element has the form:\n\n       {component1, component2, function, list-of-values},\n\n       where\n\
\n       component1, component2: fit locations (see FIT).\n       function: name of the function (see matching-function-commands).\
\n       list-of-values: list of the value of the function for each orbit Length nf.\n       The central orbit comes at the Floor[\
(n+1)/2]-th element.\n\n(2) With matching-function names, sets the matching-functions at the current fit point to be printed out a\
fter calculation. If the matching-function is followed by a minus sign, it suppresses the print-out.\n\\nExample: CALC BX BY CAL"[
       p$1228,p1$1228]])===
    Undefined,
equ$1228="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Usage: (1) CAL [[NO]EXPAND]]\n       (2) CAL\
 matching-function1[-] [matching-function2[-]..]\n \n(1) With no argument or with an option [NO]EXPAND, calculates the optics and \
the matching-functions using the current values of the components. It prints out the values of the matching-functions specified ei\
ther by the matching-function-commands or the second usage of CAL, as described below. If an option EXPAND is given(default), it e\
xpands the beam line before the calculation. If NOEXPAND is given, it calculates without any expansion.   FFS[\"CAL\"] and FFS[\"G\
O\"] returns the result as a list, whose format is\n\n   {dp, kind, reslist, function-values},\n\nwhere\t\n\ndp:        a list con\
tains dp/p0 .\nkind:      a list of kind of the orbit (usually 0, but 1 to 6 for the finite amplitude matching, see MatchingAmplit\
ude).\nreslist:   a list of {residual, xstab, ystab}, where\t\n       residual: matching residual,\n       xstab:    True when the\
 matrix is stable in X,\n       ystab:    True when the matrix is stable in Y, for each orbit.\n\nAbove are lists with length nf (\
== number of orbits).\n\nfunction-values: a list of length nc (== number of calculated items). Each element has the form:\n\n     \
  {component1, component2, function, list-of-values},\n\n       where\n\n       component1, component2: fit locations (see FIT).\n\
       function: name of the function (see matching-function-commands).\n       list-of-values: list of the value of the function \
for each orbit Length nf.\n       The central orbit comes at the Floor[(n+1)/2]-th element.\n\n(2) With matching-function names, s\
ets the matching-functions at the current fit point to be printed out after calculation. If the matching-function is followed by a\
 minus sign, it suppresses the print-out.\n\\nExample: CALC BX BY CAL"[p$1228,p1$1228]]=
       equ$1228;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1228},out$1228=lx$1228@Typeset["Usage: (1) CAL [[NO]EXPAND]]\n       (2) CAL matching-function1[-] [matching-function2[-]\
..]\n \n(1) With no argument or with an option [NO]EXPAND, calculates the optics and the matching-functions using the current valu\
es of the components. It prints out the values of the matching-functions specified either by the matching-function-commands or the\
 second usage of CAL, as described below. If an option EXPAND is given(default), it expands the beam line before the calculation. \
If NOEXPAND is given, it calculates without any expansion.   FFS[\"CAL\"] and FFS[\"GO\"] returns the result as a list, whose form\
at is\n\n   {dp, kind, reslist, function-values},\n\nwhere\t\n\ndp:        a list contains dp/p0 .\nkind:      a list of kind of t\
he orbit (usually 0, but 1 to 6 for the finite amplitude matching, see MatchingAmplitude).\nreslist:   a list of {residual, xstab,\
 ystab}, where\t\n       residual: matching residual,\n       xstab:    True when the matrix is stable in X,\n       ystab:    Tru\
e when the matrix is stable in Y, for each orbit.\n\nAbove are lists with length nf (== number of orbits).\n\nfunction-values: a l\
ist of length nc (== number of calculated items). Each element has the form:\n\n       {component1, component2, function, list-of-\
values},\n\n       where\n\n       component1, component2: fit locations (see FIT).\n       function: name of the function (see ma\
tching-function-commands).\n       list-of-values: list of the value of the function for each orbit Length nf.\n       The central\
 orbit comes at the Floor[(n+1)/2]-th element.\n\n(2) With matching-function names, sets the matching-functions at the current fit\
 point to be printed out after calculation. If the matching-function is followed by a minus sign, it suppresses the print-out.\n\\\
nExample: CALC BX BY CAL"[p$1228,p1$1228],Format->Help2HTML`oB$];
        System["mv -f "//out$1228//" "//equ$1228]];
      Exit[]]];
   "Usage: (1) CAL [[NO]EXPAND]]\n       (2) CAL matching-function1[-] [matching-function2[-]..]\n \n(1) With no argument or with \
an option [NO]EXPAND, calculates the optics and the matching-functions using the current values of the components. It prints out t\
he values of the matching-functions specified either by the matching-function-commands or the second usage of CAL, as described be\
low. If an option EXPAND is given(default), it expands the beam line before the calculation. If NOEXPAND is given, it calculates w\
ithout any expansion.   FFS[\"CAL\"] and FFS[\"GO\"] returns the result as a list, whose format is\n\n   {dp, kind, reslist, funct\
ion-values},\n\nwhere\t\n\ndp:        a list contains dp/p0 .\nkind:      a list of kind of the orbit (usually 0, but 1 to 6 for t\
he finite amplitude matching, see MatchingAmplitude).\nreslist:   a list of {residual, xstab, ystab}, where\t\n       residual: ma\
tching residual,\n       xstab:    True when the matrix is stable in X,\n       ystab:    True when the matrix is stable in Y, for\
 each orbit.\n\nAbove are lists with length nf (== number of orbits).\n\nfunction-values: a list of length nc (== number of calcul\
ated items). Each element has the form:\n\n       {component1, component2, function, list-of-values},\n\n       where\n\n       co\
mponent1, component2: fit locations (see FIT).\n       function: name of the function (see matching-function-commands).\n       li\
st-of-values: list of the value of the function for each orbit Length nf.\n       The central orbit comes at the Floor[(n+1)/2]-th\
 element.\n\n(2) With matching-function names, sets the matching-functions at the current fit point to be printed out after calcul\
ation. If the matching-function is followed by a minus sign, it suppresses the print-out.\n\\nExample: CALC BX BY CAL"[1,
    Max[p0$1228,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$1228//"\" />"//
Help2HTML`oy$["Usage: (1) CAL [[NO]EXPAND]]\n       (2) CAL matching-function1[-] [matching-function2[-]..]\n \n(1) With no argume\
nt or with an option [NO]EXPAND, calculates the optics and the matching-functions using the current values of the components. It p\
rints out the values of the matching-functions specified either by the matching-function-commands or the second usage of CAL, as d\
escribed below. If an option EXPAND is given(default), it expands the beam line before the calculation. If NOEXPAND is given, it c\
alculates without any expansion.   FFS[\"CAL\"] and FFS[\"GO\"] returns the result as a list, whose format is\n\n   {dp, kind, res\
list, function-values},\n\nwhere\t\n\ndp:        a list contains dp/p0 .\nkind:      a list of kind of the orbit (usually 0, but 1\
 to 6 for the finite amplitude matching, see MatchingAmplitude).\nreslist:   a list of {residual, xstab, ystab}, where\t\n       r\
esidual: matching residual,\n       xstab:    True when the matrix is stable in X,\n       ystab:    True when the matrix is stabl\
e in Y, for each orbit.\n\nAbove are lists with length nf (== number of orbits).\n\nfunction-values: a list of length nc (== numbe\
r of calculated items). Each element has the form:\n\n       {component1, component2, function, list-of-values},\n\n       where\n\
\n       component1, component2: fit locations (see FIT).\n       function: name of the function (see matching-function-commands).\
\n       list-of-values: list of the value of the function for each orbit Length nf.\n       The central orbit comes at the Floor[\
(n+1)/2]-th element.\n\n(2) With matching-function names, sets the matching-functions at the current fit point to be printed out a\
fter calculation. If the matching-function is followed by a minus sign, it suppresses the print-out.\n\\nExample: CALC BX BY CAL"[
     p2$1228,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L469>GO</A> <A HREF=#L56>DISPLAY(DISP)</A> <A HREF=#L35>COUPLE(COUP)</A> <A HREF=#L4>ATTRIBUTE(ATTR)</A> <A HREF=#L550>SHOW</A> <A HREF=#L463>FIT</A> <A HREF=#L473>matching-function-commands</A> <A HREF=#L299>EXPAND</A>
 <A HREF=#L309>CONV</A> <A HREF=#L504>CONVERGENCE</A> <A HREF=#L528>MatchingResidual</A> <A HREF=#L392>FFS</A></PRE>
<H3><A NAME=L33>
CHROMATICITY(CHRO)</A></H3>
<PRE>If[{},
Help2HTML`oA$["CHRO prints out the chromaticity of QUAD and SEXT in the entire beam line using the simplest formula:\n\n     xi_{x\
,y}=Integrate[-(K1/L) beta_{x,y}(s) ds] for QUAD,\n     xi_{x,y}=Integrate[-(K2/L) eta_x (s) beta_{x,y}(s) ds] for SEXT.\n\nThese \
formula are not valid when there is x-y coupling or vertical dispersion."],
p$1231=1+p$1231[[1,2]];p1$1231=StringPosition["CHRO prints out the chromaticity of QUAD and SEXT in the entire beam line using the\
 simplest formula:\n\n     xi_{x,y}=Integrate[-(K1/L) beta_{x,y}(s) ds] for QUAD,\n     xi_{x,y}=Integrate[-(K2/L) eta_x (s) beta_\
{x,y}(s) ds] for SEXT.\n\nThese formula are not valid when there is x-y coupling or vertical dispersion."[p$1231,-1],">::",1];
   p1$1231=If[p1$1231==={},312,-2+p$1231+p1$1231[[1,1]]];
neq=Which["CHRO prints out the chromaticity of QUAD and SEXT in the entire beam line using the simplest formula:\n\n     xi_{x,y}=\
Integrate[-(K1/L) beta_{x,y}(s) ds] for QUAD,\n     xi_{x,y}=Integrate[-(K2/L) eta_x (s) beta_{x,y}(s) ds] for SEXT.\n\nThese form\
ula are not valid when there is x-y coupling or vertical dispersion."[p$1231,4+p$1231]==="Text[",
    lx$1231:=Help2HTML`oa$;p$1231=5+p$1231;p1$1231-=1;p2$1231=5+p1$1231;p0$1231=-9+p$1231;
If[(pe$1231=StringPosition["CHRO prints out the chromaticity of QUAD and SEXT in the entire beam line using the simplest formula:\\
n\n     xi_{x,y}=Integrate[-(K1/L) beta_{x,y}(s) ds] for QUAD,\n     xi_{x,y}=Integrate[-(K2/L) eta_x (s) beta_{x,y}(s) ds] for SE\
XT.\n\nThese formula are not valid when there is x-y coupling or vertical dispersion."[p$1231,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["CHRO prints out the chromaticity of QUAD and SEXT in the entire beam line using the simplest formula:\n\n     xi_\
{x,y}=Integrate[-(K1/L) beta_{x,y}(s) ds] for QUAD,\n     xi_{x,y}=Integrate[-(K2/L) eta_x (s) beta_{x,y}(s) ds] for SEXT.\n\nThes\
e formula are not valid when there is x-y coupling or vertical dispersion."[p$1231+pe$1231[[1,2]],p1$1231]]],
        p1$1231=-2+p$1231+pe$1231[[1,1]]}[[
       1]],
      0],
    1,lx$1231:=Help2HTML`o9$;p2$1231=4+p1$1231;p0$1231=-4+p$1231;0];
  If[(equ$1231=
Help2HTML`o8$["CHRO prints out the chromaticity of QUAD and SEXT in the entire beam line using the simplest formula:\n\n     xi_{x\
,y}=Integrate[-(K1/L) beta_{x,y}(s) ds] for QUAD,\n     xi_{x,y}=Integrate[-(K2/L) eta_x (s) beta_{x,y}(s) ds] for SEXT.\n\nThese \
formula are not valid when there is x-y coupling or vertical dispersion."[p$1231,p1$1231]])===
    Undefined,
equ$1231="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["CHRO prints out the chromaticity of QUAD and\
 SEXT in the entire beam line using the simplest formula:\n\n     xi_{x,y}=Integrate[-(K1/L) beta_{x,y}(s) ds] for QUAD,\n     xi_\
{x,y}=Integrate[-(K2/L) eta_x (s) beta_{x,y}(s) ds] for SEXT.\n\nThese formula are not valid when there is x-y coupling or vertica\
l dispersion."[p$1231,p1$1231]]=
       equ$1231;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1231},out$1231=lx$1231@Typeset["CHRO prints out the chromaticity of QUAD and SEXT in the entire beam line using the simpl\
est formula:\n\n     xi_{x,y}=Integrate[-(K1/L) beta_{x,y}(s) ds] for QUAD,\n     xi_{x,y}=Integrate[-(K2/L) eta_x (s) beta_{x,y}(\
s) ds] for SEXT.\n\nThese formula are not valid when there is x-y coupling or vertical dispersion."[p$1231,p1$1231],
          Format->Help2HTML`oB$];
        System["mv -f "//out$1231//" "//equ$1231]];
      Exit[]]];
   "CHRO prints out the chromaticity of QUAD and SEXT in the entire beam line using the simplest formula:\n\n     xi_{x,y}=Integra\
te[-(K1/L) beta_{x,y}(s) ds] for QUAD,\n     xi_{x,y}=Integrate[-(K2/L) eta_x (s) beta_{x,y}(s) ds] for SEXT.\n\nThese formula are\
 not valid when there is x-y coupling or vertical dispersion."[1,Max[p0$1231,0]]//"<img  class=\"eqs\" SRC=\""//equ$1231//"\" />"//
   Help2HTML`oy$["CHRO prints out the chromaticity of QUAD and SEXT in the entire beam line using the simplest formula:\n\n     xi\
_{x,y}=Integrate[-(K1/L) beta_{x,y}(s) ds] for QUAD,\n     xi_{x,y}=Integrate[-(K2/L) eta_x (s) beta_{x,y}(s) ds] for SEXT.\n\nThe\
se formula are not valid when there is x-y coupling or vertical dispersion."[p2$1231,-1]]
]</PRE>
<H3><A NAME=L34>
CLOSE(CLO)</A></H3>
<PRE>If[{},
Help2HTML`oA$["   CLOSE [INPUT(IN)] closes the current input stream and switches it to the previous input stream.\n   CLOSE OUTPUT\
(OUT) suspends the current output and switches it to the previous output stream."],
p$1233=1+p$1233[[1,2]];p1$1233=StringPosition["   CLOSE [INPUT(IN)] closes the current input stream and switches it to the previou\
s input stream.\n   CLOSE OUTPUT(OUT) suspends the current output and switches it to the previous output stream."[p$1233,-1],">::",
    1];
   p1$1233=If[p1$1233==={},194,-2+p$1233+p1$1233[[1,1]]];
neq=Which["   CLOSE [INPUT(IN)] closes the current input stream and switches it to the previous input stream.\n   CLOSE OUTPUT(OUT\
) suspends the current output and switches it to the previous output stream."[p$1233,4+p$1233]==="Text[",
    lx$1233:=Help2HTML`oa$;p$1233=5+p$1233;p1$1233-=1;p2$1233=5+p1$1233;p0$1233=-9+p$1233;
If[(pe$1233=StringPosition["   CLOSE [INPUT(IN)] closes the current input stream and switches it to the previous input stream.\n  \
 CLOSE OUTPUT(OUT) suspends the current output and switches it to the previous output stream."[p$1233,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["   CLOSE [INPUT(IN)] closes the current input stream and switches it to the previous input stream.\n   CLOSE OUTP\
UT(OUT) suspends the current output and switches it to the previous output stream."[p$1233+pe$1233[[1,2]],p1$1233]]],
        p1$1233=-2+p$1233+pe$1233[[1,1]]}[[
       1]],
      0],
    1,lx$1233:=Help2HTML`o9$;p2$1233=4+p1$1233;p0$1233=-4+p$1233;0];
  If[(equ$1233=
Help2HTML`o8$["   CLOSE [INPUT(IN)] closes the current input stream and switches it to the previous input stream.\n   CLOSE OUTPUT\
(OUT) suspends the current output and switches it to the previous output stream."[p$1233,p1$1233]])===
    Undefined,
equ$1233="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["   CLOSE [INPUT(IN)] closes the current inpu\
t stream and switches it to the previous input stream.\n   CLOSE OUTPUT(OUT) suspends the current output and switches it to the pr\
evious output stream."[p$1233,p1$1233]]=
       equ$1233;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1233},out$1233=lx$1233@Typeset["   CLOSE [INPUT(IN)] closes the current input stream and switches it to the previous inpu\
t stream.\n   CLOSE OUTPUT(OUT) suspends the current output and switches it to the previous output stream."[p$1233,p1$1233],
          Format->Help2HTML`oB$];
        System["mv -f "//out$1233//" "//equ$1233]];
      Exit[]]];
   "   CLOSE [INPUT(IN)] closes the current input stream and switches it to the previous input stream.\n   CLOSE OUTPUT(OUT) suspe\
nds the current output and switches it to the previous output stream."[1,Max[p0$1233,0]]//"<img  class=\"eqs\" SRC=\""//equ$1233//
   "\" />"//
Help2HTML`oy$["   CLOSE [INPUT(IN)] closes the current input stream and switches it to the previous input stream.\n   CLOSE OUTPUT\
(OUT) suspends the current output and switches it to the previous output stream."[p2$1233,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L555>TERMINATE(TERM)</A> <A HREF=#L471>INPUT(IN)</A> <A HREF=#L487>READ</A> <A HREF=#L480>OUTPUT(OUT)</A> <A HREF=#L3>APPEND(APP)</A> <A HREF=#L296>END</A></PRE>
<H3><A NAME=L35>
COUPLE(COUP)</A></H3>
<PRE>If[{},
Help2HTML`oA$["   Usage: COUP slave-element master-element coefficient\n\nsets the value of the default-keyword of slave-element t\
o be equal to coefficient times the value of the default-keyword of master-element. COUPLE(COUP) cannot be cascaded. The master-el\
ement cannot be COUPLEd to any other element. To reset COUPLE, say COUP slave-element slave-element 1.\n Consider ElementValues to\
 define universal coupling for any keywords."],
p$1236=1+p$1236[[1,2]];p1$1236=StringPosition["   Usage: COUP slave-element master-element coefficient\n\nsets the value of the de\
fault-keyword of slave-element to be equal to coefficient times the value of the default-keyword of master-element. COUPLE(COUP) c\
annot be cascaded. The master-element cannot be COUPLEd to any other element. To reset COUPLE, say COUP slave-element slave-elemen\
t 1.\n Consider ElementValues to define universal coupling for any keywords."[p$1236,-1],">::",1];
   p1$1236=If[p1$1236==={},416,-2+p$1236+p1$1236[[1,1]]];
neq=Which["   Usage: COUP slave-element master-element coefficient\n\nsets the value of the default-keyword of slave-element to be\
 equal to coefficient times the value of the default-keyword of master-element. COUPLE(COUP) cannot be cascaded. The master-elemen\
t cannot be COUPLEd to any other element. To reset COUPLE, say COUP slave-element slave-element 1.\n Consider ElementValues to def\
ine universal coupling for any keywords."[p$1236,4+p$1236]==="Text[",
    lx$1236:=Help2HTML`oa$;p$1236=5+p$1236;p1$1236-=1;p2$1236=5+p1$1236;p0$1236=-9+p$1236;
If[(pe$1236=StringPosition["   Usage: COUP slave-element master-element coefficient\n\nsets the value of the default-keyword of sl\
ave-element to be equal to coefficient times the value of the default-keyword of master-element. COUPLE(COUP) cannot be cascaded. \
The master-element cannot be COUPLEd to any other element. To reset COUPLE, say COUP slave-element slave-element 1.\n Consider Ele\
mentValues to define universal coupling for any keywords."[p$1236,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["   Usage: COUP slave-element master-element coefficient\n\nsets the value of the default-keyword of slave-element\
 to be equal to coefficient times the value of the default-keyword of master-element. COUPLE(COUP) cannot be cascaded. The master-\
element cannot be COUPLEd to any other element. To reset COUPLE, say COUP slave-element slave-element 1.\n Consider ElementValues \
to define universal coupling for any keywords."[p$1236+pe$1236[[1,2]],p1$1236]]],
        p1$1236=-2+p$1236+pe$1236[[1,1]]}[[
       1]],
      0],
    1,lx$1236:=Help2HTML`o9$;p2$1236=4+p1$1236;p0$1236=-4+p$1236;0];
  If[(equ$1236=
Help2HTML`o8$["   Usage: COUP slave-element master-element coefficient\n\nsets the value of the default-keyword of slave-element t\
o be equal to coefficient times the value of the default-keyword of master-element. COUPLE(COUP) cannot be cascaded. The master-el\
ement cannot be COUPLEd to any other element. To reset COUPLE, say COUP slave-element slave-element 1.\n Consider ElementValues to\
 define universal coupling for any keywords."[p$1236,p1$1236]])===
    Undefined,
equ$1236="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["   Usage: COUP slave-element master-element \
coefficient\n\nsets the value of the default-keyword of slave-element to be equal to coefficient times the value of the default-ke\
yword of master-element. COUPLE(COUP) cannot be cascaded. The master-element cannot be COUPLEd to any other element. To reset COUP\
LE, say COUP slave-element slave-element 1.\n Consider ElementValues to define universal coupling for any keywords."[p$1236,p1$1236
         ]]=
       equ$1236;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1236},out$1236=lx$1236@Typeset["   Usage: COUP slave-element master-element coefficient\n\nsets the value of the default-\
keyword of slave-element to be equal to coefficient times the value of the default-keyword of master-element. COUPLE(COUP) cannot \
be cascaded. The master-element cannot be COUPLEd to any other element. To reset COUPLE, say COUP slave-element slave-element 1.\n\
 Consider ElementValues to define universal coupling for any keywords."[p$1236,p1$1236],Format->Help2HTML`oB$];
        System["mv -f "//out$1236//" "//equ$1236]];
      Exit[]]];
   "   Usage: COUP slave-element master-element coefficient\n\nsets the value of the default-keyword of slave-element to be equal \
to coefficient times the value of the default-keyword of master-element. COUPLE(COUP) cannot be cascaded. The master-element canno\
t be COUPLEd to any other element. To reset COUPLE, say COUP slave-element slave-element 1.\n Consider ElementValues to define uni\
versal coupling for any keywords."[1,Max[p0$1236,0]]//"<img  class=\"eqs\" SRC=\""//equ$1236//"\" />"//
Help2HTML`oy$["   Usage: COUP slave-element master-element coefficient\n\nsets the value of the default-keyword of slave-element t\
o be equal to coefficient times the value of the default-keyword of master-element. COUPLE(COUP) cannot be cascaded. The master-el\
ement cannot be COUPLEd to any other element. To reset COUPLE, say COUP slave-element slave-element 1.\n Consider ElementValues to\
 define universal coupling for any keywords."[p2$1236,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L4>ATTRIBUTE(ATTR)</A> <A HREF=#L466>FREE</A> <A HREF=#L512>ElementValues</A></PRE>
<H3><A NAME=L36>
data-structure</A></H3>
<PRE>If[{},
Help2HTML`oA$["All data and \"programs\" in SAD Script are expressed either by an atom or a list-structure:\n\n   head[body1 [,bod\
y2...]]\n\nwhere head and body1... are atom or list-structure. Defined atoms are:\n\t\nReal      a real number\nSymbol    a symbol\
\nString    a character-string\nPattern   a pattern structure for argument matching\t\n\nCurrently the lengths of a list-structure\
, a character-string, and the name of a symbol are limited to 2^31-1. A real number has an accuracy of 8 bytes."],
 p$1239=1+p$1239[[1,2]];
p1$1239=StringPosition["All data and \"programs\" in SAD Script are expressed either by an atom or a list-structure:\n\n   head[bo\
dy1 [,body2...]]\n\nwhere head and body1... are atom or list-structure. Defined atoms are:\n\t\nReal      a real number\nSymbol   \
 a symbol\nString    a character-string\nPattern   a pattern structure for argument matching\t\n\nCurrently the lengths of a list-\
structure, a character-string, and the name of a symbol are limited to 2^31-1. A real number has an accuracy of 8 bytes."[p$1239,-1
     ],
    ">::",1];
   p1$1239=If[p1$1239==={},471,-2+p$1239+p1$1239[[1,1]]];
neq=Which["All data and \"programs\" in SAD Script are expressed either by an atom or a list-structure:\n\n   head[body1 [,body2..\
.]]\n\nwhere head and body1... are atom or list-structure. Defined atoms are:\n\t\nReal      a real number\nSymbol    a symbol\nSt\
ring    a character-string\nPattern   a pattern structure for argument matching\t\n\nCurrently the lengths of a list-structure, a \
character-string, and the name of a symbol are limited to 2^31-1. A real number has an accuracy of 8 bytes."[p$1239,4+p$1239]===
     "Text[",
lx$1239:=Help2HTML`oa$;p$1239=5+p$1239;p1$1239-=1;p2$1239=5+p1$1239;p0$1239=-9+p$1239;If[(pe$1239=StringPosition["All data and \"p\
rograms\" in SAD Script are expressed either by an atom or a list-structure:\n\n   head[body1 [,body2...]]\n\nwhere head and body1\
... are atom or list-structure. Defined atoms are:\n\t\nReal      a real number\nSymbol    a symbol\nString    a character-string\\
nPattern   a pattern structure for argument matching\t\n\nCurrently the lengths of a list-structure, a character-string, and the n\
ame of a symbol are limited to 2^31-1. A real number has an accuracy of 8 bytes."[p$1239,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["All data and \"programs\" in SAD Script are expressed either by an atom or a list-structure:\n\n   head[body1 [,b\
ody2...]]\n\nwhere head and body1... are atom or list-structure. Defined atoms are:\n\t\nReal      a real number\nSymbol    a symb\
ol\nString    a character-string\nPattern   a pattern structure for argument matching\t\n\nCurrently the lengths of a list-structu\
re, a character-string, and the name of a symbol are limited to 2^31-1. A real number has an accuracy of 8 bytes."[p$1239+
            pe$1239[[1,2]],
           p1$1239]]],
        p1$1239=-2+p$1239+pe$1239[[1,1]]}[[
       1]],
      0],
    1,lx$1239:=Help2HTML`o9$;p2$1239=4+p1$1239;p0$1239=-4+p$1239;0];
  If[(equ$1239=
Help2HTML`o8$["All data and \"programs\" in SAD Script are expressed either by an atom or a list-structure:\n\n   head[body1 [,bod\
y2...]]\n\nwhere head and body1... are atom or list-structure. Defined atoms are:\n\t\nReal      a real number\nSymbol    a symbol\
\nString    a character-string\nPattern   a pattern structure for argument matching\t\n\nCurrently the lengths of a list-structure\
, a character-string, and the name of a symbol are limited to 2^31-1. A real number has an accuracy of 8 bytes."[p$1239,p1$1239]]
     )===
    Undefined,
equ$1239="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["All data and \"programs\" in SAD Script are \
expressed either by an atom or a list-structure:\n\n   head[body1 [,body2...]]\n\nwhere head and body1... are atom or list-structu\
re. Defined atoms are:\n\t\nReal      a real number\nSymbol    a symbol\nString    a character-string\nPattern   a pattern structu\
re for argument matching\t\n\nCurrently the lengths of a list-structure, a character-string, and the name of a symbol are limited \
to 2^31-1. A real number has an accuracy of 8 bytes."[p$1239,p1$1239]]=
       equ$1239;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1239},out$1239=lx$1239@Typeset["All data and \"programs\" in SAD Script are expressed either by an atom or a list-structu\
re:\n\n   head[body1 [,body2...]]\n\nwhere head and body1... are atom or list-structure. Defined atoms are:\n\t\nReal      a real \
number\nSymbol    a symbol\nString    a character-string\nPattern   a pattern structure for argument matching\t\n\nCurrently the l\
engths of a list-structure, a character-string, and the name of a symbol are limited to 2^31-1. A real number has an accuracy of 8\
 bytes."[p$1239,p1$1239],Format->Help2HTML`oB$];
        System["mv -f "//out$1239//" "//equ$1239]];
      Exit[]]];
   "All data and \"programs\" in SAD Script are expressed either by an atom or a list-structure:\n\n   head[body1 [,body2...]]\n\n\
where head and body1... are atom or list-structure. Defined atoms are:\n\t\nReal      a real number\nSymbol    a symbol\nString   \
 a character-string\nPattern   a pattern structure for argument matching\t\n\nCurrently the lengths of a list-structure, a charact\
er-string, and the name of a symbol are limited to 2^31-1. A real number has an accuracy of 8 bytes."[1,Max[p0$1239,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$1239//"\" />"//
Help2HTML`oy$["All data and \"programs\" in SAD Script are expressed either by an atom or a list-structure:\n\n   head[body1 [,bod\
y2...]]\n\nwhere head and body1... are atom or list-structure. Defined atoms are:\n\t\nReal      a real number\nSymbol    a symbol\
\nString    a character-string\nPattern   a pattern structure for argument matching\t\n\nCurrently the lengths of a list-structure\
, a character-string, and the name of a symbol are limited to 2^31-1. A real number has an accuracy of 8 bytes."[p2$1239,-1]]
 ]
</PRE>
<PRE>See also:
 <A HREF=#L15>character-string</A> <A HREF=#L481>pattern</A></PRE>
<UL>
<LI>
<H3><A NAME=L37>
Extract</A></H3>
<PRE>If[{},
Help2HTML`oA$["   Extract[f, part [,head]]\n\ntakes elements specified by part, which is a list of indices or Null. Optional head \
is applied at each element before evaluation.\n\nExample: Extract[{a,b,c,d,e},{3}]       returns c\n         Extract[{a,b,c,d,e},{\
3,4}]     is an error\n         Extract[{a,b,c,d,e},{{3},{4}}] returns {c,d}\n         Extract[Hold[{a,b,c,d,e}],{1,3}, Hold] retu\
rns Hold[c]"],
p$1242=1+p$1242[[1,2]];p1$1242=StringPosition["   Extract[f, part [,head]]\n\ntakes elements specified by part, which is a list of\
 indices or Null. Optional head is applied at each element before evaluation.\n\nExample: Extract[{a,b,c,d,e},{3}]       returns c\
\n         Extract[{a,b,c,d,e},{3,4}]     is an error\n         Extract[{a,b,c,d,e},{{3},{4}}] returns {c,d}\n         Extract[Hol\
d[{a,b,c,d,e}],{1,3}, Hold] returns Hold[c]"[p$1242,-1],">::",1];
   p1$1242=If[p1$1242==={},379,-2+p$1242+p1$1242[[1,1]]];
neq=Which["   Extract[f, part [,head]]\n\ntakes elements specified by part, which is a list of indices or Null. Optional head is a\
pplied at each element before evaluation.\n\nExample: Extract[{a,b,c,d,e},{3}]       returns c\n         Extract[{a,b,c,d,e},{3,4}\
]     is an error\n         Extract[{a,b,c,d,e},{{3},{4}}] returns {c,d}\n         Extract[Hold[{a,b,c,d,e}],{1,3}, Hold] returns \
Hold[c]"[p$1242,4+p$1242]==="Text[",
    lx$1242:=Help2HTML`oa$;p$1242=5+p$1242;p1$1242-=1;p2$1242=5+p1$1242;p0$1242=-9+p$1242;If[(pe$1242=
StringPosition["   Extract[f, part [,head]]\n\ntakes elements specified by part, which is a list of indices or Null. Optional head\
 is applied at each element before evaluation.\n\nExample: Extract[{a,b,c,d,e},{3}]       returns c\n         Extract[{a,b,c,d,e},\
{3,4}]     is an error\n         Extract[{a,b,c,d,e},{{3},{4}}] returns {c,d}\n         Extract[Hold[{a,b,c,d,e}],{1,3}, Hold] ret\
urns Hold[c]"[p$1242,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["   Extract[f, part [,head]]\n\ntakes elements specified by part, which is a list of indices or Null. Optional hea\
d is applied at each element before evaluation.\n\nExample: Extract[{a,b,c,d,e},{3}]       returns c\n         Extract[{a,b,c,d,e}\
,{3,4}]     is an error\n         Extract[{a,b,c,d,e},{{3},{4}}] returns {c,d}\n         Extract[Hold[{a,b,c,d,e}],{1,3}, Hold] re\
turns Hold[c]"[p$1242+pe$1242[[1,2]],p1$1242]]],
        p1$1242=-2+p$1242+pe$1242[[1,1]]}[[
       1]],
      0],
    1,lx$1242:=Help2HTML`o9$;p2$1242=4+p1$1242;p0$1242=-4+p$1242;0];
  If[(equ$1242=
Help2HTML`o8$["   Extract[f, part [,head]]\n\ntakes elements specified by part, which is a list of indices or Null. Optional head \
is applied at each element before evaluation.\n\nExample: Extract[{a,b,c,d,e},{3}]       returns c\n         Extract[{a,b,c,d,e},{\
3,4}]     is an error\n         Extract[{a,b,c,d,e},{{3},{4}}] returns {c,d}\n         Extract[Hold[{a,b,c,d,e}],{1,3}, Hold] retu\
rns Hold[c]"[p$1242,p1$1242]])===
    Undefined,
equ$1242="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["   Extract[f, part [,head]]\n\ntakes element\
s specified by part, which is a list of indices or Null. Optional head is applied at each element before evaluation.\n\nExample: E\
xtract[{a,b,c,d,e},{3}]       returns c\n         Extract[{a,b,c,d,e},{3,4}]     is an error\n         Extract[{a,b,c,d,e},{{3},{4\
}}] returns {c,d}\n         Extract[Hold[{a,b,c,d,e}],{1,3}, Hold] returns Hold[c]"[p$1242,p1$1242]]=
       equ$1242;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1242},out$1242=lx$1242@Typeset["   Extract[f, part [,head]]\n\ntakes elements specified by part, which is a list of indic\
es or Null. Optional head is applied at each element before evaluation.\n\nExample: Extract[{a,b,c,d,e},{3}]       returns c\n    \
     Extract[{a,b,c,d,e},{3,4}]     is an error\n         Extract[{a,b,c,d,e},{{3},{4}}] returns {c,d}\n         Extract[Hold[{a,b\
,c,d,e}],{1,3}, Hold] returns Hold[c]"[p$1242,p1$1242],Format->Help2HTML`oB$];
        System["mv -f "//out$1242//" "//equ$1242]];
      Exit[]]];
   "   Extract[f, part [,head]]\n\ntakes elements specified by part, which is a list of indices or Null. Optional head is applied \
at each element before evaluation.\n\nExample: Extract[{a,b,c,d,e},{3}]       returns c\n         Extract[{a,b,c,d,e},{3,4}]     i\
s an error\n         Extract[{a,b,c,d,e},{{3},{4}}] returns {c,d}\n         Extract[Hold[{a,b,c,d,e}],{1,3}, Hold] returns Hold[c]"
   [1,Max[p0$1242,0]]//"<img  class=\"eqs\" SRC=\""//equ$1242//"\" />"//
Help2HTML`oy$["   Extract[f, part [,head]]\n\ntakes elements specified by part, which is a list of indices or Null. Optional head \
is applied at each element before evaluation.\n\nExample: Extract[{a,b,c,d,e},{3}]       returns c\n         Extract[{a,b,c,d,e},{\
3,4}]     is an error\n         Extract[{a,b,c,d,e},{{3},{4}}] returns {c,d}\n         Extract[Hold[{a,b,c,d,e}],{1,3}, Hold] retu\
rns Hold[c]"[p2$1242,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L41>Part</A></PRE>
<LI>
<H3><A NAME=L38>
Head</A></H3>
<PRE>If[{},Help2HTML`oA$["Head[f] takes the head of an expression f."],
 p$1245=1+p$1245[[1,2]];p1$1245=StringPosition["Head[f] takes the head of an expression f."[p$1245,-1],">::",1];
  p1$1245=If[p1$1245==={},42,-2+p$1245+p1$1245[[1,1]]];
  neq=Which["Head[f] takes the head of an expression f."[p$1245,4+p$1245]==="Text[",
    lx$1245:=Help2HTML`oa$;p$1245=5+p$1245;p1$1245-=1;p2$1245=5+p1$1245;p0$1245=-9+p$1245;
     If[(pe$1245=StringPosition["Head[f] takes the head of an expression f."[p$1245,-2],";;;"])<=>{},
      {Max[0,-1+ToExpression["Head[f] takes the head of an expression f."[p$1245+pe$1245[[1,2]],p1$1245]]],
       p1$1245=-2+p$1245+pe$1245[[1,1]]}[[1]],
      0],
    1,lx$1245:=Help2HTML`o9$;p2$1245=4+p1$1245;p0$1245=-4+p$1245;0];
  If[(equ$1245=Help2HTML`o8$["Head[f] takes the head of an expression f."[p$1245,p1$1245]])===Undefined,
   equ$1245="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["Head[f] takes the head of an expression f."[p$1245,p1$1245]]=equ$1245;LaTeX`ob$+=neq,
     --LaTeX`ob$;With[{lx$1245},
       out$1245=lx$1245@Typeset["Head[f] takes the head of an expression f."[p$1245,p1$1245],Format->Help2HTML`oB$];
        System["mv -f "//out$1245//" "//equ$1245]];
      Exit[]]];
   "Head[f] takes the head of an expression f."[1,Max[p0$1245,0]]//"<img  class=\"eqs\" SRC=\""//equ$1245//"\" />"//
   Help2HTML`oy$["Head[f] takes the head of an expression f."[p2$1245,-1]]
]</PRE>
<LI>
<H3><A NAME=L39>
Length</A></H3>
<PRE>If[{},Help2HTML`oA$[" Length[f] returns the number of elements in the body of a structure f."],
 p$1247=1+p$1247[[1,2]];p1$1247=StringPosition[" Length[f] returns the number of elements in the body of a structure f."[p$1247,-1
     ],
    ">::",1];
   p1$1247=If[p1$1247==={},71,-2+p$1247+p1$1247[[1,1]]];
  neq=Which[" Length[f] returns the number of elements in the body of a structure f."[p$1247,4+p$1247]==="Text[",
    lx$1247:=Help2HTML`oa$;p$1247=5+p$1247;p1$1247-=1;p2$1247=5+p1$1247;p0$1247=-9+p$1247;
     If[(pe$1247=StringPosition[" Length[f] returns the number of elements in the body of a structure f."[p$1247,-2],";;;"])<=>{},
      {Max[0,
        -1+ToExpression[" Length[f] returns the number of elements in the body of a structure f."[p$1247+pe$1247[[1,2]],p1$1247]]],
       p1$1247=-2+p$1247+pe$1247[[1,1]]}[[1]],
      0],
    1,lx$1247:=Help2HTML`o9$;p2$1247=4+p1$1247;p0$1247=-4+p$1247;0];
  If[(equ$1247=Help2HTML`o8$[" Length[f] returns the number of elements in the body of a structure f."[p$1247,p1$1247]])===
    Undefined,
   equ$1247="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        " Length[f] returns the number of elements in the body of a structure f."[p$1247,p1$1247]]=
       equ$1247;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$1247},out$1247=lx$1247@Typeset[" Length[f] returns the number of elements in the body of a structure f."[p$1247,
           p1$1247],Format->Help2HTML`oB$];
        System["mv -f "//out$1247//" "//equ$1247]];
      Exit[]]];
   " Length[f] returns the number of elements in the body of a structure f."[1,Max[p0$1247,0]]//"<img  class=\"eqs\" SRC=\""//
   equ$1247//"\" />"//Help2HTML`oy$[" Length[f] returns the number of elements in the body of a structure f."[p2$1247,-1]]
]</PRE>
<LI>
<H3><A NAME=L40>
List</A></H3>
<PRE>If[{},
Help2HTML`oA$[" List is a special symbol to be the head of generic list-structure.\n List[a, b, c, ...] is represented as {a, b, c\
, ...}.\n A list is also used to represent a mathematical vector and matrices.\n Most of mathematical functions are operated at ea\
ch element of a list."],
p$1249=1+p$1249[[1,2]];p1$1249=StringPosition[" List is a special symbol to be the head of generic list-structure.\n List[a, b, c,\
 ...] is represented as {a, b, c, ...}.\n A list is also used to represent a mathematical vector and matrices.\n Most of mathemati\
cal functions are operated at each element of a list."[p$1249,-1],">::",1];
   p1$1249=If[p1$1249==={},263,-2+p$1249+p1$1249[[1,1]]];
neq=Which[" List is a special symbol to be the head of generic list-structure.\n List[a, b, c, ...] is represented as {a, b, c, ..\
.}.\n A list is also used to represent a mathematical vector and matrices.\n Most of mathematical functions are operated at each e\
lement of a list."[p$1249,4+p$1249]==="Text[",
    lx$1249:=Help2HTML`oa$;p$1249=5+p$1249;p1$1249-=1;p2$1249=5+p1$1249;p0$1249=-9+p$1249;
If[(pe$1249=StringPosition[" List is a special symbol to be the head of generic list-structure.\n List[a, b, c, ...] is represente\
d as {a, b, c, ...}.\n A list is also used to represent a mathematical vector and matrices.\n Most of mathematical functions are o\
perated at each element of a list."[p$1249,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression[" List is a special symbol to be the head of generic list-structure.\n List[a, b, c, ...] is represented as {a, b,\
 c, ...}.\n A list is also used to represent a mathematical vector and matrices.\n Most of mathematical functions are operated at \
each element of a list."[p$1249+pe$1249[[1,2]],p1$1249]]],
        p1$1249=-2+p$1249+pe$1249[[1,1]]}[[
       1]],
      0],
    1,lx$1249:=Help2HTML`o9$;p2$1249=4+p1$1249;p0$1249=-4+p$1249;0];
  If[(equ$1249=
Help2HTML`o8$[" List is a special symbol to be the head of generic list-structure.\n List[a, b, c, ...] is represented as {a, b, c\
, ...}.\n A list is also used to represent a mathematical vector and matrices.\n Most of mathematical functions are operated at ea\
ch element of a list."[p$1249,p1$1249]])===
    Undefined,
equ$1249="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[" List is a special symbol to be the head of \
generic list-structure.\n List[a, b, c, ...] is represented as {a, b, c, ...}.\n A list is also used to represent a mathematical v\
ector and matrices.\n Most of mathematical functions are operated at each element of a list."[p$1249,p1$1249]]=
       equ$1249;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1249},out$1249=lx$1249@Typeset[" List is a special symbol to be the head of generic list-structure.\n List[a, b, c, ...] \
is represented as {a, b, c, ...}.\n A list is also used to represent a mathematical vector and matrices.\n Most of mathematical fu\
nctions are operated at each element of a list."[p$1249,p1$1249],Format->Help2HTML`oB$];
        System["mv -f "//out$1249//" "//equ$1249]];
      Exit[]]];
   " List is a special symbol to be the head of generic list-structure.\n List[a, b, c, ...] is represented as {a, b, c, ...}.\n A\
 list is also used to represent a mathematical vector and matrices.\n Most of mathematical functions are operated at each element \
of a list."[1,Max[p0$1249,0]]//"<img  class=\"eqs\" SRC=\""//equ$1249//"\" />"//
Help2HTML`oy$[" List is a special symbol to be the head of generic list-structure.\n List[a, b, c, ...] is represented as {a, b, c\
, ...}.\n A list is also used to represent a mathematical vector and matrices.\n Most of mathematical functions are operated at ea\
ch element of a list."[p2$1249,-1]]
]</PRE>
<LI>
<H3><A NAME=L41>
Part</A></H3>
<PRE>If[{},
Help2HTML`oA$["  Part[f, a [,b ,...]] ===> f[[a, [,b ...]]]\n\ntakes the a-th element of structure f. f[[a, b]] is equivalent to f\
[[a]][[b]].\n If a is zero, it takes the head of f.\n if a is negative, f[[a]] os equivalent to f[[Length[f] + 1 + a]].\n If a is \
a list of Reals {a1, a2, ...}, f[[a]] returns {f[[a1]], f[[a2]], ...}.\n If a is Null, f[[,b]] is returns {f[[1,a]], ..., f[[Lengt\
h[f], b]]}."],
p$1251=1+p$1251[[1,2]];p1$1251=StringPosition["  Part[f, a [,b ,...]] ===> f[[a, [,b ...]]]\n\ntakes the a-th element of structure\
 f. f[[a, b]] is equivalent to f[[a]][[b]].\n If a is zero, it takes the head of f.\n if a is negative, f[[a]] os equivalent to f[\
[Length[f] + 1 + a]].\n If a is a list of Reals {a1, a2, ...}, f[[a]] returns {f[[a1]], f[[a2]], ...}.\n If a is Null, f[[,b]] is \
returns {f[[1,a]], ..., f[[Length[f], b]]}."[p$1251,-1],">::",1];
   p1$1251=If[p1$1251==={},380,-2+p$1251+p1$1251[[1,1]]];
neq=Which["  Part[f, a [,b ,...]] ===> f[[a, [,b ...]]]\n\ntakes the a-th element of structure f. f[[a, b]] is equivalent to f[[a]\
][[b]].\n If a is zero, it takes the head of f.\n if a is negative, f[[a]] os equivalent to f[[Length[f] + 1 + a]].\n If a is a li\
st of Reals {a1, a2, ...}, f[[a]] returns {f[[a1]], f[[a2]], ...}.\n If a is Null, f[[,b]] is returns {f[[1,a]], ..., f[[Length[f]\
, b]]}."[p$1251,4+p$1251]==="Text[",
    lx$1251:=Help2HTML`oa$;p$1251=5+p$1251;p1$1251-=1;p2$1251=5+p1$1251;p0$1251=-9+p$1251;If[(pe$1251=
StringPosition["  Part[f, a [,b ,...]] ===> f[[a, [,b ...]]]\n\ntakes the a-th element of structure f. f[[a, b]] is equivalent to \
f[[a]][[b]].\n If a is zero, it takes the head of f.\n if a is negative, f[[a]] os equivalent to f[[Length[f] + 1 + a]].\n If a is\
 a list of Reals {a1, a2, ...}, f[[a]] returns {f[[a1]], f[[a2]], ...}.\n If a is Null, f[[,b]] is returns {f[[1,a]], ..., f[[Leng\
th[f], b]]}."[p$1251,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["  Part[f, a [,b ,...]] ===> f[[a, [,b ...]]]\n\ntakes the a-th element of structure f. f[[a, b]] is equivalent to\
 f[[a]][[b]].\n If a is zero, it takes the head of f.\n if a is negative, f[[a]] os equivalent to f[[Length[f] + 1 + a]].\n If a i\
s a list of Reals {a1, a2, ...}, f[[a]] returns {f[[a1]], f[[a2]], ...}.\n If a is Null, f[[,b]] is returns {f[[1,a]], ..., f[[Len\
gth[f], b]]}."[p$1251+pe$1251[[1,2]],p1$1251]]],
        p1$1251=-2+p$1251+pe$1251[[1,1]]}[[
       1]],
      0],
    1,lx$1251:=Help2HTML`o9$;p2$1251=4+p1$1251;p0$1251=-4+p$1251;0];
  If[(equ$1251=
Help2HTML`o8$["  Part[f, a [,b ,...]] ===> f[[a, [,b ...]]]\n\ntakes the a-th element of structure f. f[[a, b]] is equivalent to f\
[[a]][[b]].\n If a is zero, it takes the head of f.\n if a is negative, f[[a]] os equivalent to f[[Length[f] + 1 + a]].\n If a is \
a list of Reals {a1, a2, ...}, f[[a]] returns {f[[a1]], f[[a2]], ...}.\n If a is Null, f[[,b]] is returns {f[[1,a]], ..., f[[Lengt\
h[f], b]]}."[p$1251,p1$1251]])===
    Undefined,
equ$1251="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["  Part[f, a [,b ,...]] ===> f[[a, [,b ...]]]\
\n\ntakes the a-th element of structure f. f[[a, b]] is equivalent to f[[a]][[b]].\n If a is zero, it takes the head of f.\n if a \
is negative, f[[a]] os equivalent to f[[Length[f] + 1 + a]].\n If a is a list of Reals {a1, a2, ...}, f[[a]] returns {f[[a1]], f[[\
a2]], ...}.\n If a is Null, f[[,b]] is returns {f[[1,a]], ..., f[[Length[f], b]]}."[p$1251,p1$1251]]=
       equ$1251;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1251},out$1251=lx$1251@Typeset["  Part[f, a [,b ,...]] ===> f[[a, [,b ...]]]\n\ntakes the a-th element of structure f. f[\
[a, b]] is equivalent to f[[a]][[b]].\n If a is zero, it takes the head of f.\n if a is negative, f[[a]] os equivalent to f[[Lengt\
h[f] + 1 + a]].\n If a is a list of Reals {a1, a2, ...}, f[[a]] returns {f[[a1]], f[[a2]], ...}.\n If a is Null, f[[,b]] is return\
s {f[[1,a]], ..., f[[Length[f], b]]}."[p$1251,p1$1251],Format->Help2HTML`oB$];
        System["mv -f "//out$1251//" "//equ$1251]];
      Exit[]]];
   "  Part[f, a [,b ,...]] ===> f[[a, [,b ...]]]\n\ntakes the a-th element of structure f. f[[a, b]] is equivalent to f[[a]][[b]].\
\n If a is zero, it takes the head of f.\n if a is negative, f[[a]] os equivalent to f[[Length[f] + 1 + a]].\n If a is a list of R\
eals {a1, a2, ...}, f[[a]] returns {f[[a1]], f[[a2]], ...}.\n If a is Null, f[[,b]] is returns {f[[1,a]], ..., f[[Length[f], b]]}."
   [1,Max[p0$1251,0]]//"<img  class=\"eqs\" SRC=\""//equ$1251//"\" />"//
Help2HTML`oy$["  Part[f, a [,b ,...]] ===> f[[a, [,b ...]]]\n\ntakes the a-th element of structure f. f[[a, b]] is equivalent to f\
[[a]][[b]].\n If a is zero, it takes the head of f.\n if a is negative, f[[a]] os equivalent to f[[Length[f] + 1 + a]].\n If a is \
a list of Reals {a1, a2, ...}, f[[a]] returns {f[[a1]], f[[a2]], ...}.\n If a is Null, f[[,b]] is returns {f[[1,a]], ..., f[[Lengt\
h[f], b]]}."[p2$1251,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L39>Length</A> <A HREF=#L38>Head</A> <A HREF=#L37>Extract</A></PRE>
</UL>
<H3><A NAME=L42>
defining-functions</A></H3>
<PRE>If[{},
Help2HTML`oA$[" A function is defined by one of the following forms:\n\nf[pat1 [,pat2...]] (:)= body;\nf[pat1 [,pat2...]] ^(:)= bo\
dy;\ng/:f[pat1 [,pat2...]] (:)= body;\n\nwhere pat1 [,pat2...] are patterns (including expressions).\n If UpSet(^=) or UpSetDelaye\
d (^:=) is used, the definition is associated with the symbol in the first level of l.h.s.\n If TagSet(/:) is used, the definition\
 is associated with the symbol on the left of /: .\n\n The patters can be an expression including constants. The definition with c\
onstant arguments can be accessed faster than searching a list, in general, so they are suitable for a data base. Definitions with\
 constant arguments have higher priorities than with patterns."],
p$1254=1+p$1254[[1,2]];p1$1254=StringPosition[" A function is defined by one of the following forms:\n\nf[pat1 [,pat2...]] (:)= bo\
dy;\nf[pat1 [,pat2...]] ^(:)= body;\ng/:f[pat1 [,pat2...]] (:)= body;\n\nwhere pat1 [,pat2...] are patterns (including expressions\
).\n If UpSet(^=) or UpSetDelayed (^:=) is used, the definition is associated with the symbol in the first level of l.h.s.\n If Ta\
gSet(/:) is used, the definition is associated with the symbol on the left of /: .\n\n The patters can be an expression including \
constants. The definition with constant arguments can be accessed faster than searching a list, in general, so they are suitable f\
or a data base. Definitions with constant arguments have higher priorities than with patterns."[p$1254,-1],">::",1];
   p1$1254=If[p1$1254==={},687,-2+p$1254+p1$1254[[1,1]]];
neq=Which[" A function is defined by one of the following forms:\n\nf[pat1 [,pat2...]] (:)= body;\nf[pat1 [,pat2...]] ^(:)= body;\\
ng/:f[pat1 [,pat2...]] (:)= body;\n\nwhere pat1 [,pat2...] are patterns (including expressions).\n If UpSet(^=) or UpSetDelayed (^\
:=) is used, the definition is associated with the symbol in the first level of l.h.s.\n If TagSet(/:) is used, the definition is \
associated with the symbol on the left of /: .\n\n The patters can be an expression including constants. The definition with const\
ant arguments can be accessed faster than searching a list, in general, so they are suitable for a data base. Definitions with con\
stant arguments have higher priorities than with patterns."[p$1254,4+p$1254]==="Text[",
    lx$1254:=Help2HTML`oa$;p$1254=5+p$1254;p1$1254-=1;p2$1254=5+p1$1254;p0$1254=-9+p$1254;
If[(pe$1254=StringPosition[" A function is defined by one of the following forms:\n\nf[pat1 [,pat2...]] (:)= body;\nf[pat1 [,pat2.\
..]] ^(:)= body;\ng/:f[pat1 [,pat2...]] (:)= body;\n\nwhere pat1 [,pat2...] are patterns (including expressions).\n If UpSet(^=) o\
r UpSetDelayed (^:=) is used, the definition is associated with the symbol in the first level of l.h.s.\n If TagSet(/:) is used, t\
he definition is associated with the symbol on the left of /: .\n\n The patters can be an expression including constants. The defi\
nition with constant arguments can be accessed faster than searching a list, in general, so they are suitable for a data base. Def\
initions with constant arguments have higher priorities than with patterns."[p$1254,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression[" A function is defined by one of the following forms:\n\nf[pat1 [,pat2...]] (:)= body;\nf[pat1 [,pat2...]] ^(:)= \
body;\ng/:f[pat1 [,pat2...]] (:)= body;\n\nwhere pat1 [,pat2...] are patterns (including expressions).\n If UpSet(^=) or UpSetDela\
yed (^:=) is used, the definition is associated with the symbol in the first level of l.h.s.\n If TagSet(/:) is used, the definiti\
on is associated with the symbol on the left of /: .\n\n The patters can be an expression including constants. The definition with\
 constant arguments can be accessed faster than searching a list, in general, so they are suitable for a data base. Definitions wi\
th constant arguments have higher priorities than with patterns."[p$1254+pe$1254[[1,2]],p1$1254]]],
        p1$1254=-2+p$1254+pe$1254[[1,1]]}[[
       1]],
      0],
    1,lx$1254:=Help2HTML`o9$;p2$1254=4+p1$1254;p0$1254=-4+p$1254;0];
  If[(equ$1254=
Help2HTML`o8$[" A function is defined by one of the following forms:\n\nf[pat1 [,pat2...]] (:)= body;\nf[pat1 [,pat2...]] ^(:)= bo\
dy;\ng/:f[pat1 [,pat2...]] (:)= body;\n\nwhere pat1 [,pat2...] are patterns (including expressions).\n If UpSet(^=) or UpSetDelaye\
d (^:=) is used, the definition is associated with the symbol in the first level of l.h.s.\n If TagSet(/:) is used, the definition\
 is associated with the symbol on the left of /: .\n\n The patters can be an expression including constants. The definition with c\
onstant arguments can be accessed faster than searching a list, in general, so they are suitable for a data base. Definitions with\
 constant arguments have higher priorities than with patterns."[p$1254,p1$1254]])===
    Undefined,
equ$1254="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[" A function is defined by one of the followi\
ng forms:\n\nf[pat1 [,pat2...]] (:)= body;\nf[pat1 [,pat2...]] ^(:)= body;\ng/:f[pat1 [,pat2...]] (:)= body;\n\nwhere pat1 [,pat2.\
..] are patterns (including expressions).\n If UpSet(^=) or UpSetDelayed (^:=) is used, the definition is associated with the symb\
ol in the first level of l.h.s.\n If TagSet(/:) is used, the definition is associated with the symbol on the left of /: .\n\n The \
patters can be an expression including constants. The definition with constant arguments can be accessed faster than searching a l\
ist, in general, so they are suitable for a data base. Definitions with constant arguments have higher priorities than with patter\
ns."[p$1254,p1$1254]]=
       equ$1254;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1254},out$1254=lx$1254@Typeset[" A function is defined by one of the following forms:\n\nf[pat1 [,pat2...]] (:)= body;\nf\
[pat1 [,pat2...]] ^(:)= body;\ng/:f[pat1 [,pat2...]] (:)= body;\n\nwhere pat1 [,pat2...] are patterns (including expressions).\n I\
f UpSet(^=) or UpSetDelayed (^:=) is used, the definition is associated with the symbol in the first level of l.h.s.\n If TagSet(/\
:) is used, the definition is associated with the symbol on the left of /: .\n\n The patters can be an expression including consta\
nts. The definition with constant arguments can be accessed faster than searching a list, in general, so they are suitable for a d\
ata base. Definitions with constant arguments have higher priorities than with patterns."[p$1254,p1$1254],Format->Help2HTML`oB$];
        System["mv -f "//out$1254//" "//equ$1254]];
      Exit[]]];
   " A function is defined by one of the following forms:\n\nf[pat1 [,pat2...]] (:)= body;\nf[pat1 [,pat2...]] ^(:)= body;\ng/:f[p\
at1 [,pat2...]] (:)= body;\n\nwhere pat1 [,pat2...] are patterns (including expressions).\n If UpSet(^=) or UpSetDelayed (^:=) is \
used, the definition is associated with the symbol in the first level of l.h.s.\n If TagSet(/:) is used, the definition is associa\
ted with the symbol on the left of /: .\n\n The patters can be an expression including constants. The definition with constant arg\
uments can be accessed faster than searching a list, in general, so they are suitable for a data base. Definitions with constant a\
rguments have higher priorities than with patterns."[1,Max[p0$1254,0]]//"<img  class=\"eqs\" SRC=\""//equ$1254//"\" />"//
   Help2HTML`oy$[" A function is defined by one of the following forms:\n\nf[pat1 [,pat2...]] (:)= body;\nf[pat1 [,pat2...]] ^(:)=\
 body;\ng/:f[pat1 [,pat2...]] (:)= body;\n\nwhere pat1 [,pat2...] are patterns (including expressions).\n If UpSet(^=) or UpSetDel\
ayed (^:=) is used, the definition is associated with the symbol in the first level of l.h.s.\n If TagSet(/:) is used, the definit\
ion is associated with the symbol on the left of /: .\n\n The patters can be an expression including constants. The definition wit\
h constant arguments can be accessed faster than searching a list, in general, so they are suitable for a data base. Definitions w\
ith constant arguments have higher priorities than with patterns."[p2$1254,-1]]
]</PRE>
<PRE>See also:
 UpSet UpSetDelayed <A HREF=#L287>TagSet(/:)</A> <A HREF=#L481>pattern</A></PRE>
<H3><A NAME=L43>
dynamics</A></H3>
<PRE>
</PRE>
<UL>
<LI>
<H3><A NAME=L44>
independent-variable</A></H3>
<PRE><img  class="eqs" SRC="SADHelp_img/equ_1.svg" />
</PRE>
<PRE>See also:
 <A HREF=#L45>Lagrangean</A> <A HREF=#L46>Hamiltonian</A></PRE>
<LI>
<H3><A NAME=L45>
Lagrangean</A></H3>
<PRE><img  class="eqs" SRC="SADHelp_img/equ_2.svg" />
</PRE>
<PRE>See also:
 <A HREF=#L46>Hamiltonian</A> <A HREF=#L44>independent-variable</A></PRE>
<LI>
<H3><A NAME=L46>
Hamiltonian</A></H3>
<PRE><img  class="eqs" SRC="SADHelp_img/equ_6.svg" />
</PRE>
<PRE>See also:
 <A HREF=#L45>Lagrangean</A> <A HREF=#L44>independent-variable</A></PRE>
<UL>
<LI>
<H3><A NAME=L47>
2nd-order-Hamiltonian</A></H3>
<PRE><img  class="eqs" SRC="SADHelp_img/equ_18.svg" />
</PRE>
<PRE>See also:
 <A HREF=#L46>Hamiltonian</A> <A HREF=#L50>remarks-on-dynamics</A></PRE>
<UL>
<LI>
<H3><A NAME=L48>
solution-H2</A></H3>
<PRE><img  class="eqs" SRC="SADHelp_img/equ_20.svg" />
</PRE>
<PRE>See also:
 <A HREF=#L49>solution-dH</A></PRE>
<LI>
<H3><A NAME=L49>
solution-dH</A></H3>
<PRE><img  class="eqs" SRC="SADHelp_img/equ_47.svg" />
</PRE>
<PRE>See also:
 <A HREF=#L48>solution-H2</A></PRE>
</UL>
</UL>
<LI>
<H3><A NAME=L50>
remarks-on-dynamics</A></H3>
<PRE><img  class="eqs" SRC="SADHelp_img/equ_59.svg" />
</PRE>
<PRE>See also:
 <A HREF=#L46>Hamiltonian</A> <A HREF=#L47>2nd-order-Hamiltonian</A></PRE>
<LI>
<H3><A NAME=L51>
x-y-coupling</A></H3>
<PRE><img  class="eqs" SRC="SADHelp_img/equ_60.svg" />
</PRE>
<PRE>See also:
 <A HREF=#L56>DISPLAY(DISP)</A> <A HREF=#L478>optical-functions</A> <A HREF=#L473>matching-function-commands</A></PRE>
<LI>
<H3><A NAME=L52>
extended-Twiss-parameters</A></H3>
<PRE>If[{},
Help2HTML`oA$["A symplectic matrix such as the normal mode matrix can be expressed in terms of the extended Twiss parameters. In 6\
 by 6 case, those are\n\n   AX  BX          ZX  EX\n     PSIX         ZPX EPX\n   R1  R2  AY  BY  ZY  EY\n   R3  R4    PSIY ZPY EP\
Y\n                   AZ  BZ\n                     PSIZ .\n\nA(X,Y,Z), B(X,Y,Z) are alphas and betas in the usual sense, after a d\
iagonalization to 2 by 2 submatrices. PSI(X,Y,Z) are the rotation angle to set one the coordinate to parallel to the (X,Y,Z) axes.\
 R(1,2,3,4) are the components of the x-y coupling matrix (see x-y-coupling). E(X,PX,Y,PY) are \"dispersions\" which decouples syn\
chro-beta coupling terms together with Z(X,PX,Y,PY). Those parameters should agree with what FFS calculates in the case of no sync\
hro-beta couplings."],
p$1282=1+p$1282[[1,2]];p1$1282=StringPosition["A symplectic matrix such as the normal mode matrix can be expressed in terms of the\
 extended Twiss parameters. In 6 by 6 case, those are\n\n   AX  BX          ZX  EX\n     PSIX         ZPX EPX\n   R1  R2  AY  BY  \
ZY  EY\n   R3  R4    PSIY ZPY EPY\n                   AZ  BZ\n                     PSIZ .\n\nA(X,Y,Z), B(X,Y,Z) are alphas and bet\
as in the usual sense, after a diagonalization to 2 by 2 submatrices. PSI(X,Y,Z) are the rotation angle to set one the coordinate \
to parallel to the (X,Y,Z) axes. R(1,2,3,4) are the components of the x-y coupling matrix (see x-y-coupling). E(X,PX,Y,PY) are \"d\
ispersions\" which decouples synchro-beta coupling terms together with Z(X,PX,Y,PY). Those parameters should agree with what FFS c\
alculates in the case of no synchro-beta couplings."[p$1282,-1],">::",1];
   p1$1282=If[p1$1282==={},773,-2+p$1282+p1$1282[[1,1]]];
neq=Which["A symplectic matrix such as the normal mode matrix can be expressed in terms of the extended Twiss parameters. In 6 by \
6 case, those are\n\n   AX  BX          ZX  EX\n     PSIX         ZPX EPX\n   R1  R2  AY  BY  ZY  EY\n   R3  R4    PSIY ZPY EPY\n \
                  AZ  BZ\n                     PSIZ .\n\nA(X,Y,Z), B(X,Y,Z) are alphas and betas in the usual sense, after a diago\
nalization to 2 by 2 submatrices. PSI(X,Y,Z) are the rotation angle to set one the coordinate to parallel to the (X,Y,Z) axes. R(1\
,2,3,4) are the components of the x-y coupling matrix (see x-y-coupling). E(X,PX,Y,PY) are \"dispersions\" which decouples synchro\
-beta coupling terms together with Z(X,PX,Y,PY). Those parameters should agree with what FFS calculates in the case of no synchro-\
beta couplings."[p$1282,4+p$1282]==="Text[",
    lx$1282:=Help2HTML`oa$;p$1282=5+p$1282;p1$1282-=1;p2$1282=5+p1$1282;p0$1282=-9+p$1282;If[(pe$1282=
StringPosition["A symplectic matrix such as the normal mode matrix can be expressed in terms of the extended Twiss parameters. In \
6 by 6 case, those are\n\n   AX  BX          ZX  EX\n     PSIX         ZPX EPX\n   R1  R2  AY  BY  ZY  EY\n   R3  R4    PSIY ZPY E\
PY\n                   AZ  BZ\n                     PSIZ .\n\nA(X,Y,Z), B(X,Y,Z) are alphas and betas in the usual sense, after a \
diagonalization to 2 by 2 submatrices. PSI(X,Y,Z) are the rotation angle to set one the coordinate to parallel to the (X,Y,Z) axes\
. R(1,2,3,4) are the components of the x-y coupling matrix (see x-y-coupling). E(X,PX,Y,PY) are \"dispersions\" which decouples sy\
nchro-beta coupling terms together with Z(X,PX,Y,PY). Those parameters should agree with what FFS calculates in the case of no syn\
chro-beta couplings."[p$1282,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["A symplectic matrix such as the normal mode matrix can be expressed in terms of the extended Twiss parameters. In\
 6 by 6 case, those are\n\n   AX  BX          ZX  EX\n     PSIX         ZPX EPX\n   R1  R2  AY  BY  ZY  EY\n   R3  R4    PSIY ZPY \
EPY\n                   AZ  BZ\n                     PSIZ .\n\nA(X,Y,Z), B(X,Y,Z) are alphas and betas in the usual sense, after a\
 diagonalization to 2 by 2 submatrices. PSI(X,Y,Z) are the rotation angle to set one the coordinate to parallel to the (X,Y,Z) axe\
s. R(1,2,3,4) are the components of the x-y coupling matrix (see x-y-coupling). E(X,PX,Y,PY) are \"dispersions\" which decouples s\
ynchro-beta coupling terms together with Z(X,PX,Y,PY). Those parameters should agree with what FFS calculates in the case of no sy\
nchro-beta couplings."[p$1282+pe$1282[[1,2]],p1$1282]]],
        p1$1282=-2+p$1282+pe$1282[[1,1]]}[[
       1]],
      0],
    1,lx$1282:=Help2HTML`o9$;p2$1282=4+p1$1282;p0$1282=-4+p$1282;0];
  If[(equ$1282=
Help2HTML`o8$["A symplectic matrix such as the normal mode matrix can be expressed in terms of the extended Twiss parameters. In 6\
 by 6 case, those are\n\n   AX  BX          ZX  EX\n     PSIX         ZPX EPX\n   R1  R2  AY  BY  ZY  EY\n   R3  R4    PSIY ZPY EP\
Y\n                   AZ  BZ\n                     PSIZ .\n\nA(X,Y,Z), B(X,Y,Z) are alphas and betas in the usual sense, after a d\
iagonalization to 2 by 2 submatrices. PSI(X,Y,Z) are the rotation angle to set one the coordinate to parallel to the (X,Y,Z) axes.\
 R(1,2,3,4) are the components of the x-y coupling matrix (see x-y-coupling). E(X,PX,Y,PY) are \"dispersions\" which decouples syn\
chro-beta coupling terms together with Z(X,PX,Y,PY). Those parameters should agree with what FFS calculates in the case of no sync\
hro-beta couplings."[p$1282,p1$1282]])===
    Undefined,
equ$1282="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["A symplectic matrix such as the normal mode \
matrix can be expressed in terms of the extended Twiss parameters. In 6 by 6 case, those are\n\n   AX  BX          ZX  EX\n     PS\
IX         ZPX EPX\n   R1  R2  AY  BY  ZY  EY\n   R3  R4    PSIY ZPY EPY\n                   AZ  BZ\n                     PSIZ .\n\
\nA(X,Y,Z), B(X,Y,Z) are alphas and betas in the usual sense, after a diagonalization to 2 by 2 submatrices. PSI(X,Y,Z) are the ro\
tation angle to set one the coordinate to parallel to the (X,Y,Z) axes. R(1,2,3,4) are the components of the x-y coupling matrix (\
see x-y-coupling). E(X,PX,Y,PY) are \"dispersions\" which decouples synchro-beta coupling terms together with Z(X,PX,Y,PY). Those \
parameters should agree with what FFS calculates in the case of no synchro-beta couplings."[p$1282,p1$1282]]=
       equ$1282;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1282},out$1282=lx$1282@Typeset["A symplectic matrix such as the normal mode matrix can be expressed in terms of the exten\
ded Twiss parameters. In 6 by 6 case, those are\n\n   AX  BX          ZX  EX\n     PSIX         ZPX EPX\n   R1  R2  AY  BY  ZY  EY\
\n   R3  R4    PSIY ZPY EPY\n                   AZ  BZ\n                     PSIZ .\n\nA(X,Y,Z), B(X,Y,Z) are alphas and betas in \
the usual sense, after a diagonalization to 2 by 2 submatrices. PSI(X,Y,Z) are the rotation angle to set one the coordinate to par\
allel to the (X,Y,Z) axes. R(1,2,3,4) are the components of the x-y coupling matrix (see x-y-coupling). E(X,PX,Y,PY) are \"dispers\
ions\" which decouples synchro-beta coupling terms together with Z(X,PX,Y,PY). Those parameters should agree with what FFS calcula\
tes in the case of no synchro-beta couplings."[p$1282,p1$1282],Format->Help2HTML`oB$];
        System["mv -f "//out$1282//" "//equ$1282]];
      Exit[]]];
   "A symplectic matrix such as the normal mode matrix can be expressed in terms of the extended Twiss parameters. In 6 by 6 case,\
 those are\n\n   AX  BX          ZX  EX\n     PSIX         ZPX EPX\n   R1  R2  AY  BY  ZY  EY\n   R3  R4    PSIY ZPY EPY\n        \
           AZ  BZ\n                     PSIZ .\n\nA(X,Y,Z), B(X,Y,Z) are alphas and betas in the usual sense, after a diagonalizat\
ion to 2 by 2 submatrices. PSI(X,Y,Z) are the rotation angle to set one the coordinate to parallel to the (X,Y,Z) axes. R(1,2,3,4)\
 are the components of the x-y coupling matrix (see x-y-coupling). E(X,PX,Y,PY) are \"dispersions\" which decouples synchro-beta c\
oupling terms together with Z(X,PX,Y,PY). Those parameters should agree with what FFS calculates in the case of no synchro-beta co\
uplings."[1,Max[p0$1282,0]]//"<img  class=\"eqs\" SRC=\""//equ$1282//"\" />"//
Help2HTML`oy$["A symplectic matrix such as the normal mode matrix can be expressed in terms of the extended Twiss parameters. In 6\
 by 6 case, those are\n\n   AX  BX          ZX  EX\n     PSIX         ZPX EPX\n   R1  R2  AY  BY  ZY  EY\n   R3  R4    PSIY ZPY EP\
Y\n                   AZ  BZ\n                     PSIZ .\n\nA(X,Y,Z), B(X,Y,Z) are alphas and betas in the usual sense, after a d\
iagonalization to 2 by 2 submatrices. PSI(X,Y,Z) are the rotation angle to set one the coordinate to parallel to the (X,Y,Z) axes.\
 R(1,2,3,4) are the components of the x-y coupling matrix (see x-y-coupling). E(X,PX,Y,PY) are \"dispersions\" which decouples syn\
chro-beta coupling terms together with Z(X,PX,Y,PY). Those parameters should agree with what FFS calculates in the case of no sync\
hro-beta couplings."[p2$1282,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L51>x-y-coupling</A> <A HREF=#L478>optical-functions</A></PRE>
<UL>
<LI>
<H3><A NAME=L53>
definitions</A></H3>
<PRE><img  class="eqs" SRC="SADHelp_img/equ_68.svg" />
</PRE>
</UL>
<LI>
<H3><A NAME=L54>
synchrotron-radiation</A></H3>
<PRE><img  class="eqs" SRC="SADHelp_img/equ_81.svg" />
</PRE>
<PRE>See also:
 <A HREF=#L337>RAD</A> <A HREF=#L338>RADCOD</A> <A HREF=#L46>Hamiltonian</A> <A HREF=#L77>BEND</A> <A HREF=#L88>F1</A></PRE>
<LI>
<H3><A NAME=L55>
equilibrium-beam-envelope</A></H3>
<PRE><img  class="eqs" SRC="SADHelp_img/equ_85.svg" />
</PRE>
<PRE>See also:
 <A HREF=#L295>EMITTANCE(EMIT)</A> <A HREF=#L389>Emittance</A> <A HREF=#L325>INTRA</A> <A HREF=#L357>WSPAC</A> <A HREF=#L530>MINCOUP</A></PRE>
</UL>
<H3><A NAME=L56>
DISPLAY(DISP)</A></H3>
<PRE>If[{},
Help2HTML`oA$["Usage: DISP_LAY [keywords] [pattern-string] [region]\n\nDisplays values of various optical-/geometric-functions at \
the components given by the pattern-string in the region (see region) in the current beam line. It has several display modes speci\
fied by the keywords. As the default, it displays AX, BX, NX, EX, EPX, AY, BY, NY, EY, EPY, LENG, the length and the value of the \
default-keyword of the component. Each line refers to the entrance of each component of the line. The end of the beam line has the\
 name \"$$$\". The first component can be specified by \"^^^\".\n   DISP suspends the output to the terminal at every 66 lines, as\
king (q_uit, c_ontinue, a_ll)?. The further output depends on the first character of the answer from the terminal input. This dial\
og is suppressed by specifying ALL.\n   DISP does not calculate the functions to be displayed, so CALCULATE(CALC) or GO is necessa\
ry whenever values of components are updated."],
p$1293=1+p$1293[[1,2]];p1$1293=StringPosition["Usage: DISP_LAY [keywords] [pattern-string] [region]\n\nDisplays values of various \
optical-/geometric-functions at the components given by the pattern-string in the region (see region) in the current beam line. It\
 has several display modes specified by the keywords. As the default, it displays AX, BX, NX, EX, EPX, AY, BY, NY, EY, EPY, LENG, \
the length and the value of the default-keyword of the component. Each line refers to the entrance of each component of the line. \
The end of the beam line has the name \"$$$\". The first component can be specified by \"^^^\".\n   DISP suspends the output to th\
e terminal at every 66 lines, asking (q_uit, c_ontinue, a_ll)?. The further output depends on the first character of the answer fr\
om the terminal input. This dialog is suppressed by specifying ALL.\n   DISP does not calculate the functions to be displayed, so \
CALCULATE(CALC) or GO is necessary whenever values of components are updated."[p$1293,-1],">::",1];
   p1$1293=If[p1$1293==={},932,-2+p$1293+p1$1293[[1,1]]];
neq=Which["Usage: DISP_LAY [keywords] [pattern-string] [region]\n\nDisplays values of various optical-/geometric-functions at the \
components given by the pattern-string in the region (see region) in the current beam line. It has several display modes specified\
 by the keywords. As the default, it displays AX, BX, NX, EX, EPX, AY, BY, NY, EY, EPY, LENG, the length and the value of the defa\
ult-keyword of the component. Each line refers to the entrance of each component of the line. The end of the beam line has the nam\
e \"$$$\". The first component can be specified by \"^^^\".\n   DISP suspends the output to the terminal at every 66 lines, asking\
 (q_uit, c_ontinue, a_ll)?. The further output depends on the first character of the answer from the terminal input. This dialog i\
s suppressed by specifying ALL.\n   DISP does not calculate the functions to be displayed, so CALCULATE(CALC) or GO is necessary w\
henever values of components are updated."[p$1293,4+p$1293]==="Text[",
    lx$1293:=Help2HTML`oa$;p$1293=5+p$1293;p1$1293-=1;p2$1293=5+p1$1293;p0$1293=-9+p$1293;
If[(pe$1293=StringPosition["Usage: DISP_LAY [keywords] [pattern-string] [region]\n\nDisplays values of various optical-/geometric-\
functions at the components given by the pattern-string in the region (see region) in the current beam line. It has several displa\
y modes specified by the keywords. As the default, it displays AX, BX, NX, EX, EPX, AY, BY, NY, EY, EPY, LENG, the length and the \
value of the default-keyword of the component. Each line refers to the entrance of each component of the line. The end of the beam\
 line has the name \"$$$\". The first component can be specified by \"^^^\".\n   DISP suspends the output to the terminal at every\
 66 lines, asking (q_uit, c_ontinue, a_ll)?. The further output depends on the first character of the answer from the terminal inp\
ut. This dialog is suppressed by specifying ALL.\n   DISP does not calculate the functions to be displayed, so CALCULATE(CALC) or \
GO is necessary whenever values of components are updated."[p$1293,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Usage: DISP_LAY [keywords] [pattern-string] [region]\n\nDisplays values of various optical-/geometric-functions a\
t the components given by the pattern-string in the region (see region) in the current beam line. It has several display modes spe\
cified by the keywords. As the default, it displays AX, BX, NX, EX, EPX, AY, BY, NY, EY, EPY, LENG, the length and the value of th\
e default-keyword of the component. Each line refers to the entrance of each component of the line. The end of the beam line has t\
he name \"$$$\". The first component can be specified by \"^^^\".\n   DISP suspends the output to the terminal at every 66 lines, \
asking (q_uit, c_ontinue, a_ll)?. The further output depends on the first character of the answer from the terminal input. This di\
alog is suppressed by specifying ALL.\n   DISP does not calculate the functions to be displayed, so CALCULATE(CALC) or GO is neces\
sary whenever values of components are updated."[p$1293+pe$1293[[1,2]],p1$1293]]],
        p1$1293=-2+p$1293+pe$1293[[1,1]]}[[
       1]],
      0],
    1,lx$1293:=Help2HTML`o9$;p2$1293=4+p1$1293;p0$1293=-4+p$1293;0];
  If[(equ$1293=
Help2HTML`o8$["Usage: DISP_LAY [keywords] [pattern-string] [region]\n\nDisplays values of various optical-/geometric-functions at \
the components given by the pattern-string in the region (see region) in the current beam line. It has several display modes speci\
fied by the keywords. As the default, it displays AX, BX, NX, EX, EPX, AY, BY, NY, EY, EPY, LENG, the length and the value of the \
default-keyword of the component. Each line refers to the entrance of each component of the line. The end of the beam line has the\
 name \"$$$\". The first component can be specified by \"^^^\".\n   DISP suspends the output to the terminal at every 66 lines, as\
king (q_uit, c_ontinue, a_ll)?. The further output depends on the first character of the answer from the terminal input. This dial\
og is suppressed by specifying ALL.\n   DISP does not calculate the functions to be displayed, so CALCULATE(CALC) or GO is necessa\
ry whenever values of components are updated."[p$1293,p1$1293]])===
    Undefined,
equ$1293="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Usage: DISP_LAY [keywords] [pattern-string] \
[region]\n\nDisplays values of various optical-/geometric-functions at the components given by the pattern-string in the region (s\
ee region) in the current beam line. It has several display modes specified by the keywords. As the default, it displays AX, BX, N\
X, EX, EPX, AY, BY, NY, EY, EPY, LENG, the length and the value of the default-keyword of the component. Each line refers to the e\
ntrance of each component of the line. The end of the beam line has the name \"$$$\". The first component can be specified by \"^^\
^\".\n   DISP suspends the output to the terminal at every 66 lines, asking (q_uit, c_ontinue, a_ll)?. The further output depends \
on the first character of the answer from the terminal input. This dialog is suppressed by specifying ALL.\n   DISP does not calcu\
late the functions to be displayed, so CALCULATE(CALC) or GO is necessary whenever values of components are updated."[p$1293,
         p1$1293]]=
       equ$1293;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1293},out$1293=lx$1293@Typeset["Usage: DISP_LAY [keywords] [pattern-string] [region]\n\nDisplays values of various optica\
l-/geometric-functions at the components given by the pattern-string in the region (see region) in the current beam line. It has s\
everal display modes specified by the keywords. As the default, it displays AX, BX, NX, EX, EPX, AY, BY, NY, EY, EPY, LENG, the le\
ngth and the value of the default-keyword of the component. Each line refers to the entrance of each component of the line. The en\
d of the beam line has the name \"$$$\". The first component can be specified by \"^^^\".\n   DISP suspends the output to the term\
inal at every 66 lines, asking (q_uit, c_ontinue, a_ll)?. The further output depends on the first character of the answer from the\
 terminal input. This dialog is suppressed by specifying ALL.\n   DISP does not calculate the functions to be displayed, so CALCUL\
ATE(CALC) or GO is necessary whenever values of components are updated."[p$1293,p1$1293],Format->Help2HTML`oB$];
        System["mv -f "//out$1293//" "//equ$1293]];
      Exit[]]];
   "Usage: DISP_LAY [keywords] [pattern-string] [region]\n\nDisplays values of various optical-/geometric-functions at the compone\
nts given by the pattern-string in the region (see region) in the current beam line. It has several display modes specified by the\
 keywords. As the default, it displays AX, BX, NX, EX, EPX, AY, BY, NY, EY, EPY, LENG, the length and the value of the default-key\
word of the component. Each line refers to the entrance of each component of the line. The end of the beam line has the name \"$$$\
\". The first component can be specified by \"^^^\".\n   DISP suspends the output to the terminal at every 66 lines, asking (q_uit\
, c_ontinue, a_ll)?. The further output depends on the first character of the answer from the terminal input. This dialog is suppr\
essed by specifying ALL.\n   DISP does not calculate the functions to be displayed, so CALCULATE(CALC) or GO is necessary whenever\
 values of components are updated."[1,Max[p0$1293,0]]//"<img  class=\"eqs\" SRC=\""//equ$1293//"\" />"//
Help2HTML`oy$["Usage: DISP_LAY [keywords] [pattern-string] [region]\n\nDisplays values of various optical-/geometric-functions at \
the components given by the pattern-string in the region (see region) in the current beam line. It has several display modes speci\
fied by the keywords. As the default, it displays AX, BX, NX, EX, EPX, AY, BY, NY, EY, EPY, LENG, the length and the value of the \
default-keyword of the component. Each line refers to the entrance of each component of the line. The end of the beam line has the\
 name \"$$$\". The first component can be specified by \"^^^\".\n   DISP suspends the output to the terminal at every 66 lines, as\
king (q_uit, c_ontinue, a_ll)?. The further output depends on the first character of the answer from the terminal input. This dial\
og is suppressed by specifying ALL.\n   DISP does not calculate the functions to be displayed, so CALCULATE(CALC) or GO is necessa\
ry whenever values of components are updated."[p2$1293,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L556>TYPE(T)</A> <A HREF=#L478>optical-functions</A> <A HREF=#L468>geometric-functions</A></PRE>
<UL>
<LI>
<H3><A NAME=L57>
ACCELERATION(A)</A></H3>
<PRE>If[{},
Help2HTML`oA$["DISP A displays the nominal energy, energy deviation(DDP), longitudinal position(z), and emittances for a transport\
 line with accelerating cavities. The flag TRPT must be on."],
p$1296=1+p$1296[[1,2]];p1$1296=StringPosition["DISP A displays the nominal energy, energy deviation(DDP), longitudinal position(z)\
, and emittances for a transport line with accelerating cavities. The flag TRPT must be on."[p$1296,-1],">::",1];
   p1$1296=If[p1$1296==={},174,-2+p$1296+p1$1296[[1,1]]];
neq=Which["DISP A displays the nominal energy, energy deviation(DDP), longitudinal position(z), and emittances for a transport lin\
e with accelerating cavities. The flag TRPT must be on."[p$1296,4+p$1296]==="Text[",
    lx$1296:=Help2HTML`oa$;p$1296=5+p$1296;p1$1296-=1;p2$1296=5+p1$1296;p0$1296=-9+p$1296;
If[(pe$1296=StringPosition["DISP A displays the nominal energy, energy deviation(DDP), longitudinal position(z), and emittances fo\
r a transport line with accelerating cavities. The flag TRPT must be on."[p$1296,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["DISP A displays the nominal energy, energy deviation(DDP), longitudinal position(z), and emittances for a transpo\
rt line with accelerating cavities. The flag TRPT must be on."[p$1296+pe$1296[[1,2]],p1$1296]]],
        p1$1296=-2+p$1296+pe$1296[[1,1]]}[[
       1]],
      0],
    1,lx$1296:=Help2HTML`o9$;p2$1296=4+p1$1296;p0$1296=-4+p$1296;0];
  If[(equ$1296=
Help2HTML`o8$["DISP A displays the nominal energy, energy deviation(DDP), longitudinal position(z), and emittances for a transport\
 line with accelerating cavities. The flag TRPT must be on."[p$1296,p1$1296]])===
    Undefined,
equ$1296="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["DISP A displays the nominal energy, energy d\
eviation(DDP), longitudinal position(z), and emittances for a transport line with accelerating cavities. The flag TRPT must be on."
        [p$1296,p1$1296]]=
       equ$1296;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1296},out$1296=lx$1296@Typeset["DISP A displays the nominal energy, energy deviation(DDP), longitudinal position(z), and \
emittances for a transport line with accelerating cavities. The flag TRPT must be on."[p$1296,p1$1296],Format->Help2HTML`oB$];
        System["mv -f "//out$1296//" "//equ$1296]];
      Exit[]]];
   "DISP A displays the nominal energy, energy deviation(DDP), longitudinal position(z), and emittances for a transport line with \
accelerating cavities. The flag TRPT must be on."[1,Max[p0$1296,0]]//"<img  class=\"eqs\" SRC=\""//equ$1296//"\" />"//
   Help2HTML`oy$["DISP A displays the nominal energy, energy deviation(DDP), longitudinal position(z), and emittances for a transp\
ort line with accelerating cavities. The flag TRPT must be on."[p2$1296,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L352>TRPT</A> <A HREF=#L345>RING</A> <A HREF=#L75>elements</A> <A HREF=#L97>CAVI</A> <A HREF=#L500>special-variables</A> <A HREF=#L513>EMITX</A> <A HREF=#L515>EMITY</A> <A HREF=#L506>DP</A></PRE>
<LI>
<H3><A NAME=L58>
ALL</A></H3>
<PRE>If[{},
Help2HTML`oA$["ALL is a word to choose the entire beam line for the region to be displayed. If ALL is given, a dialog at every 66 \
lines to control the output to the terminal is suppressed. Thus \"DISP ALL e1 e2\" works to suppress the dialog for the output reg\
ion e1 from e2."],
p$1299=1+p$1299[[1,2]];p1$1299=StringPosition["ALL is a word to choose the entire beam line for the region to be displayed. If ALL\
 is given, a dialog at every 66 lines to control the output to the terminal is suppressed. Thus \"DISP ALL e1 e2\" works to suppre\
ss the dialog for the output region e1 from e2."[p$1299,-1],">::",1];
   p1$1299=If[p1$1299==={},258,-2+p$1299+p1$1299[[1,1]]];
neq=Which["ALL is a word to choose the entire beam line for the region to be displayed. If ALL is given, a dialog at every 66 line\
s to control the output to the terminal is suppressed. Thus \"DISP ALL e1 e2\" works to suppress the dialog for the output region \
e1 from e2."[p$1299,4+p$1299]==="Text[",
    lx$1299:=Help2HTML`oa$;p$1299=5+p$1299;p1$1299-=1;p2$1299=5+p1$1299;p0$1299=-9+p$1299;If[(pe$1299=
StringPosition["ALL is a word to choose the entire beam line for the region to be displayed. If ALL is given, a dialog at every 66\
 lines to control the output to the terminal is suppressed. Thus \"DISP ALL e1 e2\" works to suppress the dialog for the output re\
gion e1 from e2."[p$1299,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["ALL is a word to choose the entire beam line for the region to be displayed. If ALL is given, a dialog at every 6\
6 lines to control the output to the terminal is suppressed. Thus \"DISP ALL e1 e2\" works to suppress the dialog for the output r\
egion e1 from e2."[p$1299+pe$1299[[1,2]],p1$1299]]],
        p1$1299=-2+p$1299+pe$1299[[1,1]]}[[
       1]],
      0],
    1,lx$1299:=Help2HTML`o9$;p2$1299=4+p1$1299;p0$1299=-4+p$1299;0];
  If[(equ$1299=
Help2HTML`o8$["ALL is a word to choose the entire beam line for the region to be displayed. If ALL is given, a dialog at every 66 \
lines to control the output to the terminal is suppressed. Thus \"DISP ALL e1 e2\" works to suppress the dialog for the output reg\
ion e1 from e2."[p$1299,p1$1299]])===
    Undefined,
equ$1299="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["ALL is a word to choose the entire beam line\
 for the region to be displayed. If ALL is given, a dialog at every 66 lines to control the output to the terminal is suppressed. \
Thus \"DISP ALL e1 e2\" works to suppress the dialog for the output region e1 from e2."[p$1299,p1$1299]]=
       equ$1299;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1299},out$1299=lx$1299@Typeset["ALL is a word to choose the entire beam line for the region to be displayed. If ALL is gi\
ven, a dialog at every 66 lines to control the output to the terminal is suppressed. Thus \"DISP ALL e1 e2\" works to suppress the\
 dialog for the output region e1 from e2."[p$1299,p1$1299],Format->Help2HTML`oB$];
        System["mv -f "//out$1299//" "//equ$1299]];
      Exit[]]];
   "ALL is a word to choose the entire beam line for the region to be displayed. If ALL is given, a dialog at every 66 lines to co\
ntrol the output to the terminal is suppressed. Thus \"DISP ALL e1 e2\" works to suppress the dialog for the output region e1 from\
 e2."[1,Max[p0$1299,0]]//"<img  class=\"eqs\" SRC=\""//equ$1299//"\" />"//
Help2HTML`oy$["ALL is a word to choose the entire beam line for the region to be displayed. If ALL is given, a dialog at every 66 \
lines to control the output to the terminal is suppressed. Thus \"DISP ALL e1 e2\" works to suppress the dialog for the output reg\
ion e1 from e2."[p2$1299,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L68>region</A> <A HREF=#L66>pattern-string</A></PRE>
<LI>
<H3><A NAME=L59>
BEAM(B)</A></H3>
<PRE>If[{},
Help2HTML`oA$["DISP B displays the beam sizes and the projected Twiss parameters calculated either by Twiss parameters or the EMIT\
 command with the CODPLOT flag.\n\nExample: EMITX=...; EMITY=...;DP=...; \n         BEAMSIZE(BEAM)\n         DISP B"],
 p$1302=1+p$1302[[1,2]];
p1$1302=StringPosition["DISP B displays the beam sizes and the projected Twiss parameters calculated either by Twiss parameters or\
 the EMIT command with the CODPLOT flag.\n\nExample: EMITX=...; EMITY=...;DP=...; \n         BEAMSIZE(BEAM)\n         DISP B"[p
     $1302,-1],
    ">::",1];
   p1$1302=If[p1$1302==={},226,-2+p$1302+p1$1302[[1,1]]];
neq=Which["DISP B displays the beam sizes and the projected Twiss parameters calculated either by Twiss parameters or the EMIT com\
mand with the CODPLOT flag.\n\nExample: EMITX=...; EMITY=...;DP=...; \n         BEAMSIZE(BEAM)\n         DISP B"[p$1302,4+p$1302
      ]===
     "Text[",
lx$1302:=Help2HTML`oa$;p$1302=5+p$1302;p1$1302-=1;p2$1302=5+p1$1302;p0$1302=-9+p$1302;If[(pe$1302=StringPosition["DISP B displays \
the beam sizes and the projected Twiss parameters calculated either by Twiss parameters or the EMIT command with the CODPLOT flag.\
\n\nExample: EMITX=...; EMITY=...;DP=...; \n         BEAMSIZE(BEAM)\n         DISP B"[p$1302,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["DISP B displays the beam sizes and the projected Twiss parameters calculated either by Twiss parameters or the EM\
IT command with the CODPLOT flag.\n\nExample: EMITX=...; EMITY=...;DP=...; \n         BEAMSIZE(BEAM)\n         DISP B"[p$1302+
            pe$1302[[1,2]],
           p1$1302]]],
        p1$1302=-2+p$1302+pe$1302[[1,1]]}[[
       1]],
      0],
    1,lx$1302:=Help2HTML`o9$;p2$1302=4+p1$1302;p0$1302=-4+p$1302;0];
  If[(equ$1302=
Help2HTML`o8$["DISP B displays the beam sizes and the projected Twiss parameters calculated either by Twiss parameters or the EMIT\
 command with the CODPLOT flag.\n\nExample: EMITX=...; EMITY=...;DP=...; \n         BEAMSIZE(BEAM)\n         DISP B"[p$1302,p1$1302
       ]])===
    Undefined,
equ$1302="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["DISP B displays the beam sizes and the proje\
cted Twiss parameters calculated either by Twiss parameters or the EMIT command with the CODPLOT flag.\n\nExample: EMITX=...; EMIT\
Y=...;DP=...; \n         BEAMSIZE(BEAM)\n         DISP B"[p$1302,p1$1302]]=
       equ$1302;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1302},out$1302=lx$1302@Typeset["DISP B displays the beam sizes and the projected Twiss parameters calculated either by Tw\
iss parameters or the EMIT command with the CODPLOT flag.\n\nExample: EMITX=...; EMITY=...;DP=...; \n         BEAMSIZE(BEAM)\n    \
     DISP B"[p$1302,p1$1302],Format->Help2HTML`oB$];
        System["mv -f "//out$1302//" "//equ$1302]];
      Exit[]]];
   "DISP B displays the beam sizes and the projected Twiss parameters calculated either by Twiss parameters or the EMIT command wi\
th the CODPLOT flag.\n\nExample: EMITX=...; EMITY=...;DP=...; \n         BEAMSIZE(BEAM)\n         DISP B"[1,Max[p0$1302,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$1302//"\" />"//
Help2HTML`oy$["DISP B displays the beam sizes and the projected Twiss parameters calculated either by Twiss parameters or the EMIT\
 command with the CODPLOT flag.\n\nExample: EMITX=...; EMITY=...;DP=...; \n         BEAMSIZE(BEAM)\n         DISP B"[p2$1302,-1]]
 ]
</PRE>
<PRE>See also:
 <A HREF=#L13>BEAMSIZE(BEAM)</A> <A HREF=#L295>EMITTANCE(EMIT)</A> <A HREF=#L308>CODPLOT</A> <A HREF=#L319>GAUSS</A> <A HREF=#L354>UNIFORM</A> <A HREF=#L500>special-variables</A> <A HREF=#L513>EMITX</A> <A HREF=#L515>EMITY</A>
 <A HREF=#L530>MINCOUP</A> <A HREF=#L506>DP</A></PRE>
<LI>
<H3><A NAME=L60>
DREFERENCE(DRE)</A></H3>
<PRE>If[{},
 Help2HTML`oA$["Display the difference between the reference optics. (beta - betaR)/betaR are displayed for BX, BY, BZ."],
 p$1305=1+p$1305[[1,2]];
  p1$1305=StringPosition["Display the difference between the reference optics. (beta - betaR)/betaR are displayed for BX, BY, BZ."[
     p$1305,-1],
    ">::",1];
   p1$1305=If[p1$1305==={},103,-2+p$1305+p1$1305[[1,1]]];
  neq=Which["Display the difference between the reference optics. (beta - betaR)/betaR are displayed for BX, BY, BZ."[p$1305,
      4+p$1305]===
     "Text[",
    lx$1305:=Help2HTML`oa$;p$1305=5+p$1305;p1$1305-=1;p2$1305=5+p1$1305;p0$1305=-9+p$1305;If[(pe$1305=StringPosition[
         "Display the difference between the reference optics. (beta - betaR)/betaR are displayed for BX, BY, BZ."[p$1305,-2],";;;"
         ])<=>
       {},
      {Max[0,
        -1+ToExpression["Display the difference between the reference optics. (beta - betaR)/betaR are displayed for BX, BY, BZ."[
            p$1305+pe$1305[[1,2]],
           p1$1305]]],
        p1$1305=-2+p$1305+pe$1305[[1,1]]}[[
       1]],
      0],
    1,lx$1305:=Help2HTML`o9$;p2$1305=4+p1$1305;p0$1305=-4+p$1305;0];
  If[(equ$1305=
     Help2HTML`o8$["Display the difference between the reference optics. (beta - betaR)/betaR are displayed for BX, BY, BZ."[p$1305
       ,p1$1305]])===
    Undefined,
   equ$1305="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "Display the difference between the reference optics. (beta - betaR)/betaR are displayed for BX, BY, BZ."[p$1305,p1$1305]]=
       equ$1305;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$1305},out$1305=lx$1305@Typeset[
          "Display the difference between the reference optics. (beta - betaR)/betaR are displayed for BX, BY, BZ."[p$1305,p1$1305
           ],Format->Help2HTML`oB$];
        System["mv -f "//out$1305//" "//equ$1305]];
      Exit[]]];
   "Display the difference between the reference optics. (beta - betaR)/betaR are displayed for BX, BY, BZ."[1,Max[p0$1305,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$1305//"\" />"//
   Help2HTML`oy$["Display the difference between the reference optics. (beta - betaR)/betaR are displayed for BX, BY, BZ."[p2$1305,
     -1]]
]</PRE>
<PRE>See also:
 <A HREF=#L490>reference-optics</A> <A HREF=#L489>REFERENCE(REF)</A> <A HREF=#L56>DISPLAY(DISP)</A> <A HREF=#L69>REFERENCE(RE)</A> <A HREF=#L410>Twiss</A> <A HREF=#L423>OpticsPlot</A></PRE>
<LI>
<H3><A NAME=L61>
DUMPOPTICS(D)</A></H3>
<PRE>If[{},Help2HTML`oA$["DISP D displays all matching-functions in one line suitable to be read by a spread-sheet program."],
 p$1308=1+p$1308[[1,2]];
  p1$1308=StringPosition["DISP D displays all matching-functions in one line suitable to be read by a spread-sheet program."[p$1308
     ,-1],
    ">::",1];
   p1$1308=If[p1$1308==={},97,-2+p$1308+p1$1308[[1,1]]];
  neq=Which["DISP D displays all matching-functions in one line suitable to be read by a spread-sheet program."[p$1308,4+p$1308]===
     "Text[",
    lx$1308:=Help2HTML`oa$;p$1308=5+p$1308;p1$1308-=1;p2$1308=5+p1$1308;p0$1308=-9+p$1308;If[(pe$1308=StringPosition[
         "DISP D displays all matching-functions in one line suitable to be read by a spread-sheet program."[p$1308,-2],";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression["DISP D displays all matching-functions in one line suitable to be read by a spread-sheet program."[p$1308+
            pe$1308[[1,2]],
           p1$1308]]],
        p1$1308=-2+p$1308+pe$1308[[1,1]]}[[
       1]],
      0],
    1,lx$1308:=Help2HTML`o9$;p2$1308=4+p1$1308;p0$1308=-4+p$1308;0];
  If[(equ$1308=
     Help2HTML`o8$["DISP D displays all matching-functions in one line suitable to be read by a spread-sheet program."[p$1308,
       p1$1308]])===
    Undefined,
   equ$1308="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "DISP D displays all matching-functions in one line suitable to be read by a spread-sheet program."[p$1308,p1$1308]]=
       equ$1308;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$1308},out$1308=lx$1308@Typeset[
          "DISP D displays all matching-functions in one line suitable to be read by a spread-sheet program."[p$1308,p1$1308],
          Format->Help2HTML`oB$];
        System["mv -f "//out$1308//" "//equ$1308]];
      Exit[]]];
   "DISP D displays all matching-functions in one line suitable to be read by a spread-sheet program."[1,Max[p0$1308,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$1308//"\" />"//
   Help2HTML`oy$["DISP D displays all matching-functions in one line suitable to be read by a spread-sheet program."[p2$1308,-1]]
 ]
</PRE>
<PRE>See also:
 <A HREF=#L478>optical-functions</A> <A HREF=#L468>geometric-functions</A> <A HREF=#L473>matching-function-commands</A></PRE>
<LI>
<H3><A NAME=L62>
GAMMA(GA)</A></H3>
<PRE>If[{},
Help2HTML`oA$["DISP GA displays gamma functions for x and y, instead of dispersions, as well as gamma*L, which is nealry equal to \
the natural chromaticity."],
p$1311=1+p$1311[[1,2]];p1$1311=StringPosition["DISP GA displays gamma functions for x and y, instead of dispersions, as well as ga\
mma*L, which is nealry equal to the natural chromaticity."[p$1311,-1],">::",1];
   p1$1311=If[p1$1311==={},140,-2+p$1311+p1$1311[[1,1]]];
neq=Which["DISP GA displays gamma functions for x and y, instead of dispersions, as well as gamma*L, which is nealry equal to the \
natural chromaticity."[p$1311,4+p$1311]==="Text[",
    lx$1311:=Help2HTML`oa$;p$1311=5+p$1311;p1$1311-=1;p2$1311=5+p1$1311;p0$1311=-9+p$1311;
If[(pe$1311=StringPosition["DISP GA displays gamma functions for x and y, instead of dispersions, as well as gamma*L, which is nea\
lry equal to the natural chromaticity."[p$1311,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["DISP GA displays gamma functions for x and y, instead of dispersions, as well as gamma*L, which is nealry equal t\
o the natural chromaticity."[p$1311+pe$1311[[1,2]],p1$1311]]],
        p1$1311=-2+p$1311+pe$1311[[1,1]]}[[
       1]],
      0],
    1,lx$1311:=Help2HTML`o9$;p2$1311=4+p1$1311;p0$1311=-4+p$1311;0];
  If[(equ$1311=
Help2HTML`o8$["DISP GA displays gamma functions for x and y, instead of dispersions, as well as gamma*L, which is nealry equal to \
the natural chromaticity."[p$1311,p1$1311]])===
    Undefined,
equ$1311="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["DISP GA displays gamma functions for x and y\
, instead of dispersions, as well as gamma*L, which is nealry equal to the natural chromaticity."[p$1311,p1$1311]]=
       equ$1311;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1311},out$1311=lx$1311@Typeset["DISP GA displays gamma functions for x and y, instead of dispersions, as well as gamma*L,\
 which is nealry equal to the natural chromaticity."[p$1311,p1$1311],Format->Help2HTML`oB$];
        System["mv -f "//out$1311//" "//equ$1311]];
      Exit[]]];
   "DISP GA displays gamma functions for x and y, instead of dispersions, as well as gamma*L, which is nealry equal to the natural\
 chromaticity."[1,Max[p0$1311,0]]//"<img  class=\"eqs\" SRC=\""//equ$1311//"\" />"//
Help2HTML`oy$["DISP GA displays gamma functions for x and y, instead of dispersions, as well as gamma*L, which is nealry equal to \
the natural chromaticity."[p2$1311,-1]]
]</PRE>
<LI>
<H3><A NAME=L63>
GEOMETRY(G)</A></H3>
<PRE>If[{},Help2HTML`oA$["DISP G displays geometric information of the beam line. It shows the geometry of the coordinate."],
 p$1313=1+p$1313[[1,2]];
  p1$1313=StringPosition["DISP G displays geometric information of the beam line. It shows the geometry of the coordinate."[p$1313,
     -1],
    ">::",1];
   p1$1313=If[p1$1313==={},96,-2+p$1313+p1$1313[[1,1]]];
  neq=Which["DISP G displays geometric information of the beam line. It shows the geometry of the coordinate."[p$1313,4+p$1313]===
     "Text[",
    lx$1313:=Help2HTML`oa$;p$1313=5+p$1313;p1$1313-=1;p2$1313=5+p1$1313;p0$1313=-9+p$1313;If[(pe$1313=StringPosition[
         "DISP G displays geometric information of the beam line. It shows the geometry of the coordinate."[p$1313,-2],";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression["DISP G displays geometric information of the beam line. It shows the geometry of the coordinate."[p$1313+
            pe$1313[[1,2]],
           p1$1313]]],
        p1$1313=-2+p$1313+pe$1313[[1,1]]}[[
       1]],
      0],
    1,lx$1313:=Help2HTML`o9$;p2$1313=4+p1$1313;p0$1313=-4+p$1313;0];
  If[(equ$1313=
     Help2HTML`o8$["DISP G displays geometric information of the beam line. It shows the geometry of the coordinate."[p$1313,
       p1$1313]])===
    Undefined,
   equ$1313="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "DISP G displays geometric information of the beam line. It shows the geometry of the coordinate."[p$1313,p1$1313]]=
       equ$1313;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$1313},out$1313=lx$1313@Typeset[
          "DISP G displays geometric information of the beam line. It shows the geometry of the coordinate."[p$1313,p1$1313],
          Format->Help2HTML`oB$];
        System["mv -f "//out$1313//" "//equ$1313]];
      Exit[]]];
   "DISP G displays geometric information of the beam line. It shows the geometry of the coordinate."[1,Max[p0$1313,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$1313//"\" />"//
   Help2HTML`oy$["DISP G displays geometric information of the beam line. It shows the geometry of the coordinate."[p2$1313,-1]]
 ]
</PRE>
<PRE>See also:
 <A HREF=#L468>geometric-functions</A> <A HREF=#L473>matching-function-commands</A> <A HREF=#L64>OGEOMETRY(OG)</A></PRE>
<LI>
<H3><A NAME=L64>
OGEOMETRY(OG)</A></H3>
<PRE>If[{},Help2HTML`oA$["DISP OG displays geometric information at the orbit."],
 p$1316=1+p$1316[[1,2]];p1$1316=StringPosition["DISP OG displays geometric information at the orbit."[p$1316,-1],">::",1];
  p1$1316=If[p1$1316==={},52,-2+p$1316+p1$1316[[1,1]]];
  neq=Which["DISP OG displays geometric information at the orbit."[p$1316,4+p$1316]==="Text[",
    lx$1316:=Help2HTML`oa$;p$1316=5+p$1316;p1$1316-=1;p2$1316=5+p1$1316;p0$1316=-9+p$1316;
     If[(pe$1316=StringPosition["DISP OG displays geometric information at the orbit."[p$1316,-2],";;;"])<=>{},
      {Max[0,-1+ToExpression["DISP OG displays geometric information at the orbit."[p$1316+pe$1316[[1,2]],p1$1316]]],
       p1$1316=-2+p$1316+pe$1316[[1,1]]}[[1]],
      0],
    1,lx$1316:=Help2HTML`o9$;p2$1316=4+p1$1316;p0$1316=-4+p$1316;0];
  If[(equ$1316=Help2HTML`o8$["DISP OG displays geometric information at the orbit."[p$1316,p1$1316]])===Undefined,
   equ$1316="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["DISP OG displays geometric information at the orbit."[p$1316,p1$1316]]=equ$1316;LaTeX`ob$+=neq,
     --LaTeX`ob$;
      With[{lx$1316},out$1316=lx$1316@Typeset["DISP OG displays geometric information at the orbit."[p$1316,p1$1316],Format->
           Help2HTML`oB$];
        System["mv -f "//out$1316//" "//equ$1316]];
      Exit[]]];
   "DISP OG displays geometric information at the orbit."[1,Max[p0$1316,0]]//"<img  class=\"eqs\" SRC=\""//equ$1316//"\" />"//
   Help2HTML`oy$["DISP OG displays geometric information at the orbit."[p2$1316,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L468>geometric-functions</A> <A HREF=#L473>matching-function-commands</A> <A HREF=#L63>GEOMETRY(G)</A></PRE>
<LI>
<H3><A NAME=L65>
ORBIT(O)</A></H3>
<PRE>If[{},Help2HTML`oA$["DISP O displays the orbits DX, DPX, DY, DPY together with the other \noptical-functions."],
 p$1319=1+p$1319[[1,2]];
  p1$1319=StringPosition["DISP O displays the orbits DX, DPX, DY, DPY together with the other \noptical-functions."[p$1319,-1],
    ">::",1];
   p1$1319=If[p1$1319==={},87,-2+p$1319+p1$1319[[1,1]]];
  neq=Which["DISP O displays the orbits DX, DPX, DY, DPY together with the other \noptical-functions."[p$1319,4+p$1319]==="Text[",
    lx$1319:=Help2HTML`oa$;p$1319=5+p$1319;p1$1319-=1;p2$1319=5+p1$1319;p0$1319=-9+p$1319;
     If[(pe$1319=StringPosition["DISP O displays the orbits DX, DPX, DY, DPY together with the other \noptical-functions."[p$1319,
          -2],
         ";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression["DISP O displays the orbits DX, DPX, DY, DPY together with the other \noptical-functions."[p$1319+pe$1319[[
             1,2]],
           p1$1319]]],
        p1$1319=-2+p$1319+pe$1319[[1,1]]}[[
       1]],
      0],
    1,lx$1319:=Help2HTML`o9$;p2$1319=4+p1$1319;p0$1319=-4+p$1319;0];
  If[(equ$1319=
     Help2HTML`o8$["DISP O displays the orbits DX, DPX, DY, DPY together with the other \noptical-functions."[p$1319,p1$1319]])===
    Undefined,
   equ$1319="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "DISP O displays the orbits DX, DPX, DY, DPY together with the other \noptical-functions."[p$1319,p1$1319]]=
       equ$1319;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$1319},out$1319=lx$1319@Typeset[
          "DISP O displays the orbits DX, DPX, DY, DPY together with the other \noptical-functions."[p$1319,p1$1319],
          Format->Help2HTML`oB$];
        System["mv -f "//out$1319//" "//equ$1319]];
      Exit[]]];
   "DISP O displays the orbits DX, DPX, DY, DPY together with the other \noptical-functions."[1,Max[p0$1319,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$1319//"\" />"//
   Help2HTML`oy$["DISP O displays the orbits DX, DPX, DY, DPY together with the other \noptical-functions."[p2$1319,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L478>optical-functions</A> <A HREF=#L473>matching-function-commands</A></PRE>
<LI>
<H3><A NAME=L66>
pattern-string</A></H3>
<PRE>If[{},
Help2HTML`oA$["The components in the current region can be selectively displayed by the DISP command using the pattern-string. The\
 pattern-string is a character string involving the wildcards to match the name of the components. Note that the components are ch\
osen in the current region, and the keyword ALL is necessary to extend it to the entire beam line."],
 p$1322=1+p$1322[[1,2]];p1$1322=
StringPosition["The components in the current region can be selectively displayed by the DISP command using the pattern-string. Th\
e pattern-string is a character string involving the wildcards to match the name of the components. Note that the components are c\
hosen in the current region, and the keyword ALL is necessary to extend it to the entire beam line."[p$1322,-1],">::",1];
   p1$1322=If[p1$1322==={},343,-2+p$1322+p1$1322[[1,1]]];
neq=Which["The components in the current region can be selectively displayed by the DISP command using the pattern-string. The pat\
tern-string is a character string involving the wildcards to match the name of the components. Note that the components are chosen\
 in the current region, and the keyword ALL is necessary to extend it to the entire beam line."[p$1322,4+p$1322]==="Text[",
    lx$1322:=Help2HTML`oa$;p$1322=5+p$1322;p1$1322-=1;p2$1322=5+p1$1322;p0$1322=-9+p$1322;
If[(pe$1322=StringPosition["The components in the current region can be selectively displayed by the DISP command using the patter\
n-string. The pattern-string is a character string involving the wildcards to match the name of the components. Note that the comp\
onents are chosen in the current region, and the keyword ALL is necessary to extend it to the entire beam line."[p$1322,-2],";;;"]
        )<=>
       {},
      {Max[0,
-1+ToExpression["The components in the current region can be selectively displayed by the DISP command using the pattern-string. T\
he pattern-string is a character string involving the wildcards to match the name of the components. Note that the components are \
chosen in the current region, and the keyword ALL is necessary to extend it to the entire beam line."[p$1322+pe$1322[[1,2]],p1$1322
           ]]],
        p1$1322=-2+p$1322+pe$1322[[1,1]]}[[
       1]],
      0],
    1,lx$1322:=Help2HTML`o9$;p2$1322=4+p1$1322;p0$1322=-4+p$1322;0];
  If[(equ$1322=
Help2HTML`o8$["The components in the current region can be selectively displayed by the DISP command using the pattern-string. The\
 pattern-string is a character string involving the wildcards to match the name of the components. Note that the components are ch\
osen in the current region, and the keyword ALL is necessary to extend it to the entire beam line."[p$1322,p1$1322]])===
    Undefined,
equ$1322="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["The components in the current region can be \
selectively displayed by the DISP command using the pattern-string. The pattern-string is a character string involving the wildcar\
ds to match the name of the components. Note that the components are chosen in the current region, and the keyword ALL is necessar\
y to extend it to the entire beam line."[p$1322,p1$1322]]=
       equ$1322;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1322},out$1322=lx$1322@Typeset["The components in the current region can be selectively displayed by the DISP command usi\
ng the pattern-string. The pattern-string is a character string involving the wildcards to match the name of the components. Note \
that the components are chosen in the current region, and the keyword ALL is necessary to extend it to the entire beam line."[p
           $1322,p1$1322],Format->Help2HTML`oB$];
        System["mv -f "//out$1322//" "//equ$1322]];
      Exit[]]];
   "The components in the current region can be selectively displayed by the DISP command using the pattern-string. The pattern-st\
ring is a character string involving the wildcards to match the name of the components. Note that the components are chosen in the\
 current region, and the keyword ALL is necessary to extend it to the entire beam line."[1,Max[p0$1322,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$1322//"\" />"//
Help2HTML`oy$["The components in the current region can be selectively displayed by the DISP command using the pattern-string. The\
 pattern-string is a character string involving the wildcards to match the name of the components. Note that the components are ch\
osen in the current region, and the keyword ALL is necessary to extend it to the entire beam line."[p2$1322,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L56>DISPLAY(DISP)</A> <A HREF=#L562>wildcards</A> <A HREF=#L30>components</A> <A HREF=#L68>region</A> <A HREF=#L58>ALL</A></PRE>
<LI>
<H3><A NAME=L67>
PHYSICAL(P)</A></H3>
<PRE>If[{},Help2HTML`oA$["DISP P displays the physical dispersions PEX, PEPX, PEY, PEP, together with the 1D optical parameters."],
 p$1325=1+p$1325[[1,2]];
  p1$1325=StringPosition["DISP P displays the physical dispersions PEX, PEPX, PEY, PEP, together with the 1D optical parameters."[
     p$1325,-1],
    ">::",1];
   p1$1325=If[p1$1325==={},102,-2+p$1325+p1$1325[[1,1]]];
  neq=Which["DISP P displays the physical dispersions PEX, PEPX, PEY, PEP, together with the 1D optical parameters."[p$1325,
      4+p$1325]===
     "Text[",
    lx$1325:=Help2HTML`oa$;p$1325=5+p$1325;p1$1325-=1;p2$1325=5+p1$1325;p0$1325=-9+p$1325;If[(pe$1325=StringPosition[
         "DISP P displays the physical dispersions PEX, PEPX, PEY, PEP, together with the 1D optical parameters."[p$1325,-2],";;;"]
        )<=>
       {},
      {Max[0,
        -1+ToExpression["DISP P displays the physical dispersions PEX, PEPX, PEY, PEP, together with the 1D optical parameters."[
            p$1325+pe$1325[[1,2]],
           p1$1325]]],
        p1$1325=-2+p$1325+pe$1325[[1,1]]}[[
       1]],
      0],
    1,lx$1325:=Help2HTML`o9$;p2$1325=4+p1$1325;p0$1325=-4+p$1325;0];
  If[(equ$1325=
     Help2HTML`o8$["DISP P displays the physical dispersions PEX, PEPX, PEY, PEP, together with the 1D optical parameters."[p$1325,
       p1$1325]])===
    Undefined,
   equ$1325="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "DISP P displays the physical dispersions PEX, PEPX, PEY, PEP, together with the 1D optical parameters."[p$1325,p1$1325]]=
       equ$1325;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$1325},out$1325=lx$1325@Typeset[
          "DISP P displays the physical dispersions PEX, PEPX, PEY, PEP, together with the 1D optical parameters."[p$1325,p1$1325],
          Format->Help2HTML`oB$];
        System["mv -f "//out$1325//" "//equ$1325]];
      Exit[]]];
   "DISP P displays the physical dispersions PEX, PEPX, PEY, PEP, together with the 1D optical parameters."[1,Max[p0$1325,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$1325//"\" />"//
   Help2HTML`oy$["DISP P displays the physical dispersions PEX, PEPX, PEY, PEP, together with the 1D optical parameters."[p2$1325,
     -1]]
]</PRE>
<PRE>See also:
 <A HREF=#L478>optical-functions</A> <A HREF=#L473>matching-function-commands</A></PRE>
<LI>
<H3><A NAME=L68>
region</A></H3>
<PRE>If[{},
Help2HTML`oA$["Region for DISPLAY(DISP) is specified as \n\n        DISP .... begin [end] \n\nwith begin and end having the form n\
ame[.order][{+-}offset], or the component number (see components).\n\nExample:   DISP ... QF.2-10 QD+5\n           DISP ... 100 20\
0\n\ndisplays functions starting at 10 elements upstream from the entrance of the second QF through 5 elements downstream from the\
 entrance of the first QD. The region for DISP is kept after once set. It is shown in the second part of the prompt when FFSPRMPT \
is ON, and also seen by the STATUS(STAT) command.\n   If begin points to a component after end, DISP displays from begin to $$$, t\
hen from ^^^ to end.\n   ALL can be specified before the region. In such a case, the dialog for the output control is suppressed.\\
n   The components which match the pattern-string in DISP are only chosen in the current region."],
 p$1328=1+p$1328[[1,2]];p1$1328=StringPosition["Region for DISPLAY(DISP) is specified as \n\n        DISP .... begin [end] \n\nwit\
h begin and end having the form name[.order][{+-}offset], or the component number (see components).\n\nExample:   DISP ... QF.2-10\
 QD+5\n           DISP ... 100 200\n\ndisplays functions starting at 10 elements upstream from the entrance of the second QF throu\
gh 5 elements downstream from the entrance of the first QD. The region for DISP is kept after once set. It is shown in the second \
part of the prompt when FFSPRMPT is ON, and also seen by the STATUS(STAT) command.\n   If begin points to a component after end, D\
ISP displays from begin to $$$, then from ^^^ to end.\n   ALL can be specified before the region. In such a case, the dialog for t\
he output control is suppressed.\n   The components which match the pattern-string in DISP are only chosen in the current region."[
     p$1328,-1],
    ">::",1];
   p1$1328=If[p1$1328==={},849,-2+p$1328+p1$1328[[1,1]]];
neq=Which["Region for DISPLAY(DISP) is specified as \n\n        DISP .... begin [end] \n\nwith begin and end having the form name[\
.order][{+-}offset], or the component number (see components).\n\nExample:   DISP ... QF.2-10 QD+5\n           DISP ... 100 200\n\\
ndisplays functions starting at 10 elements upstream from the entrance of the second QF through 5 elements downstream from the ent\
rance of the first QD. The region for DISP is kept after once set. It is shown in the second part of the prompt when FFSPRMPT is O\
N, and also seen by the STATUS(STAT) command.\n   If begin points to a component after end, DISP displays from begin to $$$, then \
from ^^^ to end.\n   ALL can be specified before the region. In such a case, the dialog for the output control is suppressed.\n   \
The components which match the pattern-string in DISP are only chosen in the current region."[p$1328,4+p$1328]==="Text[",
    lx$1328:=Help2HTML`oa$;p$1328=5+p$1328;p1$1328-=1;p2$1328=5+p1$1328;p0$1328=-9+p$1328;
If[(pe$1328=StringPosition["Region for DISPLAY(DISP) is specified as \n\n        DISP .... begin [end] \n\nwith begin and end havi\
ng the form name[.order][{+-}offset], or the component number (see components).\n\nExample:   DISP ... QF.2-10 QD+5\n           DI\
SP ... 100 200\n\ndisplays functions starting at 10 elements upstream from the entrance of the second QF through 5 elements downst\
ream from the entrance of the first QD. The region for DISP is kept after once set. It is shown in the second part of the prompt w\
hen FFSPRMPT is ON, and also seen by the STATUS(STAT) command.\n   If begin points to a component after end, DISP displays from be\
gin to $$$, then from ^^^ to end.\n   ALL can be specified before the region. In such a case, the dialog for the output control is\
 suppressed.\n   The components which match the pattern-string in DISP are only chosen in the current region."[p$1328,-2],";;;"]
        )<=>
       {},
      {Max[0,
-1+ToExpression["Region for DISPLAY(DISP) is specified as \n\n        DISP .... begin [end] \n\nwith begin and end having the form\
 name[.order][{+-}offset], or the component number (see components).\n\nExample:   DISP ... QF.2-10 QD+5\n           DISP ... 100 \
200\n\ndisplays functions starting at 10 elements upstream from the entrance of the second QF through 5 elements downstream from t\
he entrance of the first QD. The region for DISP is kept after once set. It is shown in the second part of the prompt when FFSPRMP\
T is ON, and also seen by the STATUS(STAT) command.\n   If begin points to a component after end, DISP displays from begin to $$$,\
 then from ^^^ to end.\n   ALL can be specified before the region. In such a case, the dialog for the output control is suppressed\
.\n   The components which match the pattern-string in DISP are only chosen in the current region."[p$1328+pe$1328[[1,2]],p1$1328]]
        ],p1$1328=-2+p$1328+pe$1328[[1,1]]}[[
       1]],
      0],
    1,lx$1328:=Help2HTML`o9$;p2$1328=4+p1$1328;p0$1328=-4+p$1328;0];
  If[(equ$1328=
Help2HTML`o8$["Region for DISPLAY(DISP) is specified as \n\n        DISP .... begin [end] \n\nwith begin and end having the form n\
ame[.order][{+-}offset], or the component number (see components).\n\nExample:   DISP ... QF.2-10 QD+5\n           DISP ... 100 20\
0\n\ndisplays functions starting at 10 elements upstream from the entrance of the second QF through 5 elements downstream from the\
 entrance of the first QD. The region for DISP is kept after once set. It is shown in the second part of the prompt when FFSPRMPT \
is ON, and also seen by the STATUS(STAT) command.\n   If begin points to a component after end, DISP displays from begin to $$$, t\
hen from ^^^ to end.\n   ALL can be specified before the region. In such a case, the dialog for the output control is suppressed.\\
n   The components which match the pattern-string in DISP are only chosen in the current region."[p$1328,p1$1328]])===
    Undefined,
equ$1328="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Region for DISPLAY(DISP) is specified as \n\\
n        DISP .... begin [end] \n\nwith begin and end having the form name[.order][{+-}offset], or the component number (see compo\
nents).\n\nExample:   DISP ... QF.2-10 QD+5\n           DISP ... 100 200\n\ndisplays functions starting at 10 elements upstream fr\
om the entrance of the second QF through 5 elements downstream from the entrance of the first QD. The region for DISP is kept afte\
r once set. It is shown in the second part of the prompt when FFSPRMPT is ON, and also seen by the STATUS(STAT) command.\n   If be\
gin points to a component after end, DISP displays from begin to $$$, then from ^^^ to end.\n   ALL can be specified before the re\
gion. In such a case, the dialog for the output control is suppressed.\n   The components which match the pattern-string in DISP a\
re only chosen in the current region."[p$1328,p1$1328]]=
       equ$1328;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1328},out$1328=lx$1328@Typeset["Region for DISPLAY(DISP) is specified as \n\n        DISP .... begin [end] \n\nwith begin\
 and end having the form name[.order][{+-}offset], or the component number (see components).\n\nExample:   DISP ... QF.2-10 QD+5\n\
           DISP ... 100 200\n\ndisplays functions starting at 10 elements upstream from the entrance of the second QF through 5 el\
ements downstream from the entrance of the first QD. The region for DISP is kept after once set. It is shown in the second part of\
 the prompt when FFSPRMPT is ON, and also seen by the STATUS(STAT) command.\n   If begin points to a component after end, DISP dis\
plays from begin to $$$, then from ^^^ to end.\n   ALL can be specified before the region. In such a case, the dialog for the outp\
ut control is suppressed.\n   The components which match the pattern-string in DISP are only chosen in the current region."[p$1328,
           p1$1328],Format->Help2HTML`oB$];
        System["mv -f "//out$1328//" "//equ$1328]];
      Exit[]]];
   "Region for DISPLAY(DISP) is specified as \n\n        DISP .... begin [end] \n\nwith begin and end having the form name[.order]\
[{+-}offset], or the component number (see components).\n\nExample:   DISP ... QF.2-10 QD+5\n           DISP ... 100 200\n\ndispla\
ys functions starting at 10 elements upstream from the entrance of the second QF through 5 elements downstream from the entrance o\
f the first QD. The region for DISP is kept after once set. It is shown in the second part of the prompt when FFSPRMPT is ON, and \
also seen by the STATUS(STAT) command.\n   If begin points to a component after end, DISP displays from begin to $$$, then from ^^\
^ to end.\n   ALL can be specified before the region. In such a case, the dialog for the output control is suppressed.\n   The com\
ponents which match the pattern-string in DISP are only chosen in the current region."[1,Max[p0$1328,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$1328//"\" />"//
Help2HTML`oy$["Region for DISPLAY(DISP) is specified as \n\n        DISP .... begin [end] \n\nwith begin and end having the form n\
ame[.order][{+-}offset], or the component number (see components).\n\nExample:   DISP ... QF.2-10 QD+5\n           DISP ... 100 20\
0\n\ndisplays functions starting at 10 elements upstream from the entrance of the second QF through 5 elements downstream from the\
 entrance of the first QD. The region for DISP is kept after once set. It is shown in the second part of the prompt when FFSPRMPT \
is ON, and also seen by the STATUS(STAT) command.\n   If begin points to a component after end, DISP displays from begin to $$$, t\
hen from ^^^ to end.\n   ALL can be specified before the region. In such a case, the dialog for the output control is suppressed.\\
n   The components which match the pattern-string in DISP are only chosen in the current region."[p2$1328,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L58>ALL</A> <A HREF=#L66>pattern-string</A> <A HREF=#L30>components</A> <A HREF=#L552>STATUS(STAT)</A></PRE>
<LI>
<H3><A NAME=L69>
REFERENCE(RE)</A></H3>
<PRE>If[{},Help2HTML`oA$["Specify the reference optics to be displayed."],
 p$1331=1+p$1331[[1,2]];p1$1331=StringPosition["Specify the reference optics to be displayed."[p$1331,-1],">::",1];
  p1$1331=If[p1$1331==={},45,-2+p$1331+p1$1331[[1,1]]];
  neq=Which["Specify the reference optics to be displayed."[p$1331,4+p$1331]==="Text[",
    lx$1331:=Help2HTML`oa$;p$1331=5+p$1331;p1$1331-=1;p2$1331=5+p1$1331;p0$1331=-9+p$1331;
     If[(pe$1331=StringPosition["Specify the reference optics to be displayed."[p$1331,-2],";;;"])<=>{},
      {Max[0,-1+ToExpression["Specify the reference optics to be displayed."[p$1331+pe$1331[[1,2]],p1$1331]]],
       p1$1331=-2+p$1331+pe$1331[[1,1]]}[[1]],
      0],
    1,lx$1331:=Help2HTML`o9$;p2$1331=4+p1$1331;p0$1331=-4+p$1331;0];
  If[(equ$1331=Help2HTML`o8$["Specify the reference optics to be displayed."[p$1331,p1$1331]])===Undefined,
   equ$1331="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["Specify the reference optics to be displayed."[p$1331,p1$1331]]=equ$1331;LaTeX`ob$+=neq,
     --LaTeX`ob$;With[{lx$1331},
       out$1331=lx$1331@Typeset["Specify the reference optics to be displayed."[p$1331,p1$1331],Format->Help2HTML`oB$];
        System["mv -f "//out$1331//" "//equ$1331]];
      Exit[]]];
   "Specify the reference optics to be displayed."[1,Max[p0$1331,0]]//"<img  class=\"eqs\" SRC=\""//equ$1331//"\" />"//
   Help2HTML`oy$["Specify the reference optics to be displayed."[p2$1331,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L490>reference-optics</A> <A HREF=#L489>REFERENCE(REF)</A> <A HREF=#L56>DISPLAY(DISP)</A> <A HREF=#L60>DREFERENCE(DRE)</A> <A HREF=#L410>Twiss</A> <A HREF=#L423>OpticsPlot</A></PRE>
<LI>
<H3><A NAME=L70>
RMATRIX(R)</A></H3>
<PRE>If[{},
 Help2HTML`oA$[
  "DISP R displays the components of the x-y coupling matrix R together with the 1D optical parameters. See x-y-coupling."],
 p$1334=1+p$1334[[1,2]];
  p1$1334=StringPosition[
    "DISP R displays the components of the x-y coupling matrix R together with the 1D optical parameters. See x-y-coupling."[p$1334
     ,-1],
    ">::",1];
   p1$1334=If[p1$1334==={},118,-2+p$1334+p1$1334[[1,1]]];
  neq=Which[
     "DISP R displays the components of the x-y coupling matrix R together with the 1D optical parameters. See x-y-coupling."[p
      $1334,4+p$1334]===
     "Text[",
    lx$1334:=Help2HTML`oa$;p$1334=5+p$1334;p1$1334-=1;p2$1334=5+p1$1334;p0$1334=-9+p$1334;If[(pe$1334=StringPosition[
         "DISP R displays the components of the x-y coupling matrix R together with the 1D optical parameters. See x-y-coupling."[
          p$1334,-2],
         ";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression[
          "DISP R displays the components of the x-y coupling matrix R together with the 1D optical parameters. See x-y-coupling."[
            p$1334+pe$1334[[1,2]],
           p1$1334]]],
        p1$1334=-2+p$1334+pe$1334[[1,1]]}[[
       1]],
      0],
    1,lx$1334:=Help2HTML`o9$;p2$1334=4+p1$1334;p0$1334=-4+p$1334;0];
  If[(equ$1334=
     Help2HTML`o8$[
      "DISP R displays the components of the x-y coupling matrix R together with the 1D optical parameters. See x-y-coupling."[p
       $1334,p1$1334]])===
    Undefined,
   equ$1334="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "DISP R displays the components of the x-y coupling matrix R together with the 1D optical parameters. See x-y-coupling."[
         p$1334,p1$1334]]=
       equ$1334;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$1334},out$1334=lx$1334@Typeset[
          "DISP R displays the components of the x-y coupling matrix R together with the 1D optical parameters. See x-y-coupling."[
           p$1334,p1$1334],Format->Help2HTML`oB$];
        System["mv -f "//out$1334//" "//equ$1334]];
      Exit[]]];
  "DISP R displays the components of the x-y coupling matrix R together with the 1D optical parameters. See x-y-coupling."[1,
    Max[p0$1334,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$1334//"\" />"//
   Help2HTML`oy$[
    "DISP R displays the components of the x-y coupling matrix R together with the 1D optical parameters. See x-y-coupling."[p2
     $1334,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L51>x-y-coupling</A> <A HREF=#L478>optical-functions</A> <A HREF=#L473>matching-function-commands</A></PRE>
<LI>
<H3><A NAME=L71>
Z</A></H3>
<PRE>If[{},
Help2HTML`oA$["DISP Z displays muatching functions related to the Z plane: AZ BZ NZ DZ DDP ZX ZPX ZY ZPY GMZ , which are obtained \
by CAL/GO with CALC6D."],
p$1337=1+p$1337[[1,2]];p1$1337=StringPosition["DISP Z displays muatching functions related to the Z plane: AZ BZ NZ DZ DDP ZX ZPX \
ZY ZPY GMZ , which are obtained by CAL/GO with CALC6D."[p$1337,-1],">::",1];
   p1$1337=If[p1$1337==={},137,-2+p$1337+p1$1337[[1,1]]];
neq=Which["DISP Z displays muatching functions related to the Z plane: AZ BZ NZ DZ DDP ZX ZPX ZY ZPY GMZ , which are obtained by C\
AL/GO with CALC6D."[p$1337,4+p$1337]==="Text[",
    lx$1337:=Help2HTML`oa$;p$1337=5+p$1337;p1$1337-=1;p2$1337=5+p1$1337;p0$1337=-9+p$1337;
If[(pe$1337=StringPosition["DISP Z displays muatching functions related to the Z plane: AZ BZ NZ DZ DDP ZX ZPX ZY ZPY GMZ , which \
are obtained by CAL/GO with CALC6D."[p$1337,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["DISP Z displays muatching functions related to the Z plane: AZ BZ NZ DZ DDP ZX ZPX ZY ZPY GMZ , which are obtaine\
d by CAL/GO with CALC6D."[p$1337+pe$1337[[1,2]],p1$1337]]],
        p1$1337=-2+p$1337+pe$1337[[1,1]]}[[
       1]],
      0],
    1,lx$1337:=Help2HTML`o9$;p2$1337=4+p1$1337;p0$1337=-4+p$1337;0];
  If[(equ$1337=
Help2HTML`o8$["DISP Z displays muatching functions related to the Z plane: AZ BZ NZ DZ DDP ZX ZPX ZY ZPY GMZ , which are obtained \
by CAL/GO with CALC6D."[p$1337,p1$1337]])===
    Undefined,
equ$1337="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["DISP Z displays muatching functions related \
to the Z plane: AZ BZ NZ DZ DDP ZX ZPX ZY ZPY GMZ , which are obtained by CAL/GO with CALC6D."[p$1337,p1$1337]]=
       equ$1337;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1337},out$1337=lx$1337@Typeset["DISP Z displays muatching functions related to the Z plane: AZ BZ NZ DZ DDP ZX ZPX ZY ZPY\
 GMZ , which are obtained by CAL/GO with CALC6D."[p$1337,p1$1337],Format->Help2HTML`oB$];
        System["mv -f "//out$1337//" "//equ$1337]];
      Exit[]]];
   "DISP Z displays muatching functions related to the Z plane: AZ BZ NZ DZ DDP ZX ZPX ZY ZPY GMZ , which are obtained by CAL/GO w\
ith CALC6D."[1,Max[p0$1337,0]]//"<img  class=\"eqs\" SRC=\""//equ$1337//"\" />"//
Help2HTML`oy$["DISP Z displays muatching functions related to the Z plane: AZ BZ NZ DZ DDP ZX ZPX ZY ZPY GMZ , which are obtained \
by CAL/GO with CALC6D."[p2$1337,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L52>extended-Twiss-parameters</A> <A HREF=#L304>CALC6D</A> <A HREF=#L303>CALC4D</A></PRE>
</UL>
<H3><A NAME=L72>
DRAW</A></H3>
<PRE>If[{},
Help2HTML`oA$["Usage: DRAW [begin end] fun1 [fun2..] [& fun11 [fun12..]] [element-pattern]\n\ndraws a plot of optical functions in\
 multi columns. It calls OpticsPlot internally. Available functions are all matching-functions (except LENG, TRX, TRY, GX, GY, GZ,\
 CHI1, CHI2, CHI3) and additional functions. If functions are separated by ampersand (&), these are plotted in a separated window.\
\n  Function name preceded by \"R\" and \"D\" refer the reference optics and the difference, respectively.\n  If begin- and end-co\
mponents are specified, the plot region is limited between them. If the end-component comes earlier than the begin-components, it \
wraps the plot around the beam line.\n  If the optional element-pattern is given, it draws the beam-line lattice with the labels f\
or elements which match element-pattern. If LAT is specified for element-pattern, the lattice is drawn without label.\n A characte\
r string assigned to TITLE is shown as the FrameLabel on the top of the plot.\n\n Example:\n   TITLE=\"FCCee_t_202_nosol_16_ipac.s\
ad\";\n   Draw$Option={Thickness->2};\n   DRAW BX BY & EX EY Q*;\n\n<DRAW.png"],
p$1340=1+p$1340[[1,2]];p1$1340=StringPosition["Usage: DRAW [begin end] fun1 [fun2..] [& fun11 [fun12..]] [element-pattern]\n\ndraw\
s a plot of optical functions in multi columns. It calls OpticsPlot internally. Available functions are all matching-functions (ex\
cept LENG, TRX, TRY, GX, GY, GZ, CHI1, CHI2, CHI3) and additional functions. If functions are separated by ampersand (&), these ar\
e plotted in a separated window.\n  Function name preceded by \"R\" and \"D\" refer the reference optics and the difference, respe\
ctively.\n  If begin- and end-components are specified, the plot region is limited between them. If the end-component comes earlie\
r than the begin-components, it wraps the plot around the beam line.\n  If the optional element-pattern is given, it draws the bea\
m-line lattice with the labels for elements which match element-pattern. If LAT is specified for element-pattern, the lattice is d\
rawn without label.\n A character string assigned to TITLE is shown as the FrameLabel on the top of the plot.\n\n Example:\n   TIT\
LE=\"FCCee_t_202_nosol_16_ipac.sad\";\n   Draw$Option={Thickness->2};\n   DRAW BX BY & EX EY Q*;\n\n<DRAW.png"[p$1340,-1],">::",1];
  p1$1340=If[p1$1340==={},1083,-2+p$1340+p1$1340[[1,1]]];
neq=Which["Usage: DRAW [begin end] fun1 [fun2..] [& fun11 [fun12..]] [element-pattern]\n\ndraws a plot of optical functions in mul\
ti columns. It calls OpticsPlot internally. Available functions are all matching-functions (except LENG, TRX, TRY, GX, GY, GZ, CHI\
1, CHI2, CHI3) and additional functions. If functions are separated by ampersand (&), these are plotted in a separated window.\n  \
Function name preceded by \"R\" and \"D\" refer the reference optics and the difference, respectively.\n  If begin- and end-compon\
ents are specified, the plot region is limited between them. If the end-component comes earlier than the begin-components, it wrap\
s the plot around the beam line.\n  If the optional element-pattern is given, it draws the beam-line lattice with the labels for e\
lements which match element-pattern. If LAT is specified for element-pattern, the lattice is drawn without label.\n A character st\
ring assigned to TITLE is shown as the FrameLabel on the top of the plot.\n\n Example:\n   TITLE=\"FCCee_t_202_nosol_16_ipac.sad\"\
;\n   Draw$Option={Thickness->2};\n   DRAW BX BY & EX EY Q*;\n\n<DRAW.png"[p$1340,4+p$1340]==="Text[",
    lx$1340:=Help2HTML`oa$;p$1340=5+p$1340;p1$1340-=1;p2$1340=5+p1$1340;p0$1340=-9+p$1340;
If[(pe$1340=StringPosition["Usage: DRAW [begin end] fun1 [fun2..] [& fun11 [fun12..]] [element-pattern]\n\ndraws a plot of optical\
 functions in multi columns. It calls OpticsPlot internally. Available functions are all matching-functions (except LENG, TRX, TRY\
, GX, GY, GZ, CHI1, CHI2, CHI3) and additional functions. If functions are separated by ampersand (&), these are plotted in a sepa\
rated window.\n  Function name preceded by \"R\" and \"D\" refer the reference optics and the difference, respectively.\n  If begi\
n- and end-components are specified, the plot region is limited between them. If the end-component comes earlier than the begin-co\
mponents, it wraps the plot around the beam line.\n  If the optional element-pattern is given, it draws the beam-line lattice with\
 the labels for elements which match element-pattern. If LAT is specified for element-pattern, the lattice is drawn without label.\
\n A character string assigned to TITLE is shown as the FrameLabel on the top of the plot.\n\n Example:\n   TITLE=\"FCCee_t_202_no\
sol_16_ipac.sad\";\n   Draw$Option={Thickness->2};\n   DRAW BX BY & EX EY Q*;\n\n<DRAW.png"[p$1340,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Usage: DRAW [begin end] fun1 [fun2..] [& fun11 [fun12..]] [element-pattern]\n\ndraws a plot of optical functions \
in multi columns. It calls OpticsPlot internally. Available functions are all matching-functions (except LENG, TRX, TRY, GX, GY, G\
Z, CHI1, CHI2, CHI3) and additional functions. If functions are separated by ampersand (&), these are plotted in a separated windo\
w.\n  Function name preceded by \"R\" and \"D\" refer the reference optics and the difference, respectively.\n  If begin- and end-\
components are specified, the plot region is limited between them. If the end-component comes earlier than the begin-components, i\
t wraps the plot around the beam line.\n  If the optional element-pattern is given, it draws the beam-line lattice with the labels\
 for elements which match element-pattern. If LAT is specified for element-pattern, the lattice is drawn without label.\n A charac\
ter string assigned to TITLE is shown as the FrameLabel on the top of the plot.\n\n Example:\n   TITLE=\"FCCee_t_202_nosol_16_ipac\
.sad\";\n   Draw$Option={Thickness->2};\n   DRAW BX BY & EX EY Q*;\n\n<DRAW.png"[p$1340+pe$1340[[1,2]],p1$1340]]],
        p1$1340=-2+p$1340+pe$1340[[1,1]]}[[
       1]],
      0],
    1,lx$1340:=Help2HTML`o9$;p2$1340=4+p1$1340;p0$1340=-4+p$1340;0];
  If[(equ$1340=
Help2HTML`o8$["Usage: DRAW [begin end] fun1 [fun2..] [& fun11 [fun12..]] [element-pattern]\n\ndraws a plot of optical functions in\
 multi columns. It calls OpticsPlot internally. Available functions are all matching-functions (except LENG, TRX, TRY, GX, GY, GZ,\
 CHI1, CHI2, CHI3) and additional functions. If functions are separated by ampersand (&), these are plotted in a separated window.\
\n  Function name preceded by \"R\" and \"D\" refer the reference optics and the difference, respectively.\n  If begin- and end-co\
mponents are specified, the plot region is limited between them. If the end-component comes earlier than the begin-components, it \
wraps the plot around the beam line.\n  If the optional element-pattern is given, it draws the beam-line lattice with the labels f\
or elements which match element-pattern. If LAT is specified for element-pattern, the lattice is drawn without label.\n A characte\
r string assigned to TITLE is shown as the FrameLabel on the top of the plot.\n\n Example:\n   TITLE=\"FCCee_t_202_nosol_16_ipac.s\
ad\";\n   Draw$Option={Thickness->2};\n   DRAW BX BY & EX EY Q*;\n\n<DRAW.png"[p$1340,p1$1340]])===
    Undefined,
equ$1340="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Usage: DRAW [begin end] fun1 [fun2..] [& fun\
11 [fun12..]] [element-pattern]\n\ndraws a plot of optical functions in multi columns. It calls OpticsPlot internally. Available f\
unctions are all matching-functions (except LENG, TRX, TRY, GX, GY, GZ, CHI1, CHI2, CHI3) and additional functions. If functions a\
re separated by ampersand (&), these are plotted in a separated window.\n  Function name preceded by \"R\" and \"D\" refer the ref\
erence optics and the difference, respectively.\n  If begin- and end-components are specified, the plot region is limited between \
them. If the end-component comes earlier than the begin-components, it wraps the plot around the beam line.\n  If the optional ele\
ment-pattern is given, it draws the beam-line lattice with the labels for elements which match element-pattern. If LAT is specifie\
d for element-pattern, the lattice is drawn without label.\n A character string assigned to TITLE is shown as the FrameLabel on th\
e top of the plot.\n\n Example:\n   TITLE=\"FCCee_t_202_nosol_16_ipac.sad\";\n   Draw$Option={Thickness->2};\n   DRAW BX BY & EX E\
Y Q*;\n\n<DRAW.png"[p$1340,p1$1340]]=
       equ$1340;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1340},out$1340=lx$1340@Typeset["Usage: DRAW [begin end] fun1 [fun2..] [& fun11 [fun12..]] [element-pattern]\n\ndraws a pl\
ot of optical functions in multi columns. It calls OpticsPlot internally. Available functions are all matching-functions (except L\
ENG, TRX, TRY, GX, GY, GZ, CHI1, CHI2, CHI3) and additional functions. If functions are separated by ampersand (&), these are plot\
ted in a separated window.\n  Function name preceded by \"R\" and \"D\" refer the reference optics and the difference, respectivel\
y.\n  If begin- and end-components are specified, the plot region is limited between them. If the end-component comes earlier than\
 the begin-components, it wraps the plot around the beam line.\n  If the optional element-pattern is given, it draws the beam-line\
 lattice with the labels for elements which match element-pattern. If LAT is specified for element-pattern, the lattice is drawn w\
ithout label.\n A character string assigned to TITLE is shown as the FrameLabel on the top of the plot.\n\n Example:\n   TITLE=\"F\
CCee_t_202_nosol_16_ipac.sad\";\n   Draw$Option={Thickness->2};\n   DRAW BX BY & EX EY Q*;\n\n<DRAW.png"[p$1340,p1$1340],
          Format->Help2HTML`oB$];
        System["mv -f "//out$1340//" "//equ$1340]];
      Exit[]]];
   "Usage: DRAW [begin end] fun1 [fun2..] [& fun11 [fun12..]] [element-pattern]\n\ndraws a plot of optical functions in multi colu\
mns. It calls OpticsPlot internally. Available functions are all matching-functions (except LENG, TRX, TRY, GX, GY, GZ, CHI1, CHI2\
, CHI3) and additional functions. If functions are separated by ampersand (&), these are plotted in a separated window.\n  Functio\
n name preceded by \"R\" and \"D\" refer the reference optics and the difference, respectively.\n  If begin- and end-components ar\
e specified, the plot region is limited between them. If the end-component comes earlier than the begin-components, it wraps the p\
lot around the beam line.\n  If the optional element-pattern is given, it draws the beam-line lattice with the labels for elements\
 which match element-pattern. If LAT is specified for element-pattern, the lattice is drawn without label.\n A character string as\
signed to TITLE is shown as the FrameLabel on the top of the plot.\n\n Example:\n   TITLE=\"FCCee_t_202_nosol_16_ipac.sad\";\n   D\
raw$Option={Thickness->2};\n   DRAW BX BY & EX EY Q*;\n\n<DRAW.png"[1,Max[p0$1340,0]]//"<img  class=\"eqs\" SRC=\""//equ$1340//
   "\" />"//
Help2HTML`oy$["Usage: DRAW [begin end] fun1 [fun2..] [& fun11 [fun12..]] [element-pattern]\n\ndraws a plot of optical functions in\
 multi columns. It calls OpticsPlot internally. Available functions are all matching-functions (except LENG, TRX, TRY, GX, GY, GZ,\
 CHI1, CHI2, CHI3) and additional functions. If functions are separated by ampersand (&), these are plotted in a separated window.\
\n  Function name preceded by \"R\" and \"D\" refer the reference optics and the difference, respectively.\n  If begin- and end-co\
mponents are specified, the plot region is limited between them. If the end-component comes earlier than the begin-components, it \
wraps the plot around the beam line.\n  If the optional element-pattern is given, it draws the beam-line lattice with the labels f\
or elements which match element-pattern. If LAT is specified for element-pattern, the lattice is drawn without label.\n A characte\
r string assigned to TITLE is shown as the FrameLabel on the top of the plot.\n\n Example:\n   TITLE=\"FCCee_t_202_nosol_16_ipac.s\
ad\";\n   Draw$Option={Thickness->2};\n   DRAW BX BY & EX EY Q*;\n\n<DRAW.png"[p2$1340,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L423>OpticsPlot</A> <A HREF=#L500>special-variables</A> <A HREF=#L547>TITLE</A> <A HREF=#L473>matching-function-commands</A> <A HREF=#L480>OUTPUT(OUT)</A> <A HREF=#L555>TERMINATE(TERM)</A>
 <A HREF=#L245>GEO</A> <A HREF=#L56>DISPLAY(DISP)</A> <A HREF=#L562>wildcards</A></PRE>
<UL>
<LI>
<H3><A NAME=L73>
Draw$Option</A></H3>
<PRE>If[{},
Help2HTML`oA$[" Draw$Option is a list of rules to specify Graphics options for the entire DRAW. If you need option for each column\
, use OpticsPlot"],
p$1343=1+p$1343[[1,2]];p1$1343=StringPosition[" Draw$Option is a list of rules to specify Graphics options for the entire DRAW. If\
 you need option for each column, use OpticsPlot"[p$1343,-1],">::",1];
   p1$1343=If[p1$1343==={},131,-2+p$1343+p1$1343[[1,1]]];
neq=Which[" Draw$Option is a list of rules to specify Graphics options for the entire DRAW. If you need option for each column, us\
e OpticsPlot"[p$1343,4+p$1343]==="Text[",
    lx$1343:=Help2HTML`oa$;p$1343=5+p$1343;p1$1343-=1;p2$1343=5+p1$1343;p0$1343=-9+p$1343;If[(pe$1343=
StringPosition[" Draw$Option is a list of rules to specify Graphics options for the entire DRAW. If you need option for each colum\
n, use OpticsPlot"[p$1343,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression[" Draw$Option is a list of rules to specify Graphics options for the entire DRAW. If you need option for each colu\
mn, use OpticsPlot"[p$1343+pe$1343[[1,2]],p1$1343]]],
        p1$1343=-2+p$1343+pe$1343[[1,1]]}[[
       1]],
      0],
    1,lx$1343:=Help2HTML`o9$;p2$1343=4+p1$1343;p0$1343=-4+p$1343;0];
  If[(equ$1343=
Help2HTML`o8$[" Draw$Option is a list of rules to specify Graphics options for the entire DRAW. If you need option for each column\
, use OpticsPlot"[p$1343,p1$1343]])===
    Undefined,
equ$1343="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[" Draw$Option is a list of rules to specify G\
raphics options for the entire DRAW. If you need option for each column, use OpticsPlot"[p$1343,p1$1343]]=
       equ$1343;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1343},out$1343=lx$1343@Typeset[" Draw$Option is a list of rules to specify Graphics options for the entire DRAW. If you n\
eed option for each column, use OpticsPlot"[p$1343,p1$1343],Format->Help2HTML`oB$];
        System["mv -f "//out$1343//" "//equ$1343]];
      Exit[]]];
   " Draw$Option is a list of rules to specify Graphics options for the entire DRAW. If you need option for each column, use Optic\
sPlot"[1,Max[p0$1343,0]]//"<img  class=\"eqs\" SRC=\""//equ$1343//"\" />"//
Help2HTML`oy$[" Draw$Option is a list of rules to specify Graphics options for the entire DRAW. If you need option for each column\
, use OpticsPlot"[p2$1343,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L72>DRAW</A> <A HREF=#L423>OpticsPlot</A> <A HREF=#L414>Graphics</A> <A HREF=#L489>REFERENCE(REF)</A></PRE>
</UL>
<H3><A NAME=L74>
DUMP</A></H3>
<PRE>If[{},
Help2HTML`oA$["Usage: DUMP component-pattern [component-pattern1..]\n\nprints out the current machine errors of components which m\
atch component-pattern."],
p$1346=1+p$1346[[1,2]];p1$1346=StringPosition["Usage: DUMP component-pattern [component-pattern1..]\n\nprints out the current mach\
ine errors of components which match component-pattern."[p$1346,-1],">::",1];
   p1$1346=If[p1$1346==={},136,-2+p$1346+p1$1346[[1,1]]];
neq=Which["Usage: DUMP component-pattern [component-pattern1..]\n\nprints out the current machine errors of components which match\
 component-pattern."[p$1346,4+p$1346]==="Text[",
    lx$1346:=Help2HTML`oa$;p$1346=5+p$1346;p1$1346-=1;p2$1346=5+p1$1346;p0$1346=-9+p$1346;
If[(pe$1346=StringPosition["Usage: DUMP component-pattern [component-pattern1..]\n\nprints out the current machine errors of compo\
nents which match component-pattern."[p$1346,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Usage: DUMP component-pattern [component-pattern1..]\n\nprints out the current machine errors of components which\
 match component-pattern."[p$1346+pe$1346[[1,2]],p1$1346]]],
        p1$1346=-2+p$1346+pe$1346[[1,1]]}[[
       1]],
      0],
    1,lx$1346:=Help2HTML`o9$;p2$1346=4+p1$1346;p0$1346=-4+p$1346;0];
  If[(equ$1346=
Help2HTML`o8$["Usage: DUMP component-pattern [component-pattern1..]\n\nprints out the current machine errors of components which m\
atch component-pattern."[p$1346,p1$1346]])===
    Undefined,
equ$1346="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Usage: DUMP component-pattern [component-pat\
tern1..]\n\nprints out the current machine errors of components which match component-pattern."[p$1346,p1$1346]]=
       equ$1346;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1346},out$1346=lx$1346@Typeset["Usage: DUMP component-pattern [component-pattern1..]\n\nprints out the current machine er\
rors of components which match component-pattern."[p$1346,p1$1346],Format->Help2HTML`oB$];
        System["mv -f "//out$1346//" "//equ$1346]];
      Exit[]]];
   "Usage: DUMP component-pattern [component-pattern1..]\n\nprints out the current machine errors of components which match compon\
ent-pattern."[1,Max[p0$1346,0]]//"<img  class=\"eqs\" SRC=\""//equ$1346//"\" />"//
Help2HTML`oy$["Usage: DUMP component-pattern [component-pattern1..]\n\nprints out the current machine errors of components which m\
atch component-pattern."[p2$1346,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L472>machine-error-commands</A> <A HREF=#L30>components</A> <A HREF=#L562>wildcards</A></PRE>
<H3><A NAME=L75>
elements</A></H3>
<PRE>If[{},
Help2HTML`oA$["An element in FFS represents an object which has a unique name and several keywords with values. This simulates a p\
ower supply of a magnet. An element has one or more components, which correspond to individual magnets in a beam line. Each compon\
ent may have different values from the values of the corresponding element. This simulates the machine error which varies magnet t\
o magnet\n   The value of an element can be saved to or recovered from the element-save-buffer by SAVE or RESET commands. Differen\
t beam lines can share the same element, and their values can be different to each other, but they have the common element-save-bu\
ffer. Therefore the value of an element can be transferred between beam lines by SAVE and RESET command through the element-save-b\
uffer.\n   An element is created only in SAD MAIN level. In the definition, if a keyword is omitted, the previous definition is un\
changed. All keywords have the default value zero. In FFS, it is only possible to change their values."],
 p$1349=1+p$1349[[1,2]];p1$1349=
StringPosition["An element in FFS represents an object which has a unique name and several keywords with values. This simulates a \
power supply of a magnet. An element has one or more components, which correspond to individual magnets in a beam line. Each compo\
nent may have different values from the values of the corresponding element. This simulates the machine error which varies magnet \
to magnet\n   The value of an element can be saved to or recovered from the element-save-buffer by SAVE or RESET commands. Differe\
nt beam lines can share the same element, and their values can be different to each other, but they have the common element-save-b\
uffer. Therefore the value of an element can be transferred between beam lines by SAVE and RESET command through the element-save-\
buffer.\n   An element is created only in SAD MAIN level. In the definition, if a keyword is omitted, the previous definition is u\
nchanged. All keywords have the default value zero. In FFS, it is only possible to change their values."[p$1349,-1],">::",1];
   p1$1349=If[p1$1349==={},995,-2+p$1349+p1$1349[[1,1]]];
neq=Which["An element in FFS represents an object which has a unique name and several keywords with values. This simulates a power\
 supply of a magnet. An element has one or more components, which correspond to individual magnets in a beam line. Each component \
may have different values from the values of the corresponding element. This simulates the machine error which varies magnet to ma\
gnet\n   The value of an element can be saved to or recovered from the element-save-buffer by SAVE or RESET commands. Different be\
am lines can share the same element, and their values can be different to each other, but they have the common element-save-buffer\
. Therefore the value of an element can be transferred between beam lines by SAVE and RESET command through the element-save-buffe\
r.\n   An element is created only in SAD MAIN level. In the definition, if a keyword is omitted, the previous definition is unchan\
ged. All keywords have the default value zero. In FFS, it is only possible to change their values."[p$1349,4+p$1349]==="Text[",
    lx$1349:=Help2HTML`oa$;p$1349=5+p$1349;p1$1349-=1;p2$1349=5+p1$1349;p0$1349=-9+p$1349;
If[(pe$1349=StringPosition["An element in FFS represents an object which has a unique name and several keywords with values. This \
simulates a power supply of a magnet. An element has one or more components, which correspond to individual magnets in a beam line\
. Each component may have different values from the values of the corresponding element. This simulates the machine error which va\
ries magnet to magnet\n   The value of an element can be saved to or recovered from the element-save-buffer by SAVE or RESET comma\
nds. Different beam lines can share the same element, and their values can be different to each other, but they have the common el\
ement-save-buffer. Therefore the value of an element can be transferred between beam lines by SAVE and RESET command through the e\
lement-save-buffer.\n   An element is created only in SAD MAIN level. In the definition, if a keyword is omitted, the previous def\
inition is unchanged. All keywords have the default value zero. In FFS, it is only possible to change their values."[p$1349,-2],
         ";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["An element in FFS represents an object which has a unique name and several keywords with values. This simulates a\
 power supply of a magnet. An element has one or more components, which correspond to individual magnets in a beam line. Each comp\
onent may have different values from the values of the corresponding element. This simulates the machine error which varies magnet\
 to magnet\n   The value of an element can be saved to or recovered from the element-save-buffer by SAVE or RESET commands. Differ\
ent beam lines can share the same element, and their values can be different to each other, but they have the common element-save-\
buffer. Therefore the value of an element can be transferred between beam lines by SAVE and RESET command through the element-save\
-buffer.\n   An element is created only in SAD MAIN level. In the definition, if a keyword is omitted, the previous definition is \
unchanged. All keywords have the default value zero. In FFS, it is only possible to change their values."[p$1349+pe$1349[[1,2]],
           p1$1349]]],
        p1$1349=-2+p$1349+pe$1349[[1,1]]}[[
       1]],
      0],
    1,lx$1349:=Help2HTML`o9$;p2$1349=4+p1$1349;p0$1349=-4+p$1349;0];
  If[(equ$1349=
Help2HTML`o8$["An element in FFS represents an object which has a unique name and several keywords with values. This simulates a p\
ower supply of a magnet. An element has one or more components, which correspond to individual magnets in a beam line. Each compon\
ent may have different values from the values of the corresponding element. This simulates the machine error which varies magnet t\
o magnet\n   The value of an element can be saved to or recovered from the element-save-buffer by SAVE or RESET commands. Differen\
t beam lines can share the same element, and their values can be different to each other, but they have the common element-save-bu\
ffer. Therefore the value of an element can be transferred between beam lines by SAVE and RESET command through the element-save-b\
uffer.\n   An element is created only in SAD MAIN level. In the definition, if a keyword is omitted, the previous definition is un\
changed. All keywords have the default value zero. In FFS, it is only possible to change their values."[p$1349,p1$1349]])===
    Undefined,
equ$1349="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["An element in FFS represents an object which\
 has a unique name and several keywords with values. This simulates a power supply of a magnet. An element has one or more compone\
nts, which correspond to individual magnets in a beam line. Each component may have different values from the values of the corres\
ponding element. This simulates the machine error which varies magnet to magnet\n   The value of an element can be saved to or rec\
overed from the element-save-buffer by SAVE or RESET commands. Different beam lines can share the same element, and their values c\
an be different to each other, but they have the common element-save-buffer. Therefore the value of an element can be transferred \
between beam lines by SAVE and RESET command through the element-save-buffer.\n   An element is created only in SAD MAIN level. In\
 the definition, if a keyword is omitted, the previous definition is unchanged. All keywords have the default value zero. In FFS, \
it is only possible to change their values."[p$1349,p1$1349]]=
       equ$1349;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1349},out$1349=lx$1349@Typeset["An element in FFS represents an object which has a unique name and several keywords with \
values. This simulates a power supply of a magnet. An element has one or more components, which correspond to individual magnets i\
n a beam line. Each component may have different values from the values of the corresponding element. This simulates the machine e\
rror which varies magnet to magnet\n   The value of an element can be saved to or recovered from the element-save-buffer by SAVE o\
r RESET commands. Different beam lines can share the same element, and their values can be different to each other, but they have \
the common element-save-buffer. Therefore the value of an element can be transferred between beam lines by SAVE and RESET command \
through the element-save-buffer.\n   An element is created only in SAD MAIN level. In the definition, if a keyword is omitted, the\
 previous definition is unchanged. All keywords have the default value zero. In FFS, it is only possible to change their values."[
           p$1349,p1$1349],Format->Help2HTML`oB$];
        System["mv -f "//out$1349//" "//equ$1349]];
      Exit[]]];
   "An element in FFS represents an object which has a unique name and several keywords with values. This simulates a power supply\
 of a magnet. An element has one or more components, which correspond to individual magnets in a beam line. Each component may hav\
e different values from the values of the corresponding element. This simulates the machine error which varies magnet to magnet\n \
  The value of an element can be saved to or recovered from the element-save-buffer by SAVE or RESET commands. Different beam line\
s can share the same element, and their values can be different to each other, but they have the common element-save-buffer. There\
fore the value of an element can be transferred between beam lines by SAVE and RESET command through the element-save-buffer.\n   \
An element is created only in SAD MAIN level. In the definition, if a keyword is omitted, the previous definition is unchanged. Al\
l keywords have the default value zero. In FFS, it is only possible to change their values."[1,Max[p0$1349,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$1349//"\" />"//
Help2HTML`oy$["An element in FFS represents an object which has a unique name and several keywords with values. This simulates a p\
ower supply of a magnet. An element has one or more components, which correspond to individual magnets in a beam line. Each compon\
ent may have different values from the values of the corresponding element. This simulates the machine error which varies magnet t\
o magnet\n   The value of an element can be saved to or recovered from the element-save-buffer by SAVE or RESET commands. Differen\
t beam lines can share the same element, and their values can be different to each other, but they have the common element-save-bu\
ffer. Therefore the value of an element can be transferred between beam lines by SAVE and RESET command through the element-save-b\
uffer.\n   An element is created only in SAD MAIN level. In the definition, if a keyword is omitted, the previous definition is un\
changed. All keywords have the default value zero. In FFS, it is only possible to change their values."[p2$1349,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L556>TYPE(T)</A> <A HREF=#L497>set-value-of-element</A> <A HREF=#L387>Element</A></PRE>
<UL>
<LI>
<H3><A NAME=L76>
APERT</A></H3>
<PRE>An aperture. Only valid in tracking. A particle with

<img  class="eqs" SRC="SADHelp_img/equ_87.svg" />If[{},Help2HTML`oA$["\n\ncan pass through the aperture, otherwise it is lost and a
 message is printed out. If AX or AY is zero (default), they are interpreted as infinity. If AX <=> 0 && AY <=> 0 and (DX1 == DX2 o
r DY1 == DY2) then the aperture is only determined by AX and AY."],p$1353=1+p$1353[[1,2]];p1$1353=StringPosition["\n\ncan pass thro
ugh the aperture, otherwise it is lost and a message is printed out. If AX or AY is zero (default), they are interpreted as infinit
y. If AX <=> 0 && AY <=> 0 and (DX1 == DX2 or DY1 == DY2) then the aperture is only determined by AX and AY."[p$1353,-1],">::",1];p
1$1353=If[p1$1353==={},254,-2+p$1353+p1$1353[[1,1]]];neq=Which["\n\ncan pass through the aperture, otherwise it is lost and a messa
ge is printed out. If AX or AY is zero (default), they are interpreted as infinity. If AX <=> 0 && AY <=> 0 and (DX1 == DX2 or DY1 
== DY2) then the aperture is only determined by AX and AY."[p$1353,4+p$1353]==="Text[",lx$1353:=Help2HTML`oa$;p$1353=5+p$1353;p1$13
53-=1;p2$1353=5+p1$1353;p0$1353=-9+p$1353;If[(pe$1353=StringPosition["\n\ncan pass through the aperture, otherwise it is lost and a
 message is printed out. If AX or AY is zero (default), they are interpreted as infinity. If AX <=> 0 && AY <=> 0 and (DX1 == DX2 o
r DY1 == DY2) then the aperture is only determined by AX and AY."[p$1353,-2],";;;"])<=>{},{Max[0,-1+ToExpression["\n\ncan pass thro
ugh the aperture, otherwise it is lost and a message is printed out. If AX or AY is zero (default), they are interpreted as infinit
y. If AX <=> 0 && AY <=> 0 and (DX1 == DX2 or DY1 == DY2) then the aperture is only determined by AX and AY."[p$1353+pe$1353[[1,2]]
,p1$1353]]],p1$1353=-2+p$1353+pe$1353[[1,1]]}[[1]],0],1,lx$1353:=Help2HTML`o9$;p2$1353=4+p1$1353;p0$1353=-4+p$1353;0];If[(equ$1353=
Help2HTML`o8$["\n\ncan pass through the aperture, otherwise it is lost and a message is printed out. If AX or AY is zero (default),
 they are interpreted as infinity. If AX <=> 0 && AY <=> 0 and (DX1 == DX2 or DY1 == DY2) then the aperture is only determined by A
X and AY."[p$1353,p1$1353]])===Undefined,equ$1353="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["\n\n
can pass through the aperture, otherwise it is lost and a message is printed out. If AX or AY is zero (default), they are interpret
ed as infinity. If AX <=> 0 && AY <=> 0 and (DX1 == DX2 or DY1 == DY2) then the aperture is only determined by AX and AY."[p$1353,p
1$1353]]=equ$1353;LaTeX`ob$+=neq,--LaTeX`ob$;With[{lx$1353},out$1353=lx$1353@Typeset["\n\ncan pass through the aperture, otherwise 
it is lost and a message is printed out. If AX or AY is zero (default), they are interpreted as infinity. If AX <=> 0 && AY <=> 0 a
nd (DX1 == DX2 or DY1 == DY2) then the aperture is only determined by AX and AY."[p$1353,p1$1353],Format->Help2HTML`oB$];System["mv
 -f "//out$1353//" "//equ$1353]];Exit[]]];"\n\ncan pass through the aperture, otherwise it is lost and a message is printed out. If
 AX or AY is zero (default), they are interpreted as infinity. If AX <=> 0 && AY <=> 0 and (DX1 == DX2 or DY1 == DY2) then the aper
ture is only determined by AX and AY."[1,Max[p0$1353,0]]//"<img  class=\"eqs\" SRC=\""//equ$1353//"\" />"//Help2HTML`oy$["\n\ncan p
ass through the aperture, otherwise it is lost and a message is printed out. If AX or AY is zero (default), they are interpreted as
 infinity. If AX <=> 0 && AY <=> 0 and (DX1 == DX2 or DY1 == DY2) then the aperture is only determined by AX and AY."[p2$1353,-1]]]

</PRE>
<LI>
<H3><A NAME=L77>
BEND</A></H3>
<PRE>If[{},Help2HTML`oA$["A bending magnet."],
 p$1355=1+p$1355[[1,2]];p1$1355=StringPosition["A bending magnet."[p$1355,-1],">::",1];
  p1$1355=If[p1$1355==={},17,-2+p$1355+p1$1355[[1,1]]];
  neq=Which["A bending magnet."[p$1355,4+p$1355]==="Text[",lx$1355:=Help2HTML`oa$;p$1355=5+p$1355;p1$1355-=1;p2$1355=5+p1$1355;
     p0$1355=-9+p$1355;
     If[(pe$1355=StringPosition["A bending magnet."[p$1355,-2],";;;"])<=>{},{Max[0,-1+ToExpression["A bending magnet."[p$1355+
            pe$1355[[1,2]],
           p1$1355]]],
        p1$1355=-2+p$1355+pe$1355[[1,1]]}[[
       1]],
      0],
    1,lx$1355:=Help2HTML`o9$;p2$1355=4+p1$1355;p0$1355=-4+p$1355;0];
  If[(equ$1355=Help2HTML`o8$["A bending magnet."[p$1355,p1$1355]])===Undefined,
   equ$1355="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["A bending magnet."[p$1355,p1$1355]]=equ$1355;LaTeX`ob$+=neq,
     --LaTeX`ob$;With[{lx$1355},out$1355=lx$1355@Typeset["A bending magnet."[p$1355,p1$1355],Format->Help2HTML`oB$];
        System["mv -f "//out$1355//" "//equ$1355]];
      Exit[]]];
   "A bending magnet."[1,Max[p0$1355,0]]//"<img  class=\"eqs\" SRC=\""//equ$1355//"\" />"//
   Help2HTML`oy$["A bending magnet."[p2$1355,-1]]
]</PRE>
<UL>
<LI>
<H3><A NAME=L78>
AE1</A></H3>
<PRE>If[{},
Help2HTML`oA$["The absolute face angle at the entrance. The effective face angle is E1 * ANGLE + AE1, and a positive angle at the \
entrance corresponds to a surface with dx/ds > 0."],
p$1357=1+p$1357[[1,2]];p1$1357=StringPosition["The absolute face angle at the entrance. The effective face angle is E1 * ANGLE + A\
E1, and a positive angle at the entrance corresponds to a surface with dx/ds > 0."[p$1357,-1],">::",1];
   p1$1357=If[p1$1357==={},164,-2+p$1357+p1$1357[[1,1]]];
neq=Which["The absolute face angle at the entrance. The effective face angle is E1 * ANGLE + AE1, and a positive angle at the entr\
ance corresponds to a surface with dx/ds > 0."[p$1357,4+p$1357]==="Text[",
    lx$1357:=Help2HTML`oa$;p$1357=5+p$1357;p1$1357-=1;p2$1357=5+p1$1357;p0$1357=-9+p$1357;
If[(pe$1357=StringPosition["The absolute face angle at the entrance. The effective face angle is E1 * ANGLE + AE1, and a positive \
angle at the entrance corresponds to a surface with dx/ds > 0."[p$1357,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["The absolute face angle at the entrance. The effective face angle is E1 * ANGLE + AE1, and a positive angle at th\
e entrance corresponds to a surface with dx/ds > 0."[p$1357+pe$1357[[1,2]],p1$1357]]],
        p1$1357=-2+p$1357+pe$1357[[1,1]]}[[
       1]],
      0],
    1,lx$1357:=Help2HTML`o9$;p2$1357=4+p1$1357;p0$1357=-4+p$1357;0];
  If[(equ$1357=
Help2HTML`o8$["The absolute face angle at the entrance. The effective face angle is E1 * ANGLE + AE1, and a positive angle at the \
entrance corresponds to a surface with dx/ds > 0."[p$1357,p1$1357]])===
    Undefined,
equ$1357="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["The absolute face angle at the entrance. The\
 effective face angle is E1 * ANGLE + AE1, and a positive angle at the entrance corresponds to a surface with dx/ds > 0."[p$1357,
         p1$1357]]=
       equ$1357;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1357},out$1357=lx$1357@Typeset["The absolute face angle at the entrance. The effective face angle is E1 * ANGLE + AE1, an\
d a positive angle at the entrance corresponds to a surface with dx/ds > 0."[p$1357,p1$1357],Format->Help2HTML`oB$];
        System["mv -f "//out$1357//" "//equ$1357]];
      Exit[]]];
   "The absolute face angle at the entrance. The effective face angle is E1 * ANGLE + AE1, and a positive angle at the entrance co\
rresponds to a surface with dx/ds > 0."[1,Max[p0$1357,0]]//"<img  class=\"eqs\" SRC=\""//equ$1357//"\" />"//
Help2HTML`oy$["The absolute face angle at the entrance. The effective face angle is E1 * ANGLE + AE1, and a positive angle at the \
entrance corresponds to a surface with dx/ds > 0."[p2$1357,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L86>E1</A> <A HREF=#L79>AE2</A> <A HREF=#L80>ANGLE</A></PRE>
<LI>
<H3><A NAME=L79>
AE2</A></H3>
<PRE>If[{},
Help2HTML`oA$["The absolute face-angle at the exit to the bending angle. The effective face angle is E2 * ANGLE + AE2, and a posit\
ive angle at the exit corresponds to a surface with dx/ds &lt 0."],
p$1360=1+p$1360[[1,2]];p1$1360=StringPosition["The absolute face-angle at the exit to the bending angle. The effective face angle \
is E2 * ANGLE + AE2, and a positive angle at the exit corresponds to a surface with dx/ds &lt 0."[p$1360,-1],">::",1];
   p1$1360=If[p1$1360==={},179,-2+p$1360+p1$1360[[1,1]]];
neq=Which["The absolute face-angle at the exit to the bending angle. The effective face angle is E2 * ANGLE + AE2, and a positive \
angle at the exit corresponds to a surface with dx/ds &lt 0."[p$1360,4+p$1360]==="Text[",
    lx$1360:=Help2HTML`oa$;p$1360=5+p$1360;p1$1360-=1;p2$1360=5+p1$1360;p0$1360=-9+p$1360;
If[(pe$1360=StringPosition["The absolute face-angle at the exit to the bending angle. The effective face angle is E2 * ANGLE + AE2\
, and a positive angle at the exit corresponds to a surface with dx/ds &lt 0."[p$1360,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["The absolute face-angle at the exit to the bending angle. The effective face angle is E2 * ANGLE + AE2, and a pos\
itive angle at the exit corresponds to a surface with dx/ds &lt 0."[p$1360+pe$1360[[1,2]],p1$1360]]],
        p1$1360=-2+p$1360+pe$1360[[1,1]]}[[
       1]],
      0],
    1,lx$1360:=Help2HTML`o9$;p2$1360=4+p1$1360;p0$1360=-4+p$1360;0];
  If[(equ$1360=
Help2HTML`o8$["The absolute face-angle at the exit to the bending angle. The effective face angle is E2 * ANGLE + AE2, and a posit\
ive angle at the exit corresponds to a surface with dx/ds &lt 0."[p$1360,p1$1360]])===
    Undefined,
equ$1360="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["The absolute face-angle at the exit to the b\
ending angle. The effective face angle is E2 * ANGLE + AE2, and a positive angle at the exit corresponds to a surface with dx/ds &\
lt 0."[p$1360,p1$1360]]=
       equ$1360;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1360},out$1360=lx$1360@Typeset["The absolute face-angle at the exit to the bending angle. The effective face angle is E2 \
* ANGLE + AE2, and a positive angle at the exit corresponds to a surface with dx/ds &lt 0."[p$1360,p1$1360],Format->Help2HTML`oB$];
        System["mv -f "//out$1360//" "//equ$1360]];
      Exit[]]];
   "The absolute face-angle at the exit to the bending angle. The effective face angle is E2 * ANGLE + AE2, and a positive angle a\
t the exit corresponds to a surface with dx/ds &lt 0."[1,Max[p0$1360,0]]//"<img  class=\"eqs\" SRC=\""//equ$1360//"\" />"//
   Help2HTML`oy$["The absolute face-angle at the exit to the bending angle. The effective face angle is E2 * ANGLE + AE2, and a po\
sitive angle at the exit corresponds to a surface with dx/ds &lt 0."[p2$1360,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L87>E2</A> <A HREF=#L78>AE1</A> <A HREF=#L80>ANGLE</A></PRE>
<LI>
<H3><A NAME=L80>
ANGLE</A></H3>
<PRE>If[{},
Help2HTML`oA$["The bending angle. If positive, it bends the orbit in x-s plane toward negative-x-direction. ANGLE determines the g\
eometry of the beam line, while K0 represents a dipole kick on top of the bending angle given by ANGLE, i.e., the total deflection\
 of the beam is given of ANGLE + K0."],
p$1363=1+p$1363[[1,2]];p1$1363=StringPosition["The bending angle. If positive, it bends the orbit in x-s plane toward negative-x-d\
irection. ANGLE determines the geometry of the beam line, while K0 represents a dipole kick on top of the bending angle given by A\
NGLE, i.e., the total deflection of the beam is given of ANGLE + K0."[p$1363,-1],">::",1];
   p1$1363=If[p1$1363==={},281,-2+p$1363+p1$1363[[1,1]]];
neq=Which["The bending angle. If positive, it bends the orbit in x-s plane toward negative-x-direction. ANGLE determines the geome\
try of the beam line, while K0 represents a dipole kick on top of the bending angle given by ANGLE, i.e., the total deflection of \
the beam is given of ANGLE + K0."[p$1363,4+p$1363]==="Text[",
    lx$1363:=Help2HTML`oa$;p$1363=5+p$1363;p1$1363-=1;p2$1363=5+p1$1363;p0$1363=-9+p$1363;
If[(pe$1363=StringPosition["The bending angle. If positive, it bends the orbit in x-s plane toward negative-x-direction. ANGLE det\
ermines the geometry of the beam line, while K0 represents a dipole kick on top of the bending angle given by ANGLE, i.e., the tot\
al deflection of the beam is given of ANGLE + K0."[p$1363,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["The bending angle. If positive, it bends the orbit in x-s plane toward negative-x-direction. ANGLE determines the\
 geometry of the beam line, while K0 represents a dipole kick on top of the bending angle given by ANGLE, i.e., the total deflecti\
on of the beam is given of ANGLE + K0."[p$1363+pe$1363[[1,2]],p1$1363]]],
        p1$1363=-2+p$1363+pe$1363[[1,1]]}[[
       1]],
      0],
    1,lx$1363:=Help2HTML`o9$;p2$1363=4+p1$1363;p0$1363=-4+p$1363;0];
  If[(equ$1363=
Help2HTML`o8$["The bending angle. If positive, it bends the orbit in x-s plane toward negative-x-direction. ANGLE determines the g\
eometry of the beam line, while K0 represents a dipole kick on top of the bending angle given by ANGLE, i.e., the total deflection\
 of the beam is given of ANGLE + K0."[p$1363,p1$1363]])===
    Undefined,
equ$1363="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["The bending angle. If positive, it bends the\
 orbit in x-s plane toward negative-x-direction. ANGLE determines the geometry of the beam line, while K0 represents a dipole kick\
 on top of the bending angle given by ANGLE, i.e., the total deflection of the beam is given of ANGLE + K0."[p$1363,p1$1363]]=
       equ$1363;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1363},out$1363=lx$1363@Typeset["The bending angle. If positive, it bends the orbit in x-s plane toward negative-x-directi\
on. ANGLE determines the geometry of the beam line, while K0 represents a dipole kick on top of the bending angle given by ANGLE, \
i.e., the total deflection of the beam is given of ANGLE + K0."[p$1363,p1$1363],Format->Help2HTML`oB$];
        System["mv -f "//out$1363//" "//equ$1363]];
      Exit[]]];
   "The bending angle. If positive, it bends the orbit in x-s plane toward negative-x-direction. ANGLE determines the geometry of \
the beam line, while K0 represents a dipole kick on top of the bending angle given by ANGLE, i.e., the total deflection of the bea\
m is given of ANGLE + K0."[1,Max[p0$1363,0]]//"<img  class=\"eqs\" SRC=\""//equ$1363//"\" />"//
Help2HTML`oy$["The bending angle. If positive, it bends the orbit in x-s plane toward negative-x-direction. ANGLE determines the g\
eometry of the beam line, while K0 represents a dipole kick on top of the bending angle given by ANGLE, i.e., the total deflection\
 of the beam is given of ANGLE + K0."[p2$1363,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L92>K0</A></PRE>
<LI>
<H3><A NAME=L81>
DISFRIN</A></H3>
<PRE>If[{},Help2HTML`oA$["If nonzero, the nonlinear Maxwellian fringe is suppressed."],
 p$1366=1+p$1366[[1,2]];p1$1366=StringPosition["If nonzero, the nonlinear Maxwellian fringe is suppressed."[p$1366,-1],">::",1];
  p1$1366=If[p1$1366==={},58,-2+p$1366+p1$1366[[1,1]]];
  neq=Which["If nonzero, the nonlinear Maxwellian fringe is suppressed."[p$1366,4+p$1366]==="Text[",
    lx$1366:=Help2HTML`oa$;p$1366=5+p$1366;p1$1366-=1;p2$1366=5+p1$1366;p0$1366=-9+p$1366;
     If[(pe$1366=StringPosition["If nonzero, the nonlinear Maxwellian fringe is suppressed."[p$1366,-2],";;;"])<=>{},
      {Max[0,-1+ToExpression["If nonzero, the nonlinear Maxwellian fringe is suppressed."[p$1366+pe$1366[[1,2]],p1$1366]]],
       p1$1366=-2+p$1366+pe$1366[[1,1]]}[[1]],
      0],
    1,lx$1366:=Help2HTML`o9$;p2$1366=4+p1$1366;p0$1366=-4+p$1366;0];
  If[(equ$1366=Help2HTML`o8$["If nonzero, the nonlinear Maxwellian fringe is suppressed."[p$1366,p1$1366]])===Undefined,
   equ$1366="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["If nonzero, the nonlinear Maxwellian fringe is suppressed."[p$1366,p1$1366]]=equ$1366;LaTeX`ob$+=neq,
     --LaTeX`ob$;
      With[{lx$1366},out$1366=lx$1366@Typeset["If nonzero, the nonlinear Maxwellian fringe is suppressed."[p$1366,p1$1366],
          Format->Help2HTML`oB$];
        System["mv -f "//out$1366//" "//equ$1366]];
      Exit[]]];
   "If nonzero, the nonlinear Maxwellian fringe is suppressed."[1,Max[p0$1366,0]]//"<img  class=\"eqs\" SRC=\""//equ$1366//
   "\" />"//Help2HTML`oy$["If nonzero, the nonlinear Maxwellian fringe is suppressed."[p2$1366,-1]]
]</PRE>
<LI>
<H3><A NAME=L82>
DISRAD</A></H3>
<PRE>If[{},Help2HTML`oA$["If nonzero, the synchrotron radiation in the particle-tracking is inhibited."],
 p$1368=1+p$1368[[1,2]];p1$1368=
   StringPosition["If nonzero, the synchrotron radiation in the particle-tracking is inhibited."[p$1368,-1],">::",1];
  p1$1368=If[p1$1368==={},76,-2+p$1368+p1$1368[[1,1]]];
  neq=Which["If nonzero, the synchrotron radiation in the particle-tracking is inhibited."[p$1368,4+p$1368]==="Text[",
    lx$1368:=Help2HTML`oa$;p$1368=5+p$1368;p1$1368-=1;p2$1368=5+p1$1368;p0$1368=-9+p$1368;
     If[(pe$1368=StringPosition["If nonzero, the synchrotron radiation in the particle-tracking is inhibited."[p$1368,-2],";;;"]
        )<=>
       {},
      {Max[0,
        -1+ToExpression["If nonzero, the synchrotron radiation in the particle-tracking is inhibited."[p$1368+pe$1368[[1,2]],p1
           $1368]]],
        p1$1368=-2+p$1368+pe$1368[[1,1]]}[[
       1]],
      0],
    1,lx$1368:=Help2HTML`o9$;p2$1368=4+p1$1368;p0$1368=-4+p$1368;0];
  If[(equ$1368=Help2HTML`o8$["If nonzero, the synchrotron radiation in the particle-tracking is inhibited."[p$1368,p1$1368]])===
    Undefined,
   equ$1368="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "If nonzero, the synchrotron radiation in the particle-tracking is inhibited."[p$1368,p1$1368]]=
       equ$1368;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$1368},out$1368=lx$1368@Typeset["If nonzero, the synchrotron radiation in the particle-tracking is inhibited."[p$1368
           ,p1$1368],Format->Help2HTML`oB$];
        System["mv -f "//out$1368//" "//equ$1368]];
      Exit[]]];
   "If nonzero, the synchrotron radiation in the particle-tracking is inhibited."[1,Max[p0$1368,0]]//"<img  class=\"eqs\" SRC=\""//
   equ$1368//"\" />"//Help2HTML`oy$["If nonzero, the synchrotron radiation in the particle-tracking is inhibited."[p2$1368,-1]]
 ]
</PRE>
<PRE>See also:
 <A HREF=#L337>RAD</A></PRE>
<LI>
<H3><A NAME=L83>
DROTATE</A></H3>
<PRE>If[{},
 Help2HTML`oA$["Additional rotation in x-y plane to simulate a rotation error. DROTATE does not affect the geometry of the ring."],
 p$1371=1+p$1371[[1,2]];
  p1$1371=StringPosition[
    "Additional rotation in x-y plane to simulate a rotation error. DROTATE does not affect the geometry of the ring."[p$1371,-1],
    ">::",1];
   p1$1371=If[p1$1371==={},112,-2+p$1371+p1$1371[[1,1]]];
  neq=Which["Additional rotation in x-y plane to simulate a rotation error. DROTATE does not affect the geometry of the ring."[p
      $1371,4+p$1371]===
     "Text[",
    lx$1371:=Help2HTML`oa$;p$1371=5+p$1371;p1$1371-=1;p2$1371=5+p1$1371;p0$1371=-9+p$1371;If[(pe$1371=StringPosition[
         "Additional rotation in x-y plane to simulate a rotation error. DROTATE does not affect the geometry of the ring."[p$1371,
          -2],
         ";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression[
          "Additional rotation in x-y plane to simulate a rotation error. DROTATE does not affect the geometry of the ring."[p$1371
            +pe$1371[[1,2]],
           p1$1371]]],
        p1$1371=-2+p$1371+pe$1371[[1,1]]}[[
       1]],
      0],
    1,lx$1371:=Help2HTML`o9$;p2$1371=4+p1$1371;p0$1371=-4+p$1371;0];
  If[(equ$1371=
     Help2HTML`o8$[
      "Additional rotation in x-y plane to simulate a rotation error. DROTATE does not affect the geometry of the ring."[p$1371,
       p1$1371]])===
    Undefined,
   equ$1371="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "Additional rotation in x-y plane to simulate a rotation error. DROTATE does not affect the geometry of the ring."[p$1371,
         p1$1371]]=
       equ$1371;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$1371},out$1371=lx$1371@Typeset[
          "Additional rotation in x-y plane to simulate a rotation error. DROTATE does not affect the geometry of the ring."[p$1371
           ,p1$1371],Format->Help2HTML`oB$];
        System["mv -f "//out$1371//" "//equ$1371]];
      Exit[]]];
   "Additional rotation in x-y plane to simulate a rotation error. DROTATE does not affect the geometry of the ring."[1,
    Max[p0$1371,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$1371//"\" />"//
   Help2HTML`oy$["Additional rotation in x-y plane to simulate a rotation error. DROTATE does not affect the geometry of the ring."
    [p2$1371,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L84>DX</A> <A HREF=#L85>DY</A> <A HREF=#L95>ROTATE</A></PRE>
<LI>
<H3><A NAME=L84>
DX</A></H3>
<PRE>If[{},Help2HTML`oA$["Horizontal displacement of magnet. This applied before the rotation by ROTATE."],
 p$1374=1+p$1374[[1,2]];p1$1374=
   StringPosition["Horizontal displacement of magnet. This applied before the rotation by ROTATE."[p$1374,-1],">::",1];
  p1$1374=If[p1$1374==={},78,-2+p$1374+p1$1374[[1,1]]];
  neq=Which["Horizontal displacement of magnet. This applied before the rotation by ROTATE."[p$1374,4+p$1374]==="Text[",
    lx$1374:=Help2HTML`oa$;p$1374=5+p$1374;p1$1374-=1;p2$1374=5+p1$1374;p0$1374=-9+p$1374;
     If[(pe$1374=StringPosition["Horizontal displacement of magnet. This applied before the rotation by ROTATE."[p$1374,-2],";;;"]
        )<=>
       {},
      {Max[0,
        -1+ToExpression["Horizontal displacement of magnet. This applied before the rotation by ROTATE."[p$1374+pe$1374[[1,2]],
           p1$1374]]],
        p1$1374=-2+p$1374+pe$1374[[1,1]]}[[
       1]],
      0],
    1,lx$1374:=Help2HTML`o9$;p2$1374=4+p1$1374;p0$1374=-4+p$1374;0];
  If[(equ$1374=Help2HTML`o8$["Horizontal displacement of magnet. This applied before the rotation by ROTATE."[p$1374,p1$1374]])===
    Undefined,
   equ$1374="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "Horizontal displacement of magnet. This applied before the rotation by ROTATE."[p$1374,p1$1374]]=
       equ$1374;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$1374},out$1374=lx$1374@Typeset["Horizontal displacement of magnet. This applied before the rotation by ROTATE."[p
           $1374,p1$1374],Format->Help2HTML`oB$];
        System["mv -f "//out$1374//" "//equ$1374]];
      Exit[]]];
   "Horizontal displacement of magnet. This applied before the rotation by ROTATE."[1,Max[p0$1374,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$1374//"\" />"//
   Help2HTML`oy$["Horizontal displacement of magnet. This applied before the rotation by ROTATE."[p2$1374,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L85>DY</A> <A HREF=#L95>ROTATE</A> <A HREF=#L83>DROTATE</A></PRE>
<LI>
<H3><A NAME=L85>
DY</A></H3>
<PRE>If[{},Help2HTML`oA$["Vertical displacement of magnet. This applied before the rotation by ROTATE."],
 p$1377=1+p$1377[[1,2]];p1$1377=
   StringPosition["Vertical displacement of magnet. This applied before the rotation by ROTATE."[p$1377,-1],">::",1];
  p1$1377=If[p1$1377==={},76,-2+p$1377+p1$1377[[1,1]]];
  neq=Which["Vertical displacement of magnet. This applied before the rotation by ROTATE."[p$1377,4+p$1377]==="Text[",
    lx$1377:=Help2HTML`oa$;p$1377=5+p$1377;p1$1377-=1;p2$1377=5+p1$1377;p0$1377=-9+p$1377;
     If[(pe$1377=StringPosition["Vertical displacement of magnet. This applied before the rotation by ROTATE."[p$1377,-2],";;;"]
        )<=>
       {},
      {Max[0,
        -1+ToExpression["Vertical displacement of magnet. This applied before the rotation by ROTATE."[p$1377+pe$1377[[1,2]],p1
           $1377]]],
        p1$1377=-2+p$1377+pe$1377[[1,1]]}[[
       1]],
      0],
    1,lx$1377:=Help2HTML`o9$;p2$1377=4+p1$1377;p0$1377=-4+p$1377;0];
  If[(equ$1377=Help2HTML`o8$["Vertical displacement of magnet. This applied before the rotation by ROTATE."[p$1377,p1$1377]])===
    Undefined,
   equ$1377="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "Vertical displacement of magnet. This applied before the rotation by ROTATE."[p$1377,p1$1377]]=
       equ$1377;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$1377},out$1377=lx$1377@Typeset["Vertical displacement of magnet. This applied before the rotation by ROTATE."[p$1377
           ,p1$1377],Format->Help2HTML`oB$];
        System["mv -f "//out$1377//" "//equ$1377]];
      Exit[]]];
   "Vertical displacement of magnet. This applied before the rotation by ROTATE."[1,Max[p0$1377,0]]//"<img  class=\"eqs\" SRC=\""//
   equ$1377//"\" />"//Help2HTML`oy$["Vertical displacement of magnet. This applied before the rotation by ROTATE."[p2$1377,-1]]
 ]
</PRE>
<PRE>See also:
 <A HREF=#L84>DX</A> <A HREF=#L95>ROTATE</A> <A HREF=#L83>DROTATE</A></PRE>
<LI>
<H3><A NAME=L86>
E1</A></H3>
<PRE>If[{},
Help2HTML`oA$["The ratio of the face-angle at the entrance to the bending angle. The effective face angle is E1 * ANGLE + AE1, and\
 a positive angle at the entrance corresponds to a surface with dx/ds > 0. For example, a symmetrically-placed rectangular magnet \
has\n E1 = 0.5 and E2 = 0.5."],
p$1380=1+p$1380[[1,2]];p1$1380=StringPosition["The ratio of the face-angle at the entrance to the bending angle. The effective fac\
e angle is E1 * ANGLE + AE1, and a positive angle at the entrance corresponds to a surface with dx/ds > 0. For example, a symmetri\
cally-placed rectangular magnet has\n E1 = 0.5 and E2 = 0.5."[p$1380,-1],">::",1];
   p1$1380=If[p1$1380==={},272,-2+p$1380+p1$1380[[1,1]]];
neq=Which["The ratio of the face-angle at the entrance to the bending angle. The effective face angle is E1 * ANGLE + AE1, and a p\
ositive angle at the entrance corresponds to a surface with dx/ds > 0. For example, a symmetrically-placed rectangular magnet has\\
n E1 = 0.5 and E2 = 0.5."[p$1380,4+p$1380]==="Text[",
    lx$1380:=Help2HTML`oa$;p$1380=5+p$1380;p1$1380-=1;p2$1380=5+p1$1380;p0$1380=-9+p$1380;
If[(pe$1380=StringPosition["The ratio of the face-angle at the entrance to the bending angle. The effective face angle is E1 * ANG\
LE + AE1, and a positive angle at the entrance corresponds to a surface with dx/ds > 0. For example, a symmetrically-placed rectan\
gular magnet has\n E1 = 0.5 and E2 = 0.5."[p$1380,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["The ratio of the face-angle at the entrance to the bending angle. The effective face angle is E1 * ANGLE + AE1, a\
nd a positive angle at the entrance corresponds to a surface with dx/ds > 0. For example, a symmetrically-placed rectangular magne\
t has\n E1 = 0.5 and E2 = 0.5."[p$1380+pe$1380[[1,2]],p1$1380]]],
        p1$1380=-2+p$1380+pe$1380[[1,1]]}[[
       1]],
      0],
    1,lx$1380:=Help2HTML`o9$;p2$1380=4+p1$1380;p0$1380=-4+p$1380;0];
  If[(equ$1380=
Help2HTML`o8$["The ratio of the face-angle at the entrance to the bending angle. The effective face angle is E1 * ANGLE + AE1, and\
 a positive angle at the entrance corresponds to a surface with dx/ds > 0. For example, a symmetrically-placed rectangular magnet \
has\n E1 = 0.5 and E2 = 0.5."[p$1380,p1$1380]])===
    Undefined,
equ$1380="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["The ratio of the face-angle at the entrance \
to the bending angle. The effective face angle is E1 * ANGLE + AE1, and a positive angle at the entrance corresponds to a surface \
with dx/ds > 0. For example, a symmetrically-placed rectangular magnet has\n E1 = 0.5 and E2 = 0.5."[p$1380,p1$1380]]=
       equ$1380;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1380},out$1380=lx$1380@Typeset["The ratio of the face-angle at the entrance to the bending angle. The effective face angl\
e is E1 * ANGLE + AE1, and a positive angle at the entrance corresponds to a surface with dx/ds > 0. For example, a symmetrically-\
placed rectangular magnet has\n E1 = 0.5 and E2 = 0.5."[p$1380,p1$1380],Format->Help2HTML`oB$];
        System["mv -f "//out$1380//" "//equ$1380]];
      Exit[]]];
   "The ratio of the face-angle at the entrance to the bending angle. The effective face angle is E1 * ANGLE + AE1, and a positive\
 angle at the entrance corresponds to a surface with dx/ds > 0. For example, a symmetrically-placed rectangular magnet has\n E1 = \
0.5 and E2 = 0.5."[1,Max[p0$1380,0]]//"<img  class=\"eqs\" SRC=\""//equ$1380//"\" />"//
Help2HTML`oy$["The ratio of the face-angle at the entrance to the bending angle. The effective face angle is E1 * ANGLE + AE1, and\
 a positive angle at the entrance corresponds to a surface with dx/ds > 0. For example, a symmetrically-placed rectangular magnet \
has\n E1 = 0.5 and E2 = 0.5."[p2$1380,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L78>AE1</A> <A HREF=#L87>E2</A> <A HREF=#L80>ANGLE</A></PRE>
<LI>
<H3><A NAME=L87>
E2</A></H3>
<PRE>If[{},
Help2HTML`oA$["The ratio of the face-angle at the exit to the bending angle. The effective face angle is E2 * ANGLE + AE2, and a p\
ositive angle at the exit corresponds to a surface with dx/ds &lt 0. For example, a symmetrically-placed rectangular magnet has E1\
 = 0.5 and E2 = 0.5."],
p$1383=1+p$1383[[1,2]];p1$1383=StringPosition["The ratio of the face-angle at the exit to the bending angle. The effective face an\
gle is E2 * ANGLE + AE2, and a positive angle at the exit corresponds to a surface with dx/ds &lt 0. For example, a symmetrically-\
placed rectangular magnet has E1 = 0.5 and E2 = 0.5."[p$1383,-1],">::",1];
   p1$1383=If[p1$1383==={},265,-2+p$1383+p1$1383[[1,1]]];
neq=Which["The ratio of the face-angle at the exit to the bending angle. The effective face angle is E2 * ANGLE + AE2, and a posit\
ive angle at the exit corresponds to a surface with dx/ds &lt 0. For example, a symmetrically-placed rectangular magnet has E1 = 0\
.5 and E2 = 0.5."[p$1383,4+p$1383]==="Text[",
    lx$1383:=Help2HTML`oa$;p$1383=5+p$1383;p1$1383-=1;p2$1383=5+p1$1383;p0$1383=-9+p$1383;If[(pe$1383=
StringPosition["The ratio of the face-angle at the exit to the bending angle. The effective face angle is E2 * ANGLE + AE2, and a \
positive angle at the exit corresponds to a surface with dx/ds &lt 0. For example, a symmetrically-placed rectangular magnet has E\
1 = 0.5 and E2 = 0.5."[p$1383,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["The ratio of the face-angle at the exit to the bending angle. The effective face angle is E2 * ANGLE + AE2, and a\
 positive angle at the exit corresponds to a surface with dx/ds &lt 0. For example, a symmetrically-placed rectangular magnet has \
E1 = 0.5 and E2 = 0.5."[p$1383+pe$1383[[1,2]],p1$1383]]],
        p1$1383=-2+p$1383+pe$1383[[1,1]]}[[
       1]],
      0],
    1,lx$1383:=Help2HTML`o9$;p2$1383=4+p1$1383;p0$1383=-4+p$1383;0];
  If[(equ$1383=
Help2HTML`o8$["The ratio of the face-angle at the exit to the bending angle. The effective face angle is E2 * ANGLE + AE2, and a p\
ositive angle at the exit corresponds to a surface with dx/ds &lt 0. For example, a symmetrically-placed rectangular magnet has E1\
 = 0.5 and E2 = 0.5."[p$1383,p1$1383]])===
    Undefined,
equ$1383="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["The ratio of the face-angle at the exit to t\
he bending angle. The effective face angle is E2 * ANGLE + AE2, and a positive angle at the exit corresponds to a surface with dx/\
ds &lt 0. For example, a symmetrically-placed rectangular magnet has E1 = 0.5 and E2 = 0.5."[p$1383,p1$1383]]=
       equ$1383;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1383},out$1383=lx$1383@Typeset["The ratio of the face-angle at the exit to the bending angle. The effective face angle is\
 E2 * ANGLE + AE2, and a positive angle at the exit corresponds to a surface with dx/ds &lt 0. For example, a symmetrically-placed\
 rectangular magnet has E1 = 0.5 and E2 = 0.5."[p$1383,p1$1383],Format->Help2HTML`oB$];
        System["mv -f "//out$1383//" "//equ$1383]];
      Exit[]]];
   "The ratio of the face-angle at the exit to the bending angle. The effective face angle is E2 * ANGLE + AE2, and a positive ang\
le at the exit corresponds to a surface with dx/ds &lt 0. For example, a symmetrically-placed rectangular magnet has E1 = 0.5 and \
E2 = 0.5."[1,Max[p0$1383,0]]//"<img  class=\"eqs\" SRC=\""//equ$1383//"\" />"//
Help2HTML`oy$["The ratio of the face-angle at the exit to the bending angle. The effective face angle is E2 * ANGLE + AE2, and a p\
ositive angle at the exit corresponds to a surface with dx/ds &lt 0. For example, a symmetrically-placed rectangular magnet has E1\
 = 0.5 and E2 = 0.5."[p2$1383,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L79>AE2</A> <A HREF=#L86>E1</A> <A HREF=#L80>ANGLE</A></PRE>
<LI>
<H3><A NAME=L88>
F1</A></H3>
<PRE>Length of the slope of the field at the edge as:

                By(s) |   *******
                      |  *
                      | *
                      |*
                      *
                     *|
                    * |
                   *  |
        ----*******---+--------- s
                  |       |
                  |<----->|
                  |   F1  |

Only the effects up to y^4 in Hamiltonian are taken into account. A more rigorous definition is

<img  class="eqs" SRC="SADHelp_img/equ_88.svg" />

where integration is done over one fringe.

   The transformation of the linear fringe of the entrance of a bend is

<img  class="eqs" SRC="SADHelp_img/equ_89.svg" />

where f is the length of fringe given by F1, and rhob bending radius at the design momentum. At the exit, the sign of rhob is chang
ed. This linear fringe also changes the path length in the body of the bend as

<img  class="eqs" SRC="SADHelp_img/equ_90.svg" />If[{},Help2HTML`oA$["\n\nto maintain the geometric position of the design orbit, i
.e., you have to increase the bend field a little bit to keep the orbit unchanged. Unlike a quadrupole, the effect of linear fringe
 is always applied at both the entrance and the exit, otherwise you cannot obtain a circular design orbit.\n\n   Use FB1 and FB2 to
 specify the values of entrance and exit separately."],p$1389=1+p$1389[[1,2]];p1$1389=StringPosition["\n\nto maintain the geometric
 position of the design orbit, i.e., you have to increase the bend field a little bit to keep the orbit unchanged. Unlike a quadrup
ole, the effect of linear fringe is always applied at both the entrance and the exit, otherwise you cannot obtain a circular design
 orbit.\n\n   Use FB1 and FB2 to specify the values of entrance and exit separately."[p$1389,-1],">::",1];p1$1389=If[p1$1389==={},3
71,-2+p$1389+p1$1389[[1,1]]];neq=Which["\n\nto maintain the geometric position of the design orbit, i.e., you have to increase the 
bend field a little bit to keep the orbit unchanged. Unlike a quadrupole, the effect of linear fringe is always applied at both the
 entrance and the exit, otherwise you cannot obtain a circular design orbit.\n\n   Use FB1 and FB2 to specify the values of entranc
e and exit separately."[p$1389,4+p$1389]==="Text[",lx$1389:=Help2HTML`oa$;p$1389=5+p$1389;p1$1389-=1;p2$1389=5+p1$1389;p0$1389=-9+p
$1389;If[(pe$1389=StringPosition["\n\nto maintain the geometric position of the design orbit, i.e., you have to increase the bend f
ield a little bit to keep the orbit unchanged. Unlike a quadrupole, the effect of linear fringe is always applied at both the entra
nce and the exit, otherwise you cannot obtain a circular design orbit.\n\n   Use FB1 and FB2 to specify the values of entrance and 
exit separately."[p$1389,-2],";;;"])<=>{},{Max[0,-1+ToExpression["\n\nto maintain the geometric position of the design orbit, i.e.,
 you have to increase the bend field a little bit to keep the orbit unchanged. Unlike a quadrupole, the effect of linear fringe is 
always applied at both the entrance and the exit, otherwise you cannot obtain a circular design orbit.\n\n   Use FB1 and FB2 to spe
cify the values of entrance and exit separately."[p$1389+pe$1389[[1,2]],p1$1389]]],p1$1389=-2+p$1389+pe$1389[[1,1]]}[[1]],0],1,lx$1
389:=Help2HTML`o9$;p2$1389=4+p1$1389;p0$1389=-4+p$1389;0];If[(equ$1389=Help2HTML`o8$["\n\nto maintain the geometric position of the
 design orbit, i.e., you have to increase the bend field a little bit to keep the orbit unchanged. Unlike a quadrupole, the effect 
of linear fringe is always applied at both the entrance and the exit, otherwise you cannot obtain a circular design orbit.\n\n   Us
e FB1 and FB2 to specify the values of entrance and exit separately."[p$1389,p1$1389]])===Undefined,equ$1389="SADHelp_img/equ_"//++
LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["\n\nto maintain the geometric position of the design orbit, i.e., you have t
o increase the bend field a little bit to keep the orbit unchanged. Unlike a quadrupole, the effect of linear fringe is always appl
ied at both the entrance and the exit, otherwise you cannot obtain a circular design orbit.\n\n   Use FB1 and FB2 to specify the va
lues of entrance and exit separately."[p$1389,p1$1389]]=equ$1389;LaTeX`ob$+=neq,--LaTeX`ob$;With[{lx$1389},out$1389=lx$1389@Typeset
["\n\nto maintain the geometric position of the design orbit, i.e., you have to increase the bend field a little bit to keep the or
bit unchanged. Unlike a quadrupole, the effect of linear fringe is always applied at both the entrance and the exit, otherwise you 
cannot obtain a circular design orbit.\n\n   Use FB1 and FB2 to specify the values of entrance and exit separately."[p$1389,p1$1389
],Format->Help2HTML`oB$];System["mv -f "//out$1389//" "//equ$1389]];Exit[]]];"\n\nto maintain the geometric position of the design 
orbit, i.e., you have to increase the bend field a little bit to keep the orbit unchanged. Unlike a quadrupole, the effect of linea
r fringe is always applied at both the entrance and the exit, otherwise you cannot obtain a circular design orbit.\n\n   Use FB1 an
d FB2 to specify the values of entrance and exit separately."[1,Max[p0$1389,0]]//"<img  class=\"eqs\" SRC=\""//equ$1389//"\" />"//H
elp2HTML`oy$["\n\nto maintain the geometric position of the design orbit, i.e., you have to increase the bend field a little bit to
 keep the orbit unchanged. Unlike a quadrupole, the effect of linear fringe is always applied at both the entrance and the exit, ot
herwise you cannot obtain a circular design orbit.\n\n   Use FB1 and FB2 to specify the values of entrance and exit separately."[p2
$1389,-1]]]
</PRE>
<PRE>See also:
 <A HREF=#L91>FRINGE</A> <A HREF=#L89>FB1</A> <A HREF=#L90>FB2</A></PRE>
<LI>
<H3><A NAME=L89>
FB1</A></H3>
<PRE>If[{},Help2HTML`oA$["   F1 at the entrance. Actually F1 + FB1 is used at the entrance."],
 p$1392=1+p$1392[[1,2]];p1$1392=StringPosition["   F1 at the entrance. Actually F1 + FB1 is used at the entrance."[p$1392,-1],
    ">::",1];
   p1$1392=If[p1$1392==={},65,-2+p$1392+p1$1392[[1,1]]];
  neq=Which["   F1 at the entrance. Actually F1 + FB1 is used at the entrance."[p$1392,4+p$1392]==="Text[",
    lx$1392:=Help2HTML`oa$;p$1392=5+p$1392;p1$1392-=1;p2$1392=5+p1$1392;p0$1392=-9+p$1392;
     If[(pe$1392=StringPosition["   F1 at the entrance. Actually F1 + FB1 is used at the entrance."[p$1392,-2],";;;"])<=>{},
      {Max[0,-1+ToExpression["   F1 at the entrance. Actually F1 + FB1 is used at the entrance."[p$1392+pe$1392[[1,2]],p1$1392]]],
       p1$1392=-2+p$1392+pe$1392[[1,1]]}[[1]],
      0],
    1,lx$1392:=Help2HTML`o9$;p2$1392=4+p1$1392;p0$1392=-4+p$1392;0];
  If[(equ$1392=Help2HTML`o8$["   F1 at the entrance. Actually F1 + FB1 is used at the entrance."[p$1392,p1$1392]])===Undefined,
   equ$1392="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["   F1 at the entrance. Actually F1 + FB1 is used at the entrance."[p$1392,p1$1392]]=equ$1392;
      LaTeX`ob$+=neq,
     --LaTeX`ob$;With[{lx$1392},out$1392=lx$1392@Typeset["   F1 at the entrance. Actually F1 + FB1 is used at the entrance."[p$1392
           ,p1$1392],Format->Help2HTML`oB$];
        System["mv -f "//out$1392//" "//equ$1392]];
      Exit[]]];
   "   F1 at the entrance. Actually F1 + FB1 is used at the entrance."[1,Max[p0$1392,0]]//"<img  class=\"eqs\" SRC=\""//equ$1392//
   "\" />"//Help2HTML`oy$["   F1 at the entrance. Actually F1 + FB1 is used at the entrance."[p2$1392,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L88>F1</A> <A HREF=#L90>FB2</A></PRE>
<LI>
<H3><A NAME=L90>
FB2</A></H3>
<PRE>If[{},Help2HTML`oA$["   F1 at the exit. Actually F1 + FB2 is used at the exit."],
 p$1395=1+p$1395[[1,2]];p1$1395=StringPosition["   F1 at the exit. Actually F1 + FB2 is used at the exit."[p$1395,-1],">::",1];
  p1$1395=If[p1$1395==={},57,-2+p$1395+p1$1395[[1,1]]];
  neq=Which["   F1 at the exit. Actually F1 + FB2 is used at the exit."[p$1395,4+p$1395]==="Text[",
    lx$1395:=Help2HTML`oa$;p$1395=5+p$1395;p1$1395-=1;p2$1395=5+p1$1395;p0$1395=-9+p$1395;
     If[(pe$1395=StringPosition["   F1 at the exit. Actually F1 + FB2 is used at the exit."[p$1395,-2],";;;"])<=>{},
      {Max[0,-1+ToExpression["   F1 at the exit. Actually F1 + FB2 is used at the exit."[p$1395+pe$1395[[1,2]],p1$1395]]],
       p1$1395=-2+p$1395+pe$1395[[1,1]]}[[1]],
      0],
    1,lx$1395:=Help2HTML`o9$;p2$1395=4+p1$1395;p0$1395=-4+p$1395;0];
  If[(equ$1395=Help2HTML`o8$["   F1 at the exit. Actually F1 + FB2 is used at the exit."[p$1395,p1$1395]])===Undefined,
   equ$1395="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["   F1 at the exit. Actually F1 + FB2 is used at the exit."[p$1395,p1$1395]]=equ$1395;LaTeX`ob$+=neq,
     --LaTeX`ob$;
      With[{lx$1395},out$1395=lx$1395@Typeset["   F1 at the exit. Actually F1 + FB2 is used at the exit."[p$1395,p1$1395],
          Format->Help2HTML`oB$];
        System["mv -f "//out$1395//" "//equ$1395]];
      Exit[]]];
   "   F1 at the exit. Actually F1 + FB2 is used at the exit."[1,Max[p0$1395,0]]//"<img  class=\"eqs\" SRC=\""//equ$1395//"\" />"//
   Help2HTML`oy$["   F1 at the exit. Actually F1 + FB2 is used at the exit."[p2$1395,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L88>F1</A> <A HREF=#L89>FB1</A></PRE>
<LI>
<H3><A NAME=L91>
FRINGE</A></H3>
<PRE>When FRINGE is non-zero, the effect of the linear fringe F1 is taken into account both at the entrance and the exit.
   The transformation of the linear fringe of the entrance of a bend is

<img  class="eqs" SRC="SADHelp_img/equ_89.svg" />

where f is the length of fringe given by F1, and rhob bending radius at the design momentum. At the exit, the sign of rhob is chang
ed. This linear fringe also changes the path length in the body of the bend as

<img  class="eqs" SRC="SADHelp_img/equ_90.svg" />If[{},Help2HTML`oA$["\n\nto maintain the geometric position of the design orbit, i
.e., you have to increase the bend field a little bit to keep the orbit unchanged. Unlike a quadrupole, the effect of linear fringe
 is always applied at both the entrance and the exit, otherwise you cannot obtain a circular design orbit.\n\n   Use FB1 and FB2 to
 specify the values of entrance and exit separately."],p$1400=1+p$1400[[1,2]];p1$1400=StringPosition["\n\nto maintain the geometric
 position of the design orbit, i.e., you have to increase the bend field a little bit to keep the orbit unchanged. Unlike a quadrup
ole, the effect of linear fringe is always applied at both the entrance and the exit, otherwise you cannot obtain a circular design
 orbit.\n\n   Use FB1 and FB2 to specify the values of entrance and exit separately."[p$1400,-1],">::",1];p1$1400=If[p1$1400==={},3
71,-2+p$1400+p1$1400[[1,1]]];neq=Which["\n\nto maintain the geometric position of the design orbit, i.e., you have to increase the 
bend field a little bit to keep the orbit unchanged. Unlike a quadrupole, the effect of linear fringe is always applied at both the
 entrance and the exit, otherwise you cannot obtain a circular design orbit.\n\n   Use FB1 and FB2 to specify the values of entranc
e and exit separately."[p$1400,4+p$1400]==="Text[",lx$1400:=Help2HTML`oa$;p$1400=5+p$1400;p1$1400-=1;p2$1400=5+p1$1400;p0$1400=-9+p
$1400;If[(pe$1400=StringPosition["\n\nto maintain the geometric position of the design orbit, i.e., you have to increase the bend f
ield a little bit to keep the orbit unchanged. Unlike a quadrupole, the effect of linear fringe is always applied at both the entra
nce and the exit, otherwise you cannot obtain a circular design orbit.\n\n   Use FB1 and FB2 to specify the values of entrance and 
exit separately."[p$1400,-2],";;;"])<=>{},{Max[0,-1+ToExpression["\n\nto maintain the geometric position of the design orbit, i.e.,
 you have to increase the bend field a little bit to keep the orbit unchanged. Unlike a quadrupole, the effect of linear fringe is 
always applied at both the entrance and the exit, otherwise you cannot obtain a circular design orbit.\n\n   Use FB1 and FB2 to spe
cify the values of entrance and exit separately."[p$1400+pe$1400[[1,2]],p1$1400]]],p1$1400=-2+p$1400+pe$1400[[1,1]]}[[1]],0],1,lx$1
400:=Help2HTML`o9$;p2$1400=4+p1$1400;p0$1400=-4+p$1400;0];If[(equ$1400=Help2HTML`o8$["\n\nto maintain the geometric position of the
 design orbit, i.e., you have to increase the bend field a little bit to keep the orbit unchanged. Unlike a quadrupole, the effect 
of linear fringe is always applied at both the entrance and the exit, otherwise you cannot obtain a circular design orbit.\n\n   Us
e FB1 and FB2 to specify the values of entrance and exit separately."[p$1400,p1$1400]])===Undefined,equ$1400="SADHelp_img/equ_"//++
LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["\n\nto maintain the geometric position of the design orbit, i.e., you have t
o increase the bend field a little bit to keep the orbit unchanged. Unlike a quadrupole, the effect of linear fringe is always appl
ied at both the entrance and the exit, otherwise you cannot obtain a circular design orbit.\n\n   Use FB1 and FB2 to specify the va
lues of entrance and exit separately."[p$1400,p1$1400]]=equ$1400;LaTeX`ob$+=neq,--LaTeX`ob$;With[{lx$1400},out$1400=lx$1400@Typeset
["\n\nto maintain the geometric position of the design orbit, i.e., you have to increase the bend field a little bit to keep the or
bit unchanged. Unlike a quadrupole, the effect of linear fringe is always applied at both the entrance and the exit, otherwise you 
cannot obtain a circular design orbit.\n\n   Use FB1 and FB2 to specify the values of entrance and exit separately."[p$1400,p1$1400
],Format->Help2HTML`oB$];System["mv -f "//out$1400//" "//equ$1400]];Exit[]]];"\n\nto maintain the geometric position of the design 
orbit, i.e., you have to increase the bend field a little bit to keep the orbit unchanged. Unlike a quadrupole, the effect of linea
r fringe is always applied at both the entrance and the exit, otherwise you cannot obtain a circular design orbit.\n\n   Use FB1 an
d FB2 to specify the values of entrance and exit separately."[1,Max[p0$1400,0]]//"<img  class=\"eqs\" SRC=\""//equ$1400//"\" />"//H
elp2HTML`oy$["\n\nto maintain the geometric position of the design orbit, i.e., you have to increase the bend field a little bit to
 keep the orbit unchanged. Unlike a quadrupole, the effect of linear fringe is always applied at both the entrance and the exit, ot
herwise you cannot obtain a circular design orbit.\n\n   Use FB1 and FB2 to specify the values of entrance and exit separately."[p2
$1400,-1]]]
</PRE>
<PRE>See also:
 <A HREF=#L88>F1</A></PRE>
<LI>
<H3><A NAME=L92>
K0</A></H3>
<PRE>The normal dipole magnetic field component (times the length L).

<img  class="eqs" SRC="SADHelp_img/equ_91.svg" />If[{},Help2HTML`oA$["\n\nwhere L is the effective length of the component. Positiv
e sign means horizontal focusing."],p$1404=1+p$1404[[1,2]];p1$1404=StringPosition["\n\nwhere L is the effective length of the compo
nent. Positive sign means horizontal focusing."[p$1404,-1],">::",1];p1$1404=If[p1$1404==={},92,-2+p$1404+p1$1404[[1,1]]];neq=Which[
"\n\nwhere L is the effective length of the component. Positive sign means horizontal focusing."[p$1404,4+p$1404]==="Text[",lx$1404
:=Help2HTML`oa$;p$1404=5+p$1404;p1$1404-=1;p2$1404=5+p1$1404;p0$1404=-9+p$1404;If[(pe$1404=StringPosition["\n\nwhere L is the effec
tive length of the component. Positive sign means horizontal focusing."[p$1404,-2],";;;"])<=>{},{Max[0,-1+ToExpression["\n\nwhere L
 is the effective length of the component. Positive sign means horizontal focusing."[p$1404+pe$1404[[1,2]],p1$1404]]],p1$1404=-2+p$
1404+pe$1404[[1,1]]}[[1]],0],1,lx$1404:=Help2HTML`o9$;p2$1404=4+p1$1404;p0$1404=-4+p$1404;0];If[(equ$1404=Help2HTML`o8$["\n\nwhere 
L is the effective length of the component. Positive sign means horizontal focusing."[p$1404,p1$1404]])===Undefined,equ$1404="SADHe
lp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["\n\nwhere L is the effective length of the component. Positi
ve sign means horizontal focusing."[p$1404,p1$1404]]=equ$1404;LaTeX`ob$+=neq,--LaTeX`ob$;With[{lx$1404},out$1404=lx$1404@Typeset["\
n\nwhere L is the effective length of the component. Positive sign means horizontal focusing."[p$1404,p1$1404],Format->Help2HTML`oB
$];System["mv -f "//out$1404//" "//equ$1404]];Exit[]]];"\n\nwhere L is the effective length of the component. Positive sign means h
orizontal focusing."[1,Max[p0$1404,0]]//"<img  class=\"eqs\" SRC=\""//equ$1404//"\" />"//Help2HTML`oy$["\n\nwhere L is the effectiv
e length of the component. Positive sign means horizontal focusing."[p2$1404,-1]]]
</PRE>
<PRE>See also:
 <A HREF=#L94>L</A></PRE>
<LI>
<H3><A NAME=L93>
K1</A></H3>
<PRE>The normal quadrupole magnetic field component (times the length L).

<img  class="eqs" SRC="SADHelp_img/equ_92.svg" />If[{},Help2HTML`oA$["\n\nwhere L is the effective length of the component. Positiv
e sign means horizontal focusing."],p$1408=1+p$1408[[1,2]];p1$1408=StringPosition["\n\nwhere L is the effective length of the compo
nent. Positive sign means horizontal focusing."[p$1408,-1],">::",1];p1$1408=If[p1$1408==={},92,-2+p$1408+p1$1408[[1,1]]];neq=Which[
"\n\nwhere L is the effective length of the component. Positive sign means horizontal focusing."[p$1408,4+p$1408]==="Text[",lx$1408
:=Help2HTML`oa$;p$1408=5+p$1408;p1$1408-=1;p2$1408=5+p1$1408;p0$1408=-9+p$1408;If[(pe$1408=StringPosition["\n\nwhere L is the effec
tive length of the component. Positive sign means horizontal focusing."[p$1408,-2],";;;"])<=>{},{Max[0,-1+ToExpression["\n\nwhere L
 is the effective length of the component. Positive sign means horizontal focusing."[p$1408+pe$1408[[1,2]],p1$1408]]],p1$1408=-2+p$
1408+pe$1408[[1,1]]}[[1]],0],1,lx$1408:=Help2HTML`o9$;p2$1408=4+p1$1408;p0$1408=-4+p$1408;0];If[(equ$1408=Help2HTML`o8$["\n\nwhere 
L is the effective length of the component. Positive sign means horizontal focusing."[p$1408,p1$1408]])===Undefined,equ$1408="SADHe
lp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["\n\nwhere L is the effective length of the component. Positi
ve sign means horizontal focusing."[p$1408,p1$1408]]=equ$1408;LaTeX`ob$+=neq,--LaTeX`ob$;With[{lx$1408},out$1408=lx$1408@Typeset["\
n\nwhere L is the effective length of the component. Positive sign means horizontal focusing."[p$1408,p1$1408],Format->Help2HTML`oB
$];System["mv -f "//out$1408//" "//equ$1408]];Exit[]]];"\n\nwhere L is the effective length of the component. Positive sign means h
orizontal focusing."[1,Max[p0$1408,0]]//"<img  class=\"eqs\" SRC=\""//equ$1408//"\" />"//Help2HTML`oy$["\n\nwhere L is the effectiv
e length of the component. Positive sign means horizontal focusing."[p2$1408,-1]]]
</PRE>
<PRE>See also:
 <A HREF=#L94>L</A></PRE>
<LI>
<H3><A NAME=L94>
L</A></H3>
<PRE>If[{},Help2HTML`oA$["The effective length along the arc of the orbit."],
 p$1411=1+p$1411[[1,2]];p1$1411=StringPosition["The effective length along the arc of the orbit."[p$1411,-1],">::",1];
  p1$1411=If[p1$1411==={},48,-2+p$1411+p1$1411[[1,1]]];
  neq=Which["The effective length along the arc of the orbit."[p$1411,4+p$1411]==="Text[",
    lx$1411:=Help2HTML`oa$;p$1411=5+p$1411;p1$1411-=1;p2$1411=5+p1$1411;p0$1411=-9+p$1411;
     If[(pe$1411=StringPosition["The effective length along the arc of the orbit."[p$1411,-2],";;;"])<=>{},
      {Max[0,-1+ToExpression["The effective length along the arc of the orbit."[p$1411+pe$1411[[1,2]],p1$1411]]],
       p1$1411=-2+p$1411+pe$1411[[1,1]]}[[1]],
      0],
    1,lx$1411:=Help2HTML`o9$;p2$1411=4+p1$1411;p0$1411=-4+p$1411;0];
  If[(equ$1411=Help2HTML`o8$["The effective length along the arc of the orbit."[p$1411,p1$1411]])===Undefined,
   equ$1411="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["The effective length along the arc of the orbit."[p$1411,p1$1411]]=equ$1411;LaTeX`ob$+=neq,
     --LaTeX`ob$;
      With[{lx$1411},out$1411=lx$1411@Typeset["The effective length along the arc of the orbit."[p$1411,p1$1411],Format->
           Help2HTML`oB$];
        System["mv -f "//out$1411//" "//equ$1411]];
      Exit[]]];
   "The effective length along the arc of the orbit."[1,Max[p0$1411,0]]//"<img  class=\"eqs\" SRC=\""//equ$1411//"\" />"//
   Help2HTML`oy$["The effective length along the arc of the orbit."[p2$1411,-1]]
]</PRE>
<LI>
<H3><A NAME=L95>
ROTATE</A></H3>
<PRE>If[{},
Help2HTML`oA$["Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet around the local s-axis by -(amo\
unt given by ROTATE), then place the component. At the exit rotate back the magnet around the local s-axis at the exit, then take \
out displacement."],
p$1413=1+p$1413[[1,2]];p1$1413=StringPosition["Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet \
around the local s-axis by -(amount given by ROTATE), then place the component. At the exit rotate back the magnet around the loca\
l s-axis at the exit, then take out displacement."[p$1413,-1],">::",1];
   p1$1413=If[p1$1413==={},262,-2+p$1413+p1$1413[[1,1]]];
neq=Which["Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet around the local s-axis by -(amount \
given by ROTATE), then place the component. At the exit rotate back the magnet around the local s-axis at the exit, then take out \
displacement."[p$1413,4+p$1413]==="Text[",
    lx$1413:=Help2HTML`oa$;p$1413=5+p$1413;p1$1413-=1;p2$1413=5+p1$1413;p0$1413=-9+p$1413;If[(pe$1413=
StringPosition["Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet around the local s-axis by -(am\
ount given by ROTATE), then place the component. At the exit rotate back the magnet around the local s-axis at the exit, then take\
 out displacement."[p$1413,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet around the local s-axis by -(a\
mount given by ROTATE), then place the component. At the exit rotate back the magnet around the local s-axis at the exit, then tak\
e out displacement."[p$1413+pe$1413[[1,2]],p1$1413]]],
        p1$1413=-2+p$1413+pe$1413[[1,1]]}[[
       1]],
      0],
    1,lx$1413:=Help2HTML`o9$;p2$1413=4+p1$1413;p0$1413=-4+p$1413;0];
  If[(equ$1413=
Help2HTML`o8$["Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet around the local s-axis by -(amo\
unt given by ROTATE), then place the component. At the exit rotate back the magnet around the local s-axis at the exit, then take \
out displacement."[p$1413,p1$1413]])===
    Undefined,
equ$1413="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Rotation in x-y plane. After displacing the \
magnet by DX and DY, rotate the magnet around the local s-axis by -(amount given by ROTATE), then place the component. At the exit\
 rotate back the magnet around the local s-axis at the exit, then take out displacement."[p$1413,p1$1413]]=
       equ$1413;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1413},out$1413=lx$1413@Typeset["Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet around\
 the local s-axis by -(amount given by ROTATE), then place the component. At the exit rotate back the magnet around the local s-ax\
is at the exit, then take out displacement."[p$1413,p1$1413],Format->Help2HTML`oB$];
        System["mv -f "//out$1413//" "//equ$1413]];
      Exit[]]];
   "Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet around the local s-axis by -(amount given b\
y ROTATE), then place the component. At the exit rotate back the magnet around the local s-axis at the exit, then take out displac\
ement."[1,Max[p0$1413,0]]//"<img  class=\"eqs\" SRC=\""//equ$1413//"\" />"//
Help2HTML`oy$["Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet around the local s-axis by -(amo\
unt given by ROTATE), then place the component. At the exit rotate back the magnet around the local s-axis at the exit, then take \
out displacement."[p2$1413,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L84>DX</A> <A HREF=#L85>DY</A> <A HREF=#L83>DROTATE</A></PRE>
<LI>
<H3><A NAME=L96>
transformation:BEND</A></H3>
<PRE>The transformation of a bend depends on the value of K1. If K1 is zero, it is a series of transformations:

    (transformation due to misalignments)
   (drift to the entrance face)
<img  class="eqs" SRC="SADHelp_img/equ_93.svg" />
   (linear fringe at entrance face)
<img  class="eqs" SRC="SADHelp_img/equ_94.svg" />
   (nonlinear fringe at entrance)
<img  class="eqs" SRC="SADHelp_img/equ_95.svg" />
   (body of bend)
<img  class="eqs" SRC="SADHelp_img/equ_96.svg" />
   (nonlinear fringe at exit)
<img  class="eqs" SRC="SADHelp_img/equ_97.svg" />
   (linear fringe at exit face)
<img  class="eqs" SRC="SADHelp_img/equ_98.svg" />
   (drift from the exit face)
<img  class="eqs" SRC="SADHelp_img/equ_99.svg" />If[{},Help2HTML`oA$["\n   (transformation due to misalignments)\n\nIf K1 is nonzer
o, the effects from E1 and E2 are approximated by thin\nquadrupoles. Then the body is subdivided into\n\n   1 + floor(sqrt(abs(K1 L
')/(12 10^-5 EPS)))\n\npieces (EPS = 1 is used when EPS = 0), and the bend-body transformation above is done for each piece and the
 kick from K1 is applied alternatively. In FFS optics and Emittance calculations, or when the synchrotron radiation is turned on, t
he same algorithm as K1 <> 0 is applied."],p$1423=1+p$1423[[1,2]];p1$1423=StringPosition["\n   (transformation due to misalignments
)\n\nIf K1 is nonzero, the effects from E1 and E2 are approximated by thin\nquadrupoles. Then the body is subdivided into\n\n   1 +
 floor(sqrt(abs(K1 L')/(12 10^-5 EPS)))\n\npieces (EPS = 1 is used when EPS = 0), and the bend-body transformation above is done fo
r each piece and the kick from K1 is applied alternatively. In FFS optics and Emittance calculations, or when the synchrotron radia
tion is turned on, the same algorithm as K1 <> 0 is applied."[p$1423,-1],">::",1];p1$1423=If[p1$1423==={},486,-2+p$1423+p1$1423[[1,
1]]];neq=Which["\n   (transformation due to misalignments)\n\nIf K1 is nonzero, the effects from E1 and E2 are approximated by thin
\nquadrupoles. Then the body is subdivided into\n\n   1 + floor(sqrt(abs(K1 L')/(12 10^-5 EPS)))\n\npieces (EPS = 1 is used when EP
S = 0), and the bend-body transformation above is done for each piece and the kick from K1 is applied alternatively. In FFS optics 
and Emittance calculations, or when the synchrotron radiation is turned on, the same algorithm as K1 <> 0 is applied."[p$1423,4+p$1
423]==="Text[",lx$1423:=Help2HTML`oa$;p$1423=5+p$1423;p1$1423-=1;p2$1423=5+p1$1423;p0$1423=-9+p$1423;If[(pe$1423=StringPosition["\n
   (transformation due to misalignments)\n\nIf K1 is nonzero, the effects from E1 and E2 are approximated by thin\nquadrupoles. The
n the body is subdivided into\n\n   1 + floor(sqrt(abs(K1 L')/(12 10^-5 EPS)))\n\npieces (EPS = 1 is used when EPS = 0), and the be
nd-body transformation above is done for each piece and the kick from K1 is applied alternatively. In FFS optics and Emittance calc
ulations, or when the synchrotron radiation is turned on, the same algorithm as K1 <> 0 is applied."[p$1423,-2],";;;"])<=>{},{Max[0
,-1+ToExpression["\n   (transformation due to misalignments)\n\nIf K1 is nonzero, the effects from E1 and E2 are approximated by th
in\nquadrupoles. Then the body is subdivided into\n\n   1 + floor(sqrt(abs(K1 L')/(12 10^-5 EPS)))\n\npieces (EPS = 1 is used when 
EPS = 0), and the bend-body transformation above is done for each piece and the kick from K1 is applied alternatively. In FFS optic
s and Emittance calculations, or when the synchrotron radiation is turned on, the same algorithm as K1 <> 0 is applied."[p$1423+pe$
1423[[1,2]],p1$1423]]],p1$1423=-2+p$1423+pe$1423[[1,1]]}[[1]],0],1,lx$1423:=Help2HTML`o9$;p2$1423=4+p1$1423;p0$1423=-4+p$1423;0];If
[(equ$1423=Help2HTML`o8$["\n   (transformation due to misalignments)\n\nIf K1 is nonzero, the effects from E1 and E2 are approximat
ed by thin\nquadrupoles. Then the body is subdivided into\n\n   1 + floor(sqrt(abs(K1 L')/(12 10^-5 EPS)))\n\npieces (EPS = 1 is us
ed when EPS = 0), and the bend-body transformation above is done for each piece and the kick from K1 is applied alternatively. In F
FS optics and Emittance calculations, or when the synchrotron radiation is turned on, the same algorithm as K1 <> 0 is applied."[p$
1423,p1$1423]])===Undefined,equ$1423="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["\n   (transformat
ion due to misalignments)\n\nIf K1 is nonzero, the effects from E1 and E2 are approximated by thin\nquadrupoles. Then the body is s
ubdivided into\n\n   1 + floor(sqrt(abs(K1 L')/(12 10^-5 EPS)))\n\npieces (EPS = 1 is used when EPS = 0), and the bend-body transfo
rmation above is done for each piece and the kick from K1 is applied alternatively. In FFS optics and Emittance calculations, or wh
en the synchrotron radiation is turned on, the same algorithm as K1 <> 0 is applied."[p$1423,p1$1423]]=equ$1423;LaTeX`ob$+=neq,--La
TeX`ob$;With[{lx$1423},out$1423=lx$1423@Typeset["\n   (transformation due to misalignments)\n\nIf K1 is nonzero, the effects from E
1 and E2 are approximated by thin\nquadrupoles. Then the body is subdivided into\n\n   1 + floor(sqrt(abs(K1 L')/(12 10^-5 EPS)))\n
\npieces (EPS = 1 is used when EPS = 0), and the bend-body transformation above is done for each piece and the kick from K1 is appl
ied alternatively. In FFS optics and Emittance calculations, or when the synchrotron radiation is turned on, the same algorithm as 
K1 <> 0 is applied."[p$1423,p1$1423],Format->Help2HTML`oB$];System["mv -f "//out$1423//" "//equ$1423]];Exit[]]];"\n   (transformati
on due to misalignments)\n\nIf K1 is nonzero, the effects from E1 and E2 are approximated by thin\nquadrupoles. Then the body is su
bdivided into\n\n   1 + floor(sqrt(abs(K1 L')/(12 10^-5 EPS)))\n\npieces (EPS = 1 is used when EPS = 0), and the bend-body transfor
mation above is done for each piece and the kick from K1 is applied alternatively. In FFS optics and Emittance calculations, or whe
n the synchrotron radiation is turned on, the same algorithm as K1 <> 0 is applied."[1,Max[p0$1423,0]]//"<img  class=\"eqs\" SRC=\"
"//equ$1423//"\" />"//Help2HTML`oy$["\n   (transformation due to misalignments)\n\nIf K1 is nonzero, the effects from E1 and E2 are
 approximated by thin\nquadrupoles. Then the body is subdivided into\n\n   1 + floor(sqrt(abs(K1 L')/(12 10^-5 EPS)))\n\npieces (EP
S = 1 is used when EPS = 0), and the bend-body transformation above is done for each piece and the kick from K1 is applied alternat
ively. In FFS optics and Emittance calculations, or when the synchrotron radiation is turned on, the same algorithm as K1 <> 0 is a
pplied."[p2$1423,-1]]]
</PRE>
<PRE>See also:
 coordinates <A HREF=#L55>equilibrium-beam-envelope</A></PRE>
</UL>
<LI>
<H3><A NAME=L97>
CAVI</A></H3>
<PRE>If[{},Help2HTML`oA$["Accelerating structure."],
 p$1426=1+p$1426[[1,2]];p1$1426=StringPosition["Accelerating structure."[p$1426,-1],">::",1];
  p1$1426=If[p1$1426==={},23,-2+p$1426+p1$1426[[1,1]]];
  neq=Which["Accelerating structure."[p$1426,4+p$1426]==="Text[",lx$1426:=Help2HTML`oa$;p$1426=5+p$1426;p1$1426-=1;
     p2$1426=5+p1$1426;p0$1426=-9+p$1426;
     If[(pe$1426=StringPosition["Accelerating structure."[p$1426,-2],";;;"])<=>{},{Max[0,-1+ToExpression["Accelerating structure."[
            p$1426+pe$1426[[1,2]],
           p1$1426]]],
        p1$1426=-2+p$1426+pe$1426[[1,1]]}[[
       1]],
      0],
    1,lx$1426:=Help2HTML`o9$;p2$1426=4+p1$1426;p0$1426=-4+p$1426;0];
  If[(equ$1426=Help2HTML`o8$["Accelerating structure."[p$1426,p1$1426]])===Undefined,
   equ$1426="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["Accelerating structure."[p$1426,p1$1426]]=equ$1426;LaTeX`ob$+=neq,
     --LaTeX`ob$;With[{lx$1426},out$1426=lx$1426@Typeset["Accelerating structure."[p$1426,p1$1426],Format->Help2HTML`oB$];
        System["mv -f "//out$1426//" "//equ$1426]];
      Exit[]]];
   "Accelerating structure."[1,Max[p0$1426,0]]//"<img  class=\"eqs\" SRC=\""//equ$1426//"\" />"//
   Help2HTML`oy$["Accelerating structure."[p2$1426,-1]]
]</PRE>
<UL>
<LI>
<H3><A NAME=L98>
DISFRIN</A></H3>
<PRE>If[{},
Help2HTML`oA$["If nonzero, the Maxwellian fringe is suppressed. The effects of DISFRIN and FRINGE are summarized as\n\n           \
  DISFRIN=0          DISFRIN<>0\nFRINGE=0    entr & exit            none\nFRINGE=1       entr                none\nFRINGE=2       \
exit                none\nFRINGE=3    entr & exit            none"],
p$1428=1+p$1428[[1,2]];p1$1428=StringPosition["If nonzero, the Maxwellian fringe is suppressed. The effects of DISFRIN and FRINGE \
are summarized as\n\n             DISFRIN=0          DISFRIN<>0\nFRINGE=0    entr & exit            none\nFRINGE=1       entr     \
           none\nFRINGE=2       exit                none\nFRINGE=3    entr & exit            none"[p$1428,-1],">::",1];
   p1$1428=If[p1$1428==={},304,-2+p$1428+p1$1428[[1,1]]];
neq=Which["If nonzero, the Maxwellian fringe is suppressed. The effects of DISFRIN and FRINGE are summarized as\n\n             DI\
SFRIN=0          DISFRIN<>0\nFRINGE=0    entr & exit            none\nFRINGE=1       entr                none\nFRINGE=2       exit\
                none\nFRINGE=3    entr & exit            none"[p$1428,4+p$1428]==="Text[",
    lx$1428:=Help2HTML`oa$;p$1428=5+p$1428;p1$1428-=1;p2$1428=5+p1$1428;p0$1428=-9+p$1428;
If[(pe$1428=StringPosition["If nonzero, the Maxwellian fringe is suppressed. The effects of DISFRIN and FRINGE are summarized as\n\
\n             DISFRIN=0          DISFRIN<>0\nFRINGE=0    entr & exit            none\nFRINGE=1       entr                none\nFR\
INGE=2       exit                none\nFRINGE=3    entr & exit            none"[p$1428,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["If nonzero, the Maxwellian fringe is suppressed. The effects of DISFRIN and FRINGE are summarized as\n\n         \
    DISFRIN=0          DISFRIN<>0\nFRINGE=0    entr & exit            none\nFRINGE=1       entr                none\nFRINGE=2     \
  exit                none\nFRINGE=3    entr & exit            none"[p$1428+pe$1428[[1,2]],p1$1428]]],
        p1$1428=-2+p$1428+pe$1428[[1,1]]}[[
       1]],
      0],
    1,lx$1428:=Help2HTML`o9$;p2$1428=4+p1$1428;p0$1428=-4+p$1428;0];
  If[(equ$1428=
Help2HTML`o8$["If nonzero, the Maxwellian fringe is suppressed. The effects of DISFRIN and FRINGE are summarized as\n\n           \
  DISFRIN=0          DISFRIN<>0\nFRINGE=0    entr & exit            none\nFRINGE=1       entr                none\nFRINGE=2       \
exit                none\nFRINGE=3    entr & exit            none"[p$1428,p1$1428]])===
    Undefined,
equ$1428="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["If nonzero, the Maxwellian fringe is suppres\
sed. The effects of DISFRIN and FRINGE are summarized as\n\n             DISFRIN=0          DISFRIN<>0\nFRINGE=0    entr & exit   \
         none\nFRINGE=1       entr                none\nFRINGE=2       exit                none\nFRINGE=3    entr & exit          \
  none"[p$1428,p1$1428]]=
       equ$1428;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1428},out$1428=lx$1428@Typeset["If nonzero, the Maxwellian fringe is suppressed. The effects of DISFRIN and FRINGE are su\
mmarized as\n\n             DISFRIN=0          DISFRIN<>0\nFRINGE=0    entr & exit            none\nFRINGE=1       entr           \
     none\nFRINGE=2       exit                none\nFRINGE=3    entr & exit            none"[p$1428,p1$1428],
          Format->Help2HTML`oB$];
        System["mv -f "//out$1428//" "//equ$1428]];
      Exit[]]];
   "If nonzero, the Maxwellian fringe is suppressed. The effects of DISFRIN and FRINGE are summarized as\n\n             DISFRIN=0\
          DISFRIN<>0\nFRINGE=0    entr & exit            none\nFRINGE=1       entr                none\nFRINGE=2       exit       \
         none\nFRINGE=3    entr & exit            none"[1,Max[p0$1428,0]]//"<img  class=\"eqs\" SRC=\""//equ$1428//"\" />"//
   Help2HTML`oy$["If nonzero, the Maxwellian fringe is suppressed. The effects of DISFRIN and FRINGE are summarized as\n\n        \
     DISFRIN=0          DISFRIN<>0\nFRINGE=0    entr & exit            none\nFRINGE=1       entr                none\nFRINGE=2    \
   exit                none\nFRINGE=3    entr & exit            none"[p2$1428,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L91>FRINGE</A></PRE>
<LI>
<H3><A NAME=L99>
DPHI</A></H3>
<PRE> Relative phase offset. The stable synchrotron phase above the transition is near PHI = 0. The acceleration is given by 

<img  class="eqs" SRC="SADHelp_img/equ_100.svg" />If[{},Help2HTML`oA$["\n\nwhere ts is the equilibrium time determined by the valan
ce between the acceleration and the radiation loss around the ring. DPHI is not taken into account to determine the design momentum
 p0(s)."],p$1432=1+p$1432[[1,2]];p1$1432=StringPosition["\n\nwhere ts is the equilibrium time determined by the valance between the
 acceleration and the radiation loss around the ring. DPHI is not taken into account to determine the design momentum p0(s)."[p$143
2,-1],">::",1];p1$1432=If[p1$1432==={},196,-2+p$1432+p1$1432[[1,1]]];neq=Which["\n\nwhere ts is the equilibrium time determined by 
the valance between the acceleration and the radiation loss around the ring. DPHI is not taken into account to determine the design
 momentum p0(s)."[p$1432,4+p$1432]==="Text[",lx$1432:=Help2HTML`oa$;p$1432=5+p$1432;p1$1432-=1;p2$1432=5+p1$1432;p0$1432=-9+p$1432;
If[(pe$1432=StringPosition["\n\nwhere ts is the equilibrium time determined by the valance between the acceleration and the radiati
on loss around the ring. DPHI is not taken into account to determine the design momentum p0(s)."[p$1432,-2],";;;"])<=>{},{Max[0,-1+
ToExpression["\n\nwhere ts is the equilibrium time determined by the valance between the acceleration and the radiation loss around
 the ring. DPHI is not taken into account to determine the design momentum p0(s)."[p$1432+pe$1432[[1,2]],p1$1432]]],p1$1432=-2+p$14
32+pe$1432[[1,1]]}[[1]],0],1,lx$1432:=Help2HTML`o9$;p2$1432=4+p1$1432;p0$1432=-4+p$1432;0];If[(equ$1432=Help2HTML`o8$["\n\nwhere ts
 is the equilibrium time determined by the valance between the acceleration and the radiation loss around the ring. DPHI is not tak
en into account to determine the design momentum p0(s)."[p$1432,p1$1432]])===Undefined,equ$1432="SADHelp_img/equ_"//++LaTeX`ob$//".
"//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["\n\nwhere ts is the equilibrium time determined by the valance between the acceleration a
nd the radiation loss around the ring. DPHI is not taken into account to determine the design momentum p0(s)."[p$1432,p1$1432]]=equ
$1432;LaTeX`ob$+=neq,--LaTeX`ob$;With[{lx$1432},out$1432=lx$1432@Typeset["\n\nwhere ts is the equilibrium time determined by the va
lance between the acceleration and the radiation loss around the ring. DPHI is not taken into account to determine the design momen
tum p0(s)."[p$1432,p1$1432],Format->Help2HTML`oB$];System["mv -f "//out$1432//" "//equ$1432]];Exit[]]];"\n\nwhere ts is the equilib
rium time determined by the valance between the acceleration and the radiation loss around the ring. DPHI is not taken into account
 to determine the design momentum p0(s)."[1,Max[p0$1432,0]]//"<img  class=\"eqs\" SRC=\""//equ$1432//"\" />"//Help2HTML`oy$["\n\nwh
ere ts is the equilibrium time determined by the valance between the acceleration and the radiation loss around the ring. DPHI is n
ot taken into account to determine the design momentum p0(s)."[p2$1432,-1]]]
</PRE>
<PRE>See also:
 <A HREF=#L103>FREQ</A> <A HREF=#L111>VOLT</A> <A HREF=#L100>DVOLT</A> <A HREF=#L109>V1</A> V20 <A HREF=#L110>V11</A></PRE>
<LI>
<H3><A NAME=L100>
DVOLT</A></H3>
<PRE>If[{},Help2HTML`oA$["Additional accelerating voltage to be added to VOLT without affecting the design momentum."],
 p$1435=1+p$1435[[1,2]];
  p1$1435=StringPosition["Additional accelerating voltage to be added to VOLT without affecting the design momentum."[p$1435,-1],
    ">::",1];
   p1$1435=If[p1$1435==={},90,-2+p$1435+p1$1435[[1,1]]];
  neq=Which["Additional accelerating voltage to be added to VOLT without affecting the design momentum."[p$1435,4+p$1435]==="Text["
     ,
    lx$1435:=Help2HTML`oa$;p$1435=5+p$1435;p1$1435-=1;p2$1435=5+p1$1435;p0$1435=-9+p$1435;If[(pe$1435=StringPosition[
         "Additional accelerating voltage to be added to VOLT without affecting the design momentum."[p$1435,-2],";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression["Additional accelerating voltage to be added to VOLT without affecting the design momentum."[p$1435+pe$1435
            [[1,2]],
           p1$1435]]],
        p1$1435=-2+p$1435+pe$1435[[1,1]]}[[
       1]],
      0],
    1,lx$1435:=Help2HTML`o9$;p2$1435=4+p1$1435;p0$1435=-4+p$1435;0];
  If[(equ$1435=
     Help2HTML`o8$["Additional accelerating voltage to be added to VOLT without affecting the design momentum."[p$1435,p1$1435]]
     )===
    Undefined,
   equ$1435="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "Additional accelerating voltage to be added to VOLT without affecting the design momentum."[p$1435,p1$1435]]=
       equ$1435;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$1435},out$1435=lx$1435@Typeset[
          "Additional accelerating voltage to be added to VOLT without affecting the design momentum."[p$1435,p1$1435],
          Format->Help2HTML`oB$];
        System["mv -f "//out$1435//" "//equ$1435]];
      Exit[]]];
   "Additional accelerating voltage to be added to VOLT without affecting the design momentum."[1,Max[p0$1435,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$1435//"\" />"//
   Help2HTML`oy$["Additional accelerating voltage to be added to VOLT without affecting the design momentum."[p2$1435,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L111>VOLT</A></PRE>
<LI>
<H3><A NAME=L101>
DX</A></H3>
<PRE>If[{},Help2HTML`oA$["Horizontal displacement of magnet. This applied before the rotation by ROTATE."],
 p$1438=1+p$1438[[1,2]];p1$1438=
   StringPosition["Horizontal displacement of magnet. This applied before the rotation by ROTATE."[p$1438,-1],">::",1];
  p1$1438=If[p1$1438==={},78,-2+p$1438+p1$1438[[1,1]]];
  neq=Which["Horizontal displacement of magnet. This applied before the rotation by ROTATE."[p$1438,4+p$1438]==="Text[",
    lx$1438:=Help2HTML`oa$;p$1438=5+p$1438;p1$1438-=1;p2$1438=5+p1$1438;p0$1438=-9+p$1438;
     If[(pe$1438=StringPosition["Horizontal displacement of magnet. This applied before the rotation by ROTATE."[p$1438,-2],";;;"]
        )<=>
       {},
      {Max[0,
        -1+ToExpression["Horizontal displacement of magnet. This applied before the rotation by ROTATE."[p$1438+pe$1438[[1,2]],
           p1$1438]]],
        p1$1438=-2+p$1438+pe$1438[[1,1]]}[[
       1]],
      0],
    1,lx$1438:=Help2HTML`o9$;p2$1438=4+p1$1438;p0$1438=-4+p$1438;0];
  If[(equ$1438=Help2HTML`o8$["Horizontal displacement of magnet. This applied before the rotation by ROTATE."[p$1438,p1$1438]])===
    Undefined,
   equ$1438="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "Horizontal displacement of magnet. This applied before the rotation by ROTATE."[p$1438,p1$1438]]=
       equ$1438;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$1438},out$1438=lx$1438@Typeset["Horizontal displacement of magnet. This applied before the rotation by ROTATE."[p
           $1438,p1$1438],Format->Help2HTML`oB$];
        System["mv -f "//out$1438//" "//equ$1438]];
      Exit[]]];
   "Horizontal displacement of magnet. This applied before the rotation by ROTATE."[1,Max[p0$1438,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$1438//"\" />"//
   Help2HTML`oy$["Horizontal displacement of magnet. This applied before the rotation by ROTATE."[p2$1438,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L85>DY</A> <A HREF=#L95>ROTATE</A> <A HREF=#L83>DROTATE</A></PRE>
<LI>
<H3><A NAME=L102>
DY</A></H3>
<PRE>If[{},Help2HTML`oA$["Vertical displacement of magnet. This applied before the rotation by ROTATE."],
 p$1441=1+p$1441[[1,2]];p1$1441=
   StringPosition["Vertical displacement of magnet. This applied before the rotation by ROTATE."[p$1441,-1],">::",1];
  p1$1441=If[p1$1441==={},76,-2+p$1441+p1$1441[[1,1]]];
  neq=Which["Vertical displacement of magnet. This applied before the rotation by ROTATE."[p$1441,4+p$1441]==="Text[",
    lx$1441:=Help2HTML`oa$;p$1441=5+p$1441;p1$1441-=1;p2$1441=5+p1$1441;p0$1441=-9+p$1441;
     If[(pe$1441=StringPosition["Vertical displacement of magnet. This applied before the rotation by ROTATE."[p$1441,-2],";;;"]
        )<=>
       {},
      {Max[0,
        -1+ToExpression["Vertical displacement of magnet. This applied before the rotation by ROTATE."[p$1441+pe$1441[[1,2]],p1
           $1441]]],
        p1$1441=-2+p$1441+pe$1441[[1,1]]}[[
       1]],
      0],
    1,lx$1441:=Help2HTML`o9$;p2$1441=4+p1$1441;p0$1441=-4+p$1441;0];
  If[(equ$1441=Help2HTML`o8$["Vertical displacement of magnet. This applied before the rotation by ROTATE."[p$1441,p1$1441]])===
    Undefined,
   equ$1441="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "Vertical displacement of magnet. This applied before the rotation by ROTATE."[p$1441,p1$1441]]=
       equ$1441;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$1441},out$1441=lx$1441@Typeset["Vertical displacement of magnet. This applied before the rotation by ROTATE."[p$1441
           ,p1$1441],Format->Help2HTML`oB$];
        System["mv -f "//out$1441//" "//equ$1441]];
      Exit[]]];
   "Vertical displacement of magnet. This applied before the rotation by ROTATE."[1,Max[p0$1441,0]]//"<img  class=\"eqs\" SRC=\""//
   equ$1441//"\" />"//Help2HTML`oy$["Vertical displacement of magnet. This applied before the rotation by ROTATE."[p2$1441,-1]]
 ]
</PRE>
<PRE>See also:
 <A HREF=#L84>DX</A> <A HREF=#L95>ROTATE</A> <A HREF=#L83>DROTATE</A></PRE>
<LI>
<H3><A NAME=L103>
FREQ</A></H3>
<PRE> Rf frequency. If this keyword is nonzero, the keyword HARM is ignored.
<img  class="eqs" SRC="SADHelp_img/equ_100.svg" />
</PRE>
<PRE>See also:
 <A HREF=#L104>HARM</A></PRE>
<LI>
<H3><A NAME=L104>
HARM</A></H3>
<PRE>If[{},Help2HTML`oA$[" A harmonic number. This is valid only when FREQ is zero."],
 p$1447=1+p$1447[[1,2]];p1$1447=StringPosition[" A harmonic number. This is valid only when FREQ is zero."[p$1447,-1],">::",1];
  p1$1447=If[p1$1447==={},57,-2+p$1447+p1$1447[[1,1]]];
  neq=Which[" A harmonic number. This is valid only when FREQ is zero."[p$1447,4+p$1447]==="Text[",
    lx$1447:=Help2HTML`oa$;p$1447=5+p$1447;p1$1447-=1;p2$1447=5+p1$1447;p0$1447=-9+p$1447;
     If[(pe$1447=StringPosition[" A harmonic number. This is valid only when FREQ is zero."[p$1447,-2],";;;"])<=>{},
      {Max[0,-1+ToExpression[" A harmonic number. This is valid only when FREQ is zero."[p$1447+pe$1447[[1,2]],p1$1447]]],
       p1$1447=-2+p$1447+pe$1447[[1,1]]}[[1]],
      0],
    1,lx$1447:=Help2HTML`o9$;p2$1447=4+p1$1447;p0$1447=-4+p$1447;0];
  If[(equ$1447=Help2HTML`o8$[" A harmonic number. This is valid only when FREQ is zero."[p$1447,p1$1447]])===Undefined,
   equ$1447="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$[" A harmonic number. This is valid only when FREQ is zero."[p$1447,p1$1447]]=equ$1447;LaTeX`ob$+=neq,
     --LaTeX`ob$;
      With[{lx$1447},out$1447=lx$1447@Typeset[" A harmonic number. This is valid only when FREQ is zero."[p$1447,p1$1447],
          Format->Help2HTML`oB$];
        System["mv -f "//out$1447//" "//equ$1447]];
      Exit[]]];
   " A harmonic number. This is valid only when FREQ is zero."[1,Max[p0$1447,0]]//"<img  class=\"eqs\" SRC=\""//equ$1447//"\" />"//
   Help2HTML`oy$[" A harmonic number. This is valid only when FREQ is zero."[p2$1447,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L103>FREQ</A></PRE>
<LI>
<H3><A NAME=L105>
L</A></H3>
<PRE>If[{},Help2HTML`oA$["The effective length."],
 p$1450=1+p$1450[[1,2]];p1$1450=StringPosition["The effective length."[p$1450,-1],">::",1];
  p1$1450=If[p1$1450==={},21,-2+p$1450+p1$1450[[1,1]]];
  neq=Which["The effective length."[p$1450,4+p$1450]==="Text[",lx$1450:=Help2HTML`oa$;p$1450=5+p$1450;p1$1450-=1;p2$1450=5+p1$1450;
     p0$1450=-9+p$1450;
     If[(pe$1450=StringPosition["The effective length."[p$1450,-2],";;;"])<=>{},{Max[0,-1+ToExpression["The effective length."[p
            $1450+pe$1450[[1,2]],
           p1$1450]]],
        p1$1450=-2+p$1450+pe$1450[[1,1]]}[[
       1]],
      0],
    1,lx$1450:=Help2HTML`o9$;p2$1450=4+p1$1450;p0$1450=-4+p$1450;0];
  If[(equ$1450=Help2HTML`o8$["The effective length."[p$1450,p1$1450]])===Undefined,
   equ$1450="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["The effective length."[p$1450,p1$1450]]=equ$1450;LaTeX`ob$+=neq,
     --LaTeX`ob$;With[{lx$1450},out$1450=lx$1450@Typeset["The effective length."[p$1450,p1$1450],Format->Help2HTML`oB$];
        System["mv -f "//out$1450//" "//equ$1450]];
      Exit[]]];
   "The effective length."[1,Max[p0$1450,0]]//"<img  class=\"eqs\" SRC=\""//equ$1450//"\" />"//
   Help2HTML`oy$["The effective length."[p2$1450,-1]]
]</PRE>
<LI>
<H3><A NAME=L106>
PHI</A></H3>
<PRE> Relative phase offset. The stable synchrotron phase above the transition is near PHI = 0. The acceleration is given by 

<img  class="eqs" SRC="SADHelp_img/equ_100.svg" />If[{},Help2HTML`oA$["\n\nwhere ts is the equilibrium time determined by the valan
ce between the acceleration and the radiation loss around the ring."],p$1453=1+p$1453[[1,2]];p1$1453=StringPosition["\n\nwhere ts i
s the equilibrium time determined by the valance between the acceleration and the radiation loss around the ring."[p$1453,-1],">::"
,1];p1$1453=If[p1$1453==={},125,-2+p$1453+p1$1453[[1,1]]];neq=Which["\n\nwhere ts is the equilibrium time determined by the valance
 between the acceleration and the radiation loss around the ring."[p$1453,4+p$1453]==="Text[",lx$1453:=Help2HTML`oa$;p$1453=5+p$145
3;p1$1453-=1;p2$1453=5+p1$1453;p0$1453=-9+p$1453;If[(pe$1453=StringPosition["\n\nwhere ts is the equilibrium time determined by the
 valance between the acceleration and the radiation loss around the ring."[p$1453,-2],";;;"])<=>{},{Max[0,-1+ToExpression["\n\nwher
e ts is the equilibrium time determined by the valance between the acceleration and the radiation loss around the ring."[p$1453+pe$
1453[[1,2]],p1$1453]]],p1$1453=-2+p$1453+pe$1453[[1,1]]}[[1]],0],1,lx$1453:=Help2HTML`o9$;p2$1453=4+p1$1453;p0$1453=-4+p$1453;0];If
[(equ$1453=Help2HTML`o8$["\n\nwhere ts is the equilibrium time determined by the valance between the acceleration and the radiation
 loss around the ring."[p$1453,p1$1453]])===Undefined,equ$1453="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2H
TML`o8$["\n\nwhere ts is the equilibrium time determined by the valance between the acceleration and the radiation loss around the 
ring."[p$1453,p1$1453]]=equ$1453;LaTeX`ob$+=neq,--LaTeX`ob$;With[{lx$1453},out$1453=lx$1453@Typeset["\n\nwhere ts is the equilibriu
m time determined by the valance between the acceleration and the radiation loss around the ring."[p$1453,p1$1453],Format->Help2HTM
L`oB$];System["mv -f "//out$1453//" "//equ$1453]];Exit[]]];"\n\nwhere ts is the equilibrium time determined by the valance between 
the acceleration and the radiation loss around the ring."[1,Max[p0$1453,0]]//"<img  class=\"eqs\" SRC=\""//equ$1453//"\" />"//Help2
HTML`oy$["\n\nwhere ts is the equilibrium time determined by the valance between the acceleration and the radiation loss around the
 ring."[p2$1453,-1]]]
</PRE>
<PRE>See also:
 <A HREF=#L103>FREQ</A> <A HREF=#L111>VOLT</A> <A HREF=#L100>DVOLT</A> <A HREF=#L109>V1</A> V20 <A HREF=#L110>V11</A></PRE>
<LI>
<H3><A NAME=L107>
ROTATE</A></H3>
<PRE>If[{},
Help2HTML`oA$["Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet around the local s-axis by -(amo\
unt given by ROTATE), then place the component. At the exit rotate back the magnet around the local s-axis at the exit, then take \
out displacement."],
p$1456=1+p$1456[[1,2]];p1$1456=StringPosition["Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet \
around the local s-axis by -(amount given by ROTATE), then place the component. At the exit rotate back the magnet around the loca\
l s-axis at the exit, then take out displacement."[p$1456,-1],">::",1];
   p1$1456=If[p1$1456==={},262,-2+p$1456+p1$1456[[1,1]]];
neq=Which["Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet around the local s-axis by -(amount \
given by ROTATE), then place the component. At the exit rotate back the magnet around the local s-axis at the exit, then take out \
displacement."[p$1456,4+p$1456]==="Text[",
    lx$1456:=Help2HTML`oa$;p$1456=5+p$1456;p1$1456-=1;p2$1456=5+p1$1456;p0$1456=-9+p$1456;If[(pe$1456=
StringPosition["Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet around the local s-axis by -(am\
ount given by ROTATE), then place the component. At the exit rotate back the magnet around the local s-axis at the exit, then take\
 out displacement."[p$1456,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet around the local s-axis by -(a\
mount given by ROTATE), then place the component. At the exit rotate back the magnet around the local s-axis at the exit, then tak\
e out displacement."[p$1456+pe$1456[[1,2]],p1$1456]]],
        p1$1456=-2+p$1456+pe$1456[[1,1]]}[[
       1]],
      0],
    1,lx$1456:=Help2HTML`o9$;p2$1456=4+p1$1456;p0$1456=-4+p$1456;0];
  If[(equ$1456=
Help2HTML`o8$["Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet around the local s-axis by -(amo\
unt given by ROTATE), then place the component. At the exit rotate back the magnet around the local s-axis at the exit, then take \
out displacement."[p$1456,p1$1456]])===
    Undefined,
equ$1456="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Rotation in x-y plane. After displacing the \
magnet by DX and DY, rotate the magnet around the local s-axis by -(amount given by ROTATE), then place the component. At the exit\
 rotate back the magnet around the local s-axis at the exit, then take out displacement."[p$1456,p1$1456]]=
       equ$1456;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1456},out$1456=lx$1456@Typeset["Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet around\
 the local s-axis by -(amount given by ROTATE), then place the component. At the exit rotate back the magnet around the local s-ax\
is at the exit, then take out displacement."[p$1456,p1$1456],Format->Help2HTML`oB$];
        System["mv -f "//out$1456//" "//equ$1456]];
      Exit[]]];
   "Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet around the local s-axis by -(amount given b\
y ROTATE), then place the component. At the exit rotate back the magnet around the local s-axis at the exit, then take out displac\
ement."[1,Max[p0$1456,0]]//"<img  class=\"eqs\" SRC=\""//equ$1456//"\" />"//
Help2HTML`oy$["Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet around the local s-axis by -(amo\
unt given by ROTATE), then place the component. At the exit rotate back the magnet around the local s-axis at the exit, then take \
out displacement."[p2$1456,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L84>DX</A> <A HREF=#L85>DY</A> <A HREF=#L83>DROTATE</A></PRE>
<LI>
<H3><A NAME=L108>
V02</A></H3>
<PRE> The y^2-dependence of the acceleration. Tracking only.
<img  class="eqs" SRC="SADHelp_img/equ_100.svg" />
</PRE>
<PRE>See also:
 <A HREF=#L111>VOLT</A> <A HREF=#L100>DVOLT</A> <A HREF=#L109>V1</A> V20 <A HREF=#L110>V11</A></PRE>
<LI>
<H3><A NAME=L109>
V1</A></H3>
<PRE> The linear x-dependence of the acceleration. Tracking only.
<img  class="eqs" SRC="SADHelp_img/equ_100.svg" />
</PRE>
<PRE>See also:
 <A HREF=#L111>VOLT</A> <A HREF=#L100>DVOLT</A> <A HREF=#L109>V1</A> <A HREF=#L110>V11</A> <A HREF=#L108>V02</A></PRE>
<LI>
<H3><A NAME=L110>
V11</A></H3>
<PRE> The xy-dependence of the acceleration. Tracking only.
<img  class="eqs" SRC="SADHelp_img/equ_100.svg" />
</PRE>
<PRE>See also:
 <A HREF=#L111>VOLT</A> <A HREF=#L100>DVOLT</A> <A HREF=#L109>V1</A> V20 <A HREF=#L108>V02</A></PRE>
<LI>
<H3><A NAME=L111>
VOLT</A></H3>
<PRE>Accelerating peak voltage in Volt.

<img  class="eqs" SRC="SADHelp_img/equ_100.svg" />If[{},Help2HTML`oA$["\n\nwhere ts is the equilibrium time determined by the valan
ce between the acceleration and the radiation loss around the ring. (CAVI only) The non-relativistic corrections\n\n     (VOLT+DVOL
T)*(2 Pi FREQ/c)^2/(gamma beta)^2/4 are\n\nautomatically added to V20 and V02, respectively. The Lorentz factor is evaluated as inv
erse of average of 1/(beta gamma) at the entrance and the exit.\n   CAVI includes the edge effect at the lowest order, given by a H
amiltonian at the entrance edge at s0:\n\n   Hf = - (e (VOLT+DVOLT)/L)(Sin(omega t - dphi) + Sin(dphi) - offset) (x^2+y^2)/4 delta(
s-s0)\n where dphi and offset are determined by the cavity phase and the radiation loss, which is nonzero only in the case of NORAD
. The sign flips at the exit. This Hamiltonian should be consistent with what Kiyoshi Kubo derived."],p$1469=1+p$1469[[1,2]];p1$146
9=StringPosition["\n\nwhere ts is the equilibrium time determined by the valance between the acceleration and the radiation loss ar
ound the ring. (CAVI only) The non-relativistic corrections\n\n     (VOLT+DVOLT)*(2 Pi FREQ/c)^2/(gamma beta)^2/4 are\n\nautomatica
lly added to V20 and V02, respectively. The Lorentz factor is evaluated as inverse of average of 1/(beta gamma) at the entrance and
 the exit.\n   CAVI includes the edge effect at the lowest order, given by a Hamiltonian at the entrance edge at s0:\n\n   Hf = - (
e (VOLT+DVOLT)/L)(Sin(omega t - dphi) + Sin(dphi) - offset) (x^2+y^2)/4 delta(s-s0)\n where dphi and offset are determined by the c
avity phase and the radiation loss, which is nonzero only in the case of NORAD. The sign flips at the exit. This Hamiltonian should
 be consistent with what Kiyoshi Kubo derived."[p$1469,-1],">::",1];p1$1469=If[p1$1469==={},804,-2+p$1469+p1$1469[[1,1]]];neq=Which
["\n\nwhere ts is the equilibrium time determined by the valance between the acceleration and the radiation loss around the ring. (
CAVI only) The non-relativistic corrections\n\n     (VOLT+DVOLT)*(2 Pi FREQ/c)^2/(gamma beta)^2/4 are\n\nautomatically added to V20
 and V02, respectively. The Lorentz factor is evaluated as inverse of average of 1/(beta gamma) at the entrance and the exit.\n   C
AVI includes the edge effect at the lowest order, given by a Hamiltonian at the entrance edge at s0:\n\n   Hf = - (e (VOLT+DVOLT)/L
)(Sin(omega t - dphi) + Sin(dphi) - offset) (x^2+y^2)/4 delta(s-s0)\n where dphi and offset are determined by the cavity phase and 
the radiation loss, which is nonzero only in the case of NORAD. The sign flips at the exit. This Hamiltonian should be consistent w
ith what Kiyoshi Kubo derived."[p$1469,4+p$1469]==="Text[",lx$1469:=Help2HTML`oa$;p$1469=5+p$1469;p1$1469-=1;p2$1469=5+p1$1469;p0$1
469=-9+p$1469;If[(pe$1469=StringPosition["\n\nwhere ts is the equilibrium time determined by the valance between the acceleration a
nd the radiation loss around the ring. (CAVI only) The non-relativistic corrections\n\n     (VOLT+DVOLT)*(2 Pi FREQ/c)^2/(gamma bet
a)^2/4 are\n\nautomatically added to V20 and V02, respectively. The Lorentz factor is evaluated as inverse of average of 1/(beta ga
mma) at the entrance and the exit.\n   CAVI includes the edge effect at the lowest order, given by a Hamiltonian at the entrance ed
ge at s0:\n\n   Hf = - (e (VOLT+DVOLT)/L)(Sin(omega t - dphi) + Sin(dphi) - offset) (x^2+y^2)/4 delta(s-s0)\n where dphi and offset
 are determined by the cavity phase and the radiation loss, which is nonzero only in the case of NORAD. The sign flips at the exit.
 This Hamiltonian should be consistent with what Kiyoshi Kubo derived."[p$1469,-2],";;;"])<=>{},{Max[0,-1+ToExpression["\n\nwhere t
s is the equilibrium time determined by the valance between the acceleration and the radiation loss around the ring. (CAVI only) Th
e non-relativistic corrections\n\n     (VOLT+DVOLT)*(2 Pi FREQ/c)^2/(gamma beta)^2/4 are\n\nautomatically added to V20 and V02, res
pectively. The Lorentz factor is evaluated as inverse of average of 1/(beta gamma) at the entrance and the exit.\n   CAVI includes 
the edge effect at the lowest order, given by a Hamiltonian at the entrance edge at s0:\n\n   Hf = - (e (VOLT+DVOLT)/L)(Sin(omega t
 - dphi) + Sin(dphi) - offset) (x^2+y^2)/4 delta(s-s0)\n where dphi and offset are determined by the cavity phase and the radiation
 loss, which is nonzero only in the case of NORAD. The sign flips at the exit. This Hamiltonian should be consistent with what Kiyo
shi Kubo derived."[p$1469+pe$1469[[1,2]],p1$1469]]],p1$1469=-2+p$1469+pe$1469[[1,1]]}[[1]],0],1,lx$1469:=Help2HTML`o9$;p2$1469=4+p1
$1469;p0$1469=-4+p$1469;0];If[(equ$1469=Help2HTML`o8$["\n\nwhere ts is the equilibrium time determined by the valance between the a
cceleration and the radiation loss around the ring. (CAVI only) The non-relativistic corrections\n\n     (VOLT+DVOLT)*(2 Pi FREQ/c)
^2/(gamma beta)^2/4 are\n\nautomatically added to V20 and V02, respectively. The Lorentz factor is evaluated as inverse of average 
of 1/(beta gamma) at the entrance and the exit.\n   CAVI includes the edge effect at the lowest order, given by a Hamiltonian at th
e entrance edge at s0:\n\n   Hf = - (e (VOLT+DVOLT)/L)(Sin(omega t - dphi) + Sin(dphi) - offset) (x^2+y^2)/4 delta(s-s0)\n where dp
hi and offset are determined by the cavity phase and the radiation loss, which is nonzero only in the case of NORAD. The sign flips
 at the exit. This Hamiltonian should be consistent with what Kiyoshi Kubo derived."[p$1469,p1$1469]])===Undefined,equ$1469="SADHel
p_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["\n\nwhere ts is the equilibrium time determined by the valanc
e between the acceleration and the radiation loss around the ring. (CAVI only) The non-relativistic corrections\n\n     (VOLT+DVOLT
)*(2 Pi FREQ/c)^2/(gamma beta)^2/4 are\n\nautomatically added to V20 and V02, respectively. The Lorentz factor is evaluated as inve
rse of average of 1/(beta gamma) at the entrance and the exit.\n   CAVI includes the edge effect at the lowest order, given by a Ha
miltonian at the entrance edge at s0:\n\n   Hf = - (e (VOLT+DVOLT)/L)(Sin(omega t - dphi) + Sin(dphi) - offset) (x^2+y^2)/4 delta(s
-s0)\n where dphi and offset are determined by the cavity phase and the radiation loss, which is nonzero only in the case of NORAD.
 The sign flips at the exit. This Hamiltonian should be consistent with what Kiyoshi Kubo derived."[p$1469,p1$1469]]=equ$1469;LaTeX
`ob$+=neq,--LaTeX`ob$;With[{lx$1469},out$1469=lx$1469@Typeset["\n\nwhere ts is the equilibrium time determined by the valance betwe
en the acceleration and the radiation loss around the ring. (CAVI only) The non-relativistic corrections\n\n     (VOLT+DVOLT)*(2 Pi
 FREQ/c)^2/(gamma beta)^2/4 are\n\nautomatically added to V20 and V02, respectively. The Lorentz factor is evaluated as inverse of 
average of 1/(beta gamma) at the entrance and the exit.\n   CAVI includes the edge effect at the lowest order, given by a Hamiltoni
an at the entrance edge at s0:\n\n   Hf = - (e (VOLT+DVOLT)/L)(Sin(omega t - dphi) + Sin(dphi) - offset) (x^2+y^2)/4 delta(s-s0)\n 
where dphi and offset are determined by the cavity phase and the radiation loss, which is nonzero only in the case of NORAD. The si
gn flips at the exit. This Hamiltonian should be consistent with what Kiyoshi Kubo derived."[p$1469,p1$1469],Format->Help2HTML`oB$]
;System["mv -f "//out$1469//" "//equ$1469]];Exit[]]];"\n\nwhere ts is the equilibrium time determined by the valance between the ac
celeration and the radiation loss around the ring. (CAVI only) The non-relativistic corrections\n\n     (VOLT+DVOLT)*(2 Pi FREQ/c)^
2/(gamma beta)^2/4 are\n\nautomatically added to V20 and V02, respectively. The Lorentz factor is evaluated as inverse of average o
f 1/(beta gamma) at the entrance and the exit.\n   CAVI includes the edge effect at the lowest order, given by a Hamiltonian at the
 entrance edge at s0:\n\n   Hf = - (e (VOLT+DVOLT)/L)(Sin(omega t - dphi) + Sin(dphi) - offset) (x^2+y^2)/4 delta(s-s0)\n where dph
i and offset are determined by the cavity phase and the radiation loss, which is nonzero only in the case of NORAD. The sign flips 
at the exit. This Hamiltonian should be consistent with what Kiyoshi Kubo derived."[1,Max[p0$1469,0]]//"<img  class=\"eqs\" SRC=\""
//equ$1469//"\" />"//Help2HTML`oy$["\n\nwhere ts is the equilibrium time determined by the valance between the acceleration and the
 radiation loss around the ring. (CAVI only) The non-relativistic corrections\n\n     (VOLT+DVOLT)*(2 Pi FREQ/c)^2/(gamma beta)^2/4
 are\n\nautomatically added to V20 and V02, respectively. The Lorentz factor is evaluated as inverse of average of 1/(beta gamma) a
t the entrance and the exit.\n   CAVI includes the edge effect at the lowest order, given by a Hamiltonian at the entrance edge at 
s0:\n\n   Hf = - (e (VOLT+DVOLT)/L)(Sin(omega t - dphi) + Sin(dphi) - offset) (x^2+y^2)/4 delta(s-s0)\n where dphi and offset are d
etermined by the cavity phase and the radiation loss, which is nonzero only in the case of NORAD. The sign flips at the exit. This 
Hamiltonian should be consistent with what Kiyoshi Kubo derived."[p2$1469,-1]]]
</PRE>
<PRE>See also:
 <A HREF=#L100>DVOLT</A></PRE>
</UL>
<LI>
<H3><A NAME=L112>
COORD</A></H3>
<PRE>An element for an arbitrary coordinate transformation. This element can be used to express an off-axis element.

Usage: COORD name=(DX=dx DY=dy CHI1=chi1 CHI2=chi2 CHI3=chi3 DIR=dir); .

If dir is zero (default), the transformation of the coordinate by COORD is

<img  class="eqs" SRC="SADHelp_img/equ_101.svg" />

and if dir is nonzero,

<img  class="eqs" SRC="SADHelp_img/equ_102.svg" />

where {x, y, z}_1 are the new coordinates and

<img  class="eqs" SRC="SADHelp_img/equ_103.svg" />If[{},Help2HTML`oA$["\n\nNote that these transformationis are NOT the inverse to 
each other.\n\n   To use this element, you have to calculate the values of those parameters carefully. DISP G may help you but ther
e is no automatic way to get them. You may also have to be careful when you use a line with this element in the reverse direction.\
n\n   A better way to do an equivalent thing in most cases is to use SOL. Unlike COORD, SOL automatically determines the parameters
 for the coordinate transformation."],p$1475=1+p$1475[[1,2]];p1$1475=StringPosition["\n\nNote that these transformationis are NOT t
he inverse to each other.\n\n   To use this element, you have to calculate the values of those parameters carefully. DISP G may hel
p you but there is no automatic way to get them. You may also have to be careful when you use a line with this element in the rever
se direction.\n\n   A better way to do an equivalent thing in most cases is to use SOL. Unlike COORD, SOL automatically determines 
the parameters for the coordinate transformation."[p$1475,-1],">::",1];p1$1475=If[p1$1475==={},482,-2+p$1475+p1$1475[[1,1]]];neq=Wh
ich["\n\nNote that these transformationis are NOT the inverse to each other.\n\n   To use this element, you have to calculate the v
alues of those parameters carefully. DISP G may help you but there is no automatic way to get them. You may also have to be careful
 when you use a line with this element in the reverse direction.\n\n   A better way to do an equivalent thing in most cases is to u
se SOL. Unlike COORD, SOL automatically determines the parameters for the coordinate transformation."[p$1475,4+p$1475]==="Text[",lx
$1475:=Help2HTML`oa$;p$1475=5+p$1475;p1$1475-=1;p2$1475=5+p1$1475;p0$1475=-9+p$1475;If[(pe$1475=StringPosition["\n\nNote that these
 transformationis are NOT the inverse to each other.\n\n   To use this element, you have to calculate the values of those parameter
s carefully. DISP G may help you but there is no automatic way to get them. You may also have to be careful when you use a line wit
h this element in the reverse direction.\n\n   A better way to do an equivalent thing in most cases is to use SOL. Unlike COORD, SO
L automatically determines the parameters for the coordinate transformation."[p$1475,-2],";;;"])<=>{},{Max[0,-1+ToExpression["\n\nN
ote that these transformationis are NOT the inverse to each other.\n\n   To use this element, you have to calculate the values of t
hose parameters carefully. DISP G may help you but there is no automatic way to get them. You may also have to be careful when you 
use a line with this element in the reverse direction.\n\n   A better way to do an equivalent thing in most cases is to use SOL. Un
like COORD, SOL automatically determines the parameters for the coordinate transformation."[p$1475+pe$1475[[1,2]],p1$1475]]],p1$147
5=-2+p$1475+pe$1475[[1,1]]}[[1]],0],1,lx$1475:=Help2HTML`o9$;p2$1475=4+p1$1475;p0$1475=-4+p$1475;0];If[(equ$1475=Help2HTML`o8$["\n\
nNote that these transformationis are NOT the inverse to each other.\n\n   To use this element, you have to calculate the values of
 those parameters carefully. DISP G may help you but there is no automatic way to get them. You may also have to be careful when yo
u use a line with this element in the reverse direction.\n\n   A better way to do an equivalent thing in most cases is to use SOL. 
Unlike COORD, SOL automatically determines the parameters for the coordinate transformation."[p$1475,p1$1475]])===Undefined,equ$147
5="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["\n\nNote that these transformationis are NOT the inv
erse to each other.\n\n   To use this element, you have to calculate the values of those parameters carefully. DISP G may help you 
but there is no automatic way to get them. You may also have to be careful when you use a line with this element in the reverse dir
ection.\n\n   A better way to do an equivalent thing in most cases is to use SOL. Unlike COORD, SOL automatically determines the pa
rameters for the coordinate transformation."[p$1475,p1$1475]]=equ$1475;LaTeX`ob$+=neq,--LaTeX`ob$;With[{lx$1475},out$1475=lx$1475@T
ypeset["\n\nNote that these transformationis are NOT the inverse to each other.\n\n   To use this element, you have to calculate th
e values of those parameters carefully. DISP G may help you but there is no automatic way to get them. You may also have to be care
ful when you use a line with this element in the reverse direction.\n\n   A better way to do an equivalent thing in most cases is t
o use SOL. Unlike COORD, SOL automatically determines the parameters for the coordinate transformation."[p$1475,p1$1475],Format->He
lp2HTML`oB$];System["mv -f "//out$1475//" "//equ$1475]];Exit[]]];"\n\nNote that these transformationis are NOT the inverse to each 
other.\n\n   To use this element, you have to calculate the values of those parameters carefully. DISP G may help you but there is 
no automatic way to get them. You may also have to be careful when you use a line with this element in the reverse direction.\n\n  
 A better way to do an equivalent thing in most cases is to use SOL. Unlike COORD, SOL automatically determines the parameters for 
the coordinate transformation."[1,Max[p0$1475,0]]//"<img  class=\"eqs\" SRC=\""//equ$1475//"\" />"//Help2HTML`oy$["\n\nNote that th
ese transformationis are NOT the inverse to each other.\n\n   To use this element, you have to calculate the values of those parame
ters carefully. DISP G may help you but there is no automatic way to get them. You may also have to be careful when you use a line 
with this element in the reverse direction.\n\n   A better way to do an equivalent thing in most cases is to use SOL. Unlike COORD,
 SOL automatically determines the parameters for the coordinate transformation."[p2$1475,-1]]]
</PRE>
<PRE>See also:
 <A HREF=#L236>SOL</A> <A HREF=#L56>DISPLAY(DISP)</A></PRE>
<LI>
<H3><A NAME=L113>
default-keyword</A></H3>
<PRE>If[{},
Help2HTML`oA$["The default and available non-default variable keywords are:\n\ntype    default-keyword  non-default variable keywo\
rd\nDRIFT   L                -\nBEND    ANGLE            K1,K0,E1,E2\nQUAD    K1               ROTATE\nSEXT    K2               RO\
TATE\nOCT     K3               ROTATE\nDECA    K4               ROTATE\nDODECA  K5               ROTATE\nMULT    K1               \
K0,K2..K21,SK0,SK1,SK2..SK21,ROTATE,ANGLE\nMARK    -                AX,BX,EX,EPX,AY,BY,EY,EPY,R1,R2,R3,R4,DETR,\n                 \
        DX,DPX,DY,DPY,DZ,DDP,AZ,BZ,ZX,ZPX,ZY,ZPY"],
p$1478=1+p$1478[[1,2]];p1$1478=StringPosition["The default and available non-default variable keywords are:\n\ntype    default-key\
word  non-default variable keyword\nDRIFT   L                -\nBEND    ANGLE            K1,K0,E1,E2\nQUAD    K1               ROT\
ATE\nSEXT    K2               ROTATE\nOCT     K3               ROTATE\nDECA    K4               ROTATE\nDODECA  K5               R\
OTATE\nMULT    K1               K0,K2..K21,SK0,SK1,SK2..SK21,ROTATE,ANGLE\nMARK    -                AX,BX,EX,EPX,AY,BY,EY,EPY,R1,R\
2,R3,R4,DETR,\n                         DX,DPX,DY,DPY,DZ,DDP,AZ,BZ,ZX,ZPX,ZY,ZPY"[p$1478,-1],">::",1];
   p1$1478=If[p1$1478==={},541,-2+p$1478+p1$1478[[1,1]]];
neq=Which["The default and available non-default variable keywords are:\n\ntype    default-keyword  non-default variable keyword\n\
DRIFT   L                -\nBEND    ANGLE            K1,K0,E1,E2\nQUAD    K1               ROTATE\nSEXT    K2               ROTATE\
\nOCT     K3               ROTATE\nDECA    K4               ROTATE\nDODECA  K5               ROTATE\nMULT    K1               K0,K\
2..K21,SK0,SK1,SK2..SK21,ROTATE,ANGLE\nMARK    -                AX,BX,EX,EPX,AY,BY,EY,EPY,R1,R2,R3,R4,DETR,\n                     \
    DX,DPX,DY,DPY,DZ,DDP,AZ,BZ,ZX,ZPX,ZY,ZPY"[p$1478,4+p$1478]==="Text[",
    lx$1478:=Help2HTML`oa$;p$1478=5+p$1478;p1$1478-=1;p2$1478=5+p1$1478;p0$1478=-9+p$1478;
If[(pe$1478=StringPosition["The default and available non-default variable keywords are:\n\ntype    default-keyword  non-default v\
ariable keyword\nDRIFT   L                -\nBEND    ANGLE            K1,K0,E1,E2\nQUAD    K1               ROTATE\nSEXT    K2    \
           ROTATE\nOCT     K3               ROTATE\nDECA    K4               ROTATE\nDODECA  K5               ROTATE\nMULT    K1  \
             K0,K2..K21,SK0,SK1,SK2..SK21,ROTATE,ANGLE\nMARK    -                AX,BX,EX,EPX,AY,BY,EY,EPY,R1,R2,R3,R4,DETR,\n    \
                     DX,DPX,DY,DPY,DZ,DDP,AZ,BZ,ZX,ZPX,ZY,ZPY"[p$1478,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["The default and available non-default variable keywords are:\n\ntype    default-keyword  non-default variable key\
word\nDRIFT   L                -\nBEND    ANGLE            K1,K0,E1,E2\nQUAD    K1               ROTATE\nSEXT    K2               \
ROTATE\nOCT     K3               ROTATE\nDECA    K4               ROTATE\nDODECA  K5               ROTATE\nMULT    K1             \
  K0,K2..K21,SK0,SK1,SK2..SK21,ROTATE,ANGLE\nMARK    -                AX,BX,EX,EPX,AY,BY,EY,EPY,R1,R2,R3,R4,DETR,\n               \
          DX,DPX,DY,DPY,DZ,DDP,AZ,BZ,ZX,ZPX,ZY,ZPY"[p$1478+pe$1478[[1,2]],p1$1478]]],
        p1$1478=-2+p$1478+pe$1478[[1,1]]}[[
       1]],
      0],
    1,lx$1478:=Help2HTML`o9$;p2$1478=4+p1$1478;p0$1478=-4+p$1478;0];
  If[(equ$1478=
Help2HTML`o8$["The default and available non-default variable keywords are:\n\ntype    default-keyword  non-default variable keywo\
rd\nDRIFT   L                -\nBEND    ANGLE            K1,K0,E1,E2\nQUAD    K1               ROTATE\nSEXT    K2               RO\
TATE\nOCT     K3               ROTATE\nDECA    K4               ROTATE\nDODECA  K5               ROTATE\nMULT    K1               \
K0,K2..K21,SK0,SK1,SK2..SK21,ROTATE,ANGLE\nMARK    -                AX,BX,EX,EPX,AY,BY,EY,EPY,R1,R2,R3,R4,DETR,\n                 \
        DX,DPX,DY,DPY,DZ,DDP,AZ,BZ,ZX,ZPX,ZY,ZPY"[p$1478,p1$1478]])===
    Undefined,
equ$1478="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["The default and available non-default variab\
le keywords are:\n\ntype    default-keyword  non-default variable keyword\nDRIFT   L                -\nBEND    ANGLE            K1\
,K0,E1,E2\nQUAD    K1               ROTATE\nSEXT    K2               ROTATE\nOCT     K3               ROTATE\nDECA    K4          \
     ROTATE\nDODECA  K5               ROTATE\nMULT    K1               K0,K2..K21,SK0,SK1,SK2..SK21,ROTATE,ANGLE\nMARK    -       \
         AX,BX,EX,EPX,AY,BY,EY,EPY,R1,R2,R3,R4,DETR,\n                         DX,DPX,DY,DPY,DZ,DDP,AZ,BZ,ZX,ZPX,ZY,ZPY"[p$1478,
         p1$1478]]=
       equ$1478;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1478},out$1478=lx$1478@Typeset["The default and available non-default variable keywords are:\n\ntype    default-keyword  \
non-default variable keyword\nDRIFT   L                -\nBEND    ANGLE            K1,K0,E1,E2\nQUAD    K1               ROTATE\nS\
EXT    K2               ROTATE\nOCT     K3               ROTATE\nDECA    K4               ROTATE\nDODECA  K5               ROTATE\\
nMULT    K1               K0,K2..K21,SK0,SK1,SK2..SK21,ROTATE,ANGLE\nMARK    -                AX,BX,EX,EPX,AY,BY,EY,EPY,R1,R2,R3,R\
4,DETR,\n                         DX,DPX,DY,DPY,DZ,DDP,AZ,BZ,ZX,ZPX,ZY,ZPY"[p$1478,p1$1478],Format->Help2HTML`oB$];
        System["mv -f "//out$1478//" "//equ$1478]];
      Exit[]]];
   "The default and available non-default variable keywords are:\n\ntype    default-keyword  non-default variable keyword\nDRIFT  \
 L                -\nBEND    ANGLE            K1,K0,E1,E2\nQUAD    K1               ROTATE\nSEXT    K2               ROTATE\nOCT  \
   K3               ROTATE\nDECA    K4               ROTATE\nDODECA  K5               ROTATE\nMULT    K1               K0,K2..K21,\
SK0,SK1,SK2..SK21,ROTATE,ANGLE\nMARK    -                AX,BX,EX,EPX,AY,BY,EY,EPY,R1,R2,R3,R4,DETR,\n                         DX,\
DPX,DY,DPY,DZ,DDP,AZ,BZ,ZX,ZPX,ZY,ZPY"[1,Max[p0$1478,0]]//"<img  class=\"eqs\" SRC=\""//equ$1478//"\" />"//
Help2HTML`oy$["The default and available non-default variable keywords are:\n\ntype    default-keyword  non-default variable keywo\
rd\nDRIFT   L                -\nBEND    ANGLE            K1,K0,E1,E2\nQUAD    K1               ROTATE\nSEXT    K2               RO\
TATE\nOCT     K3               ROTATE\nDECA    K4               ROTATE\nDODECA  K5               ROTATE\nMULT    K1               \
K0,K2..K21,SK0,SK1,SK2..SK21,ROTATE,ANGLE\nMARK    -                AX,BX,EX,EPX,AY,BY,EY,EPY,R1,R2,R3,R4,DETR,\n                 \
        DX,DPX,DY,DPY,DZ,DDP,AZ,BZ,ZX,ZPX,ZY,ZPY"[p2$1478,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L136>keywords</A></PRE>
<LI>
<H3><A NAME=L114>
DECA</A></H3>
<PRE>If[{},Help2HTML`oA$["A decapole magnet."],
 p$1481=1+p$1481[[1,2]];p1$1481=StringPosition["A decapole magnet."[p$1481,-1],">::",1];
  p1$1481=If[p1$1481==={},18,-2+p$1481+p1$1481[[1,1]]];
  neq=Which["A decapole magnet."[p$1481,4+p$1481]==="Text[",lx$1481:=Help2HTML`oa$;p$1481=5+p$1481;p1$1481-=1;p2$1481=5+p1$1481;
     p0$1481=-9+p$1481;
     If[(pe$1481=StringPosition["A decapole magnet."[p$1481,-2],";;;"])<=>{},{Max[0,-1+ToExpression["A decapole magnet."[p$1481+
            pe$1481[[1,2]],
           p1$1481]]],
        p1$1481=-2+p$1481+pe$1481[[1,1]]}[[
       1]],
      0],
    1,lx$1481:=Help2HTML`o9$;p2$1481=4+p1$1481;p0$1481=-4+p$1481;0];
  If[(equ$1481=Help2HTML`o8$["A decapole magnet."[p$1481,p1$1481]])===Undefined,
   equ$1481="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["A decapole magnet."[p$1481,p1$1481]]=equ$1481;LaTeX`ob$+=neq,
     --LaTeX`ob$;With[{lx$1481},out$1481=lx$1481@Typeset["A decapole magnet."[p$1481,p1$1481],Format->Help2HTML`oB$];
        System["mv -f "//out$1481//" "//equ$1481]];
      Exit[]]];
   "A decapole magnet."[1,Max[p0$1481,0]]//"<img  class=\"eqs\" SRC=\""//equ$1481//"\" />"//
   Help2HTML`oy$["A decapole magnet."[p2$1481,-1]]
]</PRE>
<UL>
<LI>
<H3><A NAME=L115>
DISFRIN</A></H3>
<PRE>If[{},Help2HTML`oA$["If nonzero, the nonlinear Maxwellian fringe is suppressed."],
 p$1483=1+p$1483[[1,2]];p1$1483=StringPosition["If nonzero, the nonlinear Maxwellian fringe is suppressed."[p$1483,-1],">::",1];
  p1$1483=If[p1$1483==={},58,-2+p$1483+p1$1483[[1,1]]];
  neq=Which["If nonzero, the nonlinear Maxwellian fringe is suppressed."[p$1483,4+p$1483]==="Text[",
    lx$1483:=Help2HTML`oa$;p$1483=5+p$1483;p1$1483-=1;p2$1483=5+p1$1483;p0$1483=-9+p$1483;
     If[(pe$1483=StringPosition["If nonzero, the nonlinear Maxwellian fringe is suppressed."[p$1483,-2],";;;"])<=>{},
      {Max[0,-1+ToExpression["If nonzero, the nonlinear Maxwellian fringe is suppressed."[p$1483+pe$1483[[1,2]],p1$1483]]],
       p1$1483=-2+p$1483+pe$1483[[1,1]]}[[1]],
      0],
    1,lx$1483:=Help2HTML`o9$;p2$1483=4+p1$1483;p0$1483=-4+p$1483;0];
  If[(equ$1483=Help2HTML`o8$["If nonzero, the nonlinear Maxwellian fringe is suppressed."[p$1483,p1$1483]])===Undefined,
   equ$1483="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["If nonzero, the nonlinear Maxwellian fringe is suppressed."[p$1483,p1$1483]]=equ$1483;LaTeX`ob$+=neq,
     --LaTeX`ob$;
      With[{lx$1483},out$1483=lx$1483@Typeset["If nonzero, the nonlinear Maxwellian fringe is suppressed."[p$1483,p1$1483],
          Format->Help2HTML`oB$];
        System["mv -f "//out$1483//" "//equ$1483]];
      Exit[]]];
   "If nonzero, the nonlinear Maxwellian fringe is suppressed."[1,Max[p0$1483,0]]//"<img  class=\"eqs\" SRC=\""//equ$1483//
   "\" />"//Help2HTML`oy$["If nonzero, the nonlinear Maxwellian fringe is suppressed."[p2$1483,-1]]
]</PRE>
<LI>
<H3><A NAME=L116>
DISRAD</A></H3>
<PRE>If[{},Help2HTML`oA$["If nonzero, the synchrotron radiation in the particle-tracking is inhibited."],
 p$1485=1+p$1485[[1,2]];p1$1485=
   StringPosition["If nonzero, the synchrotron radiation in the particle-tracking is inhibited."[p$1485,-1],">::",1];
  p1$1485=If[p1$1485==={},76,-2+p$1485+p1$1485[[1,1]]];
  neq=Which["If nonzero, the synchrotron radiation in the particle-tracking is inhibited."[p$1485,4+p$1485]==="Text[",
    lx$1485:=Help2HTML`oa$;p$1485=5+p$1485;p1$1485-=1;p2$1485=5+p1$1485;p0$1485=-9+p$1485;
     If[(pe$1485=StringPosition["If nonzero, the synchrotron radiation in the particle-tracking is inhibited."[p$1485,-2],";;;"]
        )<=>
       {},
      {Max[0,
        -1+ToExpression["If nonzero, the synchrotron radiation in the particle-tracking is inhibited."[p$1485+pe$1485[[1,2]],p1
           $1485]]],
        p1$1485=-2+p$1485+pe$1485[[1,1]]}[[
       1]],
      0],
    1,lx$1485:=Help2HTML`o9$;p2$1485=4+p1$1485;p0$1485=-4+p$1485;0];
  If[(equ$1485=Help2HTML`o8$["If nonzero, the synchrotron radiation in the particle-tracking is inhibited."[p$1485,p1$1485]])===
    Undefined,
   equ$1485="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "If nonzero, the synchrotron radiation in the particle-tracking is inhibited."[p$1485,p1$1485]]=
       equ$1485;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$1485},out$1485=lx$1485@Typeset["If nonzero, the synchrotron radiation in the particle-tracking is inhibited."[p$1485
           ,p1$1485],Format->Help2HTML`oB$];
        System["mv -f "//out$1485//" "//equ$1485]];
      Exit[]]];
   "If nonzero, the synchrotron radiation in the particle-tracking is inhibited."[1,Max[p0$1485,0]]//"<img  class=\"eqs\" SRC=\""//
   equ$1485//"\" />"//Help2HTML`oy$["If nonzero, the synchrotron radiation in the particle-tracking is inhibited."[p2$1485,-1]]
 ]
</PRE>
<PRE>See also:
 <A HREF=#L337>RAD</A></PRE>
<LI>
<H3><A NAME=L117>
DX</A></H3>
<PRE>If[{},Help2HTML`oA$["Horizontal displacement of magnet. This applied before the rotation by ROTATE."],
 p$1488=1+p$1488[[1,2]];p1$1488=
   StringPosition["Horizontal displacement of magnet. This applied before the rotation by ROTATE."[p$1488,-1],">::",1];
  p1$1488=If[p1$1488==={},78,-2+p$1488+p1$1488[[1,1]]];
  neq=Which["Horizontal displacement of magnet. This applied before the rotation by ROTATE."[p$1488,4+p$1488]==="Text[",
    lx$1488:=Help2HTML`oa$;p$1488=5+p$1488;p1$1488-=1;p2$1488=5+p1$1488;p0$1488=-9+p$1488;
     If[(pe$1488=StringPosition["Horizontal displacement of magnet. This applied before the rotation by ROTATE."[p$1488,-2],";;;"]
        )<=>
       {},
      {Max[0,
        -1+ToExpression["Horizontal displacement of magnet. This applied before the rotation by ROTATE."[p$1488+pe$1488[[1,2]],
           p1$1488]]],
        p1$1488=-2+p$1488+pe$1488[[1,1]]}[[
       1]],
      0],
    1,lx$1488:=Help2HTML`o9$;p2$1488=4+p1$1488;p0$1488=-4+p$1488;0];
  If[(equ$1488=Help2HTML`o8$["Horizontal displacement of magnet. This applied before the rotation by ROTATE."[p$1488,p1$1488]])===
    Undefined,
   equ$1488="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "Horizontal displacement of magnet. This applied before the rotation by ROTATE."[p$1488,p1$1488]]=
       equ$1488;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$1488},out$1488=lx$1488@Typeset["Horizontal displacement of magnet. This applied before the rotation by ROTATE."[p
           $1488,p1$1488],Format->Help2HTML`oB$];
        System["mv -f "//out$1488//" "//equ$1488]];
      Exit[]]];
   "Horizontal displacement of magnet. This applied before the rotation by ROTATE."[1,Max[p0$1488,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$1488//"\" />"//
   Help2HTML`oy$["Horizontal displacement of magnet. This applied before the rotation by ROTATE."[p2$1488,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L85>DY</A> <A HREF=#L95>ROTATE</A> <A HREF=#L83>DROTATE</A></PRE>
<LI>
<H3><A NAME=L118>
DY</A></H3>
<PRE>If[{},Help2HTML`oA$["Vertical displacement of magnet. This applied before the rotation by ROTATE."],
 p$1491=1+p$1491[[1,2]];p1$1491=
   StringPosition["Vertical displacement of magnet. This applied before the rotation by ROTATE."[p$1491,-1],">::",1];
  p1$1491=If[p1$1491==={},76,-2+p$1491+p1$1491[[1,1]]];
  neq=Which["Vertical displacement of magnet. This applied before the rotation by ROTATE."[p$1491,4+p$1491]==="Text[",
    lx$1491:=Help2HTML`oa$;p$1491=5+p$1491;p1$1491-=1;p2$1491=5+p1$1491;p0$1491=-9+p$1491;
     If[(pe$1491=StringPosition["Vertical displacement of magnet. This applied before the rotation by ROTATE."[p$1491,-2],";;;"]
        )<=>
       {},
      {Max[0,
        -1+ToExpression["Vertical displacement of magnet. This applied before the rotation by ROTATE."[p$1491+pe$1491[[1,2]],p1
           $1491]]],
        p1$1491=-2+p$1491+pe$1491[[1,1]]}[[
       1]],
      0],
    1,lx$1491:=Help2HTML`o9$;p2$1491=4+p1$1491;p0$1491=-4+p$1491;0];
  If[(equ$1491=Help2HTML`o8$["Vertical displacement of magnet. This applied before the rotation by ROTATE."[p$1491,p1$1491]])===
    Undefined,
   equ$1491="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "Vertical displacement of magnet. This applied before the rotation by ROTATE."[p$1491,p1$1491]]=
       equ$1491;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$1491},out$1491=lx$1491@Typeset["Vertical displacement of magnet. This applied before the rotation by ROTATE."[p$1491
           ,p1$1491],Format->Help2HTML`oB$];
        System["mv -f "//out$1491//" "//equ$1491]];
      Exit[]]];
   "Vertical displacement of magnet. This applied before the rotation by ROTATE."[1,Max[p0$1491,0]]//"<img  class=\"eqs\" SRC=\""//
   equ$1491//"\" />"//Help2HTML`oy$["Vertical displacement of magnet. This applied before the rotation by ROTATE."[p2$1491,-1]]
 ]
</PRE>
<PRE>See also:
 <A HREF=#L84>DX</A> <A HREF=#L95>ROTATE</A> <A HREF=#L83>DROTATE</A></PRE>
<LI>
<H3><A NAME=L119>
K4</A></H3>
<PRE>The normal decapole magnetic field component (times the length L).

<img  class="eqs" SRC="SADHelp_img/equ_104.svg" />If[{},Help2HTML`oA$["\n\nwhere L is the effective length of the component. Positi
ve sign means horizontal focusing."],p$1495=1+p$1495[[1,2]];p1$1495=StringPosition["\n\nwhere L is the effective length of the comp
onent. Positive sign means horizontal focusing."[p$1495,-1],">::",1];p1$1495=If[p1$1495==={},92,-2+p$1495+p1$1495[[1,1]]];neq=Which
["\n\nwhere L is the effective length of the component. Positive sign means horizontal focusing."[p$1495,4+p$1495]==="Text[",lx$149
5:=Help2HTML`oa$;p$1495=5+p$1495;p1$1495-=1;p2$1495=5+p1$1495;p0$1495=-9+p$1495;If[(pe$1495=StringPosition["\n\nwhere L is the effe
ctive length of the component. Positive sign means horizontal focusing."[p$1495,-2],";;;"])<=>{},{Max[0,-1+ToExpression["\n\nwhere 
L is the effective length of the component. Positive sign means horizontal focusing."[p$1495+pe$1495[[1,2]],p1$1495]]],p1$1495=-2+p
$1495+pe$1495[[1,1]]}[[1]],0],1,lx$1495:=Help2HTML`o9$;p2$1495=4+p1$1495;p0$1495=-4+p$1495;0];If[(equ$1495=Help2HTML`o8$["\n\nwhere
 L is the effective length of the component. Positive sign means horizontal focusing."[p$1495,p1$1495]])===Undefined,equ$1495="SADH
elp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["\n\nwhere L is the effective length of the component. Posit
ive sign means horizontal focusing."[p$1495,p1$1495]]=equ$1495;LaTeX`ob$+=neq,--LaTeX`ob$;With[{lx$1495},out$1495=lx$1495@Typeset["
\n\nwhere L is the effective length of the component. Positive sign means horizontal focusing."[p$1495,p1$1495],Format->Help2HTML`o
B$];System["mv -f "//out$1495//" "//equ$1495]];Exit[]]];"\n\nwhere L is the effective length of the component. Positive sign means 
horizontal focusing."[1,Max[p0$1495,0]]//"<img  class=\"eqs\" SRC=\""//equ$1495//"\" />"//Help2HTML`oy$["\n\nwhere L is the effecti
ve length of the component. Positive sign means horizontal focusing."[p2$1495,-1]]]
</PRE>
<PRE>See also:
 <A HREF=#L94>L</A></PRE>
<LI>
<H3><A NAME=L120>
L</A></H3>
<PRE>If[{},Help2HTML`oA$["The effective length."],
 p$1498=1+p$1498[[1,2]];p1$1498=StringPosition["The effective length."[p$1498,-1],">::",1];
  p1$1498=If[p1$1498==={},21,-2+p$1498+p1$1498[[1,1]]];
  neq=Which["The effective length."[p$1498,4+p$1498]==="Text[",lx$1498:=Help2HTML`oa$;p$1498=5+p$1498;p1$1498-=1;p2$1498=5+p1$1498;
     p0$1498=-9+p$1498;
     If[(pe$1498=StringPosition["The effective length."[p$1498,-2],";;;"])<=>{},{Max[0,-1+ToExpression["The effective length."[p
            $1498+pe$1498[[1,2]],
           p1$1498]]],
        p1$1498=-2+p$1498+pe$1498[[1,1]]}[[
       1]],
      0],
    1,lx$1498:=Help2HTML`o9$;p2$1498=4+p1$1498;p0$1498=-4+p$1498;0];
  If[(equ$1498=Help2HTML`o8$["The effective length."[p$1498,p1$1498]])===Undefined,
   equ$1498="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["The effective length."[p$1498,p1$1498]]=equ$1498;LaTeX`ob$+=neq,
     --LaTeX`ob$;With[{lx$1498},out$1498=lx$1498@Typeset["The effective length."[p$1498,p1$1498],Format->Help2HTML`oB$];
        System["mv -f "//out$1498//" "//equ$1498]];
      Exit[]]];
   "The effective length."[1,Max[p0$1498,0]]//"<img  class=\"eqs\" SRC=\""//equ$1498//"\" />"//
   Help2HTML`oy$["The effective length."[p2$1498,-1]]
]</PRE>
<LI>
<H3><A NAME=L121>
ROTATE</A></H3>
<PRE>If[{},
Help2HTML`oA$["Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet around the local s-axis by -(amo\
unt given by ROTATE), then place the component. At the exit rotate back the magnet around the local s-axis at the exit, then take \
out displacement."],
p$1500=1+p$1500[[1,2]];p1$1500=StringPosition["Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet \
around the local s-axis by -(amount given by ROTATE), then place the component. At the exit rotate back the magnet around the loca\
l s-axis at the exit, then take out displacement."[p$1500,-1],">::",1];
   p1$1500=If[p1$1500==={},262,-2+p$1500+p1$1500[[1,1]]];
neq=Which["Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet around the local s-axis by -(amount \
given by ROTATE), then place the component. At the exit rotate back the magnet around the local s-axis at the exit, then take out \
displacement."[p$1500,4+p$1500]==="Text[",
    lx$1500:=Help2HTML`oa$;p$1500=5+p$1500;p1$1500-=1;p2$1500=5+p1$1500;p0$1500=-9+p$1500;If[(pe$1500=
StringPosition["Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet around the local s-axis by -(am\
ount given by ROTATE), then place the component. At the exit rotate back the magnet around the local s-axis at the exit, then take\
 out displacement."[p$1500,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet around the local s-axis by -(a\
mount given by ROTATE), then place the component. At the exit rotate back the magnet around the local s-axis at the exit, then tak\
e out displacement."[p$1500+pe$1500[[1,2]],p1$1500]]],
        p1$1500=-2+p$1500+pe$1500[[1,1]]}[[
       1]],
      0],
    1,lx$1500:=Help2HTML`o9$;p2$1500=4+p1$1500;p0$1500=-4+p$1500;0];
  If[(equ$1500=
Help2HTML`o8$["Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet around the local s-axis by -(amo\
unt given by ROTATE), then place the component. At the exit rotate back the magnet around the local s-axis at the exit, then take \
out displacement."[p$1500,p1$1500]])===
    Undefined,
equ$1500="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Rotation in x-y plane. After displacing the \
magnet by DX and DY, rotate the magnet around the local s-axis by -(amount given by ROTATE), then place the component. At the exit\
 rotate back the magnet around the local s-axis at the exit, then take out displacement."[p$1500,p1$1500]]=
       equ$1500;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1500},out$1500=lx$1500@Typeset["Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet around\
 the local s-axis by -(amount given by ROTATE), then place the component. At the exit rotate back the magnet around the local s-ax\
is at the exit, then take out displacement."[p$1500,p1$1500],Format->Help2HTML`oB$];
        System["mv -f "//out$1500//" "//equ$1500]];
      Exit[]]];
   "Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet around the local s-axis by -(amount given b\
y ROTATE), then place the component. At the exit rotate back the magnet around the local s-axis at the exit, then take out displac\
ement."[1,Max[p0$1500,0]]//"<img  class=\"eqs\" SRC=\""//equ$1500//"\" />"//
Help2HTML`oy$["Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet around the local s-axis by -(amo\
unt given by ROTATE), then place the component. At the exit rotate back the magnet around the local s-axis at the exit, then take \
out displacement."[p2$1500,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L84>DX</A> <A HREF=#L85>DY</A> <A HREF=#L83>DROTATE</A></PRE>
<LI>
<H3><A NAME=L122>
transformation:THIN</A></H3>
<PRE><img  class="eqs" SRC="SADHelp_img/equ_105.svg" />
</PRE>
</UL>
<LI>
<H3><A NAME=L123>
DODECA</A></H3>
<PRE>If[{},Help2HTML`oA$["A dodecapole magnet."],
 p$1505=1+p$1505[[1,2]];p1$1505=StringPosition["A dodecapole magnet."[p$1505,-1],">::",1];
  p1$1505=If[p1$1505==={},20,-2+p$1505+p1$1505[[1,1]]];
  neq=Which["A dodecapole magnet."[p$1505,4+p$1505]==="Text[",lx$1505:=Help2HTML`oa$;p$1505=5+p$1505;p1$1505-=1;p2$1505=5+p1$1505;
     p0$1505=-9+p$1505;
     If[(pe$1505=StringPosition["A dodecapole magnet."[p$1505,-2],";;;"])<=>{},{Max[0,-1+ToExpression["A dodecapole magnet."[p$1505
            +pe$1505[[1,2]],
           p1$1505]]],
        p1$1505=-2+p$1505+pe$1505[[1,1]]}[[
       1]],
      0],
    1,lx$1505:=Help2HTML`o9$;p2$1505=4+p1$1505;p0$1505=-4+p$1505;0];
  If[(equ$1505=Help2HTML`o8$["A dodecapole magnet."[p$1505,p1$1505]])===Undefined,
   equ$1505="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["A dodecapole magnet."[p$1505,p1$1505]]=equ$1505;LaTeX`ob$+=neq,
     --LaTeX`ob$;With[{lx$1505},out$1505=lx$1505@Typeset["A dodecapole magnet."[p$1505,p1$1505],Format->Help2HTML`oB$];
        System["mv -f "//out$1505//" "//equ$1505]];
      Exit[]]];
   "A dodecapole magnet."[1,Max[p0$1505,0]]//"<img  class=\"eqs\" SRC=\""//equ$1505//"\" />"//
   Help2HTML`oy$["A dodecapole magnet."[p2$1505,-1]]
]</PRE>
<UL>
<LI>
<H3><A NAME=L124>
DISFRIN</A></H3>
<PRE>If[{},Help2HTML`oA$["If nonzero, the nonlinear Maxwellian fringe is suppressed."],
 p$1507=1+p$1507[[1,2]];p1$1507=StringPosition["If nonzero, the nonlinear Maxwellian fringe is suppressed."[p$1507,-1],">::",1];
  p1$1507=If[p1$1507==={},58,-2+p$1507+p1$1507[[1,1]]];
  neq=Which["If nonzero, the nonlinear Maxwellian fringe is suppressed."[p$1507,4+p$1507]==="Text[",
    lx$1507:=Help2HTML`oa$;p$1507=5+p$1507;p1$1507-=1;p2$1507=5+p1$1507;p0$1507=-9+p$1507;
     If[(pe$1507=StringPosition["If nonzero, the nonlinear Maxwellian fringe is suppressed."[p$1507,-2],";;;"])<=>{},
      {Max[0,-1+ToExpression["If nonzero, the nonlinear Maxwellian fringe is suppressed."[p$1507+pe$1507[[1,2]],p1$1507]]],
       p1$1507=-2+p$1507+pe$1507[[1,1]]}[[1]],
      0],
    1,lx$1507:=Help2HTML`o9$;p2$1507=4+p1$1507;p0$1507=-4+p$1507;0];
  If[(equ$1507=Help2HTML`o8$["If nonzero, the nonlinear Maxwellian fringe is suppressed."[p$1507,p1$1507]])===Undefined,
   equ$1507="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["If nonzero, the nonlinear Maxwellian fringe is suppressed."[p$1507,p1$1507]]=equ$1507;LaTeX`ob$+=neq,
     --LaTeX`ob$;
      With[{lx$1507},out$1507=lx$1507@Typeset["If nonzero, the nonlinear Maxwellian fringe is suppressed."[p$1507,p1$1507],
          Format->Help2HTML`oB$];
        System["mv -f "//out$1507//" "//equ$1507]];
      Exit[]]];
   "If nonzero, the nonlinear Maxwellian fringe is suppressed."[1,Max[p0$1507,0]]//"<img  class=\"eqs\" SRC=\""//equ$1507//
   "\" />"//Help2HTML`oy$["If nonzero, the nonlinear Maxwellian fringe is suppressed."[p2$1507,-1]]
]</PRE>
<LI>
<H3><A NAME=L125>
DISRAD</A></H3>
<PRE>If[{},Help2HTML`oA$["If nonzero, the synchrotron radiation in the particle-tracking is inhibited."],
 p$1509=1+p$1509[[1,2]];p1$1509=
   StringPosition["If nonzero, the synchrotron radiation in the particle-tracking is inhibited."[p$1509,-1],">::",1];
  p1$1509=If[p1$1509==={},76,-2+p$1509+p1$1509[[1,1]]];
  neq=Which["If nonzero, the synchrotron radiation in the particle-tracking is inhibited."[p$1509,4+p$1509]==="Text[",
    lx$1509:=Help2HTML`oa$;p$1509=5+p$1509;p1$1509-=1;p2$1509=5+p1$1509;p0$1509=-9+p$1509;
     If[(pe$1509=StringPosition["If nonzero, the synchrotron radiation in the particle-tracking is inhibited."[p$1509,-2],";;;"]
        )<=>
       {},
      {Max[0,
        -1+ToExpression["If nonzero, the synchrotron radiation in the particle-tracking is inhibited."[p$1509+pe$1509[[1,2]],p1
           $1509]]],
        p1$1509=-2+p$1509+pe$1509[[1,1]]}[[
       1]],
      0],
    1,lx$1509:=Help2HTML`o9$;p2$1509=4+p1$1509;p0$1509=-4+p$1509;0];
  If[(equ$1509=Help2HTML`o8$["If nonzero, the synchrotron radiation in the particle-tracking is inhibited."[p$1509,p1$1509]])===
    Undefined,
   equ$1509="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "If nonzero, the synchrotron radiation in the particle-tracking is inhibited."[p$1509,p1$1509]]=
       equ$1509;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$1509},out$1509=lx$1509@Typeset["If nonzero, the synchrotron radiation in the particle-tracking is inhibited."[p$1509
           ,p1$1509],Format->Help2HTML`oB$];
        System["mv -f "//out$1509//" "//equ$1509]];
      Exit[]]];
   "If nonzero, the synchrotron radiation in the particle-tracking is inhibited."[1,Max[p0$1509,0]]//"<img  class=\"eqs\" SRC=\""//
   equ$1509//"\" />"//Help2HTML`oy$["If nonzero, the synchrotron radiation in the particle-tracking is inhibited."[p2$1509,-1]]
 ]
</PRE>
<PRE>See also:
 <A HREF=#L337>RAD</A></PRE>
<LI>
<H3><A NAME=L126>
DX</A></H3>
<PRE>If[{},Help2HTML`oA$["Horizontal displacement of magnet. This applied before the rotation by ROTATE."],
 p$1512=1+p$1512[[1,2]];p1$1512=
   StringPosition["Horizontal displacement of magnet. This applied before the rotation by ROTATE."[p$1512,-1],">::",1];
  p1$1512=If[p1$1512==={},78,-2+p$1512+p1$1512[[1,1]]];
  neq=Which["Horizontal displacement of magnet. This applied before the rotation by ROTATE."[p$1512,4+p$1512]==="Text[",
    lx$1512:=Help2HTML`oa$;p$1512=5+p$1512;p1$1512-=1;p2$1512=5+p1$1512;p0$1512=-9+p$1512;
     If[(pe$1512=StringPosition["Horizontal displacement of magnet. This applied before the rotation by ROTATE."[p$1512,-2],";;;"]
        )<=>
       {},
      {Max[0,
        -1+ToExpression["Horizontal displacement of magnet. This applied before the rotation by ROTATE."[p$1512+pe$1512[[1,2]],
           p1$1512]]],
        p1$1512=-2+p$1512+pe$1512[[1,1]]}[[
       1]],
      0],
    1,lx$1512:=Help2HTML`o9$;p2$1512=4+p1$1512;p0$1512=-4+p$1512;0];
  If[(equ$1512=Help2HTML`o8$["Horizontal displacement of magnet. This applied before the rotation by ROTATE."[p$1512,p1$1512]])===
    Undefined,
   equ$1512="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "Horizontal displacement of magnet. This applied before the rotation by ROTATE."[p$1512,p1$1512]]=
       equ$1512;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$1512},out$1512=lx$1512@Typeset["Horizontal displacement of magnet. This applied before the rotation by ROTATE."[p
           $1512,p1$1512],Format->Help2HTML`oB$];
        System["mv -f "//out$1512//" "//equ$1512]];
      Exit[]]];
   "Horizontal displacement of magnet. This applied before the rotation by ROTATE."[1,Max[p0$1512,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$1512//"\" />"//
   Help2HTML`oy$["Horizontal displacement of magnet. This applied before the rotation by ROTATE."[p2$1512,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L85>DY</A> <A HREF=#L95>ROTATE</A> <A HREF=#L83>DROTATE</A></PRE>
<LI>
<H3><A NAME=L127>
DY</A></H3>
<PRE>If[{},Help2HTML`oA$["Vertical displacement of magnet. This applied before the rotation by ROTATE."],
 p$1515=1+p$1515[[1,2]];p1$1515=
   StringPosition["Vertical displacement of magnet. This applied before the rotation by ROTATE."[p$1515,-1],">::",1];
  p1$1515=If[p1$1515==={},76,-2+p$1515+p1$1515[[1,1]]];
  neq=Which["Vertical displacement of magnet. This applied before the rotation by ROTATE."[p$1515,4+p$1515]==="Text[",
    lx$1515:=Help2HTML`oa$;p$1515=5+p$1515;p1$1515-=1;p2$1515=5+p1$1515;p0$1515=-9+p$1515;
     If[(pe$1515=StringPosition["Vertical displacement of magnet. This applied before the rotation by ROTATE."[p$1515,-2],";;;"]
        )<=>
       {},
      {Max[0,
        -1+ToExpression["Vertical displacement of magnet. This applied before the rotation by ROTATE."[p$1515+pe$1515[[1,2]],p1
           $1515]]],
        p1$1515=-2+p$1515+pe$1515[[1,1]]}[[
       1]],
      0],
    1,lx$1515:=Help2HTML`o9$;p2$1515=4+p1$1515;p0$1515=-4+p$1515;0];
  If[(equ$1515=Help2HTML`o8$["Vertical displacement of magnet. This applied before the rotation by ROTATE."[p$1515,p1$1515]])===
    Undefined,
   equ$1515="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "Vertical displacement of magnet. This applied before the rotation by ROTATE."[p$1515,p1$1515]]=
       equ$1515;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$1515},out$1515=lx$1515@Typeset["Vertical displacement of magnet. This applied before the rotation by ROTATE."[p$1515
           ,p1$1515],Format->Help2HTML`oB$];
        System["mv -f "//out$1515//" "//equ$1515]];
      Exit[]]];
   "Vertical displacement of magnet. This applied before the rotation by ROTATE."[1,Max[p0$1515,0]]//"<img  class=\"eqs\" SRC=\""//
   equ$1515//"\" />"//Help2HTML`oy$["Vertical displacement of magnet. This applied before the rotation by ROTATE."[p2$1515,-1]]
 ]
</PRE>
<PRE>See also:
 <A HREF=#L84>DX</A> <A HREF=#L95>ROTATE</A> <A HREF=#L83>DROTATE</A></PRE>
<LI>
<H3><A NAME=L128>
K5</A></H3>
<PRE>The normal dodecapole magnetic field component (times the length L).

<img  class="eqs" SRC="SADHelp_img/equ_108.svg" />If[{},Help2HTML`oA$["\n\nwhere L is the effective length of the component. Positi
ve sign means horizontal focusing."],p$1519=1+p$1519[[1,2]];p1$1519=StringPosition["\n\nwhere L is the effective length of the comp
onent. Positive sign means horizontal focusing."[p$1519,-1],">::",1];p1$1519=If[p1$1519==={},92,-2+p$1519+p1$1519[[1,1]]];neq=Which
["\n\nwhere L is the effective length of the component. Positive sign means horizontal focusing."[p$1519,4+p$1519]==="Text[",lx$151
9:=Help2HTML`oa$;p$1519=5+p$1519;p1$1519-=1;p2$1519=5+p1$1519;p0$1519=-9+p$1519;If[(pe$1519=StringPosition["\n\nwhere L is the effe
ctive length of the component. Positive sign means horizontal focusing."[p$1519,-2],";;;"])<=>{},{Max[0,-1+ToExpression["\n\nwhere 
L is the effective length of the component. Positive sign means horizontal focusing."[p$1519+pe$1519[[1,2]],p1$1519]]],p1$1519=-2+p
$1519+pe$1519[[1,1]]}[[1]],0],1,lx$1519:=Help2HTML`o9$;p2$1519=4+p1$1519;p0$1519=-4+p$1519;0];If[(equ$1519=Help2HTML`o8$["\n\nwhere
 L is the effective length of the component. Positive sign means horizontal focusing."[p$1519,p1$1519]])===Undefined,equ$1519="SADH
elp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["\n\nwhere L is the effective length of the component. Posit
ive sign means horizontal focusing."[p$1519,p1$1519]]=equ$1519;LaTeX`ob$+=neq,--LaTeX`ob$;With[{lx$1519},out$1519=lx$1519@Typeset["
\n\nwhere L is the effective length of the component. Positive sign means horizontal focusing."[p$1519,p1$1519],Format->Help2HTML`o
B$];System["mv -f "//out$1519//" "//equ$1519]];Exit[]]];"\n\nwhere L is the effective length of the component. Positive sign means 
horizontal focusing."[1,Max[p0$1519,0]]//"<img  class=\"eqs\" SRC=\""//equ$1519//"\" />"//Help2HTML`oy$["\n\nwhere L is the effecti
ve length of the component. Positive sign means horizontal focusing."[p2$1519,-1]]]
</PRE>
<PRE>See also:
 <A HREF=#L94>L</A></PRE>
<LI>
<H3><A NAME=L129>
L</A></H3>
<PRE>If[{},Help2HTML`oA$["The effective length."],
 p$1522=1+p$1522[[1,2]];p1$1522=StringPosition["The effective length."[p$1522,-1],">::",1];
  p1$1522=If[p1$1522==={},21,-2+p$1522+p1$1522[[1,1]]];
  neq=Which["The effective length."[p$1522,4+p$1522]==="Text[",lx$1522:=Help2HTML`oa$;p$1522=5+p$1522;p1$1522-=1;p2$1522=5+p1$1522;
     p0$1522=-9+p$1522;
     If[(pe$1522=StringPosition["The effective length."[p$1522,-2],";;;"])<=>{},{Max[0,-1+ToExpression["The effective length."[p
            $1522+pe$1522[[1,2]],
           p1$1522]]],
        p1$1522=-2+p$1522+pe$1522[[1,1]]}[[
       1]],
      0],
    1,lx$1522:=Help2HTML`o9$;p2$1522=4+p1$1522;p0$1522=-4+p$1522;0];
  If[(equ$1522=Help2HTML`o8$["The effective length."[p$1522,p1$1522]])===Undefined,
   equ$1522="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["The effective length."[p$1522,p1$1522]]=equ$1522;LaTeX`ob$+=neq,
     --LaTeX`ob$;With[{lx$1522},out$1522=lx$1522@Typeset["The effective length."[p$1522,p1$1522],Format->Help2HTML`oB$];
        System["mv -f "//out$1522//" "//equ$1522]];
      Exit[]]];
   "The effective length."[1,Max[p0$1522,0]]//"<img  class=\"eqs\" SRC=\""//equ$1522//"\" />"//
   Help2HTML`oy$["The effective length."[p2$1522,-1]]
]</PRE>
<LI>
<H3><A NAME=L130>
ROTATE</A></H3>
<PRE>If[{},
Help2HTML`oA$["Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet around the local s-axis by -(amo\
unt given by ROTATE), then place the component. At the exit rotate back the magnet around the local s-axis at the exit, then take \
out displacement."],
p$1524=1+p$1524[[1,2]];p1$1524=StringPosition["Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet \
around the local s-axis by -(amount given by ROTATE), then place the component. At the exit rotate back the magnet around the loca\
l s-axis at the exit, then take out displacement."[p$1524,-1],">::",1];
   p1$1524=If[p1$1524==={},262,-2+p$1524+p1$1524[[1,1]]];
neq=Which["Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet around the local s-axis by -(amount \
given by ROTATE), then place the component. At the exit rotate back the magnet around the local s-axis at the exit, then take out \
displacement."[p$1524,4+p$1524]==="Text[",
    lx$1524:=Help2HTML`oa$;p$1524=5+p$1524;p1$1524-=1;p2$1524=5+p1$1524;p0$1524=-9+p$1524;If[(pe$1524=
StringPosition["Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet around the local s-axis by -(am\
ount given by ROTATE), then place the component. At the exit rotate back the magnet around the local s-axis at the exit, then take\
 out displacement."[p$1524,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet around the local s-axis by -(a\
mount given by ROTATE), then place the component. At the exit rotate back the magnet around the local s-axis at the exit, then tak\
e out displacement."[p$1524+pe$1524[[1,2]],p1$1524]]],
        p1$1524=-2+p$1524+pe$1524[[1,1]]}[[
       1]],
      0],
    1,lx$1524:=Help2HTML`o9$;p2$1524=4+p1$1524;p0$1524=-4+p$1524;0];
  If[(equ$1524=
Help2HTML`o8$["Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet around the local s-axis by -(amo\
unt given by ROTATE), then place the component. At the exit rotate back the magnet around the local s-axis at the exit, then take \
out displacement."[p$1524,p1$1524]])===
    Undefined,
equ$1524="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Rotation in x-y plane. After displacing the \
magnet by DX and DY, rotate the magnet around the local s-axis by -(amount given by ROTATE), then place the component. At the exit\
 rotate back the magnet around the local s-axis at the exit, then take out displacement."[p$1524,p1$1524]]=
       equ$1524;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1524},out$1524=lx$1524@Typeset["Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet around\
 the local s-axis by -(amount given by ROTATE), then place the component. At the exit rotate back the magnet around the local s-ax\
is at the exit, then take out displacement."[p$1524,p1$1524],Format->Help2HTML`oB$];
        System["mv -f "//out$1524//" "//equ$1524]];
      Exit[]]];
   "Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet around the local s-axis by -(amount given b\
y ROTATE), then place the component. At the exit rotate back the magnet around the local s-axis at the exit, then take out displac\
ement."[1,Max[p0$1524,0]]//"<img  class=\"eqs\" SRC=\""//equ$1524//"\" />"//
Help2HTML`oy$["Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet around the local s-axis by -(amo\
unt given by ROTATE), then place the component. At the exit rotate back the magnet around the local s-axis at the exit, then take \
out displacement."[p2$1524,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L84>DX</A> <A HREF=#L85>DY</A> <A HREF=#L83>DROTATE</A></PRE>
<LI>
<H3><A NAME=L131>
transformation:THIN</A></H3>
<PRE><img  class="eqs" SRC="SADHelp_img/equ_109.svg" />
</PRE>
</UL>
<LI>
<H3><A NAME=L132>
DRIFT</A></H3>
<PRE>If[{},Help2HTML`oA$["A drift space."],
 p$1529=1+p$1529[[1,2]];p1$1529=StringPosition["A drift space."[p$1529,-1],">::",1];p1$1529=
   If[p1$1529==={},14,-2+p$1529+p1$1529[[1,1]]];
  neq=Which["A drift space."[p$1529,4+p$1529]==="Text[",lx$1529:=Help2HTML`oa$;p$1529=5+p$1529;p1$1529-=1;p2$1529=5+p1$1529;
     p0$1529=-9+p$1529;
     If[(pe$1529=StringPosition["A drift space."[p$1529,-2],";;;"])<=>{},{Max[0,-1+ToExpression["A drift space."[p$1529+
            pe$1529[[1,2]],
           p1$1529]]],
        p1$1529=-2+p$1529+pe$1529[[1,1]]}[[
       1]],
      0],
    1,lx$1529:=Help2HTML`o9$;p2$1529=4+p1$1529;p0$1529=-4+p$1529;0];
  If[(equ$1529=Help2HTML`o8$["A drift space."[p$1529,p1$1529]])===Undefined,
   equ$1529="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["A drift space."[p$1529,p1$1529]]=equ$1529;LaTeX`ob$+=neq,
     --LaTeX`ob$;With[{lx$1529},out$1529=lx$1529@Typeset["A drift space."[p$1529,p1$1529],Format->Help2HTML`oB$];
        System["mv -f "//out$1529//" "//equ$1529]];
      Exit[]]];
   "A drift space."[1,Max[p0$1529,0]]//"<img  class=\"eqs\" SRC=\""//equ$1529//"\" />"//Help2HTML`oy$["A drift space."[p2$1529,-1]]
 ]
</PRE>
<UL>
<LI>
<H3><A NAME=L133>
L</A></H3>
<PRE>If[{},Help2HTML`oA$["The length, can be negative."],
 p$1531=1+p$1531[[1,2]];p1$1531=StringPosition["The length, can be negative."[p$1531,-1],">::",1];
  p1$1531=If[p1$1531==={},28,-2+p$1531+p1$1531[[1,1]]];
  neq=Which["The length, can be negative."[p$1531,4+p$1531]==="Text[",lx$1531:=Help2HTML`oa$;p$1531=5+p$1531;p1$1531-=1;
     p2$1531=5+p1$1531;p0$1531=-9+p$1531;
     If[(pe$1531=StringPosition["The length, can be negative."[p$1531,-2],";;;"])<=>{},{Max[0,-1+
         ToExpression["The length, can be negative."[p$1531+pe$1531[[1,2]],p1$1531]]],
        p1$1531=-2+p$1531+pe$1531[[1,1]]}[[
       1]],
      0],
    1,lx$1531:=Help2HTML`o9$;p2$1531=4+p1$1531;p0$1531=-4+p$1531;0];
  If[(equ$1531=Help2HTML`o8$["The length, can be negative."[p$1531,p1$1531]])===Undefined,
   equ$1531="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["The length, can be negative."[p$1531,p1$1531]]=equ$1531;LaTeX`ob$+=neq,
     --LaTeX`ob$;With[{lx$1531},out$1531=lx$1531@Typeset["The length, can be negative."[p$1531,p1$1531],Format->Help2HTML`oB$];
        System["mv -f "//out$1531//" "//equ$1531]];
      Exit[]]];
   "The length, can be negative."[1,Max[p0$1531,0]]//"<img  class=\"eqs\" SRC=\""//equ$1531//"\" />"//
   Help2HTML`oy$["The length, can be negative."[p2$1531,-1]]
]</PRE>
<LI>
<H3><A NAME=L134>
RADIUS</A></H3>
<PRE>If[{},Help2HTML`oA$["Radius of the vacuum chamber. Effective when SPAC is ON."],
 p$1533=1+p$1533[[1,2]];p1$1533=StringPosition["Radius of the vacuum chamber. Effective when SPAC is ON."[p$1533,-1],">::",1];
  p1$1533=If[p1$1533==={},56,-2+p$1533+p1$1533[[1,1]]];
  neq=Which["Radius of the vacuum chamber. Effective when SPAC is ON."[p$1533,4+p$1533]==="Text[",
    lx$1533:=Help2HTML`oa$;p$1533=5+p$1533;p1$1533-=1;p2$1533=5+p1$1533;p0$1533=-9+p$1533;
     If[(pe$1533=StringPosition["Radius of the vacuum chamber. Effective when SPAC is ON."[p$1533,-2],";;;"])<=>{},
      {Max[0,-1+ToExpression["Radius of the vacuum chamber. Effective when SPAC is ON."[p$1533+pe$1533[[1,2]],p1$1533]]],
       p1$1533=-2+p$1533+pe$1533[[1,1]]}[[1]],
      0],
    1,lx$1533:=Help2HTML`o9$;p2$1533=4+p1$1533;p0$1533=-4+p$1533;0];
  If[(equ$1533=Help2HTML`o8$["Radius of the vacuum chamber. Effective when SPAC is ON."[p$1533,p1$1533]])===Undefined,
   equ$1533="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["Radius of the vacuum chamber. Effective when SPAC is ON."[p$1533,p1$1533]]=equ$1533;LaTeX`ob$+=neq,
     --LaTeX`ob$;
      With[{lx$1533},out$1533=lx$1533@Typeset["Radius of the vacuum chamber. Effective when SPAC is ON."[p$1533,p1$1533],
          Format->Help2HTML`oB$];
        System["mv -f "//out$1533//" "//equ$1533]];
      Exit[]]];
   "Radius of the vacuum chamber. Effective when SPAC is ON."[1,Max[p0$1533,0]]//"<img  class=\"eqs\" SRC=\""//equ$1533//"\" />"//
   Help2HTML`oy$["Radius of the vacuum chamber. Effective when SPAC is ON."[p2$1533,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L348>SPAC</A></PRE>
<LI>
<H3><A NAME=L135>
transformation:DRIFT</A></H3>
<PRE>The transformation of a drift is written as

<img  class="eqs" SRC="SADHelp_img/equ_112.svg" />

with

<img  class="eqs" SRC="SADHelp_img/equ_113.svg" />
</PRE>
<PRE>See also:
 coordinates</PRE>
</UL>
<LI>
<H3><A NAME=L136>
keywords</A></H3>
<PRE>If[{},
Help2HTML`oA$["Available keywords are:\t\n\ntype    keywords\nDRIFT   L RADIUS\nBEND    L ROTATE DROTATE DX DY ANGLE K0 K1 E1 E2 A\
E1 AE2 F1 FB1 FB2 FRINGE DISFRIN DISRAD EPS RANKICK\nQUAD    L ROTATE DX DY K1 F1 F2 FRINGE DISFRIN DISRAD EPS\nSEXT    L ROTATE D\
X DY K2 DISFRIN DISRAD\nOCT     L ROTATE DX DY K3 DISFRIN DISRAD\nDECA    L ROTATE DX DY K4 DISFRIN DISRAD\nDODECA  L ROTATE DX DY\
 K5 DISFRIN DISRAD\nMULT    L DX DY DZ CHI1 CHI2 ROTATE(=CHI3) K0..K21 SK0..SK21 DISFRIN F1 F2 FRINGE DISRAD EPS VOLT DVOLT HARM P\
HI DPHI FREQ RADIUS ANGLE E1 E2 AE1 AE2 DROTATE\nSOL     BZ DX DY DZ DPX DPY BOUND GEO CHI1 CHI2 CHI3 DBZ DISFRIN\nCAVI    L ROTAT\
E DX DY VOLT DVOLT V1 V20 V11 V02 FREQ PHI HARM RANVOLT RANPHASE DISFRIN FRINGE\nTCAVI   L ROTATE DX DY K0 V1 FREQ PHI HARM RANKIC\
K RANPHASE\nCOORD   DX DY CHI1 CHI2 CHI3 DIR\nMARK    AX BX AY BY EX EPX EY EPY R1 R2 R3 R4 DETR DX DPX DY DPY DZ DDP AZ BZ NZ ZX \
ZPX ZY ZPY EMITX EMITY DP AZ SIGZ GEO OFFSET\nAPERT   DX1 DX2 DY1 DY2 DP AX AY DX DY"],
 p$1540=1+p$1540[[1,2]];p1$1540=StringPosition["Available keywords are:\t\n\ntype    keywords\nDRIFT   L RADIUS\nBEND    L ROTATE \
DROTATE DX DY ANGLE K0 K1 E1 E2 AE1 AE2 F1 FB1 FB2 FRINGE DISFRIN DISRAD EPS RANKICK\nQUAD    L ROTATE DX DY K1 F1 F2 FRINGE DISFR\
IN DISRAD EPS\nSEXT    L ROTATE DX DY K2 DISFRIN DISRAD\nOCT     L ROTATE DX DY K3 DISFRIN DISRAD\nDECA    L ROTATE DX DY K4 DISFR\
IN DISRAD\nDODECA  L ROTATE DX DY K5 DISFRIN DISRAD\nMULT    L DX DY DZ CHI1 CHI2 ROTATE(=CHI3) K0..K21 SK0..SK21 DISFRIN F1 F2 FR\
INGE DISRAD EPS VOLT DVOLT HARM PHI DPHI FREQ RADIUS ANGLE E1 E2 AE1 AE2 DROTATE\nSOL     BZ DX DY DZ DPX DPY BOUND GEO CHI1 CHI2 \
CHI3 DBZ DISFRIN\nCAVI    L ROTATE DX DY VOLT DVOLT V1 V20 V11 V02 FREQ PHI HARM RANVOLT RANPHASE DISFRIN FRINGE\nTCAVI   L ROTATE\
 DX DY K0 V1 FREQ PHI HARM RANKICK RANPHASE\nCOORD   DX DY CHI1 CHI2 CHI3 DIR\nMARK    AX BX AY BY EX EPX EY EPY R1 R2 R3 R4 DETR \
DX DPX DY DPY DZ DDP AZ BZ NZ ZX ZPX ZY ZPY EMITX EMITY DP AZ SIGZ GEO OFFSET\nAPERT   DX1 DX2 DY1 DY2 DP AX AY DX DY"[p$1540,-1],
    ">::",1];
   p1$1540=If[p1$1540==={},962,-2+p$1540+p1$1540[[1,1]]];
neq=Which["Available keywords are:\t\n\ntype    keywords\nDRIFT   L RADIUS\nBEND    L ROTATE DROTATE DX DY ANGLE K0 K1 E1 E2 AE1 A\
E2 F1 FB1 FB2 FRINGE DISFRIN DISRAD EPS RANKICK\nQUAD    L ROTATE DX DY K1 F1 F2 FRINGE DISFRIN DISRAD EPS\nSEXT    L ROTATE DX DY\
 K2 DISFRIN DISRAD\nOCT     L ROTATE DX DY K3 DISFRIN DISRAD\nDECA    L ROTATE DX DY K4 DISFRIN DISRAD\nDODECA  L ROTATE DX DY K5 \
DISFRIN DISRAD\nMULT    L DX DY DZ CHI1 CHI2 ROTATE(=CHI3) K0..K21 SK0..SK21 DISFRIN F1 F2 FRINGE DISRAD EPS VOLT DVOLT HARM PHI D\
PHI FREQ RADIUS ANGLE E1 E2 AE1 AE2 DROTATE\nSOL     BZ DX DY DZ DPX DPY BOUND GEO CHI1 CHI2 CHI3 DBZ DISFRIN\nCAVI    L ROTATE DX\
 DY VOLT DVOLT V1 V20 V11 V02 FREQ PHI HARM RANVOLT RANPHASE DISFRIN FRINGE\nTCAVI   L ROTATE DX DY K0 V1 FREQ PHI HARM RANKICK RA\
NPHASE\nCOORD   DX DY CHI1 CHI2 CHI3 DIR\nMARK    AX BX AY BY EX EPX EY EPY R1 R2 R3 R4 DETR DX DPX DY DPY DZ DDP AZ BZ NZ ZX ZPX \
ZY ZPY EMITX EMITY DP AZ SIGZ GEO OFFSET\nAPERT   DX1 DX2 DY1 DY2 DP AX AY DX DY"[p$1540,4+p$1540]==="Text[",
    lx$1540:=Help2HTML`oa$;p$1540=5+p$1540;p1$1540-=1;p2$1540=5+p1$1540;p0$1540=-9+p$1540;
If[(pe$1540=StringPosition["Available keywords are:\t\n\ntype    keywords\nDRIFT   L RADIUS\nBEND    L ROTATE DROTATE DX DY ANGLE \
K0 K1 E1 E2 AE1 AE2 F1 FB1 FB2 FRINGE DISFRIN DISRAD EPS RANKICK\nQUAD    L ROTATE DX DY K1 F1 F2 FRINGE DISFRIN DISRAD EPS\nSEXT \
   L ROTATE DX DY K2 DISFRIN DISRAD\nOCT     L ROTATE DX DY K3 DISFRIN DISRAD\nDECA    L ROTATE DX DY K4 DISFRIN DISRAD\nDODECA  L\
 ROTATE DX DY K5 DISFRIN DISRAD\nMULT    L DX DY DZ CHI1 CHI2 ROTATE(=CHI3) K0..K21 SK0..SK21 DISFRIN F1 F2 FRINGE DISRAD EPS VOLT\
 DVOLT HARM PHI DPHI FREQ RADIUS ANGLE E1 E2 AE1 AE2 DROTATE\nSOL     BZ DX DY DZ DPX DPY BOUND GEO CHI1 CHI2 CHI3 DBZ DISFRIN\nCA\
VI    L ROTATE DX DY VOLT DVOLT V1 V20 V11 V02 FREQ PHI HARM RANVOLT RANPHASE DISFRIN FRINGE\nTCAVI   L ROTATE DX DY K0 V1 FREQ PH\
I HARM RANKICK RANPHASE\nCOORD   DX DY CHI1 CHI2 CHI3 DIR\nMARK    AX BX AY BY EX EPX EY EPY R1 R2 R3 R4 DETR DX DPX DY DPY DZ DDP\
 AZ BZ NZ ZX ZPX ZY ZPY EMITX EMITY DP AZ SIGZ GEO OFFSET\nAPERT   DX1 DX2 DY1 DY2 DP AX AY DX DY"[p$1540,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Available keywords are:\t\n\ntype    keywords\nDRIFT   L RADIUS\nBEND    L ROTATE DROTATE DX DY ANGLE K0 K1 E1 E2\
 AE1 AE2 F1 FB1 FB2 FRINGE DISFRIN DISRAD EPS RANKICK\nQUAD    L ROTATE DX DY K1 F1 F2 FRINGE DISFRIN DISRAD EPS\nSEXT    L ROTATE\
 DX DY K2 DISFRIN DISRAD\nOCT     L ROTATE DX DY K3 DISFRIN DISRAD\nDECA    L ROTATE DX DY K4 DISFRIN DISRAD\nDODECA  L ROTATE DX \
DY K5 DISFRIN DISRAD\nMULT    L DX DY DZ CHI1 CHI2 ROTATE(=CHI3) K0..K21 SK0..SK21 DISFRIN F1 F2 FRINGE DISRAD EPS VOLT DVOLT HARM\
 PHI DPHI FREQ RADIUS ANGLE E1 E2 AE1 AE2 DROTATE\nSOL     BZ DX DY DZ DPX DPY BOUND GEO CHI1 CHI2 CHI3 DBZ DISFRIN\nCAVI    L ROT\
ATE DX DY VOLT DVOLT V1 V20 V11 V02 FREQ PHI HARM RANVOLT RANPHASE DISFRIN FRINGE\nTCAVI   L ROTATE DX DY K0 V1 FREQ PHI HARM RANK\
ICK RANPHASE\nCOORD   DX DY CHI1 CHI2 CHI3 DIR\nMARK    AX BX AY BY EX EPX EY EPY R1 R2 R3 R4 DETR DX DPX DY DPY DZ DDP AZ BZ NZ Z\
X ZPX ZY ZPY EMITX EMITY DP AZ SIGZ GEO OFFSET\nAPERT   DX1 DX2 DY1 DY2 DP AX AY DX DY"[p$1540+pe$1540[[1,2]],p1$1540]]],
        p1$1540=-2+p$1540+pe$1540[[1,1]]}[[
       1]],
      0],
    1,lx$1540:=Help2HTML`o9$;p2$1540=4+p1$1540;p0$1540=-4+p$1540;0];
  If[(equ$1540=
Help2HTML`o8$["Available keywords are:\t\n\ntype    keywords\nDRIFT   L RADIUS\nBEND    L ROTATE DROTATE DX DY ANGLE K0 K1 E1 E2 A\
E1 AE2 F1 FB1 FB2 FRINGE DISFRIN DISRAD EPS RANKICK\nQUAD    L ROTATE DX DY K1 F1 F2 FRINGE DISFRIN DISRAD EPS\nSEXT    L ROTATE D\
X DY K2 DISFRIN DISRAD\nOCT     L ROTATE DX DY K3 DISFRIN DISRAD\nDECA    L ROTATE DX DY K4 DISFRIN DISRAD\nDODECA  L ROTATE DX DY\
 K5 DISFRIN DISRAD\nMULT    L DX DY DZ CHI1 CHI2 ROTATE(=CHI3) K0..K21 SK0..SK21 DISFRIN F1 F2 FRINGE DISRAD EPS VOLT DVOLT HARM P\
HI DPHI FREQ RADIUS ANGLE E1 E2 AE1 AE2 DROTATE\nSOL     BZ DX DY DZ DPX DPY BOUND GEO CHI1 CHI2 CHI3 DBZ DISFRIN\nCAVI    L ROTAT\
E DX DY VOLT DVOLT V1 V20 V11 V02 FREQ PHI HARM RANVOLT RANPHASE DISFRIN FRINGE\nTCAVI   L ROTATE DX DY K0 V1 FREQ PHI HARM RANKIC\
K RANPHASE\nCOORD   DX DY CHI1 CHI2 CHI3 DIR\nMARK    AX BX AY BY EX EPX EY EPY R1 R2 R3 R4 DETR DX DPX DY DPY DZ DDP AZ BZ NZ ZX \
ZPX ZY ZPY EMITX EMITY DP AZ SIGZ GEO OFFSET\nAPERT   DX1 DX2 DY1 DY2 DP AX AY DX DY"[p$1540,p1$1540]])===
    Undefined,
equ$1540="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Available keywords are:\t\n\ntype    keyword\
s\nDRIFT   L RADIUS\nBEND    L ROTATE DROTATE DX DY ANGLE K0 K1 E1 E2 AE1 AE2 F1 FB1 FB2 FRINGE DISFRIN DISRAD EPS RANKICK\nQUAD  \
  L ROTATE DX DY K1 F1 F2 FRINGE DISFRIN DISRAD EPS\nSEXT    L ROTATE DX DY K2 DISFRIN DISRAD\nOCT     L ROTATE DX DY K3 DISFRIN D\
ISRAD\nDECA    L ROTATE DX DY K4 DISFRIN DISRAD\nDODECA  L ROTATE DX DY K5 DISFRIN DISRAD\nMULT    L DX DY DZ CHI1 CHI2 ROTATE(=CH\
I3) K0..K21 SK0..SK21 DISFRIN F1 F2 FRINGE DISRAD EPS VOLT DVOLT HARM PHI DPHI FREQ RADIUS ANGLE E1 E2 AE1 AE2 DROTATE\nSOL     BZ\
 DX DY DZ DPX DPY BOUND GEO CHI1 CHI2 CHI3 DBZ DISFRIN\nCAVI    L ROTATE DX DY VOLT DVOLT V1 V20 V11 V02 FREQ PHI HARM RANVOLT RAN\
PHASE DISFRIN FRINGE\nTCAVI   L ROTATE DX DY K0 V1 FREQ PHI HARM RANKICK RANPHASE\nCOORD   DX DY CHI1 CHI2 CHI3 DIR\nMARK    AX BX\
 AY BY EX EPX EY EPY R1 R2 R3 R4 DETR DX DPX DY DPY DZ DDP AZ BZ NZ ZX ZPX ZY ZPY EMITX EMITY DP AZ SIGZ GEO OFFSET\nAPERT   DX1 D\
X2 DY1 DY2 DP AX AY DX DY"[p$1540,p1$1540]]=
       equ$1540;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1540},out$1540=lx$1540@Typeset["Available keywords are:\t\n\ntype    keywords\nDRIFT   L RADIUS\nBEND    L ROTATE DROTATE\
 DX DY ANGLE K0 K1 E1 E2 AE1 AE2 F1 FB1 FB2 FRINGE DISFRIN DISRAD EPS RANKICK\nQUAD    L ROTATE DX DY K1 F1 F2 FRINGE DISFRIN DISR\
AD EPS\nSEXT    L ROTATE DX DY K2 DISFRIN DISRAD\nOCT     L ROTATE DX DY K3 DISFRIN DISRAD\nDECA    L ROTATE DX DY K4 DISFRIN DISR\
AD\nDODECA  L ROTATE DX DY K5 DISFRIN DISRAD\nMULT    L DX DY DZ CHI1 CHI2 ROTATE(=CHI3) K0..K21 SK0..SK21 DISFRIN F1 F2 FRINGE DI\
SRAD EPS VOLT DVOLT HARM PHI DPHI FREQ RADIUS ANGLE E1 E2 AE1 AE2 DROTATE\nSOL     BZ DX DY DZ DPX DPY BOUND GEO CHI1 CHI2 CHI3 DB\
Z DISFRIN\nCAVI    L ROTATE DX DY VOLT DVOLT V1 V20 V11 V02 FREQ PHI HARM RANVOLT RANPHASE DISFRIN FRINGE\nTCAVI   L ROTATE DX DY \
K0 V1 FREQ PHI HARM RANKICK RANPHASE\nCOORD   DX DY CHI1 CHI2 CHI3 DIR\nMARK    AX BX AY BY EX EPX EY EPY R1 R2 R3 R4 DETR DX DPX \
DY DPY DZ DDP AZ BZ NZ ZX ZPX ZY ZPY EMITX EMITY DP AZ SIGZ GEO OFFSET\nAPERT   DX1 DX2 DY1 DY2 DP AX AY DX DY"[p$1540,p1$1540],
          Format->Help2HTML`oB$];
        System["mv -f "//out$1540//" "//equ$1540]];
      Exit[]]];
   "Available keywords are:\t\n\ntype    keywords\nDRIFT   L RADIUS\nBEND    L ROTATE DROTATE DX DY ANGLE K0 K1 E1 E2 AE1 AE2 F1 F\
B1 FB2 FRINGE DISFRIN DISRAD EPS RANKICK\nQUAD    L ROTATE DX DY K1 F1 F2 FRINGE DISFRIN DISRAD EPS\nSEXT    L ROTATE DX DY K2 DIS\
FRIN DISRAD\nOCT     L ROTATE DX DY K3 DISFRIN DISRAD\nDECA    L ROTATE DX DY K4 DISFRIN DISRAD\nDODECA  L ROTATE DX DY K5 DISFRIN\
 DISRAD\nMULT    L DX DY DZ CHI1 CHI2 ROTATE(=CHI3) K0..K21 SK0..SK21 DISFRIN F1 F2 FRINGE DISRAD EPS VOLT DVOLT HARM PHI DPHI FRE\
Q RADIUS ANGLE E1 E2 AE1 AE2 DROTATE\nSOL     BZ DX DY DZ DPX DPY BOUND GEO CHI1 CHI2 CHI3 DBZ DISFRIN\nCAVI    L ROTATE DX DY VOL\
T DVOLT V1 V20 V11 V02 FREQ PHI HARM RANVOLT RANPHASE DISFRIN FRINGE\nTCAVI   L ROTATE DX DY K0 V1 FREQ PHI HARM RANKICK RANPHASE\\
nCOORD   DX DY CHI1 CHI2 CHI3 DIR\nMARK    AX BX AY BY EX EPX EY EPY R1 R2 R3 R4 DETR DX DPX DY DPY DZ DDP AZ BZ NZ ZX ZPX ZY ZPY \
EMITX EMITY DP AZ SIGZ GEO OFFSET\nAPERT   DX1 DX2 DY1 DY2 DP AX AY DX DY"[1,Max[p0$1540,0]]//"<img  class=\"eqs\" SRC=\""//
   equ$1540//"\" />"//
Help2HTML`oy$["Available keywords are:\t\n\ntype    keywords\nDRIFT   L RADIUS\nBEND    L ROTATE DROTATE DX DY ANGLE K0 K1 E1 E2 A\
E1 AE2 F1 FB1 FB2 FRINGE DISFRIN DISRAD EPS RANKICK\nQUAD    L ROTATE DX DY K1 F1 F2 FRINGE DISFRIN DISRAD EPS\nSEXT    L ROTATE D\
X DY K2 DISFRIN DISRAD\nOCT     L ROTATE DX DY K3 DISFRIN DISRAD\nDECA    L ROTATE DX DY K4 DISFRIN DISRAD\nDODECA  L ROTATE DX DY\
 K5 DISFRIN DISRAD\nMULT    L DX DY DZ CHI1 CHI2 ROTATE(=CHI3) K0..K21 SK0..SK21 DISFRIN F1 F2 FRINGE DISRAD EPS VOLT DVOLT HARM P\
HI DPHI FREQ RADIUS ANGLE E1 E2 AE1 AE2 DROTATE\nSOL     BZ DX DY DZ DPX DPY BOUND GEO CHI1 CHI2 CHI3 DBZ DISFRIN\nCAVI    L ROTAT\
E DX DY VOLT DVOLT V1 V20 V11 V02 FREQ PHI HARM RANVOLT RANPHASE DISFRIN FRINGE\nTCAVI   L ROTATE DX DY K0 V1 FREQ PHI HARM RANKIC\
K RANPHASE\nCOORD   DX DY CHI1 CHI2 CHI3 DIR\nMARK    AX BX AY BY EX EPX EY EPY R1 R2 R3 R4 DETR DX DPX DY DPY DZ DDP AZ BZ NZ ZX \
ZPX ZY ZPY EMITX EMITY DP AZ SIGZ GEO OFFSET\nAPERT   DX1 DX2 DY1 DY2 DP AX AY DX DY"[p2$1540,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L113>default-keyword</A> <A HREF=#L497>set-value-of-element</A> <A HREF=#L387>Element</A></PRE>
<LI>
<H3><A NAME=L137>
MARK</A></H3>
<PRE>If[{},
Help2HTML`oA$["MARK elements play special roles in FFS:\t\n\n(1) The first element of the beam line must be a MARK element to be u\
sed by FFS. In this case the MARK element contains the parameters of the incoming beam (see optical-functions, special-variables E\
MITX, EMITY, DP). \n(2) The calculated optical parameters at a MARK command is saved by SAVE or STOP commands, then it can be used\
 as the incoming condition of other beam lines which have the same MARK element.\t\n\nExample: MARK P1 = (EMITX = .. EMITY = .. DP\
 = ..);\n         LINE  A = ( .. P1 ..)\n               B = (P1 .. );\n         FFS USE = A;\n             ...           do matchi\
ng on LINE A\n             SAVE P1       save the parameters at P1\n             USE B;        switch to LINE B\n             ... \
          do matching of LINE B whose entrance is to be\n                           matched P1.\t\n\n(3) If a MARK element has key\
word GEO nonzero, this MARK element becomes the origin of the geometric rotation after the last SOL element.\n(4) The values of op\
tical-functions of the MARK element at the beginning of the beam line can be specified as matching variables by the FREE command.\\
t\n\n A MARK elements have all optical-functions as its keywords except NX, NY, TRX, TRY, and LENG. Also it has keywords EMITX, EM\
ITY, and DP which give the values of the corresponding special-variables."],
p$1543=1+p$1543[[1,2]];p1$1543=StringPosition["MARK elements play special roles in FFS:\t\n\n(1) The first element of the beam lin\
e must be a MARK element to be used by FFS. In this case the MARK element contains the parameters of the incoming beam (see optica\
l-functions, special-variables EMITX, EMITY, DP). \n(2) The calculated optical parameters at a MARK command is saved by SAVE or ST\
OP commands, then it can be used as the incoming condition of other beam lines which have the same MARK element.\t\n\nExample: MAR\
K P1 = (EMITX = .. EMITY = .. DP = ..);\n         LINE  A = ( .. P1 ..)\n               B = (P1 .. );\n         FFS USE = A;\n    \
         ...           do matching on LINE A\n             SAVE P1       save the parameters at P1\n             USE B;        swi\
tch to LINE B\n             ...           do matching of LINE B whose entrance is to be\n                           matched P1.\t\\
n\n(3) If a MARK element has keyword GEO nonzero, this MARK element becomes the origin of the geometric rotation after the last SO\
L element.\n(4) The values of optical-functions of the MARK element at the beginning of the beam line can be specified as matching\
 variables by the FREE command.\t\n\n A MARK elements have all optical-functions as its keywords except NX, NY, TRX, TRY, and LENG\
. Also it has keywords EMITX, EMITY, and DP which give the values of the corresponding special-variables."[p$1543,-1],">::",1];
   p1$1543=If[p1$1543==={},1336,-2+p$1543+p1$1543[[1,1]]];
neq=Which["MARK elements play special roles in FFS:\t\n\n(1) The first element of the beam line must be a MARK element to be used \
by FFS. In this case the MARK element contains the parameters of the incoming beam (see optical-functions, special-variables EMITX\
, EMITY, DP). \n(2) The calculated optical parameters at a MARK command is saved by SAVE or STOP commands, then it can be used as \
the incoming condition of other beam lines which have the same MARK element.\t\n\nExample: MARK P1 = (EMITX = .. EMITY = .. DP = .\
.);\n         LINE  A = ( .. P1 ..)\n               B = (P1 .. );\n         FFS USE = A;\n             ...           do matching o\
n LINE A\n             SAVE P1       save the parameters at P1\n             USE B;        switch to LINE B\n             ...     \
      do matching of LINE B whose entrance is to be\n                           matched P1.\t\n\n(3) If a MARK element has keyword\
 GEO nonzero, this MARK element becomes the origin of the geometric rotation after the last SOL element.\n(4) The values of optica\
l-functions of the MARK element at the beginning of the beam line can be specified as matching variables by the FREE command.\t\n\\
n A MARK elements have all optical-functions as its keywords except NX, NY, TRX, TRY, and LENG. Also it has keywords EMITX, EMITY,\
 and DP which give the values of the corresponding special-variables."[p$1543,4+p$1543]==="Text[",
    lx$1543:=Help2HTML`oa$;p$1543=5+p$1543;p1$1543-=1;p2$1543=5+p1$1543;p0$1543=-9+p$1543;
If[(pe$1543=StringPosition["MARK elements play special roles in FFS:\t\n\n(1) The first element of the beam line must be a MARK el\
ement to be used by FFS. In this case the MARK element contains the parameters of the incoming beam (see optical-functions, specia\
l-variables EMITX, EMITY, DP). \n(2) The calculated optical parameters at a MARK command is saved by SAVE or STOP commands, then i\
t can be used as the incoming condition of other beam lines which have the same MARK element.\t\n\nExample: MARK P1 = (EMITX = .. \
EMITY = .. DP = ..);\n         LINE  A = ( .. P1 ..)\n               B = (P1 .. );\n         FFS USE = A;\n             ...       \
    do matching on LINE A\n             SAVE P1       save the parameters at P1\n             USE B;        switch to LINE B\n    \
         ...           do matching of LINE B whose entrance is to be\n                           matched P1.\t\n\n(3) If a MARK el\
ement has keyword GEO nonzero, this MARK element becomes the origin of the geometric rotation after the last SOL element.\n(4) The\
 values of optical-functions of the MARK element at the beginning of the beam line can be specified as matching variables by the F\
REE command.\t\n\n A MARK elements have all optical-functions as its keywords except NX, NY, TRX, TRY, and LENG. Also it has keywo\
rds EMITX, EMITY, and DP which give the values of the corresponding special-variables."[p$1543,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["MARK elements play special roles in FFS:\t\n\n(1) The first element of the beam line must be a MARK element to be\
 used by FFS. In this case the MARK element contains the parameters of the incoming beam (see optical-functions, special-variables\
 EMITX, EMITY, DP). \n(2) The calculated optical parameters at a MARK command is saved by SAVE or STOP commands, then it can be us\
ed as the incoming condition of other beam lines which have the same MARK element.\t\n\nExample: MARK P1 = (EMITX = .. EMITY = .. \
DP = ..);\n         LINE  A = ( .. P1 ..)\n               B = (P1 .. );\n         FFS USE = A;\n             ...           do matc\
hing on LINE A\n             SAVE P1       save the parameters at P1\n             USE B;        switch to LINE B\n             ..\
.           do matching of LINE B whose entrance is to be\n                           matched P1.\t\n\n(3) If a MARK element has k\
eyword GEO nonzero, this MARK element becomes the origin of the geometric rotation after the last SOL element.\n(4) The values of \
optical-functions of the MARK element at the beginning of the beam line can be specified as matching variables by the FREE command\
.\t\n\n A MARK elements have all optical-functions as its keywords except NX, NY, TRX, TRY, and LENG. Also it has keywords EMITX, \
EMITY, and DP which give the values of the corresponding special-variables."[p$1543+pe$1543[[1,2]],p1$1543]]],
        p1$1543=-2+p$1543+pe$1543[[1,1]]}[[
       1]],
      0],
    1,lx$1543:=Help2HTML`o9$;p2$1543=4+p1$1543;p0$1543=-4+p$1543;0];
  If[(equ$1543=
Help2HTML`o8$["MARK elements play special roles in FFS:\t\n\n(1) The first element of the beam line must be a MARK element to be u\
sed by FFS. In this case the MARK element contains the parameters of the incoming beam (see optical-functions, special-variables E\
MITX, EMITY, DP). \n(2) The calculated optical parameters at a MARK command is saved by SAVE or STOP commands, then it can be used\
 as the incoming condition of other beam lines which have the same MARK element.\t\n\nExample: MARK P1 = (EMITX = .. EMITY = .. DP\
 = ..);\n         LINE  A = ( .. P1 ..)\n               B = (P1 .. );\n         FFS USE = A;\n             ...           do matchi\
ng on LINE A\n             SAVE P1       save the parameters at P1\n             USE B;        switch to LINE B\n             ... \
          do matching of LINE B whose entrance is to be\n                           matched P1.\t\n\n(3) If a MARK element has key\
word GEO nonzero, this MARK element becomes the origin of the geometric rotation after the last SOL element.\n(4) The values of op\
tical-functions of the MARK element at the beginning of the beam line can be specified as matching variables by the FREE command.\\
t\n\n A MARK elements have all optical-functions as its keywords except NX, NY, TRX, TRY, and LENG. Also it has keywords EMITX, EM\
ITY, and DP which give the values of the corresponding special-variables."[p$1543,p1$1543]])===
    Undefined,
equ$1543="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["MARK elements play special roles in FFS:\t\n\
\n(1) The first element of the beam line must be a MARK element to be used by FFS. In this case the MARK element contains the para\
meters of the incoming beam (see optical-functions, special-variables EMITX, EMITY, DP). \n(2) The calculated optical parameters a\
t a MARK command is saved by SAVE or STOP commands, then it can be used as the incoming condition of other beam lines which have t\
he same MARK element.\t\n\nExample: MARK P1 = (EMITX = .. EMITY = .. DP = ..);\n         LINE  A = ( .. P1 ..)\n               B =\
 (P1 .. );\n         FFS USE = A;\n             ...           do matching on LINE A\n             SAVE P1       save the parameter\
s at P1\n             USE B;        switch to LINE B\n             ...           do matching of LINE B whose entrance is to be\n  \
                         matched P1.\t\n\n(3) If a MARK element has keyword GEO nonzero, this MARK element becomes the origin of t\
he geometric rotation after the last SOL element.\n(4) The values of optical-functions of the MARK element at the beginning of the\
 beam line can be specified as matching variables by the FREE command.\t\n\n A MARK elements have all optical-functions as its key\
words except NX, NY, TRX, TRY, and LENG. Also it has keywords EMITX, EMITY, and DP which give the values of the corresponding spec\
ial-variables."[p$1543,p1$1543]]=
       equ$1543;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1543},out$1543=lx$1543@Typeset["MARK elements play special roles in FFS:\t\n\n(1) The first element of the beam line must\
 be a MARK element to be used by FFS. In this case the MARK element contains the parameters of the incoming beam (see optical-func\
tions, special-variables EMITX, EMITY, DP). \n(2) The calculated optical parameters at a MARK command is saved by SAVE or STOP com\
mands, then it can be used as the incoming condition of other beam lines which have the same MARK element.\t\n\nExample: MARK P1 =\
 (EMITX = .. EMITY = .. DP = ..);\n         LINE  A = ( .. P1 ..)\n               B = (P1 .. );\n         FFS USE = A;\n          \
   ...           do matching on LINE A\n             SAVE P1       save the parameters at P1\n             USE B;        switch to\
 LINE B\n             ...           do matching of LINE B whose entrance is to be\n                           matched P1.\t\n\n(3)\
 If a MARK element has keyword GEO nonzero, this MARK element becomes the origin of the geometric rotation after the last SOL elem\
ent.\n(4) The values of optical-functions of the MARK element at the beginning of the beam line can be specified as matching varia\
bles by the FREE command.\t\n\n A MARK elements have all optical-functions as its keywords except NX, NY, TRX, TRY, and LENG. Also\
 it has keywords EMITX, EMITY, and DP which give the values of the corresponding special-variables."[p$1543,p1$1543],
          Format->Help2HTML`oB$];
        System["mv -f "//out$1543//" "//equ$1543]];
      Exit[]]];
   "MARK elements play special roles in FFS:\t\n\n(1) The first element of the beam line must be a MARK element to be used by FFS.\
 In this case the MARK element contains the parameters of the incoming beam (see optical-functions, special-variables EMITX, EMITY\
, DP). \n(2) The calculated optical parameters at a MARK command is saved by SAVE or STOP commands, then it can be used as the inc\
oming condition of other beam lines which have the same MARK element.\t\n\nExample: MARK P1 = (EMITX = .. EMITY = .. DP = ..);\n  \
       LINE  A = ( .. P1 ..)\n               B = (P1 .. );\n         FFS USE = A;\n             ...           do matching on LINE \
A\n             SAVE P1       save the parameters at P1\n             USE B;        switch to LINE B\n             ...           d\
o matching of LINE B whose entrance is to be\n                           matched P1.\t\n\n(3) If a MARK element has keyword GEO no\
nzero, this MARK element becomes the origin of the geometric rotation after the last SOL element.\n(4) The values of optical-funct\
ions of the MARK element at the beginning of the beam line can be specified as matching variables by the FREE command.\t\n\n A MAR\
K elements have all optical-functions as its keywords except NX, NY, TRX, TRY, and LENG. Also it has keywords EMITX, EMITY, and DP\
 which give the values of the corresponding special-variables."[1,Max[p0$1543,0]]//"<img  class=\"eqs\" SRC=\""//equ$1543//
   "\" />"//
Help2HTML`oy$["MARK elements play special roles in FFS:\t\n\n(1) The first element of the beam line must be a MARK element to be u\
sed by FFS. In this case the MARK element contains the parameters of the incoming beam (see optical-functions, special-variables E\
MITX, EMITY, DP). \n(2) The calculated optical parameters at a MARK command is saved by SAVE or STOP commands, then it can be used\
 as the incoming condition of other beam lines which have the same MARK element.\t\n\nExample: MARK P1 = (EMITX = .. EMITY = .. DP\
 = ..);\n         LINE  A = ( .. P1 ..)\n               B = (P1 .. );\n         FFS USE = A;\n             ...           do matchi\
ng on LINE A\n             SAVE P1       save the parameters at P1\n             USE B;        switch to LINE B\n             ... \
          do matching of LINE B whose entrance is to be\n                           matched P1.\t\n\n(3) If a MARK element has key\
word GEO nonzero, this MARK element becomes the origin of the geometric rotation after the last SOL element.\n(4) The values of op\
tical-functions of the MARK element at the beginning of the beam line can be specified as matching variables by the FREE command.\\
t\n\n A MARK elements have all optical-functions as its keywords except NX, NY, TRX, TRY, and LENG. Also it has keywords EMITX, EM\
ITY, and DP which give the values of the corresponding special-variables."[p2$1543,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L548>SAVE</A> <A HREF=#L558>USE</A> <A HREF=#L478>optical-functions</A> <A HREF=#L236>SOL</A> <A HREF=#L500>special-variables</A> <A HREF=#L513>EMITX</A> <A HREF=#L515>EMITY</A> <A HREF=#L506>DP</A></PRE>
<UL>
<LI>
<H3><A NAME=L138>
OFFSET</A></H3>
<PRE>If[{},
Help2HTML`oA$["OFFSET is a relative position from the current position. A fraction is allowed to specify a location within an elem\
ent.\n   If the MARK at the beginning of a beam line has OFFSET nonzero, the optics calculation starts from the shifted location. \
If the last component of a beam line is a MARK with nonzero OFFSET, the optics calculation stops at the shifted location. The peri\
odic condition is applied between those shifted locations.\n   The geometric origin and the origin of LENG shift to the first MARK\
.\n\nExamples:\n(1)  LINE A    = ( ...  QF PQFC  ... );\n     QUAD QF   = (L=0.3 K1=0.2);\n     MARK PQFC = (OFFSET = -0.5);\n\nHe\
re PQFC represents the center of QF.\n\n(2)  LINE A    = ( ...  PQFC QF  ... );\n\n     QUAD QF   = (L=0.3 K1=0.2);\n     MARK PQF\
C = (OFFSET =  1.5);\nHere PQFC represents the center of QF, too (consider why). The value of OFFSET is interpreted taking the dir\
ection of the LINE into account, i.e., a MARK in a line A represents the same location in a line -A.\n\nRestrictions:\n(1) Functio\
n TrackParticles does not take OFFSET into account if the start\n    or stop location is in the midst of a beam line and a Mark wi\
th nonzero\n    OFFSET, in the current version. Tracking for entire beam line or\n    MEASURE(MEA) command supports OFFSET.\n(2) T\
he outputs by DISPLAY(DISP) outside of the narrowed region by OFFSET are\n    meaningless."],
 p$1546=1+p$1546[[1,2]];p1$1546=StringPosition["OFFSET is a relative position from the current position. A fraction is allowed to \
specify a location within an element.\n   If the MARK at the beginning of a beam line has OFFSET nonzero, the optics calculation s\
tarts from the shifted location. If the last component of a beam line is a MARK with nonzero OFFSET, the optics calculation stops \
at the shifted location. The periodic condition is applied between those shifted locations.\n   The geometric origin and the origi\
n of LENG shift to the first MARK.\n\nExamples:\n(1)  LINE A    = ( ...  QF PQFC  ... );\n     QUAD QF   = (L=0.3 K1=0.2);\n     M\
ARK PQFC = (OFFSET = -0.5);\n\nHere PQFC represents the center of QF.\n\n(2)  LINE A    = ( ...  PQFC QF  ... );\n\n     QUAD QF  \
 = (L=0.3 K1=0.2);\n     MARK PQFC = (OFFSET =  1.5);\nHere PQFC represents the center of QF, too (consider why). The value of OFF\
SET is interpreted taking the direction of the LINE into account, i.e., a MARK in a line A represents the same location in a line \
-A.\n\nRestrictions:\n(1) Function TrackParticles does not take OFFSET into account if the start\n    or stop location is in the m\
idst of a beam line and a Mark with nonzero\n    OFFSET, in the current version. Tracking for entire beam line or\n    MEASURE(MEA\
) command supports OFFSET.\n(2) The outputs by DISPLAY(DISP) outside of the narrowed region by OFFSET are\n    meaningless."[p$1546
     ,-1],
    ">::",1];
   p1$1546=If[p1$1546==={},1352,-2+p$1546+p1$1546[[1,1]]];
neq=Which["OFFSET is a relative position from the current position. A fraction is allowed to specify a location within an element.\
\n   If the MARK at the beginning of a beam line has OFFSET nonzero, the optics calculation starts from the shifted location. If t\
he last component of a beam line is a MARK with nonzero OFFSET, the optics calculation stops at the shifted location. The periodic\
 condition is applied between those shifted locations.\n   The geometric origin and the origin of LENG shift to the first MARK.\n\\
nExamples:\n(1)  LINE A    = ( ...  QF PQFC  ... );\n     QUAD QF   = (L=0.3 K1=0.2);\n     MARK PQFC = (OFFSET = -0.5);\n\nHere P\
QFC represents the center of QF.\n\n(2)  LINE A    = ( ...  PQFC QF  ... );\n\n     QUAD QF   = (L=0.3 K1=0.2);\n     MARK PQFC = \
(OFFSET =  1.5);\nHere PQFC represents the center of QF, too (consider why). The value of OFFSET is interpreted taking the directi\
on of the LINE into account, i.e., a MARK in a line A represents the same location in a line -A.\n\nRestrictions:\n(1) Function Tr\
ackParticles does not take OFFSET into account if the start\n    or stop location is in the midst of a beam line and a Mark with n\
onzero\n    OFFSET, in the current version. Tracking for entire beam line or\n    MEASURE(MEA) command supports OFFSET.\n(2) The o\
utputs by DISPLAY(DISP) outside of the narrowed region by OFFSET are\n    meaningless."[p$1546,4+p$1546]==="Text[",
    lx$1546:=Help2HTML`oa$;p$1546=5+p$1546;p1$1546-=1;p2$1546=5+p1$1546;p0$1546=-9+p$1546;
If[(pe$1546=StringPosition["OFFSET is a relative position from the current position. A fraction is allowed to specify a location w\
ithin an element.\n   If the MARK at the beginning of a beam line has OFFSET nonzero, the optics calculation starts from the shift\
ed location. If the last component of a beam line is a MARK with nonzero OFFSET, the optics calculation stops at the shifted locat\
ion. The periodic condition is applied between those shifted locations.\n   The geometric origin and the origin of LENG shift to t\
he first MARK.\n\nExamples:\n(1)  LINE A    = ( ...  QF PQFC  ... );\n     QUAD QF   = (L=0.3 K1=0.2);\n     MARK PQFC = (OFFSET =\
 -0.5);\n\nHere PQFC represents the center of QF.\n\n(2)  LINE A    = ( ...  PQFC QF  ... );\n\n     QUAD QF   = (L=0.3 K1=0.2);\n\
     MARK PQFC = (OFFSET =  1.5);\nHere PQFC represents the center of QF, too (consider why). The value of OFFSET is interpreted t\
aking the direction of the LINE into account, i.e., a MARK in a line A represents the same location in a line -A.\n\nRestrictions:\
\n(1) Function TrackParticles does not take OFFSET into account if the start\n    or stop location is in the midst of a beam line \
and a Mark with nonzero\n    OFFSET, in the current version. Tracking for entire beam line or\n    MEASURE(MEA) command supports O\
FFSET.\n(2) The outputs by DISPLAY(DISP) outside of the narrowed region by OFFSET are\n    meaningless."[p$1546,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["OFFSET is a relative position from the current position. A fraction is allowed to specify a location within an el\
ement.\n   If the MARK at the beginning of a beam line has OFFSET nonzero, the optics calculation starts from the shifted location\
. If the last component of a beam line is a MARK with nonzero OFFSET, the optics calculation stops at the shifted location. The pe\
riodic condition is applied between those shifted locations.\n   The geometric origin and the origin of LENG shift to the first MA\
RK.\n\nExamples:\n(1)  LINE A    = ( ...  QF PQFC  ... );\n     QUAD QF   = (L=0.3 K1=0.2);\n     MARK PQFC = (OFFSET = -0.5);\n\n\
Here PQFC represents the center of QF.\n\n(2)  LINE A    = ( ...  PQFC QF  ... );\n\n     QUAD QF   = (L=0.3 K1=0.2);\n     MARK P\
QFC = (OFFSET =  1.5);\nHere PQFC represents the center of QF, too (consider why). The value of OFFSET is interpreted taking the d\
irection of the LINE into account, i.e., a MARK in a line A represents the same location in a line -A.\n\nRestrictions:\n(1) Funct\
ion TrackParticles does not take OFFSET into account if the start\n    or stop location is in the midst of a beam line and a Mark \
with nonzero\n    OFFSET, in the current version. Tracking for entire beam line or\n    MEASURE(MEA) command supports OFFSET.\n(2)\
 The outputs by DISPLAY(DISP) outside of the narrowed region by OFFSET are\n    meaningless."[p$1546+pe$1546[[1,2]],p1$1546]]],
        p1$1546=-2+p$1546+pe$1546[[1,1]]}[[
       1]],
      0],
    1,lx$1546:=Help2HTML`o9$;p2$1546=4+p1$1546;p0$1546=-4+p$1546;0];
  If[(equ$1546=
Help2HTML`o8$["OFFSET is a relative position from the current position. A fraction is allowed to specify a location within an elem\
ent.\n   If the MARK at the beginning of a beam line has OFFSET nonzero, the optics calculation starts from the shifted location. \
If the last component of a beam line is a MARK with nonzero OFFSET, the optics calculation stops at the shifted location. The peri\
odic condition is applied between those shifted locations.\n   The geometric origin and the origin of LENG shift to the first MARK\
.\n\nExamples:\n(1)  LINE A    = ( ...  QF PQFC  ... );\n     QUAD QF   = (L=0.3 K1=0.2);\n     MARK PQFC = (OFFSET = -0.5);\n\nHe\
re PQFC represents the center of QF.\n\n(2)  LINE A    = ( ...  PQFC QF  ... );\n\n     QUAD QF   = (L=0.3 K1=0.2);\n     MARK PQF\
C = (OFFSET =  1.5);\nHere PQFC represents the center of QF, too (consider why). The value of OFFSET is interpreted taking the dir\
ection of the LINE into account, i.e., a MARK in a line A represents the same location in a line -A.\n\nRestrictions:\n(1) Functio\
n TrackParticles does not take OFFSET into account if the start\n    or stop location is in the midst of a beam line and a Mark wi\
th nonzero\n    OFFSET, in the current version. Tracking for entire beam line or\n    MEASURE(MEA) command supports OFFSET.\n(2) T\
he outputs by DISPLAY(DISP) outside of the narrowed region by OFFSET are\n    meaningless."[p$1546,p1$1546]])===
    Undefined,
equ$1546="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["OFFSET is a relative position from the curre\
nt position. A fraction is allowed to specify a location within an element.\n   If the MARK at the beginning of a beam line has OF\
FSET nonzero, the optics calculation starts from the shifted location. If the last component of a beam line is a MARK with nonzero\
 OFFSET, the optics calculation stops at the shifted location. The periodic condition is applied between those shifted locations.\\
n   The geometric origin and the origin of LENG shift to the first MARK.\n\nExamples:\n(1)  LINE A    = ( ...  QF PQFC  ... );\n  \
   QUAD QF   = (L=0.3 K1=0.2);\n     MARK PQFC = (OFFSET = -0.5);\n\nHere PQFC represents the center of QF.\n\n(2)  LINE A    = ( \
...  PQFC QF  ... );\n\n     QUAD QF   = (L=0.3 K1=0.2);\n     MARK PQFC = (OFFSET =  1.5);\nHere PQFC represents the center of QF\
, too (consider why). The value of OFFSET is interpreted taking the direction of the LINE into account, i.e., a MARK in a line A r\
epresents the same location in a line -A.\n\nRestrictions:\n(1) Function TrackParticles does not take OFFSET into account if the s\
tart\n    or stop location is in the midst of a beam line and a Mark with nonzero\n    OFFSET, in the current version. Tracking fo\
r entire beam line or\n    MEASURE(MEA) command supports OFFSET.\n(2) The outputs by DISPLAY(DISP) outside of the narrowed region \
by OFFSET are\n    meaningless."[p$1546,p1$1546]]=
       equ$1546;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1546},out$1546=lx$1546@Typeset["OFFSET is a relative position from the current position. A fraction is allowed to specify\
 a location within an element.\n   If the MARK at the beginning of a beam line has OFFSET nonzero, the optics calculation starts f\
rom the shifted location. If the last component of a beam line is a MARK with nonzero OFFSET, the optics calculation stops at the \
shifted location. The periodic condition is applied between those shifted locations.\n   The geometric origin and the origin of LE\
NG shift to the first MARK.\n\nExamples:\n(1)  LINE A    = ( ...  QF PQFC  ... );\n     QUAD QF   = (L=0.3 K1=0.2);\n     MARK PQF\
C = (OFFSET = -0.5);\n\nHere PQFC represents the center of QF.\n\n(2)  LINE A    = ( ...  PQFC QF  ... );\n\n     QUAD QF   = (L=0\
.3 K1=0.2);\n     MARK PQFC = (OFFSET =  1.5);\nHere PQFC represents the center of QF, too (consider why). The value of OFFSET is \
interpreted taking the direction of the LINE into account, i.e., a MARK in a line A represents the same location in a line -A.\n\n\
Restrictions:\n(1) Function TrackParticles does not take OFFSET into account if the start\n    or stop location is in the midst of\
 a beam line and a Mark with nonzero\n    OFFSET, in the current version. Tracking for entire beam line or\n    MEASURE(MEA) comma\
nd supports OFFSET.\n(2) The outputs by DISPLAY(DISP) outside of the narrowed region by OFFSET are\n    meaningless."[p$1546,
           p1$1546],Format->Help2HTML`oB$];
        System["mv -f "//out$1546//" "//equ$1546]];
      Exit[]]];
   "OFFSET is a relative position from the current position. A fraction is allowed to specify a location within an element.\n   If\
 the MARK at the beginning of a beam line has OFFSET nonzero, the optics calculation starts from the shifted location. If the last\
 component of a beam line is a MARK with nonzero OFFSET, the optics calculation stops at the shifted location. The periodic condit\
ion is applied between those shifted locations.\n   The geometric origin and the origin of LENG shift to the first MARK.\n\nExampl\
es:\n(1)  LINE A    = ( ...  QF PQFC  ... );\n     QUAD QF   = (L=0.3 K1=0.2);\n     MARK PQFC = (OFFSET = -0.5);\n\nHere PQFC rep\
resents the center of QF.\n\n(2)  LINE A    = ( ...  PQFC QF  ... );\n\n     QUAD QF   = (L=0.3 K1=0.2);\n     MARK PQFC = (OFFSET\
 =  1.5);\nHere PQFC represents the center of QF, too (consider why). The value of OFFSET is interpreted taking the direction of t\
he LINE into account, i.e., a MARK in a line A represents the same location in a line -A.\n\nRestrictions:\n(1) Function TrackPart\
icles does not take OFFSET into account if the start\n    or stop location is in the midst of a beam line and a Mark with nonzero\\
n    OFFSET, in the current version. Tracking for entire beam line or\n    MEASURE(MEA) command supports OFFSET.\n(2) The outputs \
by DISPLAY(DISP) outside of the narrowed region by OFFSET are\n    meaningless."[1,Max[p0$1546,0]]//"<img  class=\"eqs\" SRC=\""//
   equ$1546//"\" />"//
Help2HTML`oy$["OFFSET is a relative position from the current position. A fraction is allowed to specify a location within an elem\
ent.\n   If the MARK at the beginning of a beam line has OFFSET nonzero, the optics calculation starts from the shifted location. \
If the last component of a beam line is a MARK with nonzero OFFSET, the optics calculation stops at the shifted location. The peri\
odic condition is applied between those shifted locations.\n   The geometric origin and the origin of LENG shift to the first MARK\
.\n\nExamples:\n(1)  LINE A    = ( ...  QF PQFC  ... );\n     QUAD QF   = (L=0.3 K1=0.2);\n     MARK PQFC = (OFFSET = -0.5);\n\nHe\
re PQFC represents the center of QF.\n\n(2)  LINE A    = ( ...  PQFC QF  ... );\n\n     QUAD QF   = (L=0.3 K1=0.2);\n     MARK PQF\
C = (OFFSET =  1.5);\nHere PQFC represents the center of QF, too (consider why). The value of OFFSET is interpreted taking the dir\
ection of the LINE into account, i.e., a MARK in a line A represents the same location in a line -A.\n\nRestrictions:\n(1) Functio\
n TrackParticles does not take OFFSET into account if the start\n    or stop location is in the midst of a beam line and a Mark wi\
th nonzero\n    OFFSET, in the current version. Tracking for entire beam line or\n    MEASURE(MEA) command supports OFFSET.\n(2) T\
he outputs by DISPLAY(DISP) outside of the narrowed region by OFFSET are\n    meaningless."[p2$1546,-1]]
]</PRE>
</UL>
<LI>
<H3><A NAME=L139>
MULT</A></H3>
<PRE>If[{},
Help2HTML`oA$["A magnet with multipoles. Note that the reference plane is defined so that the skew quadrupole component becomes ze\
ro.\n   It can have a nonzero ANGLE to express a combined function bending magnet with multipoles. Note that the definition of the\
 multipoles with nonzero ANGLE is very special The current version does not allow nonzero ANGLE inside a solenoid or with accelera\
tion. Also the fringe field and emittance calculation are not installed properly for nonzero ANGLE."],
 p$1548=1+p$1548[[1,2]];p1$1548=
StringPosition["A magnet with multipoles. Note that the reference plane is defined so that the skew quadrupole component becomes z\
ero.\n   It can have a nonzero ANGLE to express a combined function bending magnet with multipoles. Note that the definition of th\
e multipoles with nonzero ANGLE is very special The current version does not allow nonzero ANGLE inside a solenoid or with acceler\
ation. Also the fringe field and emittance calculation are not installed properly for nonzero ANGLE."[p$1548,-1],">::",1];
   p1$1548=If[p1$1548==={},473,-2+p$1548+p1$1548[[1,1]]];
neq=Which["A magnet with multipoles. Note that the reference plane is defined so that the skew quadrupole component becomes zero.\\
n   It can have a nonzero ANGLE to express a combined function bending magnet with multipoles. Note that the definition of the mul\
tipoles with nonzero ANGLE is very special The current version does not allow nonzero ANGLE inside a solenoid or with acceleration\
. Also the fringe field and emittance calculation are not installed properly for nonzero ANGLE."[p$1548,4+p$1548]==="Text[",
    lx$1548:=Help2HTML`oa$;p$1548=5+p$1548;p1$1548-=1;p2$1548=5+p1$1548;p0$1548=-9+p$1548;
If[(pe$1548=StringPosition["A magnet with multipoles. Note that the reference plane is defined so that the skew quadrupole compone\
nt becomes zero.\n   It can have a nonzero ANGLE to express a combined function bending magnet with multipoles. Note that the defi\
nition of the multipoles with nonzero ANGLE is very special The current version does not allow nonzero ANGLE inside a solenoid or \
with acceleration. Also the fringe field and emittance calculation are not installed properly for nonzero ANGLE."[p$1548,-2],";;;"]
        )<=>
       {},
      {Max[0,
-1+ToExpression["A magnet with multipoles. Note that the reference plane is defined so that the skew quadrupole component becomes \
zero.\n   It can have a nonzero ANGLE to express a combined function bending magnet with multipoles. Note that the definition of t\
he multipoles with nonzero ANGLE is very special The current version does not allow nonzero ANGLE inside a solenoid or with accele\
ration. Also the fringe field and emittance calculation are not installed properly for nonzero ANGLE."[p$1548+pe$1548[[1,2]],
           p1$1548]]],
        p1$1548=-2+p$1548+pe$1548[[1,1]]}[[
       1]],
      0],
    1,lx$1548:=Help2HTML`o9$;p2$1548=4+p1$1548;p0$1548=-4+p$1548;0];
  If[(equ$1548=
Help2HTML`o8$["A magnet with multipoles. Note that the reference plane is defined so that the skew quadrupole component becomes ze\
ro.\n   It can have a nonzero ANGLE to express a combined function bending magnet with multipoles. Note that the definition of the\
 multipoles with nonzero ANGLE is very special The current version does not allow nonzero ANGLE inside a solenoid or with accelera\
tion. Also the fringe field and emittance calculation are not installed properly for nonzero ANGLE."[p$1548,p1$1548]])===
    Undefined,
equ$1548="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["A magnet with multipoles. Note that the refe\
rence plane is defined so that the skew quadrupole component becomes zero.\n   It can have a nonzero ANGLE to express a combined f\
unction bending magnet with multipoles. Note that the definition of the multipoles with nonzero ANGLE is very special The current \
version does not allow nonzero ANGLE inside a solenoid or with acceleration. Also the fringe field and emittance calculation are n\
ot installed properly for nonzero ANGLE."[p$1548,p1$1548]]=
       equ$1548;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1548},out$1548=lx$1548@Typeset["A magnet with multipoles. Note that the reference plane is defined so that the skew quadr\
upole component becomes zero.\n   It can have a nonzero ANGLE to express a combined function bending magnet with multipoles. Note \
that the definition of the multipoles with nonzero ANGLE is very special The current version does not allow nonzero ANGLE inside a\
 solenoid or with acceleration. Also the fringe field and emittance calculation are not installed properly for nonzero ANGLE."[p
           $1548,p1$1548],Format->Help2HTML`oB$];
        System["mv -f "//out$1548//" "//equ$1548]];
      Exit[]]];
   "A magnet with multipoles. Note that the reference plane is defined so that the skew quadrupole component becomes zero.\n   It \
can have a nonzero ANGLE to express a combined function bending magnet with multipoles. Note that the definition of the multipoles\
 with nonzero ANGLE is very special The current version does not allow nonzero ANGLE inside a solenoid or with acceleration. Also \
the fringe field and emittance calculation are not installed properly for nonzero ANGLE."[1,Max[p0$1548,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$1548//"\" />"//
Help2HTML`oy$["A magnet with multipoles. Note that the reference plane is defined so that the skew quadrupole component becomes ze\
ro.\n   It can have a nonzero ANGLE to express a combined function bending magnet with multipoles. Note that the definition of the\
 multipoles with nonzero ANGLE is very special The current version does not allow nonzero ANGLE inside a solenoid or with accelera\
tion. Also the fringe field and emittance calculation are not installed properly for nonzero ANGLE."[p2$1548,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L202>multipole_with_nonzero_ANGLE</A></PRE>
<UL>
<LI>
<H3><A NAME=L140>
K0</A></H3>
<PRE>The normal dipole magnetic field component (times the length L).

<img  class="eqs" SRC="SADHelp_img/equ_91.svg" />If[{},Help2HTML`oA$["\n\nwhere L is the effective length of the component. Positiv
e sign means horizontal focusing."],p$1552=1+p$1552[[1,2]];p1$1552=StringPosition["\n\nwhere L is the effective length of the compo
nent. Positive sign means horizontal focusing."[p$1552,-1],">::",1];p1$1552=If[p1$1552==={},92,-2+p$1552+p1$1552[[1,1]]];neq=Which[
"\n\nwhere L is the effective length of the component. Positive sign means horizontal focusing."[p$1552,4+p$1552]==="Text[",lx$1552
:=Help2HTML`oa$;p$1552=5+p$1552;p1$1552-=1;p2$1552=5+p1$1552;p0$1552=-9+p$1552;If[(pe$1552=StringPosition["\n\nwhere L is the effec
tive length of the component. Positive sign means horizontal focusing."[p$1552,-2],";;;"])<=>{},{Max[0,-1+ToExpression["\n\nwhere L
 is the effective length of the component. Positive sign means horizontal focusing."[p$1552+pe$1552[[1,2]],p1$1552]]],p1$1552=-2+p$
1552+pe$1552[[1,1]]}[[1]],0],1,lx$1552:=Help2HTML`o9$;p2$1552=4+p1$1552;p0$1552=-4+p$1552;0];If[(equ$1552=Help2HTML`o8$["\n\nwhere 
L is the effective length of the component. Positive sign means horizontal focusing."[p$1552,p1$1552]])===Undefined,equ$1552="SADHe
lp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["\n\nwhere L is the effective length of the component. Positi
ve sign means horizontal focusing."[p$1552,p1$1552]]=equ$1552;LaTeX`ob$+=neq,--LaTeX`ob$;With[{lx$1552},out$1552=lx$1552@Typeset["\
n\nwhere L is the effective length of the component. Positive sign means horizontal focusing."[p$1552,p1$1552],Format->Help2HTML`oB
$];System["mv -f "//out$1552//" "//equ$1552]];Exit[]]];"\n\nwhere L is the effective length of the component. Positive sign means h
orizontal focusing."[1,Max[p0$1552,0]]//"<img  class=\"eqs\" SRC=\""//equ$1552//"\" />"//Help2HTML`oy$["\n\nwhere L is the effectiv
e length of the component. Positive sign means horizontal focusing."[p2$1552,-1]]]
</PRE>
<PRE>See also:
 <A HREF=#L94>L</A></PRE>
<LI>
<H3><A NAME=L141>
SK0</A></H3>
<PRE>The skew dipole magnetic field component (times the length L).
<img  class="eqs" SRC="SADHelp_img/equ_114.svg" />If[{},Help2HTML`oA$["\n\nwhere L is the length of the component. Positive sign me
ans a horizontally focusing magnet rotated around z-axis by -90/1 degree, i.e., ROTATE = 90 DEG ."],p$1556=1+p$1556[[1,2]];p1$1556=
StringPosition["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotated around z-axi
s by -90/1 degree, i.e., ROTATE = 90 DEG ."[p$1556,-1],">::",1];p1$1556=If[p1$1556==={},155,-2+p$1556+p1$1556[[1,1]]];neq=Which["\n
\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotated around z-axis by -90/1 degree,
 i.e., ROTATE = 90 DEG ."[p$1556,4+p$1556]==="Text[",lx$1556:=Help2HTML`oa$;p$1556=5+p$1556;p1$1556-=1;p2$1556=5+p1$1556;p0$1556=-9
+p$1556;If[(pe$1556=StringPosition["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet 
rotated around z-axis by -90/1 degree, i.e., ROTATE = 90 DEG ."[p$1556,-2],";;;"])<=>{},{Max[0,-1+ToExpression["\n\nwhere L is the 
length of the component. Positive sign means a horizontally focusing magnet rotated around z-axis by -90/1 degree, i.e., ROTATE = 9
0 DEG ."[p$1556+pe$1556[[1,2]],p1$1556]]],p1$1556=-2+p$1556+pe$1556[[1,1]]}[[1]],0],1,lx$1556:=Help2HTML`o9$;p2$1556=4+p1$1556;p0$1
556=-4+p$1556;0];If[(equ$1556=Help2HTML`o8$["\n\nwhere L is the length of the component. Positive sign means a horizontally focusin
g magnet rotated around z-axis by -90/1 degree, i.e., ROTATE = 90 DEG ."[p$1556,p1$1556]])===Undefined,equ$1556="SADHelp_img/equ_"/
/++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["\n\nwhere L is the length of the component. Positive sign means a horizon
tally focusing magnet rotated around z-axis by -90/1 degree, i.e., ROTATE = 90 DEG ."[p$1556,p1$1556]]=equ$1556;LaTeX`ob$+=neq,--La
TeX`ob$;With[{lx$1556},out$1556=lx$1556@Typeset["\n\nwhere L is the length of the component. Positive sign means a horizontally foc
using magnet rotated around z-axis by -90/1 degree, i.e., ROTATE = 90 DEG ."[p$1556,p1$1556],Format->Help2HTML`oB$];System["mv -f "
//out$1556//" "//equ$1556]];Exit[]]];"\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magne
t rotated around z-axis by -90/1 degree, i.e., ROTATE = 90 DEG ."[1,Max[p0$1556,0]]//"<img  class=\"eqs\" SRC=\""//equ$1556//"\" />
"//Help2HTML`oy$["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotated around z-a
xis by -90/1 degree, i.e., ROTATE = 90 DEG ."[p2$1556,-1]]]
</PRE>
<PRE>See also:
 <A HREF=#L94>L</A></PRE>
<LI>
<H3><A NAME=L142>
K1</A></H3>
<PRE>The normal quadrupole magnetic field component (times the length L).

<img  class="eqs" SRC="SADHelp_img/equ_92.svg" />If[{},Help2HTML`oA$["\n\nwhere L is the effective length of the component. Positiv
e sign means horizontal focusing."],p$1560=1+p$1560[[1,2]];p1$1560=StringPosition["\n\nwhere L is the effective length of the compo
nent. Positive sign means horizontal focusing."[p$1560,-1],">::",1];p1$1560=If[p1$1560==={},92,-2+p$1560+p1$1560[[1,1]]];neq=Which[
"\n\nwhere L is the effective length of the component. Positive sign means horizontal focusing."[p$1560,4+p$1560]==="Text[",lx$1560
:=Help2HTML`oa$;p$1560=5+p$1560;p1$1560-=1;p2$1560=5+p1$1560;p0$1560=-9+p$1560;If[(pe$1560=StringPosition["\n\nwhere L is the effec
tive length of the component. Positive sign means horizontal focusing."[p$1560,-2],";;;"])<=>{},{Max[0,-1+ToExpression["\n\nwhere L
 is the effective length of the component. Positive sign means horizontal focusing."[p$1560+pe$1560[[1,2]],p1$1560]]],p1$1560=-2+p$
1560+pe$1560[[1,1]]}[[1]],0],1,lx$1560:=Help2HTML`o9$;p2$1560=4+p1$1560;p0$1560=-4+p$1560;0];If[(equ$1560=Help2HTML`o8$["\n\nwhere 
L is the effective length of the component. Positive sign means horizontal focusing."[p$1560,p1$1560]])===Undefined,equ$1560="SADHe
lp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["\n\nwhere L is the effective length of the component. Positi
ve sign means horizontal focusing."[p$1560,p1$1560]]=equ$1560;LaTeX`ob$+=neq,--LaTeX`ob$;With[{lx$1560},out$1560=lx$1560@Typeset["\
n\nwhere L is the effective length of the component. Positive sign means horizontal focusing."[p$1560,p1$1560],Format->Help2HTML`oB
$];System["mv -f "//out$1560//" "//equ$1560]];Exit[]]];"\n\nwhere L is the effective length of the component. Positive sign means h
orizontal focusing."[1,Max[p0$1560,0]]//"<img  class=\"eqs\" SRC=\""//equ$1560//"\" />"//Help2HTML`oy$["\n\nwhere L is the effectiv
e length of the component. Positive sign means horizontal focusing."[p2$1560,-1]]]
</PRE>
<PRE>See also:
 <A HREF=#L94>L</A></PRE>
<LI>
<H3><A NAME=L143>
SK1</A></H3>
<PRE>The skew quadrupole magnetic field component (times the length L).
<img  class="eqs" SRC="SADHelp_img/equ_115.svg" />If[{},Help2HTML`oA$["\n\nwhere L is the length of the component. Positive sign me
ans a horizontally focusing magnet rotated around z-axis by -90/2 degree, i.e., ROTATE = 45 DEG ."],p$1564=1+p$1564[[1,2]];p1$1564=
StringPosition["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotated around z-axi
s by -90/2 degree, i.e., ROTATE = 45 DEG ."[p$1564,-1],">::",1];p1$1564=If[p1$1564==={},155,-2+p$1564+p1$1564[[1,1]]];neq=Which["\n
\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotated around z-axis by -90/2 degree,
 i.e., ROTATE = 45 DEG ."[p$1564,4+p$1564]==="Text[",lx$1564:=Help2HTML`oa$;p$1564=5+p$1564;p1$1564-=1;p2$1564=5+p1$1564;p0$1564=-9
+p$1564;If[(pe$1564=StringPosition["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet 
rotated around z-axis by -90/2 degree, i.e., ROTATE = 45 DEG ."[p$1564,-2],";;;"])<=>{},{Max[0,-1+ToExpression["\n\nwhere L is the 
length of the component. Positive sign means a horizontally focusing magnet rotated around z-axis by -90/2 degree, i.e., ROTATE = 4
5 DEG ."[p$1564+pe$1564[[1,2]],p1$1564]]],p1$1564=-2+p$1564+pe$1564[[1,1]]}[[1]],0],1,lx$1564:=Help2HTML`o9$;p2$1564=4+p1$1564;p0$1
564=-4+p$1564;0];If[(equ$1564=Help2HTML`o8$["\n\nwhere L is the length of the component. Positive sign means a horizontally focusin
g magnet rotated around z-axis by -90/2 degree, i.e., ROTATE = 45 DEG ."[p$1564,p1$1564]])===Undefined,equ$1564="SADHelp_img/equ_"/
/++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["\n\nwhere L is the length of the component. Positive sign means a horizon
tally focusing magnet rotated around z-axis by -90/2 degree, i.e., ROTATE = 45 DEG ."[p$1564,p1$1564]]=equ$1564;LaTeX`ob$+=neq,--La
TeX`ob$;With[{lx$1564},out$1564=lx$1564@Typeset["\n\nwhere L is the length of the component. Positive sign means a horizontally foc
using magnet rotated around z-axis by -90/2 degree, i.e., ROTATE = 45 DEG ."[p$1564,p1$1564],Format->Help2HTML`oB$];System["mv -f "
//out$1564//" "//equ$1564]];Exit[]]];"\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magne
t rotated around z-axis by -90/2 degree, i.e., ROTATE = 45 DEG ."[1,Max[p0$1564,0]]//"<img  class=\"eqs\" SRC=\""//equ$1564//"\" />
"//Help2HTML`oy$["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotated around z-a
xis by -90/2 degree, i.e., ROTATE = 45 DEG ."[p2$1564,-1]]]
</PRE>
<PRE>See also:
 <A HREF=#L94>L</A></PRE>
<LI>
<H3><A NAME=L144>
K2</A></H3>
<PRE>The normal sextupole magnetic field component (times the length L).

<img  class="eqs" SRC="SADHelp_img/equ_116.svg" />If[{},Help2HTML`oA$["\n\nwhere L is the effective length of the component. Positi
ve sign means horizontal focusing."],p$1568=1+p$1568[[1,2]];p1$1568=StringPosition["\n\nwhere L is the effective length of the comp
onent. Positive sign means horizontal focusing."[p$1568,-1],">::",1];p1$1568=If[p1$1568==={},92,-2+p$1568+p1$1568[[1,1]]];neq=Which
["\n\nwhere L is the effective length of the component. Positive sign means horizontal focusing."[p$1568,4+p$1568]==="Text[",lx$156
8:=Help2HTML`oa$;p$1568=5+p$1568;p1$1568-=1;p2$1568=5+p1$1568;p0$1568=-9+p$1568;If[(pe$1568=StringPosition["\n\nwhere L is the effe
ctive length of the component. Positive sign means horizontal focusing."[p$1568,-2],";;;"])<=>{},{Max[0,-1+ToExpression["\n\nwhere 
L is the effective length of the component. Positive sign means horizontal focusing."[p$1568+pe$1568[[1,2]],p1$1568]]],p1$1568=-2+p
$1568+pe$1568[[1,1]]}[[1]],0],1,lx$1568:=Help2HTML`o9$;p2$1568=4+p1$1568;p0$1568=-4+p$1568;0];If[(equ$1568=Help2HTML`o8$["\n\nwhere
 L is the effective length of the component. Positive sign means horizontal focusing."[p$1568,p1$1568]])===Undefined,equ$1568="SADH
elp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["\n\nwhere L is the effective length of the component. Posit
ive sign means horizontal focusing."[p$1568,p1$1568]]=equ$1568;LaTeX`ob$+=neq,--LaTeX`ob$;With[{lx$1568},out$1568=lx$1568@Typeset["
\n\nwhere L is the effective length of the component. Positive sign means horizontal focusing."[p$1568,p1$1568],Format->Help2HTML`o
B$];System["mv -f "//out$1568//" "//equ$1568]];Exit[]]];"\n\nwhere L is the effective length of the component. Positive sign means 
horizontal focusing."[1,Max[p0$1568,0]]//"<img  class=\"eqs\" SRC=\""//equ$1568//"\" />"//Help2HTML`oy$["\n\nwhere L is the effecti
ve length of the component. Positive sign means horizontal focusing."[p2$1568,-1]]]
</PRE>
<PRE>See also:
 <A HREF=#L94>L</A></PRE>
<LI>
<H3><A NAME=L145>
SK2</A></H3>
<PRE>The skew sextupole magnetic field component (times the length L).
<img  class="eqs" SRC="SADHelp_img/equ_117.svg" />If[{},Help2HTML`oA$["\n\nwhere L is the length of the component. Positive sign me
ans a horizontally focusing magnet rotated around z-axis by -90/3 degree, i.e., ROTATE = 30 DEG ."],p$1572=1+p$1572[[1,2]];p1$1572=
StringPosition["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotated around z-axi
s by -90/3 degree, i.e., ROTATE = 30 DEG ."[p$1572,-1],">::",1];p1$1572=If[p1$1572==={},155,-2+p$1572+p1$1572[[1,1]]];neq=Which["\n
\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotated around z-axis by -90/3 degree,
 i.e., ROTATE = 30 DEG ."[p$1572,4+p$1572]==="Text[",lx$1572:=Help2HTML`oa$;p$1572=5+p$1572;p1$1572-=1;p2$1572=5+p1$1572;p0$1572=-9
+p$1572;If[(pe$1572=StringPosition["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet 
rotated around z-axis by -90/3 degree, i.e., ROTATE = 30 DEG ."[p$1572,-2],";;;"])<=>{},{Max[0,-1+ToExpression["\n\nwhere L is the 
length of the component. Positive sign means a horizontally focusing magnet rotated around z-axis by -90/3 degree, i.e., ROTATE = 3
0 DEG ."[p$1572+pe$1572[[1,2]],p1$1572]]],p1$1572=-2+p$1572+pe$1572[[1,1]]}[[1]],0],1,lx$1572:=Help2HTML`o9$;p2$1572=4+p1$1572;p0$1
572=-4+p$1572;0];If[(equ$1572=Help2HTML`o8$["\n\nwhere L is the length of the component. Positive sign means a horizontally focusin
g magnet rotated around z-axis by -90/3 degree, i.e., ROTATE = 30 DEG ."[p$1572,p1$1572]])===Undefined,equ$1572="SADHelp_img/equ_"/
/++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["\n\nwhere L is the length of the component. Positive sign means a horizon
tally focusing magnet rotated around z-axis by -90/3 degree, i.e., ROTATE = 30 DEG ."[p$1572,p1$1572]]=equ$1572;LaTeX`ob$+=neq,--La
TeX`ob$;With[{lx$1572},out$1572=lx$1572@Typeset["\n\nwhere L is the length of the component. Positive sign means a horizontally foc
using magnet rotated around z-axis by -90/3 degree, i.e., ROTATE = 30 DEG ."[p$1572,p1$1572],Format->Help2HTML`oB$];System["mv -f "
//out$1572//" "//equ$1572]];Exit[]]];"\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magne
t rotated around z-axis by -90/3 degree, i.e., ROTATE = 30 DEG ."[1,Max[p0$1572,0]]//"<img  class=\"eqs\" SRC=\""//equ$1572//"\" />
"//Help2HTML`oy$["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotated around z-a
xis by -90/3 degree, i.e., ROTATE = 30 DEG ."[p2$1572,-1]]]
</PRE>
<PRE>See also:
 <A HREF=#L94>L</A></PRE>
<LI>
<H3><A NAME=L146>
K3</A></H3>
<PRE>The normal octupole magnetic field component (times the length L).

<img  class="eqs" SRC="SADHelp_img/equ_118.svg" />If[{},Help2HTML`oA$["\n\nwhere L is the effective length of the component. Positi
ve sign means horizontal focusing."],p$1576=1+p$1576[[1,2]];p1$1576=StringPosition["\n\nwhere L is the effective length of the comp
onent. Positive sign means horizontal focusing."[p$1576,-1],">::",1];p1$1576=If[p1$1576==={},92,-2+p$1576+p1$1576[[1,1]]];neq=Which
["\n\nwhere L is the effective length of the component. Positive sign means horizontal focusing."[p$1576,4+p$1576]==="Text[",lx$157
6:=Help2HTML`oa$;p$1576=5+p$1576;p1$1576-=1;p2$1576=5+p1$1576;p0$1576=-9+p$1576;If[(pe$1576=StringPosition["\n\nwhere L is the effe
ctive length of the component. Positive sign means horizontal focusing."[p$1576,-2],";;;"])<=>{},{Max[0,-1+ToExpression["\n\nwhere 
L is the effective length of the component. Positive sign means horizontal focusing."[p$1576+pe$1576[[1,2]],p1$1576]]],p1$1576=-2+p
$1576+pe$1576[[1,1]]}[[1]],0],1,lx$1576:=Help2HTML`o9$;p2$1576=4+p1$1576;p0$1576=-4+p$1576;0];If[(equ$1576=Help2HTML`o8$["\n\nwhere
 L is the effective length of the component. Positive sign means horizontal focusing."[p$1576,p1$1576]])===Undefined,equ$1576="SADH
elp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["\n\nwhere L is the effective length of the component. Posit
ive sign means horizontal focusing."[p$1576,p1$1576]]=equ$1576;LaTeX`ob$+=neq,--LaTeX`ob$;With[{lx$1576},out$1576=lx$1576@Typeset["
\n\nwhere L is the effective length of the component. Positive sign means horizontal focusing."[p$1576,p1$1576],Format->Help2HTML`o
B$];System["mv -f "//out$1576//" "//equ$1576]];Exit[]]];"\n\nwhere L is the effective length of the component. Positive sign means 
horizontal focusing."[1,Max[p0$1576,0]]//"<img  class=\"eqs\" SRC=\""//equ$1576//"\" />"//Help2HTML`oy$["\n\nwhere L is the effecti
ve length of the component. Positive sign means horizontal focusing."[p2$1576,-1]]]
</PRE>
<PRE>See also:
 <A HREF=#L94>L</A></PRE>
<LI>
<H3><A NAME=L147>
SK3</A></H3>
<PRE>The skew octupole magnetic field component (times the length L).
<img  class="eqs" SRC="SADHelp_img/equ_119.svg" />If[{},Help2HTML`oA$["\n\nwhere L is the length of the component. Positive sign me
ans a horizontally focusing magnet rotated around z-axis by -90/4 degree, i.e., ROTATE = 22.5 DEG ."],p$1580=1+p$1580[[1,2]];p1$158
0=StringPosition["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotated around z-a
xis by -90/4 degree, i.e., ROTATE = 22.5 DEG ."[p$1580,-1],">::",1];p1$1580=If[p1$1580==={},157,-2+p$1580+p1$1580[[1,1]]];neq=Which
["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotated around z-axis by -90/4 deg
ree, i.e., ROTATE = 22.5 DEG ."[p$1580,4+p$1580]==="Text[",lx$1580:=Help2HTML`oa$;p$1580=5+p$1580;p1$1580-=1;p2$1580=5+p1$1580;p0$1
580=-9+p$1580;If[(pe$1580=StringPosition["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing m
agnet rotated around z-axis by -90/4 degree, i.e., ROTATE = 22.5 DEG ."[p$1580,-2],";;;"])<=>{},{Max[0,-1+ToExpression["\n\nwhere L
 is the length of the component. Positive sign means a horizontally focusing magnet rotated around z-axis by -90/4 degree, i.e., RO
TATE = 22.5 DEG ."[p$1580+pe$1580[[1,2]],p1$1580]]],p1$1580=-2+p$1580+pe$1580[[1,1]]}[[1]],0],1,lx$1580:=Help2HTML`o9$;p2$1580=4+p1
$1580;p0$1580=-4+p$1580;0];If[(equ$1580=Help2HTML`o8$["\n\nwhere L is the length of the component. Positive sign means a horizontal
ly focusing magnet rotated around z-axis by -90/4 degree, i.e., ROTATE = 22.5 DEG ."[p$1580,p1$1580]])===Undefined,equ$1580="SADHel
p_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["\n\nwhere L is the length of the component. Positive sign mea
ns a horizontally focusing magnet rotated around z-axis by -90/4 degree, i.e., ROTATE = 22.5 DEG ."[p$1580,p1$1580]]=equ$1580;LaTeX
`ob$+=neq,--LaTeX`ob$;With[{lx$1580},out$1580=lx$1580@Typeset["\n\nwhere L is the length of the component. Positive sign means a ho
rizontally focusing magnet rotated around z-axis by -90/4 degree, i.e., ROTATE = 22.5 DEG ."[p$1580,p1$1580],Format->Help2HTML`oB$]
;System["mv -f "//out$1580//" "//equ$1580]];Exit[]]];"\n\nwhere L is the length of the component. Positive sign means a horizontall
y focusing magnet rotated around z-axis by -90/4 degree, i.e., ROTATE = 22.5 DEG ."[1,Max[p0$1580,0]]//"<img  class=\"eqs\" SRC=\""
//equ$1580//"\" />"//Help2HTML`oy$["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet 
rotated around z-axis by -90/4 degree, i.e., ROTATE = 22.5 DEG ."[p2$1580,-1]]]
</PRE>
<PRE>See also:
 <A HREF=#L94>L</A></PRE>
<LI>
<H3><A NAME=L148>
K4</A></H3>
<PRE>The normal decapole magnetic field component (times the length L).

<img  class="eqs" SRC="SADHelp_img/equ_104.svg" />If[{},Help2HTML`oA$["\n\nwhere L is the effective length of the component. Positi
ve sign means horizontal focusing."],p$1584=1+p$1584[[1,2]];p1$1584=StringPosition["\n\nwhere L is the effective length of the comp
onent. Positive sign means horizontal focusing."[p$1584,-1],">::",1];p1$1584=If[p1$1584==={},92,-2+p$1584+p1$1584[[1,1]]];neq=Which
["\n\nwhere L is the effective length of the component. Positive sign means horizontal focusing."[p$1584,4+p$1584]==="Text[",lx$158
4:=Help2HTML`oa$;p$1584=5+p$1584;p1$1584-=1;p2$1584=5+p1$1584;p0$1584=-9+p$1584;If[(pe$1584=StringPosition["\n\nwhere L is the effe
ctive length of the component. Positive sign means horizontal focusing."[p$1584,-2],";;;"])<=>{},{Max[0,-1+ToExpression["\n\nwhere 
L is the effective length of the component. Positive sign means horizontal focusing."[p$1584+pe$1584[[1,2]],p1$1584]]],p1$1584=-2+p
$1584+pe$1584[[1,1]]}[[1]],0],1,lx$1584:=Help2HTML`o9$;p2$1584=4+p1$1584;p0$1584=-4+p$1584;0];If[(equ$1584=Help2HTML`o8$["\n\nwhere
 L is the effective length of the component. Positive sign means horizontal focusing."[p$1584,p1$1584]])===Undefined,equ$1584="SADH
elp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["\n\nwhere L is the effective length of the component. Posit
ive sign means horizontal focusing."[p$1584,p1$1584]]=equ$1584;LaTeX`ob$+=neq,--LaTeX`ob$;With[{lx$1584},out$1584=lx$1584@Typeset["
\n\nwhere L is the effective length of the component. Positive sign means horizontal focusing."[p$1584,p1$1584],Format->Help2HTML`o
B$];System["mv -f "//out$1584//" "//equ$1584]];Exit[]]];"\n\nwhere L is the effective length of the component. Positive sign means 
horizontal focusing."[1,Max[p0$1584,0]]//"<img  class=\"eqs\" SRC=\""//equ$1584//"\" />"//Help2HTML`oy$["\n\nwhere L is the effecti
ve length of the component. Positive sign means horizontal focusing."[p2$1584,-1]]]
</PRE>
<PRE>See also:
 <A HREF=#L94>L</A></PRE>
<LI>
<H3><A NAME=L149>
SK4</A></H3>
<PRE>The skew decapole magnetic field component (times the length L).
<img  class="eqs" SRC="SADHelp_img/equ_120.svg" />If[{},Help2HTML`oA$["\n\nwhere L is the length of the component. Positive sign me
ans a horizontally focusing magnet rotated around z-axis by -90/5 degree, i.e., ROTATE = 18 DEG ."],p$1588=1+p$1588[[1,2]];p1$1588=
StringPosition["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotated around z-axi
s by -90/5 degree, i.e., ROTATE = 18 DEG ."[p$1588,-1],">::",1];p1$1588=If[p1$1588==={},155,-2+p$1588+p1$1588[[1,1]]];neq=Which["\n
\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotated around z-axis by -90/5 degree,
 i.e., ROTATE = 18 DEG ."[p$1588,4+p$1588]==="Text[",lx$1588:=Help2HTML`oa$;p$1588=5+p$1588;p1$1588-=1;p2$1588=5+p1$1588;p0$1588=-9
+p$1588;If[(pe$1588=StringPosition["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet 
rotated around z-axis by -90/5 degree, i.e., ROTATE = 18 DEG ."[p$1588,-2],";;;"])<=>{},{Max[0,-1+ToExpression["\n\nwhere L is the 
length of the component. Positive sign means a horizontally focusing magnet rotated around z-axis by -90/5 degree, i.e., ROTATE = 1
8 DEG ."[p$1588+pe$1588[[1,2]],p1$1588]]],p1$1588=-2+p$1588+pe$1588[[1,1]]}[[1]],0],1,lx$1588:=Help2HTML`o9$;p2$1588=4+p1$1588;p0$1
588=-4+p$1588;0];If[(equ$1588=Help2HTML`o8$["\n\nwhere L is the length of the component. Positive sign means a horizontally focusin
g magnet rotated around z-axis by -90/5 degree, i.e., ROTATE = 18 DEG ."[p$1588,p1$1588]])===Undefined,equ$1588="SADHelp_img/equ_"/
/++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["\n\nwhere L is the length of the component. Positive sign means a horizon
tally focusing magnet rotated around z-axis by -90/5 degree, i.e., ROTATE = 18 DEG ."[p$1588,p1$1588]]=equ$1588;LaTeX`ob$+=neq,--La
TeX`ob$;With[{lx$1588},out$1588=lx$1588@Typeset["\n\nwhere L is the length of the component. Positive sign means a horizontally foc
using magnet rotated around z-axis by -90/5 degree, i.e., ROTATE = 18 DEG ."[p$1588,p1$1588],Format->Help2HTML`oB$];System["mv -f "
//out$1588//" "//equ$1588]];Exit[]]];"\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magne
t rotated around z-axis by -90/5 degree, i.e., ROTATE = 18 DEG ."[1,Max[p0$1588,0]]//"<img  class=\"eqs\" SRC=\""//equ$1588//"\" />
"//Help2HTML`oy$["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotated around z-a
xis by -90/5 degree, i.e., ROTATE = 18 DEG ."[p2$1588,-1]]]
</PRE>
<PRE>See also:
 <A HREF=#L94>L</A></PRE>
<LI>
<H3><A NAME=L150>
K5</A></H3>
<PRE>The normal dodecapole magnetic field component (times the length L).

<img  class="eqs" SRC="SADHelp_img/equ_108.svg" />If[{},Help2HTML`oA$["\n\nwhere L is the effective length of the component. Positi
ve sign means horizontal focusing."],p$1592=1+p$1592[[1,2]];p1$1592=StringPosition["\n\nwhere L is the effective length of the comp
onent. Positive sign means horizontal focusing."[p$1592,-1],">::",1];p1$1592=If[p1$1592==={},92,-2+p$1592+p1$1592[[1,1]]];neq=Which
["\n\nwhere L is the effective length of the component. Positive sign means horizontal focusing."[p$1592,4+p$1592]==="Text[",lx$159
2:=Help2HTML`oa$;p$1592=5+p$1592;p1$1592-=1;p2$1592=5+p1$1592;p0$1592=-9+p$1592;If[(pe$1592=StringPosition["\n\nwhere L is the effe
ctive length of the component. Positive sign means horizontal focusing."[p$1592,-2],";;;"])<=>{},{Max[0,-1+ToExpression["\n\nwhere 
L is the effective length of the component. Positive sign means horizontal focusing."[p$1592+pe$1592[[1,2]],p1$1592]]],p1$1592=-2+p
$1592+pe$1592[[1,1]]}[[1]],0],1,lx$1592:=Help2HTML`o9$;p2$1592=4+p1$1592;p0$1592=-4+p$1592;0];If[(equ$1592=Help2HTML`o8$["\n\nwhere
 L is the effective length of the component. Positive sign means horizontal focusing."[p$1592,p1$1592]])===Undefined,equ$1592="SADH
elp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["\n\nwhere L is the effective length of the component. Posit
ive sign means horizontal focusing."[p$1592,p1$1592]]=equ$1592;LaTeX`ob$+=neq,--LaTeX`ob$;With[{lx$1592},out$1592=lx$1592@Typeset["
\n\nwhere L is the effective length of the component. Positive sign means horizontal focusing."[p$1592,p1$1592],Format->Help2HTML`o
B$];System["mv -f "//out$1592//" "//equ$1592]];Exit[]]];"\n\nwhere L is the effective length of the component. Positive sign means 
horizontal focusing."[1,Max[p0$1592,0]]//"<img  class=\"eqs\" SRC=\""//equ$1592//"\" />"//Help2HTML`oy$["\n\nwhere L is the effecti
ve length of the component. Positive sign means horizontal focusing."[p2$1592,-1]]]
</PRE>
<PRE>See also:
 <A HREF=#L94>L</A></PRE>
<LI>
<H3><A NAME=L151>
SK5</A></H3>
<PRE>The skew dodecapole magnetic field component (times the length L).
<img  class="eqs" SRC="SADHelp_img/equ_121.svg" />If[{},Help2HTML`oA$["\n\nwhere L is the length of the component. Positive sign me
ans a horizontally focusing magnet rotated around z-axis by -90/6 degree, i.e., ROTATE = 15 DEG ."],p$1596=1+p$1596[[1,2]];p1$1596=
StringPosition["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotated around z-axi
s by -90/6 degree, i.e., ROTATE = 15 DEG ."[p$1596,-1],">::",1];p1$1596=If[p1$1596==={},155,-2+p$1596+p1$1596[[1,1]]];neq=Which["\n
\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotated around z-axis by -90/6 degree,
 i.e., ROTATE = 15 DEG ."[p$1596,4+p$1596]==="Text[",lx$1596:=Help2HTML`oa$;p$1596=5+p$1596;p1$1596-=1;p2$1596=5+p1$1596;p0$1596=-9
+p$1596;If[(pe$1596=StringPosition["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet 
rotated around z-axis by -90/6 degree, i.e., ROTATE = 15 DEG ."[p$1596,-2],";;;"])<=>{},{Max[0,-1+ToExpression["\n\nwhere L is the 
length of the component. Positive sign means a horizontally focusing magnet rotated around z-axis by -90/6 degree, i.e., ROTATE = 1
5 DEG ."[p$1596+pe$1596[[1,2]],p1$1596]]],p1$1596=-2+p$1596+pe$1596[[1,1]]}[[1]],0],1,lx$1596:=Help2HTML`o9$;p2$1596=4+p1$1596;p0$1
596=-4+p$1596;0];If[(equ$1596=Help2HTML`o8$["\n\nwhere L is the length of the component. Positive sign means a horizontally focusin
g magnet rotated around z-axis by -90/6 degree, i.e., ROTATE = 15 DEG ."[p$1596,p1$1596]])===Undefined,equ$1596="SADHelp_img/equ_"/
/++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["\n\nwhere L is the length of the component. Positive sign means a horizon
tally focusing magnet rotated around z-axis by -90/6 degree, i.e., ROTATE = 15 DEG ."[p$1596,p1$1596]]=equ$1596;LaTeX`ob$+=neq,--La
TeX`ob$;With[{lx$1596},out$1596=lx$1596@Typeset["\n\nwhere L is the length of the component. Positive sign means a horizontally foc
using magnet rotated around z-axis by -90/6 degree, i.e., ROTATE = 15 DEG ."[p$1596,p1$1596],Format->Help2HTML`oB$];System["mv -f "
//out$1596//" "//equ$1596]];Exit[]]];"\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magne
t rotated around z-axis by -90/6 degree, i.e., ROTATE = 15 DEG ."[1,Max[p0$1596,0]]//"<img  class=\"eqs\" SRC=\""//equ$1596//"\" />
"//Help2HTML`oy$["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotated around z-a
xis by -90/6 degree, i.e., ROTATE = 15 DEG ."[p2$1596,-1]]]
</PRE>
<PRE>See also:
 <A HREF=#L94>L</A></PRE>
<LI>
<H3><A NAME=L152>
K6</A></H3>
<PRE>The normal 14-pole magnetic field component (times the length L).

<img  class="eqs" SRC="SADHelp_img/equ_122.svg" />If[{},Help2HTML`oA$["\n\nwhere L is the effective length of the component. Positi
ve sign means horizontal focusing."],p$1600=1+p$1600[[1,2]];p1$1600=StringPosition["\n\nwhere L is the effective length of the comp
onent. Positive sign means horizontal focusing."[p$1600,-1],">::",1];p1$1600=If[p1$1600==={},92,-2+p$1600+p1$1600[[1,1]]];neq=Which
["\n\nwhere L is the effective length of the component. Positive sign means horizontal focusing."[p$1600,4+p$1600]==="Text[",lx$160
0:=Help2HTML`oa$;p$1600=5+p$1600;p1$1600-=1;p2$1600=5+p1$1600;p0$1600=-9+p$1600;If[(pe$1600=StringPosition["\n\nwhere L is the effe
ctive length of the component. Positive sign means horizontal focusing."[p$1600,-2],";;;"])<=>{},{Max[0,-1+ToExpression["\n\nwhere 
L is the effective length of the component. Positive sign means horizontal focusing."[p$1600+pe$1600[[1,2]],p1$1600]]],p1$1600=-2+p
$1600+pe$1600[[1,1]]}[[1]],0],1,lx$1600:=Help2HTML`o9$;p2$1600=4+p1$1600;p0$1600=-4+p$1600;0];If[(equ$1600=Help2HTML`o8$["\n\nwhere
 L is the effective length of the component. Positive sign means horizontal focusing."[p$1600,p1$1600]])===Undefined,equ$1600="SADH
elp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["\n\nwhere L is the effective length of the component. Posit
ive sign means horizontal focusing."[p$1600,p1$1600]]=equ$1600;LaTeX`ob$+=neq,--LaTeX`ob$;With[{lx$1600},out$1600=lx$1600@Typeset["
\n\nwhere L is the effective length of the component. Positive sign means horizontal focusing."[p$1600,p1$1600],Format->Help2HTML`o
B$];System["mv -f "//out$1600//" "//equ$1600]];Exit[]]];"\n\nwhere L is the effective length of the component. Positive sign means 
horizontal focusing."[1,Max[p0$1600,0]]//"<img  class=\"eqs\" SRC=\""//equ$1600//"\" />"//Help2HTML`oy$["\n\nwhere L is the effecti
ve length of the component. Positive sign means horizontal focusing."[p2$1600,-1]]]
</PRE>
<PRE>See also:
 <A HREF=#L94>L</A></PRE>
<LI>
<H3><A NAME=L153>
SK6</A></H3>
<PRE>The skew 14-pole magnetic field component (times the length L).
<img  class="eqs" SRC="SADHelp_img/equ_123.svg" />If[{},Help2HTML`oA$["\n\nwhere L is the length of the component. Positive sign me
ans a horizontally focusing magnet rotated around z-axis by -90/7 degree, i.e., ROTATE = 12.857142857142856 DEG ."],p$1604=1+p$1604
[[1,2]];p1$1604=StringPosition["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rota
ted around z-axis by -90/7 degree, i.e., ROTATE = 12.857142857142856 DEG ."[p$1604,-1],">::",1];p1$1604=If[p1$1604==={},171,-2+p$16
04+p1$1604[[1,1]]];neq=Which["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotate
d around z-axis by -90/7 degree, i.e., ROTATE = 12.857142857142856 DEG ."[p$1604,4+p$1604]==="Text[",lx$1604:=Help2HTML`oa$;p$1604=
5+p$1604;p1$1604-=1;p2$1604=5+p1$1604;p0$1604=-9+p$1604;If[(pe$1604=StringPosition["\n\nwhere L is the length of the component. Pos
itive sign means a horizontally focusing magnet rotated around z-axis by -90/7 degree, i.e., ROTATE = 12.857142857142856 DEG ."[p$1
604,-2],";;;"])<=>{},{Max[0,-1+ToExpression["\n\nwhere L is the length of the component. Positive sign means a horizontally focusin
g magnet rotated around z-axis by -90/7 degree, i.e., ROTATE = 12.857142857142856 DEG ."[p$1604+pe$1604[[1,2]],p1$1604]]],p1$1604=-
2+p$1604+pe$1604[[1,1]]}[[1]],0],1,lx$1604:=Help2HTML`o9$;p2$1604=4+p1$1604;p0$1604=-4+p$1604;0];If[(equ$1604=Help2HTML`o8$["\n\nwh
ere L is the length of the component. Positive sign means a horizontally focusing magnet rotated around z-axis by -90/7 degree, i.e
., ROTATE = 12.857142857142856 DEG ."[p$1604,p1$1604]])===Undefined,equ$1604="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If
[Fork[],Help2HTML`o8$["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotated aroun
d z-axis by -90/7 degree, i.e., ROTATE = 12.857142857142856 DEG ."[p$1604,p1$1604]]=equ$1604;LaTeX`ob$+=neq,--LaTeX`ob$;With[{lx$16
04},out$1604=lx$1604@Typeset["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotate
d around z-axis by -90/7 degree, i.e., ROTATE = 12.857142857142856 DEG ."[p$1604,p1$1604],Format->Help2HTML`oB$];System["mv -f "//o
ut$1604//" "//equ$1604]];Exit[]]];"\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet r
otated around z-axis by -90/7 degree, i.e., ROTATE = 12.857142857142856 DEG ."[1,Max[p0$1604,0]]//"<img  class=\"eqs\" SRC=\""//equ
$1604//"\" />"//Help2HTML`oy$["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotat
ed around z-axis by -90/7 degree, i.e., ROTATE = 12.857142857142856 DEG ."[p2$1604,-1]]]
</PRE>
<PRE>See also:
 <A HREF=#L94>L</A></PRE>
<LI>
<H3><A NAME=L154>
K7</A></H3>
<PRE>The normal 16-pole magnetic field component (times the length L).

<img  class="eqs" SRC="SADHelp_img/equ_124.svg" />If[{},Help2HTML`oA$["\n\nwhere L is the effective length of the component. Positi
ve sign means horizontal focusing."],p$1608=1+p$1608[[1,2]];p1$1608=StringPosition["\n\nwhere L is the effective length of the comp
onent. Positive sign means horizontal focusing."[p$1608,-1],">::",1];p1$1608=If[p1$1608==={},92,-2+p$1608+p1$1608[[1,1]]];neq=Which
["\n\nwhere L is the effective length of the component. Positive sign means horizontal focusing."[p$1608,4+p$1608]==="Text[",lx$160
8:=Help2HTML`oa$;p$1608=5+p$1608;p1$1608-=1;p2$1608=5+p1$1608;p0$1608=-9+p$1608;If[(pe$1608=StringPosition["\n\nwhere L is the effe
ctive length of the component. Positive sign means horizontal focusing."[p$1608,-2],";;;"])<=>{},{Max[0,-1+ToExpression["\n\nwhere 
L is the effective length of the component. Positive sign means horizontal focusing."[p$1608+pe$1608[[1,2]],p1$1608]]],p1$1608=-2+p
$1608+pe$1608[[1,1]]}[[1]],0],1,lx$1608:=Help2HTML`o9$;p2$1608=4+p1$1608;p0$1608=-4+p$1608;0];If[(equ$1608=Help2HTML`o8$["\n\nwhere
 L is the effective length of the component. Positive sign means horizontal focusing."[p$1608,p1$1608]])===Undefined,equ$1608="SADH
elp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["\n\nwhere L is the effective length of the component. Posit
ive sign means horizontal focusing."[p$1608,p1$1608]]=equ$1608;LaTeX`ob$+=neq,--LaTeX`ob$;With[{lx$1608},out$1608=lx$1608@Typeset["
\n\nwhere L is the effective length of the component. Positive sign means horizontal focusing."[p$1608,p1$1608],Format->Help2HTML`o
B$];System["mv -f "//out$1608//" "//equ$1608]];Exit[]]];"\n\nwhere L is the effective length of the component. Positive sign means 
horizontal focusing."[1,Max[p0$1608,0]]//"<img  class=\"eqs\" SRC=\""//equ$1608//"\" />"//Help2HTML`oy$["\n\nwhere L is the effecti
ve length of the component. Positive sign means horizontal focusing."[p2$1608,-1]]]
</PRE>
<PRE>See also:
 <A HREF=#L94>L</A></PRE>
<LI>
<H3><A NAME=L155>
SK7</A></H3>
<PRE>The skew 16-pole magnetic field component (times the length L).
<img  class="eqs" SRC="SADHelp_img/equ_125.svg" />If[{},Help2HTML`oA$["\n\nwhere L is the length of the component. Positive sign me
ans a horizontally focusing magnet rotated around z-axis by -90/8 degree, i.e., ROTATE = 11.25 DEG ."],p$1612=1+p$1612[[1,2]];p1$16
12=StringPosition["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotated around z-
axis by -90/8 degree, i.e., ROTATE = 11.25 DEG ."[p$1612,-1],">::",1];p1$1612=If[p1$1612==={},158,-2+p$1612+p1$1612[[1,1]]];neq=Whi
ch["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotated around z-axis by -90/8 d
egree, i.e., ROTATE = 11.25 DEG ."[p$1612,4+p$1612]==="Text[",lx$1612:=Help2HTML`oa$;p$1612=5+p$1612;p1$1612-=1;p2$1612=5+p1$1612;p
0$1612=-9+p$1612;If[(pe$1612=StringPosition["\n\nwhere L is the length of the component. Positive sign means a horizontally focusin
g magnet rotated around z-axis by -90/8 degree, i.e., ROTATE = 11.25 DEG ."[p$1612,-2],";;;"])<=>{},{Max[0,-1+ToExpression["\n\nwhe
re L is the length of the component. Positive sign means a horizontally focusing magnet rotated around z-axis by -90/8 degree, i.e.
, ROTATE = 11.25 DEG ."[p$1612+pe$1612[[1,2]],p1$1612]]],p1$1612=-2+p$1612+pe$1612[[1,1]]}[[1]],0],1,lx$1612:=Help2HTML`o9$;p2$1612
=4+p1$1612;p0$1612=-4+p$1612;0];If[(equ$1612=Help2HTML`o8$["\n\nwhere L is the length of the component. Positive sign means a horiz
ontally focusing magnet rotated around z-axis by -90/8 degree, i.e., ROTATE = 11.25 DEG ."[p$1612,p1$1612]])===Undefined,equ$1612="
SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["\n\nwhere L is the length of the component. Positive si
gn means a horizontally focusing magnet rotated around z-axis by -90/8 degree, i.e., ROTATE = 11.25 DEG ."[p$1612,p1$1612]]=equ$161
2;LaTeX`ob$+=neq,--LaTeX`ob$;With[{lx$1612},out$1612=lx$1612@Typeset["\n\nwhere L is the length of the component. Positive sign mea
ns a horizontally focusing magnet rotated around z-axis by -90/8 degree, i.e., ROTATE = 11.25 DEG ."[p$1612,p1$1612],Format->Help2H
TML`oB$];System["mv -f "//out$1612//" "//equ$1612]];Exit[]]];"\n\nwhere L is the length of the component. Positive sign means a hor
izontally focusing magnet rotated around z-axis by -90/8 degree, i.e., ROTATE = 11.25 DEG ."[1,Max[p0$1612,0]]//"<img  class=\"eqs\
" SRC=\""//equ$1612//"\" />"//Help2HTML`oy$["\n\nwhere L is the length of the component. Positive sign means a horizontally focusin
g magnet rotated around z-axis by -90/8 degree, i.e., ROTATE = 11.25 DEG ."[p2$1612,-1]]]
</PRE>
<PRE>See also:
 <A HREF=#L94>L</A></PRE>
<LI>
<H3><A NAME=L156>
K8</A></H3>
<PRE>The normal 18-pole magnetic field component (times the length L).

<img  class="eqs" SRC="SADHelp_img/equ_126.svg" />If[{},Help2HTML`oA$["\n\nwhere L is the effective length of the component. Positi
ve sign means horizontal focusing."],p$1616=1+p$1616[[1,2]];p1$1616=StringPosition["\n\nwhere L is the effective length of the comp
onent. Positive sign means horizontal focusing."[p$1616,-1],">::",1];p1$1616=If[p1$1616==={},92,-2+p$1616+p1$1616[[1,1]]];neq=Which
["\n\nwhere L is the effective length of the component. Positive sign means horizontal focusing."[p$1616,4+p$1616]==="Text[",lx$161
6:=Help2HTML`oa$;p$1616=5+p$1616;p1$1616-=1;p2$1616=5+p1$1616;p0$1616=-9+p$1616;If[(pe$1616=StringPosition["\n\nwhere L is the effe
ctive length of the component. Positive sign means horizontal focusing."[p$1616,-2],";;;"])<=>{},{Max[0,-1+ToExpression["\n\nwhere 
L is the effective length of the component. Positive sign means horizontal focusing."[p$1616+pe$1616[[1,2]],p1$1616]]],p1$1616=-2+p
$1616+pe$1616[[1,1]]}[[1]],0],1,lx$1616:=Help2HTML`o9$;p2$1616=4+p1$1616;p0$1616=-4+p$1616;0];If[(equ$1616=Help2HTML`o8$["\n\nwhere
 L is the effective length of the component. Positive sign means horizontal focusing."[p$1616,p1$1616]])===Undefined,equ$1616="SADH
elp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["\n\nwhere L is the effective length of the component. Posit
ive sign means horizontal focusing."[p$1616,p1$1616]]=equ$1616;LaTeX`ob$+=neq,--LaTeX`ob$;With[{lx$1616},out$1616=lx$1616@Typeset["
\n\nwhere L is the effective length of the component. Positive sign means horizontal focusing."[p$1616,p1$1616],Format->Help2HTML`o
B$];System["mv -f "//out$1616//" "//equ$1616]];Exit[]]];"\n\nwhere L is the effective length of the component. Positive sign means 
horizontal focusing."[1,Max[p0$1616,0]]//"<img  class=\"eqs\" SRC=\""//equ$1616//"\" />"//Help2HTML`oy$["\n\nwhere L is the effecti
ve length of the component. Positive sign means horizontal focusing."[p2$1616,-1]]]
</PRE>
<PRE>See also:
 <A HREF=#L94>L</A></PRE>
<LI>
<H3><A NAME=L157>
SK8</A></H3>
<PRE>The skew 18-pole magnetic field component (times the length L).
<img  class="eqs" SRC="SADHelp_img/equ_127.svg" />If[{},Help2HTML`oA$["\n\nwhere L is the length of the component. Positive sign me
ans a horizontally focusing magnet rotated around z-axis by -90/9 degree, i.e., ROTATE = 10 DEG ."],p$1620=1+p$1620[[1,2]];p1$1620=
StringPosition["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotated around z-axi
s by -90/9 degree, i.e., ROTATE = 10 DEG ."[p$1620,-1],">::",1];p1$1620=If[p1$1620==={},155,-2+p$1620+p1$1620[[1,1]]];neq=Which["\n
\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotated around z-axis by -90/9 degree,
 i.e., ROTATE = 10 DEG ."[p$1620,4+p$1620]==="Text[",lx$1620:=Help2HTML`oa$;p$1620=5+p$1620;p1$1620-=1;p2$1620=5+p1$1620;p0$1620=-9
+p$1620;If[(pe$1620=StringPosition["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet 
rotated around z-axis by -90/9 degree, i.e., ROTATE = 10 DEG ."[p$1620,-2],";;;"])<=>{},{Max[0,-1+ToExpression["\n\nwhere L is the 
length of the component. Positive sign means a horizontally focusing magnet rotated around z-axis by -90/9 degree, i.e., ROTATE = 1
0 DEG ."[p$1620+pe$1620[[1,2]],p1$1620]]],p1$1620=-2+p$1620+pe$1620[[1,1]]}[[1]],0],1,lx$1620:=Help2HTML`o9$;p2$1620=4+p1$1620;p0$1
620=-4+p$1620;0];If[(equ$1620=Help2HTML`o8$["\n\nwhere L is the length of the component. Positive sign means a horizontally focusin
g magnet rotated around z-axis by -90/9 degree, i.e., ROTATE = 10 DEG ."[p$1620,p1$1620]])===Undefined,equ$1620="SADHelp_img/equ_"/
/++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["\n\nwhere L is the length of the component. Positive sign means a horizon
tally focusing magnet rotated around z-axis by -90/9 degree, i.e., ROTATE = 10 DEG ."[p$1620,p1$1620]]=equ$1620;LaTeX`ob$+=neq,--La
TeX`ob$;With[{lx$1620},out$1620=lx$1620@Typeset["\n\nwhere L is the length of the component. Positive sign means a horizontally foc
using magnet rotated around z-axis by -90/9 degree, i.e., ROTATE = 10 DEG ."[p$1620,p1$1620],Format->Help2HTML`oB$];System["mv -f "
//out$1620//" "//equ$1620]];Exit[]]];"\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magne
t rotated around z-axis by -90/9 degree, i.e., ROTATE = 10 DEG ."[1,Max[p0$1620,0]]//"<img  class=\"eqs\" SRC=\""//equ$1620//"\" />
"//Help2HTML`oy$["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotated around z-a
xis by -90/9 degree, i.e., ROTATE = 10 DEG ."[p2$1620,-1]]]
</PRE>
<PRE>See also:
 <A HREF=#L94>L</A></PRE>
<LI>
<H3><A NAME=L158>
K9</A></H3>
<PRE>The normal 20-pole magnetic field component (times the length L).

<img  class="eqs" SRC="SADHelp_img/equ_128.svg" />If[{},Help2HTML`oA$["\n\nwhere L is the effective length of the component. Positi
ve sign means horizontal focusing."],p$1624=1+p$1624[[1,2]];p1$1624=StringPosition["\n\nwhere L is the effective length of the comp
onent. Positive sign means horizontal focusing."[p$1624,-1],">::",1];p1$1624=If[p1$1624==={},92,-2+p$1624+p1$1624[[1,1]]];neq=Which
["\n\nwhere L is the effective length of the component. Positive sign means horizontal focusing."[p$1624,4+p$1624]==="Text[",lx$162
4:=Help2HTML`oa$;p$1624=5+p$1624;p1$1624-=1;p2$1624=5+p1$1624;p0$1624=-9+p$1624;If[(pe$1624=StringPosition["\n\nwhere L is the effe
ctive length of the component. Positive sign means horizontal focusing."[p$1624,-2],";;;"])<=>{},{Max[0,-1+ToExpression["\n\nwhere 
L is the effective length of the component. Positive sign means horizontal focusing."[p$1624+pe$1624[[1,2]],p1$1624]]],p1$1624=-2+p
$1624+pe$1624[[1,1]]}[[1]],0],1,lx$1624:=Help2HTML`o9$;p2$1624=4+p1$1624;p0$1624=-4+p$1624;0];If[(equ$1624=Help2HTML`o8$["\n\nwhere
 L is the effective length of the component. Positive sign means horizontal focusing."[p$1624,p1$1624]])===Undefined,equ$1624="SADH
elp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["\n\nwhere L is the effective length of the component. Posit
ive sign means horizontal focusing."[p$1624,p1$1624]]=equ$1624;LaTeX`ob$+=neq,--LaTeX`ob$;With[{lx$1624},out$1624=lx$1624@Typeset["
\n\nwhere L is the effective length of the component. Positive sign means horizontal focusing."[p$1624,p1$1624],Format->Help2HTML`o
B$];System["mv -f "//out$1624//" "//equ$1624]];Exit[]]];"\n\nwhere L is the effective length of the component. Positive sign means 
horizontal focusing."[1,Max[p0$1624,0]]//"<img  class=\"eqs\" SRC=\""//equ$1624//"\" />"//Help2HTML`oy$["\n\nwhere L is the effecti
ve length of the component. Positive sign means horizontal focusing."[p2$1624,-1]]]
</PRE>
<PRE>See also:
 <A HREF=#L94>L</A></PRE>
<LI>
<H3><A NAME=L159>
SK9</A></H3>
<PRE>The skew 20-pole magnetic field component (times the length L).
<img  class="eqs" SRC="SADHelp_img/equ_129.svg" />If[{},Help2HTML`oA$["\n\nwhere L is the length of the component. Positive sign me
ans a horizontally focusing magnet rotated around z-axis by -90/10 degree, i.e., ROTATE = 9 DEG ."],p$1628=1+p$1628[[1,2]];p1$1628=
StringPosition["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotated around z-axi
s by -90/10 degree, i.e., ROTATE = 9 DEG ."[p$1628,-1],">::",1];p1$1628=If[p1$1628==={},155,-2+p$1628+p1$1628[[1,1]]];neq=Which["\n
\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotated around z-axis by -90/10 degree
, i.e., ROTATE = 9 DEG ."[p$1628,4+p$1628]==="Text[",lx$1628:=Help2HTML`oa$;p$1628=5+p$1628;p1$1628-=1;p2$1628=5+p1$1628;p0$1628=-9
+p$1628;If[(pe$1628=StringPosition["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet 
rotated around z-axis by -90/10 degree, i.e., ROTATE = 9 DEG ."[p$1628,-2],";;;"])<=>{},{Max[0,-1+ToExpression["\n\nwhere L is the 
length of the component. Positive sign means a horizontally focusing magnet rotated around z-axis by -90/10 degree, i.e., ROTATE = 
9 DEG ."[p$1628+pe$1628[[1,2]],p1$1628]]],p1$1628=-2+p$1628+pe$1628[[1,1]]}[[1]],0],1,lx$1628:=Help2HTML`o9$;p2$1628=4+p1$1628;p0$1
628=-4+p$1628;0];If[(equ$1628=Help2HTML`o8$["\n\nwhere L is the length of the component. Positive sign means a horizontally focusin
g magnet rotated around z-axis by -90/10 degree, i.e., ROTATE = 9 DEG ."[p$1628,p1$1628]])===Undefined,equ$1628="SADHelp_img/equ_"/
/++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["\n\nwhere L is the length of the component. Positive sign means a horizon
tally focusing magnet rotated around z-axis by -90/10 degree, i.e., ROTATE = 9 DEG ."[p$1628,p1$1628]]=equ$1628;LaTeX`ob$+=neq,--La
TeX`ob$;With[{lx$1628},out$1628=lx$1628@Typeset["\n\nwhere L is the length of the component. Positive sign means a horizontally foc
using magnet rotated around z-axis by -90/10 degree, i.e., ROTATE = 9 DEG ."[p$1628,p1$1628],Format->Help2HTML`oB$];System["mv -f "
//out$1628//" "//equ$1628]];Exit[]]];"\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magne
t rotated around z-axis by -90/10 degree, i.e., ROTATE = 9 DEG ."[1,Max[p0$1628,0]]//"<img  class=\"eqs\" SRC=\""//equ$1628//"\" />
"//Help2HTML`oy$["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotated around z-a
xis by -90/10 degree, i.e., ROTATE = 9 DEG ."[p2$1628,-1]]]
</PRE>
<PRE>See also:
 <A HREF=#L94>L</A></PRE>
<LI>
<H3><A NAME=L160>
K10</A></H3>
<PRE>The normal 22-pole magnetic field component (times the length L).

<img  class="eqs" SRC="SADHelp_img/equ_130.svg" />If[{},Help2HTML`oA$["\n\nwhere L is the effective length of the component. Positi
ve sign means horizontal focusing."],p$1632=1+p$1632[[1,2]];p1$1632=StringPosition["\n\nwhere L is the effective length of the comp
onent. Positive sign means horizontal focusing."[p$1632,-1],">::",1];p1$1632=If[p1$1632==={},92,-2+p$1632+p1$1632[[1,1]]];neq=Which
["\n\nwhere L is the effective length of the component. Positive sign means horizontal focusing."[p$1632,4+p$1632]==="Text[",lx$163
2:=Help2HTML`oa$;p$1632=5+p$1632;p1$1632-=1;p2$1632=5+p1$1632;p0$1632=-9+p$1632;If[(pe$1632=StringPosition["\n\nwhere L is the effe
ctive length of the component. Positive sign means horizontal focusing."[p$1632,-2],";;;"])<=>{},{Max[0,-1+ToExpression["\n\nwhere 
L is the effective length of the component. Positive sign means horizontal focusing."[p$1632+pe$1632[[1,2]],p1$1632]]],p1$1632=-2+p
$1632+pe$1632[[1,1]]}[[1]],0],1,lx$1632:=Help2HTML`o9$;p2$1632=4+p1$1632;p0$1632=-4+p$1632;0];If[(equ$1632=Help2HTML`o8$["\n\nwhere
 L is the effective length of the component. Positive sign means horizontal focusing."[p$1632,p1$1632]])===Undefined,equ$1632="SADH
elp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["\n\nwhere L is the effective length of the component. Posit
ive sign means horizontal focusing."[p$1632,p1$1632]]=equ$1632;LaTeX`ob$+=neq,--LaTeX`ob$;With[{lx$1632},out$1632=lx$1632@Typeset["
\n\nwhere L is the effective length of the component. Positive sign means horizontal focusing."[p$1632,p1$1632],Format->Help2HTML`o
B$];System["mv -f "//out$1632//" "//equ$1632]];Exit[]]];"\n\nwhere L is the effective length of the component. Positive sign means 
horizontal focusing."[1,Max[p0$1632,0]]//"<img  class=\"eqs\" SRC=\""//equ$1632//"\" />"//Help2HTML`oy$["\n\nwhere L is the effecti
ve length of the component. Positive sign means horizontal focusing."[p2$1632,-1]]]
</PRE>
<PRE>See also:
 <A HREF=#L94>L</A></PRE>
<LI>
<H3><A NAME=L161>
SK10</A></H3>
<PRE>The skew 22-pole magnetic field component (times the length L).
<img  class="eqs" SRC="SADHelp_img/equ_131.svg" />If[{},Help2HTML`oA$["\n\nwhere L is the length of the component. Positive sign me
ans a horizontally focusing magnet rotated around z-axis by -90/11 degree, i.e., ROTATE = 8.181818181818182 DEG ."],p$1636=1+p$1636
[[1,2]];p1$1636=StringPosition["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rota
ted around z-axis by -90/11 degree, i.e., ROTATE = 8.181818181818182 DEG ."[p$1636,-1],">::",1];p1$1636=If[p1$1636==={},171,-2+p$16
36+p1$1636[[1,1]]];neq=Which["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotate
d around z-axis by -90/11 degree, i.e., ROTATE = 8.181818181818182 DEG ."[p$1636,4+p$1636]==="Text[",lx$1636:=Help2HTML`oa$;p$1636=
5+p$1636;p1$1636-=1;p2$1636=5+p1$1636;p0$1636=-9+p$1636;If[(pe$1636=StringPosition["\n\nwhere L is the length of the component. Pos
itive sign means a horizontally focusing magnet rotated around z-axis by -90/11 degree, i.e., ROTATE = 8.181818181818182 DEG ."[p$1
636,-2],";;;"])<=>{},{Max[0,-1+ToExpression["\n\nwhere L is the length of the component. Positive sign means a horizontally focusin
g magnet rotated around z-axis by -90/11 degree, i.e., ROTATE = 8.181818181818182 DEG ."[p$1636+pe$1636[[1,2]],p1$1636]]],p1$1636=-
2+p$1636+pe$1636[[1,1]]}[[1]],0],1,lx$1636:=Help2HTML`o9$;p2$1636=4+p1$1636;p0$1636=-4+p$1636;0];If[(equ$1636=Help2HTML`o8$["\n\nwh
ere L is the length of the component. Positive sign means a horizontally focusing magnet rotated around z-axis by -90/11 degree, i.
e., ROTATE = 8.181818181818182 DEG ."[p$1636,p1$1636]])===Undefined,equ$1636="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If
[Fork[],Help2HTML`o8$["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotated aroun
d z-axis by -90/11 degree, i.e., ROTATE = 8.181818181818182 DEG ."[p$1636,p1$1636]]=equ$1636;LaTeX`ob$+=neq,--LaTeX`ob$;With[{lx$16
36},out$1636=lx$1636@Typeset["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotate
d around z-axis by -90/11 degree, i.e., ROTATE = 8.181818181818182 DEG ."[p$1636,p1$1636],Format->Help2HTML`oB$];System["mv -f "//o
ut$1636//" "//equ$1636]];Exit[]]];"\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet r
otated around z-axis by -90/11 degree, i.e., ROTATE = 8.181818181818182 DEG ."[1,Max[p0$1636,0]]//"<img  class=\"eqs\" SRC=\""//equ
$1636//"\" />"//Help2HTML`oy$["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotat
ed around z-axis by -90/11 degree, i.e., ROTATE = 8.181818181818182 DEG ."[p2$1636,-1]]]
</PRE>
<PRE>See also:
 <A HREF=#L94>L</A></PRE>
<LI>
<H3><A NAME=L162>
K11</A></H3>
<PRE>The normal 24-pole magnetic field component (times the length L).

<img  class="eqs" SRC="SADHelp_img/equ_132.svg" />If[{},Help2HTML`oA$["\n\nwhere L is the effective length of the component. Positi
ve sign means horizontal focusing."],p$1640=1+p$1640[[1,2]];p1$1640=StringPosition["\n\nwhere L is the effective length of the comp
onent. Positive sign means horizontal focusing."[p$1640,-1],">::",1];p1$1640=If[p1$1640==={},92,-2+p$1640+p1$1640[[1,1]]];neq=Which
["\n\nwhere L is the effective length of the component. Positive sign means horizontal focusing."[p$1640,4+p$1640]==="Text[",lx$164
0:=Help2HTML`oa$;p$1640=5+p$1640;p1$1640-=1;p2$1640=5+p1$1640;p0$1640=-9+p$1640;If[(pe$1640=StringPosition["\n\nwhere L is the effe
ctive length of the component. Positive sign means horizontal focusing."[p$1640,-2],";;;"])<=>{},{Max[0,-1+ToExpression["\n\nwhere 
L is the effective length of the component. Positive sign means horizontal focusing."[p$1640+pe$1640[[1,2]],p1$1640]]],p1$1640=-2+p
$1640+pe$1640[[1,1]]}[[1]],0],1,lx$1640:=Help2HTML`o9$;p2$1640=4+p1$1640;p0$1640=-4+p$1640;0];If[(equ$1640=Help2HTML`o8$["\n\nwhere
 L is the effective length of the component. Positive sign means horizontal focusing."[p$1640,p1$1640]])===Undefined,equ$1640="SADH
elp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["\n\nwhere L is the effective length of the component. Posit
ive sign means horizontal focusing."[p$1640,p1$1640]]=equ$1640;LaTeX`ob$+=neq,--LaTeX`ob$;With[{lx$1640},out$1640=lx$1640@Typeset["
\n\nwhere L is the effective length of the component. Positive sign means horizontal focusing."[p$1640,p1$1640],Format->Help2HTML`o
B$];System["mv -f "//out$1640//" "//equ$1640]];Exit[]]];"\n\nwhere L is the effective length of the component. Positive sign means 
horizontal focusing."[1,Max[p0$1640,0]]//"<img  class=\"eqs\" SRC=\""//equ$1640//"\" />"//Help2HTML`oy$["\n\nwhere L is the effecti
ve length of the component. Positive sign means horizontal focusing."[p2$1640,-1]]]
</PRE>
<PRE>See also:
 <A HREF=#L94>L</A></PRE>
<LI>
<H3><A NAME=L163>
SK11</A></H3>
<PRE>The skew 24-pole magnetic field component (times the length L).
<img  class="eqs" SRC="SADHelp_img/equ_133.svg" />If[{},Help2HTML`oA$["\n\nwhere L is the length of the component. Positive sign me
ans a horizontally focusing magnet rotated around z-axis by -90/12 degree, i.e., ROTATE = 7.5 DEG ."],p$1644=1+p$1644[[1,2]];p1$164
4=StringPosition["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotated around z-a
xis by -90/12 degree, i.e., ROTATE = 7.5 DEG ."[p$1644,-1],">::",1];p1$1644=If[p1$1644==={},157,-2+p$1644+p1$1644[[1,1]]];neq=Which
["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotated around z-axis by -90/12 de
gree, i.e., ROTATE = 7.5 DEG ."[p$1644,4+p$1644]==="Text[",lx$1644:=Help2HTML`oa$;p$1644=5+p$1644;p1$1644-=1;p2$1644=5+p1$1644;p0$1
644=-9+p$1644;If[(pe$1644=StringPosition["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing m
agnet rotated around z-axis by -90/12 degree, i.e., ROTATE = 7.5 DEG ."[p$1644,-2],";;;"])<=>{},{Max[0,-1+ToExpression["\n\nwhere L
 is the length of the component. Positive sign means a horizontally focusing magnet rotated around z-axis by -90/12 degree, i.e., R
OTATE = 7.5 DEG ."[p$1644+pe$1644[[1,2]],p1$1644]]],p1$1644=-2+p$1644+pe$1644[[1,1]]}[[1]],0],1,lx$1644:=Help2HTML`o9$;p2$1644=4+p1
$1644;p0$1644=-4+p$1644;0];If[(equ$1644=Help2HTML`o8$["\n\nwhere L is the length of the component. Positive sign means a horizontal
ly focusing magnet rotated around z-axis by -90/12 degree, i.e., ROTATE = 7.5 DEG ."[p$1644,p1$1644]])===Undefined,equ$1644="SADHel
p_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["\n\nwhere L is the length of the component. Positive sign mea
ns a horizontally focusing magnet rotated around z-axis by -90/12 degree, i.e., ROTATE = 7.5 DEG ."[p$1644,p1$1644]]=equ$1644;LaTeX
`ob$+=neq,--LaTeX`ob$;With[{lx$1644},out$1644=lx$1644@Typeset["\n\nwhere L is the length of the component. Positive sign means a ho
rizontally focusing magnet rotated around z-axis by -90/12 degree, i.e., ROTATE = 7.5 DEG ."[p$1644,p1$1644],Format->Help2HTML`oB$]
;System["mv -f "//out$1644//" "//equ$1644]];Exit[]]];"\n\nwhere L is the length of the component. Positive sign means a horizontall
y focusing magnet rotated around z-axis by -90/12 degree, i.e., ROTATE = 7.5 DEG ."[1,Max[p0$1644,0]]//"<img  class=\"eqs\" SRC=\""
//equ$1644//"\" />"//Help2HTML`oy$["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet 
rotated around z-axis by -90/12 degree, i.e., ROTATE = 7.5 DEG ."[p2$1644,-1]]]
</PRE>
<PRE>See also:
 <A HREF=#L94>L</A></PRE>
<LI>
<H3><A NAME=L164>
K12</A></H3>
<PRE>The normal 26-pole magnetic field component (times the length L).

<img  class="eqs" SRC="SADHelp_img/equ_134.svg" />If[{},Help2HTML`oA$["\n\nwhere L is the effective length of the component. Positi
ve sign means horizontal focusing."],p$1648=1+p$1648[[1,2]];p1$1648=StringPosition["\n\nwhere L is the effective length of the comp
onent. Positive sign means horizontal focusing."[p$1648,-1],">::",1];p1$1648=If[p1$1648==={},92,-2+p$1648+p1$1648[[1,1]]];neq=Which
["\n\nwhere L is the effective length of the component. Positive sign means horizontal focusing."[p$1648,4+p$1648]==="Text[",lx$164
8:=Help2HTML`oa$;p$1648=5+p$1648;p1$1648-=1;p2$1648=5+p1$1648;p0$1648=-9+p$1648;If[(pe$1648=StringPosition["\n\nwhere L is the effe
ctive length of the component. Positive sign means horizontal focusing."[p$1648,-2],";;;"])<=>{},{Max[0,-1+ToExpression["\n\nwhere 
L is the effective length of the component. Positive sign means horizontal focusing."[p$1648+pe$1648[[1,2]],p1$1648]]],p1$1648=-2+p
$1648+pe$1648[[1,1]]}[[1]],0],1,lx$1648:=Help2HTML`o9$;p2$1648=4+p1$1648;p0$1648=-4+p$1648;0];If[(equ$1648=Help2HTML`o8$["\n\nwhere
 L is the effective length of the component. Positive sign means horizontal focusing."[p$1648,p1$1648]])===Undefined,equ$1648="SADH
elp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["\n\nwhere L is the effective length of the component. Posit
ive sign means horizontal focusing."[p$1648,p1$1648]]=equ$1648;LaTeX`ob$+=neq,--LaTeX`ob$;With[{lx$1648},out$1648=lx$1648@Typeset["
\n\nwhere L is the effective length of the component. Positive sign means horizontal focusing."[p$1648,p1$1648],Format->Help2HTML`o
B$];System["mv -f "//out$1648//" "//equ$1648]];Exit[]]];"\n\nwhere L is the effective length of the component. Positive sign means 
horizontal focusing."[1,Max[p0$1648,0]]//"<img  class=\"eqs\" SRC=\""//equ$1648//"\" />"//Help2HTML`oy$["\n\nwhere L is the effecti
ve length of the component. Positive sign means horizontal focusing."[p2$1648,-1]]]
</PRE>
<PRE>See also:
 <A HREF=#L94>L</A></PRE>
<LI>
<H3><A NAME=L165>
SK12</A></H3>
<PRE>The skew 26-pole magnetic field component (times the length L).
<img  class="eqs" SRC="SADHelp_img/equ_135.svg" />If[{},Help2HTML`oA$["\n\nwhere L is the length of the component. Positive sign me
ans a horizontally focusing magnet rotated around z-axis by -90/13 degree, i.e., ROTATE = 6.923076923076923 DEG ."],p$1652=1+p$1652
[[1,2]];p1$1652=StringPosition["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rota
ted around z-axis by -90/13 degree, i.e., ROTATE = 6.923076923076923 DEG ."[p$1652,-1],">::",1];p1$1652=If[p1$1652==={},171,-2+p$16
52+p1$1652[[1,1]]];neq=Which["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotate
d around z-axis by -90/13 degree, i.e., ROTATE = 6.923076923076923 DEG ."[p$1652,4+p$1652]==="Text[",lx$1652:=Help2HTML`oa$;p$1652=
5+p$1652;p1$1652-=1;p2$1652=5+p1$1652;p0$1652=-9+p$1652;If[(pe$1652=StringPosition["\n\nwhere L is the length of the component. Pos
itive sign means a horizontally focusing magnet rotated around z-axis by -90/13 degree, i.e., ROTATE = 6.923076923076923 DEG ."[p$1
652,-2],";;;"])<=>{},{Max[0,-1+ToExpression["\n\nwhere L is the length of the component. Positive sign means a horizontally focusin
g magnet rotated around z-axis by -90/13 degree, i.e., ROTATE = 6.923076923076923 DEG ."[p$1652+pe$1652[[1,2]],p1$1652]]],p1$1652=-
2+p$1652+pe$1652[[1,1]]}[[1]],0],1,lx$1652:=Help2HTML`o9$;p2$1652=4+p1$1652;p0$1652=-4+p$1652;0];If[(equ$1652=Help2HTML`o8$["\n\nwh
ere L is the length of the component. Positive sign means a horizontally focusing magnet rotated around z-axis by -90/13 degree, i.
e., ROTATE = 6.923076923076923 DEG ."[p$1652,p1$1652]])===Undefined,equ$1652="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If
[Fork[],Help2HTML`o8$["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotated aroun
d z-axis by -90/13 degree, i.e., ROTATE = 6.923076923076923 DEG ."[p$1652,p1$1652]]=equ$1652;LaTeX`ob$+=neq,--LaTeX`ob$;With[{lx$16
52},out$1652=lx$1652@Typeset["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotate
d around z-axis by -90/13 degree, i.e., ROTATE = 6.923076923076923 DEG ."[p$1652,p1$1652],Format->Help2HTML`oB$];System["mv -f "//o
ut$1652//" "//equ$1652]];Exit[]]];"\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet r
otated around z-axis by -90/13 degree, i.e., ROTATE = 6.923076923076923 DEG ."[1,Max[p0$1652,0]]//"<img  class=\"eqs\" SRC=\""//equ
$1652//"\" />"//Help2HTML`oy$["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotat
ed around z-axis by -90/13 degree, i.e., ROTATE = 6.923076923076923 DEG ."[p2$1652,-1]]]
</PRE>
<PRE>See also:
 <A HREF=#L94>L</A></PRE>
<LI>
<H3><A NAME=L166>
K13</A></H3>
<PRE>The normal 28-pole magnetic field component (times the length L).

<img  class="eqs" SRC="SADHelp_img/equ_136.svg" />If[{},Help2HTML`oA$["\n\nwhere L is the effective length of the component. Positi
ve sign means horizontal focusing."],p$1656=1+p$1656[[1,2]];p1$1656=StringPosition["\n\nwhere L is the effective length of the comp
onent. Positive sign means horizontal focusing."[p$1656,-1],">::",1];p1$1656=If[p1$1656==={},92,-2+p$1656+p1$1656[[1,1]]];neq=Which
["\n\nwhere L is the effective length of the component. Positive sign means horizontal focusing."[p$1656,4+p$1656]==="Text[",lx$165
6:=Help2HTML`oa$;p$1656=5+p$1656;p1$1656-=1;p2$1656=5+p1$1656;p0$1656=-9+p$1656;If[(pe$1656=StringPosition["\n\nwhere L is the effe
ctive length of the component. Positive sign means horizontal focusing."[p$1656,-2],";;;"])<=>{},{Max[0,-1+ToExpression["\n\nwhere 
L is the effective length of the component. Positive sign means horizontal focusing."[p$1656+pe$1656[[1,2]],p1$1656]]],p1$1656=-2+p
$1656+pe$1656[[1,1]]}[[1]],0],1,lx$1656:=Help2HTML`o9$;p2$1656=4+p1$1656;p0$1656=-4+p$1656;0];If[(equ$1656=Help2HTML`o8$["\n\nwhere
 L is the effective length of the component. Positive sign means horizontal focusing."[p$1656,p1$1656]])===Undefined,equ$1656="SADH
elp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["\n\nwhere L is the effective length of the component. Posit
ive sign means horizontal focusing."[p$1656,p1$1656]]=equ$1656;LaTeX`ob$+=neq,--LaTeX`ob$;With[{lx$1656},out$1656=lx$1656@Typeset["
\n\nwhere L is the effective length of the component. Positive sign means horizontal focusing."[p$1656,p1$1656],Format->Help2HTML`o
B$];System["mv -f "//out$1656//" "//equ$1656]];Exit[]]];"\n\nwhere L is the effective length of the component. Positive sign means 
horizontal focusing."[1,Max[p0$1656,0]]//"<img  class=\"eqs\" SRC=\""//equ$1656//"\" />"//Help2HTML`oy$["\n\nwhere L is the effecti
ve length of the component. Positive sign means horizontal focusing."[p2$1656,-1]]]
</PRE>
<PRE>See also:
 <A HREF=#L94>L</A></PRE>
<LI>
<H3><A NAME=L167>
SK13</A></H3>
<PRE>The skew 28-pole magnetic field component (times the length L).
<img  class="eqs" SRC="SADHelp_img/equ_137.svg" />If[{},Help2HTML`oA$["\n\nwhere L is the length of the component. Positive sign me
ans a horizontally focusing magnet rotated around z-axis by -90/14 degree, i.e., ROTATE = 6.428571428571428 DEG ."],p$1660=1+p$1660
[[1,2]];p1$1660=StringPosition["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rota
ted around z-axis by -90/14 degree, i.e., ROTATE = 6.428571428571428 DEG ."[p$1660,-1],">::",1];p1$1660=If[p1$1660==={},171,-2+p$16
60+p1$1660[[1,1]]];neq=Which["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotate
d around z-axis by -90/14 degree, i.e., ROTATE = 6.428571428571428 DEG ."[p$1660,4+p$1660]==="Text[",lx$1660:=Help2HTML`oa$;p$1660=
5+p$1660;p1$1660-=1;p2$1660=5+p1$1660;p0$1660=-9+p$1660;If[(pe$1660=StringPosition["\n\nwhere L is the length of the component. Pos
itive sign means a horizontally focusing magnet rotated around z-axis by -90/14 degree, i.e., ROTATE = 6.428571428571428 DEG ."[p$1
660,-2],";;;"])<=>{},{Max[0,-1+ToExpression["\n\nwhere L is the length of the component. Positive sign means a horizontally focusin
g magnet rotated around z-axis by -90/14 degree, i.e., ROTATE = 6.428571428571428 DEG ."[p$1660+pe$1660[[1,2]],p1$1660]]],p1$1660=-
2+p$1660+pe$1660[[1,1]]}[[1]],0],1,lx$1660:=Help2HTML`o9$;p2$1660=4+p1$1660;p0$1660=-4+p$1660;0];If[(equ$1660=Help2HTML`o8$["\n\nwh
ere L is the length of the component. Positive sign means a horizontally focusing magnet rotated around z-axis by -90/14 degree, i.
e., ROTATE = 6.428571428571428 DEG ."[p$1660,p1$1660]])===Undefined,equ$1660="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If
[Fork[],Help2HTML`o8$["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotated aroun
d z-axis by -90/14 degree, i.e., ROTATE = 6.428571428571428 DEG ."[p$1660,p1$1660]]=equ$1660;LaTeX`ob$+=neq,--LaTeX`ob$;With[{lx$16
60},out$1660=lx$1660@Typeset["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotate
d around z-axis by -90/14 degree, i.e., ROTATE = 6.428571428571428 DEG ."[p$1660,p1$1660],Format->Help2HTML`oB$];System["mv -f "//o
ut$1660//" "//equ$1660]];Exit[]]];"\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet r
otated around z-axis by -90/14 degree, i.e., ROTATE = 6.428571428571428 DEG ."[1,Max[p0$1660,0]]//"<img  class=\"eqs\" SRC=\""//equ
$1660//"\" />"//Help2HTML`oy$["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotat
ed around z-axis by -90/14 degree, i.e., ROTATE = 6.428571428571428 DEG ."[p2$1660,-1]]]
</PRE>
<PRE>See also:
 <A HREF=#L94>L</A></PRE>
<LI>
<H3><A NAME=L168>
K14</A></H3>
<PRE>The normal 30-pole magnetic field component (times the length L).

<img  class="eqs" SRC="SADHelp_img/equ_138.svg" />If[{},Help2HTML`oA$["\n\nwhere L is the effective length of the component. Positi
ve sign means horizontal focusing."],p$1664=1+p$1664[[1,2]];p1$1664=StringPosition["\n\nwhere L is the effective length of the comp
onent. Positive sign means horizontal focusing."[p$1664,-1],">::",1];p1$1664=If[p1$1664==={},92,-2+p$1664+p1$1664[[1,1]]];neq=Which
["\n\nwhere L is the effective length of the component. Positive sign means horizontal focusing."[p$1664,4+p$1664]==="Text[",lx$166
4:=Help2HTML`oa$;p$1664=5+p$1664;p1$1664-=1;p2$1664=5+p1$1664;p0$1664=-9+p$1664;If[(pe$1664=StringPosition["\n\nwhere L is the effe
ctive length of the component. Positive sign means horizontal focusing."[p$1664,-2],";;;"])<=>{},{Max[0,-1+ToExpression["\n\nwhere 
L is the effective length of the component. Positive sign means horizontal focusing."[p$1664+pe$1664[[1,2]],p1$1664]]],p1$1664=-2+p
$1664+pe$1664[[1,1]]}[[1]],0],1,lx$1664:=Help2HTML`o9$;p2$1664=4+p1$1664;p0$1664=-4+p$1664;0];If[(equ$1664=Help2HTML`o8$["\n\nwhere
 L is the effective length of the component. Positive sign means horizontal focusing."[p$1664,p1$1664]])===Undefined,equ$1664="SADH
elp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["\n\nwhere L is the effective length of the component. Posit
ive sign means horizontal focusing."[p$1664,p1$1664]]=equ$1664;LaTeX`ob$+=neq,--LaTeX`ob$;With[{lx$1664},out$1664=lx$1664@Typeset["
\n\nwhere L is the effective length of the component. Positive sign means horizontal focusing."[p$1664,p1$1664],Format->Help2HTML`o
B$];System["mv -f "//out$1664//" "//equ$1664]];Exit[]]];"\n\nwhere L is the effective length of the component. Positive sign means 
horizontal focusing."[1,Max[p0$1664,0]]//"<img  class=\"eqs\" SRC=\""//equ$1664//"\" />"//Help2HTML`oy$["\n\nwhere L is the effecti
ve length of the component. Positive sign means horizontal focusing."[p2$1664,-1]]]
</PRE>
<PRE>See also:
 <A HREF=#L94>L</A></PRE>
<LI>
<H3><A NAME=L169>
SK14</A></H3>
<PRE>The skew 30-pole magnetic field component (times the length L).
<img  class="eqs" SRC="SADHelp_img/equ_139.svg" />If[{},Help2HTML`oA$["\n\nwhere L is the length of the component. Positive sign me
ans a horizontally focusing magnet rotated around z-axis by -90/15 degree, i.e., ROTATE = 6 DEG ."],p$1668=1+p$1668[[1,2]];p1$1668=
StringPosition["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotated around z-axi
s by -90/15 degree, i.e., ROTATE = 6 DEG ."[p$1668,-1],">::",1];p1$1668=If[p1$1668==={},155,-2+p$1668+p1$1668[[1,1]]];neq=Which["\n
\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotated around z-axis by -90/15 degree
, i.e., ROTATE = 6 DEG ."[p$1668,4+p$1668]==="Text[",lx$1668:=Help2HTML`oa$;p$1668=5+p$1668;p1$1668-=1;p2$1668=5+p1$1668;p0$1668=-9
+p$1668;If[(pe$1668=StringPosition["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet 
rotated around z-axis by -90/15 degree, i.e., ROTATE = 6 DEG ."[p$1668,-2],";;;"])<=>{},{Max[0,-1+ToExpression["\n\nwhere L is the 
length of the component. Positive sign means a horizontally focusing magnet rotated around z-axis by -90/15 degree, i.e., ROTATE = 
6 DEG ."[p$1668+pe$1668[[1,2]],p1$1668]]],p1$1668=-2+p$1668+pe$1668[[1,1]]}[[1]],0],1,lx$1668:=Help2HTML`o9$;p2$1668=4+p1$1668;p0$1
668=-4+p$1668;0];If[(equ$1668=Help2HTML`o8$["\n\nwhere L is the length of the component. Positive sign means a horizontally focusin
g magnet rotated around z-axis by -90/15 degree, i.e., ROTATE = 6 DEG ."[p$1668,p1$1668]])===Undefined,equ$1668="SADHelp_img/equ_"/
/++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["\n\nwhere L is the length of the component. Positive sign means a horizon
tally focusing magnet rotated around z-axis by -90/15 degree, i.e., ROTATE = 6 DEG ."[p$1668,p1$1668]]=equ$1668;LaTeX`ob$+=neq,--La
TeX`ob$;With[{lx$1668},out$1668=lx$1668@Typeset["\n\nwhere L is the length of the component. Positive sign means a horizontally foc
using magnet rotated around z-axis by -90/15 degree, i.e., ROTATE = 6 DEG ."[p$1668,p1$1668],Format->Help2HTML`oB$];System["mv -f "
//out$1668//" "//equ$1668]];Exit[]]];"\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magne
t rotated around z-axis by -90/15 degree, i.e., ROTATE = 6 DEG ."[1,Max[p0$1668,0]]//"<img  class=\"eqs\" SRC=\""//equ$1668//"\" />
"//Help2HTML`oy$["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotated around z-a
xis by -90/15 degree, i.e., ROTATE = 6 DEG ."[p2$1668,-1]]]
</PRE>
<PRE>See also:
 <A HREF=#L94>L</A></PRE>
<LI>
<H3><A NAME=L170>
K15</A></H3>
<PRE>The normal 32-pole magnetic field component (times the length L).

<img  class="eqs" SRC="SADHelp_img/equ_140.svg" />If[{},Help2HTML`oA$["\n\nwhere L is the effective length of the component. Positi
ve sign means horizontal focusing."],p$1672=1+p$1672[[1,2]];p1$1672=StringPosition["\n\nwhere L is the effective length of the comp
onent. Positive sign means horizontal focusing."[p$1672,-1],">::",1];p1$1672=If[p1$1672==={},92,-2+p$1672+p1$1672[[1,1]]];neq=Which
["\n\nwhere L is the effective length of the component. Positive sign means horizontal focusing."[p$1672,4+p$1672]==="Text[",lx$167
2:=Help2HTML`oa$;p$1672=5+p$1672;p1$1672-=1;p2$1672=5+p1$1672;p0$1672=-9+p$1672;If[(pe$1672=StringPosition["\n\nwhere L is the effe
ctive length of the component. Positive sign means horizontal focusing."[p$1672,-2],";;;"])<=>{},{Max[0,-1+ToExpression["\n\nwhere 
L is the effective length of the component. Positive sign means horizontal focusing."[p$1672+pe$1672[[1,2]],p1$1672]]],p1$1672=-2+p
$1672+pe$1672[[1,1]]}[[1]],0],1,lx$1672:=Help2HTML`o9$;p2$1672=4+p1$1672;p0$1672=-4+p$1672;0];If[(equ$1672=Help2HTML`o8$["\n\nwhere
 L is the effective length of the component. Positive sign means horizontal focusing."[p$1672,p1$1672]])===Undefined,equ$1672="SADH
elp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["\n\nwhere L is the effective length of the component. Posit
ive sign means horizontal focusing."[p$1672,p1$1672]]=equ$1672;LaTeX`ob$+=neq,--LaTeX`ob$;With[{lx$1672},out$1672=lx$1672@Typeset["
\n\nwhere L is the effective length of the component. Positive sign means horizontal focusing."[p$1672,p1$1672],Format->Help2HTML`o
B$];System["mv -f "//out$1672//" "//equ$1672]];Exit[]]];"\n\nwhere L is the effective length of the component. Positive sign means 
horizontal focusing."[1,Max[p0$1672,0]]//"<img  class=\"eqs\" SRC=\""//equ$1672//"\" />"//Help2HTML`oy$["\n\nwhere L is the effecti
ve length of the component. Positive sign means horizontal focusing."[p2$1672,-1]]]
</PRE>
<PRE>See also:
 <A HREF=#L94>L</A></PRE>
<LI>
<H3><A NAME=L171>
SK15</A></H3>
<PRE>The skew 32-pole magnetic field component (times the length L).
<img  class="eqs" SRC="SADHelp_img/equ_141.svg" />If[{},Help2HTML`oA$["\n\nwhere L is the length of the component. Positive sign me
ans a horizontally focusing magnet rotated around z-axis by -90/16 degree, i.e., ROTATE = 5.625 DEG ."],p$1676=1+p$1676[[1,2]];p1$1
676=StringPosition["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotated around z
-axis by -90/16 degree, i.e., ROTATE = 5.625 DEG ."[p$1676,-1],">::",1];p1$1676=If[p1$1676==={},159,-2+p$1676+p1$1676[[1,1]]];neq=W
hich["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotated around z-axis by -90/1
6 degree, i.e., ROTATE = 5.625 DEG ."[p$1676,4+p$1676]==="Text[",lx$1676:=Help2HTML`oa$;p$1676=5+p$1676;p1$1676-=1;p2$1676=5+p1$167
6;p0$1676=-9+p$1676;If[(pe$1676=StringPosition["\n\nwhere L is the length of the component. Positive sign means a horizontally focu
sing magnet rotated around z-axis by -90/16 degree, i.e., ROTATE = 5.625 DEG ."[p$1676,-2],";;;"])<=>{},{Max[0,-1+ToExpression["\n\
nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotated around z-axis by -90/16 degree,
 i.e., ROTATE = 5.625 DEG ."[p$1676+pe$1676[[1,2]],p1$1676]]],p1$1676=-2+p$1676+pe$1676[[1,1]]}[[1]],0],1,lx$1676:=Help2HTML`o9$;p2
$1676=4+p1$1676;p0$1676=-4+p$1676;0];If[(equ$1676=Help2HTML`o8$["\n\nwhere L is the length of the component. Positive sign means a 
horizontally focusing magnet rotated around z-axis by -90/16 degree, i.e., ROTATE = 5.625 DEG ."[p$1676,p1$1676]])===Undefined,equ$
1676="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["\n\nwhere L is the length of the component. Posit
ive sign means a horizontally focusing magnet rotated around z-axis by -90/16 degree, i.e., ROTATE = 5.625 DEG ."[p$1676,p1$1676]]=
equ$1676;LaTeX`ob$+=neq,--LaTeX`ob$;With[{lx$1676},out$1676=lx$1676@Typeset["\n\nwhere L is the length of the component. Positive s
ign means a horizontally focusing magnet rotated around z-axis by -90/16 degree, i.e., ROTATE = 5.625 DEG ."[p$1676,p1$1676],Format
->Help2HTML`oB$];System["mv -f "//out$1676//" "//equ$1676]];Exit[]]];"\n\nwhere L is the length of the component. Positive sign mea
ns a horizontally focusing magnet rotated around z-axis by -90/16 degree, i.e., ROTATE = 5.625 DEG ."[1,Max[p0$1676,0]]//"<img  cla
ss=\"eqs\" SRC=\""//equ$1676//"\" />"//Help2HTML`oy$["\n\nwhere L is the length of the component. Positive sign means a horizontall
y focusing magnet rotated around z-axis by -90/16 degree, i.e., ROTATE = 5.625 DEG ."[p2$1676,-1]]]
</PRE>
<PRE>See also:
 <A HREF=#L94>L</A></PRE>
<LI>
<H3><A NAME=L172>
K16</A></H3>
<PRE>The normal 34-pole magnetic field component (times the length L).

<img  class="eqs" SRC="SADHelp_img/equ_142.svg" />If[{},Help2HTML`oA$["\n\nwhere L is the effective length of the component. Positi
ve sign means horizontal focusing."],p$1680=1+p$1680[[1,2]];p1$1680=StringPosition["\n\nwhere L is the effective length of the comp
onent. Positive sign means horizontal focusing."[p$1680,-1],">::",1];p1$1680=If[p1$1680==={},92,-2+p$1680+p1$1680[[1,1]]];neq=Which
["\n\nwhere L is the effective length of the component. Positive sign means horizontal focusing."[p$1680,4+p$1680]==="Text[",lx$168
0:=Help2HTML`oa$;p$1680=5+p$1680;p1$1680-=1;p2$1680=5+p1$1680;p0$1680=-9+p$1680;If[(pe$1680=StringPosition["\n\nwhere L is the effe
ctive length of the component. Positive sign means horizontal focusing."[p$1680,-2],";;;"])<=>{},{Max[0,-1+ToExpression["\n\nwhere 
L is the effective length of the component. Positive sign means horizontal focusing."[p$1680+pe$1680[[1,2]],p1$1680]]],p1$1680=-2+p
$1680+pe$1680[[1,1]]}[[1]],0],1,lx$1680:=Help2HTML`o9$;p2$1680=4+p1$1680;p0$1680=-4+p$1680;0];If[(equ$1680=Help2HTML`o8$["\n\nwhere
 L is the effective length of the component. Positive sign means horizontal focusing."[p$1680,p1$1680]])===Undefined,equ$1680="SADH
elp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["\n\nwhere L is the effective length of the component. Posit
ive sign means horizontal focusing."[p$1680,p1$1680]]=equ$1680;LaTeX`ob$+=neq,--LaTeX`ob$;With[{lx$1680},out$1680=lx$1680@Typeset["
\n\nwhere L is the effective length of the component. Positive sign means horizontal focusing."[p$1680,p1$1680],Format->Help2HTML`o
B$];System["mv -f "//out$1680//" "//equ$1680]];Exit[]]];"\n\nwhere L is the effective length of the component. Positive sign means 
horizontal focusing."[1,Max[p0$1680,0]]//"<img  class=\"eqs\" SRC=\""//equ$1680//"\" />"//Help2HTML`oy$["\n\nwhere L is the effecti
ve length of the component. Positive sign means horizontal focusing."[p2$1680,-1]]]
</PRE>
<PRE>See also:
 <A HREF=#L94>L</A></PRE>
<LI>
<H3><A NAME=L173>
SK16</A></H3>
<PRE>The skew 34-pole magnetic field component (times the length L).
<img  class="eqs" SRC="SADHelp_img/equ_143.svg" />If[{},Help2HTML`oA$["\n\nwhere L is the length of the component. Positive sign me
ans a horizontally focusing magnet rotated around z-axis by -90/17 degree, i.e., ROTATE = 5.294117647058823 DEG ."],p$1684=1+p$1684
[[1,2]];p1$1684=StringPosition["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rota
ted around z-axis by -90/17 degree, i.e., ROTATE = 5.294117647058823 DEG ."[p$1684,-1],">::",1];p1$1684=If[p1$1684==={},171,-2+p$16
84+p1$1684[[1,1]]];neq=Which["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotate
d around z-axis by -90/17 degree, i.e., ROTATE = 5.294117647058823 DEG ."[p$1684,4+p$1684]==="Text[",lx$1684:=Help2HTML`oa$;p$1684=
5+p$1684;p1$1684-=1;p2$1684=5+p1$1684;p0$1684=-9+p$1684;If[(pe$1684=StringPosition["\n\nwhere L is the length of the component. Pos
itive sign means a horizontally focusing magnet rotated around z-axis by -90/17 degree, i.e., ROTATE = 5.294117647058823 DEG ."[p$1
684,-2],";;;"])<=>{},{Max[0,-1+ToExpression["\n\nwhere L is the length of the component. Positive sign means a horizontally focusin
g magnet rotated around z-axis by -90/17 degree, i.e., ROTATE = 5.294117647058823 DEG ."[p$1684+pe$1684[[1,2]],p1$1684]]],p1$1684=-
2+p$1684+pe$1684[[1,1]]}[[1]],0],1,lx$1684:=Help2HTML`o9$;p2$1684=4+p1$1684;p0$1684=-4+p$1684;0];If[(equ$1684=Help2HTML`o8$["\n\nwh
ere L is the length of the component. Positive sign means a horizontally focusing magnet rotated around z-axis by -90/17 degree, i.
e., ROTATE = 5.294117647058823 DEG ."[p$1684,p1$1684]])===Undefined,equ$1684="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If
[Fork[],Help2HTML`o8$["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotated aroun
d z-axis by -90/17 degree, i.e., ROTATE = 5.294117647058823 DEG ."[p$1684,p1$1684]]=equ$1684;LaTeX`ob$+=neq,--LaTeX`ob$;With[{lx$16
84},out$1684=lx$1684@Typeset["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotate
d around z-axis by -90/17 degree, i.e., ROTATE = 5.294117647058823 DEG ."[p$1684,p1$1684],Format->Help2HTML`oB$];System["mv -f "//o
ut$1684//" "//equ$1684]];Exit[]]];"\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet r
otated around z-axis by -90/17 degree, i.e., ROTATE = 5.294117647058823 DEG ."[1,Max[p0$1684,0]]//"<img  class=\"eqs\" SRC=\""//equ
$1684//"\" />"//Help2HTML`oy$["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotat
ed around z-axis by -90/17 degree, i.e., ROTATE = 5.294117647058823 DEG ."[p2$1684,-1]]]
</PRE>
<PRE>See also:
 <A HREF=#L94>L</A></PRE>
<LI>
<H3><A NAME=L174>
K17</A></H3>
<PRE>The normal 36-pole magnetic field component (times the length L).

<img  class="eqs" SRC="SADHelp_img/equ_144.svg" />If[{},Help2HTML`oA$["\n\nwhere L is the effective length of the component. Positi
ve sign means horizontal focusing."],p$1688=1+p$1688[[1,2]];p1$1688=StringPosition["\n\nwhere L is the effective length of the comp
onent. Positive sign means horizontal focusing."[p$1688,-1],">::",1];p1$1688=If[p1$1688==={},92,-2+p$1688+p1$1688[[1,1]]];neq=Which
["\n\nwhere L is the effective length of the component. Positive sign means horizontal focusing."[p$1688,4+p$1688]==="Text[",lx$168
8:=Help2HTML`oa$;p$1688=5+p$1688;p1$1688-=1;p2$1688=5+p1$1688;p0$1688=-9+p$1688;If[(pe$1688=StringPosition["\n\nwhere L is the effe
ctive length of the component. Positive sign means horizontal focusing."[p$1688,-2],";;;"])<=>{},{Max[0,-1+ToExpression["\n\nwhere 
L is the effective length of the component. Positive sign means horizontal focusing."[p$1688+pe$1688[[1,2]],p1$1688]]],p1$1688=-2+p
$1688+pe$1688[[1,1]]}[[1]],0],1,lx$1688:=Help2HTML`o9$;p2$1688=4+p1$1688;p0$1688=-4+p$1688;0];If[(equ$1688=Help2HTML`o8$["\n\nwhere
 L is the effective length of the component. Positive sign means horizontal focusing."[p$1688,p1$1688]])===Undefined,equ$1688="SADH
elp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["\n\nwhere L is the effective length of the component. Posit
ive sign means horizontal focusing."[p$1688,p1$1688]]=equ$1688;LaTeX`ob$+=neq,--LaTeX`ob$;With[{lx$1688},out$1688=lx$1688@Typeset["
\n\nwhere L is the effective length of the component. Positive sign means horizontal focusing."[p$1688,p1$1688],Format->Help2HTML`o
B$];System["mv -f "//out$1688//" "//equ$1688]];Exit[]]];"\n\nwhere L is the effective length of the component. Positive sign means 
horizontal focusing."[1,Max[p0$1688,0]]//"<img  class=\"eqs\" SRC=\""//equ$1688//"\" />"//Help2HTML`oy$["\n\nwhere L is the effecti
ve length of the component. Positive sign means horizontal focusing."[p2$1688,-1]]]
</PRE>
<PRE>See also:
 <A HREF=#L94>L</A></PRE>
<LI>
<H3><A NAME=L175>
SK17</A></H3>
<PRE>The skew 36-pole magnetic field component (times the length L).
<img  class="eqs" SRC="SADHelp_img/equ_145.svg" />If[{},Help2HTML`oA$["\n\nwhere L is the length of the component. Positive sign me
ans a horizontally focusing magnet rotated around z-axis by -90/18 degree, i.e., ROTATE = 5 DEG ."],p$1692=1+p$1692[[1,2]];p1$1692=
StringPosition["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotated around z-axi
s by -90/18 degree, i.e., ROTATE = 5 DEG ."[p$1692,-1],">::",1];p1$1692=If[p1$1692==={},155,-2+p$1692+p1$1692[[1,1]]];neq=Which["\n
\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotated around z-axis by -90/18 degree
, i.e., ROTATE = 5 DEG ."[p$1692,4+p$1692]==="Text[",lx$1692:=Help2HTML`oa$;p$1692=5+p$1692;p1$1692-=1;p2$1692=5+p1$1692;p0$1692=-9
+p$1692;If[(pe$1692=StringPosition["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet 
rotated around z-axis by -90/18 degree, i.e., ROTATE = 5 DEG ."[p$1692,-2],";;;"])<=>{},{Max[0,-1+ToExpression["\n\nwhere L is the 
length of the component. Positive sign means a horizontally focusing magnet rotated around z-axis by -90/18 degree, i.e., ROTATE = 
5 DEG ."[p$1692+pe$1692[[1,2]],p1$1692]]],p1$1692=-2+p$1692+pe$1692[[1,1]]}[[1]],0],1,lx$1692:=Help2HTML`o9$;p2$1692=4+p1$1692;p0$1
692=-4+p$1692;0];If[(equ$1692=Help2HTML`o8$["\n\nwhere L is the length of the component. Positive sign means a horizontally focusin
g magnet rotated around z-axis by -90/18 degree, i.e., ROTATE = 5 DEG ."[p$1692,p1$1692]])===Undefined,equ$1692="SADHelp_img/equ_"/
/++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["\n\nwhere L is the length of the component. Positive sign means a horizon
tally focusing magnet rotated around z-axis by -90/18 degree, i.e., ROTATE = 5 DEG ."[p$1692,p1$1692]]=equ$1692;LaTeX`ob$+=neq,--La
TeX`ob$;With[{lx$1692},out$1692=lx$1692@Typeset["\n\nwhere L is the length of the component. Positive sign means a horizontally foc
using magnet rotated around z-axis by -90/18 degree, i.e., ROTATE = 5 DEG ."[p$1692,p1$1692],Format->Help2HTML`oB$];System["mv -f "
//out$1692//" "//equ$1692]];Exit[]]];"\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magne
t rotated around z-axis by -90/18 degree, i.e., ROTATE = 5 DEG ."[1,Max[p0$1692,0]]//"<img  class=\"eqs\" SRC=\""//equ$1692//"\" />
"//Help2HTML`oy$["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotated around z-a
xis by -90/18 degree, i.e., ROTATE = 5 DEG ."[p2$1692,-1]]]
</PRE>
<PRE>See also:
 <A HREF=#L94>L</A></PRE>
<LI>
<H3><A NAME=L176>
K18</A></H3>
<PRE>The normal 38-pole magnetic field component (times the length L).

<img  class="eqs" SRC="SADHelp_img/equ_146.svg" />If[{},Help2HTML`oA$["\n\nwhere L is the effective length of the component. Positi
ve sign means horizontal focusing."],p$1696=1+p$1696[[1,2]];p1$1696=StringPosition["\n\nwhere L is the effective length of the comp
onent. Positive sign means horizontal focusing."[p$1696,-1],">::",1];p1$1696=If[p1$1696==={},92,-2+p$1696+p1$1696[[1,1]]];neq=Which
["\n\nwhere L is the effective length of the component. Positive sign means horizontal focusing."[p$1696,4+p$1696]==="Text[",lx$169
6:=Help2HTML`oa$;p$1696=5+p$1696;p1$1696-=1;p2$1696=5+p1$1696;p0$1696=-9+p$1696;If[(pe$1696=StringPosition["\n\nwhere L is the effe
ctive length of the component. Positive sign means horizontal focusing."[p$1696,-2],";;;"])<=>{},{Max[0,-1+ToExpression["\n\nwhere 
L is the effective length of the component. Positive sign means horizontal focusing."[p$1696+pe$1696[[1,2]],p1$1696]]],p1$1696=-2+p
$1696+pe$1696[[1,1]]}[[1]],0],1,lx$1696:=Help2HTML`o9$;p2$1696=4+p1$1696;p0$1696=-4+p$1696;0];If[(equ$1696=Help2HTML`o8$["\n\nwhere
 L is the effective length of the component. Positive sign means horizontal focusing."[p$1696,p1$1696]])===Undefined,equ$1696="SADH
elp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["\n\nwhere L is the effective length of the component. Posit
ive sign means horizontal focusing."[p$1696,p1$1696]]=equ$1696;LaTeX`ob$+=neq,--LaTeX`ob$;With[{lx$1696},out$1696=lx$1696@Typeset["
\n\nwhere L is the effective length of the component. Positive sign means horizontal focusing."[p$1696,p1$1696],Format->Help2HTML`o
B$];System["mv -f "//out$1696//" "//equ$1696]];Exit[]]];"\n\nwhere L is the effective length of the component. Positive sign means 
horizontal focusing."[1,Max[p0$1696,0]]//"<img  class=\"eqs\" SRC=\""//equ$1696//"\" />"//Help2HTML`oy$["\n\nwhere L is the effecti
ve length of the component. Positive sign means horizontal focusing."[p2$1696,-1]]]
</PRE>
<PRE>See also:
 <A HREF=#L94>L</A></PRE>
<LI>
<H3><A NAME=L177>
SK18</A></H3>
<PRE>The skew 38-pole magnetic field component (times the length L).
<img  class="eqs" SRC="SADHelp_img/equ_147.svg" />If[{},Help2HTML`oA$["\n\nwhere L is the length of the component. Positive sign me
ans a horizontally focusing magnet rotated around z-axis by -90/19 degree, i.e., ROTATE = 4.7368421052631575 DEG ."],p$1700=1+p$170
0[[1,2]];p1$1700=StringPosition["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rot
ated around z-axis by -90/19 degree, i.e., ROTATE = 4.7368421052631575 DEG ."[p$1700,-1],">::",1];p1$1700=If[p1$1700==={},172,-2+p$
1700+p1$1700[[1,1]]];neq=Which["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rota
ted around z-axis by -90/19 degree, i.e., ROTATE = 4.7368421052631575 DEG ."[p$1700,4+p$1700]==="Text[",lx$1700:=Help2HTML`oa$;p$17
00=5+p$1700;p1$1700-=1;p2$1700=5+p1$1700;p0$1700=-9+p$1700;If[(pe$1700=StringPosition["\n\nwhere L is the length of the component. 
Positive sign means a horizontally focusing magnet rotated around z-axis by -90/19 degree, i.e., ROTATE = 4.7368421052631575 DEG ."
[p$1700,-2],";;;"])<=>{},{Max[0,-1+ToExpression["\n\nwhere L is the length of the component. Positive sign means a horizontally foc
using magnet rotated around z-axis by -90/19 degree, i.e., ROTATE = 4.7368421052631575 DEG ."[p$1700+pe$1700[[1,2]],p1$1700]]],p1$1
700=-2+p$1700+pe$1700[[1,1]]}[[1]],0],1,lx$1700:=Help2HTML`o9$;p2$1700=4+p1$1700;p0$1700=-4+p$1700;0];If[(equ$1700=Help2HTML`o8$["\
n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotated around z-axis by -90/19 degre
e, i.e., ROTATE = 4.7368421052631575 DEG ."[p$1700,p1$1700]])===Undefined,equ$1700="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`
oB$;If[Fork[],Help2HTML`o8$["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotated
 around z-axis by -90/19 degree, i.e., ROTATE = 4.7368421052631575 DEG ."[p$1700,p1$1700]]=equ$1700;LaTeX`ob$+=neq,--LaTeX`ob$;With
[{lx$1700},out$1700=lx$1700@Typeset["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet
 rotated around z-axis by -90/19 degree, i.e., ROTATE = 4.7368421052631575 DEG ."[p$1700,p1$1700],Format->Help2HTML`oB$];System["mv
 -f "//out$1700//" "//equ$1700]];Exit[]]];"\n\nwhere L is the length of the component. Positive sign means a horizontally focusing 
magnet rotated around z-axis by -90/19 degree, i.e., ROTATE = 4.7368421052631575 DEG ."[1,Max[p0$1700,0]]//"<img  class=\"eqs\" SRC
=\""//equ$1700//"\" />"//Help2HTML`oy$["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing mag
net rotated around z-axis by -90/19 degree, i.e., ROTATE = 4.7368421052631575 DEG ."[p2$1700,-1]]]
</PRE>
<PRE>See also:
 <A HREF=#L94>L</A></PRE>
<LI>
<H3><A NAME=L178>
K19</A></H3>
<PRE>The normal 40-pole magnetic field component (times the length L).

<img  class="eqs" SRC="SADHelp_img/equ_148.svg" />If[{},Help2HTML`oA$["\n\nwhere L is the effective length of the component. Positi
ve sign means horizontal focusing."],p$1704=1+p$1704[[1,2]];p1$1704=StringPosition["\n\nwhere L is the effective length of the comp
onent. Positive sign means horizontal focusing."[p$1704,-1],">::",1];p1$1704=If[p1$1704==={},92,-2+p$1704+p1$1704[[1,1]]];neq=Which
["\n\nwhere L is the effective length of the component. Positive sign means horizontal focusing."[p$1704,4+p$1704]==="Text[",lx$170
4:=Help2HTML`oa$;p$1704=5+p$1704;p1$1704-=1;p2$1704=5+p1$1704;p0$1704=-9+p$1704;If[(pe$1704=StringPosition["\n\nwhere L is the effe
ctive length of the component. Positive sign means horizontal focusing."[p$1704,-2],";;;"])<=>{},{Max[0,-1+ToExpression["\n\nwhere 
L is the effective length of the component. Positive sign means horizontal focusing."[p$1704+pe$1704[[1,2]],p1$1704]]],p1$1704=-2+p
$1704+pe$1704[[1,1]]}[[1]],0],1,lx$1704:=Help2HTML`o9$;p2$1704=4+p1$1704;p0$1704=-4+p$1704;0];If[(equ$1704=Help2HTML`o8$["\n\nwhere
 L is the effective length of the component. Positive sign means horizontal focusing."[p$1704,p1$1704]])===Undefined,equ$1704="SADH
elp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["\n\nwhere L is the effective length of the component. Posit
ive sign means horizontal focusing."[p$1704,p1$1704]]=equ$1704;LaTeX`ob$+=neq,--LaTeX`ob$;With[{lx$1704},out$1704=lx$1704@Typeset["
\n\nwhere L is the effective length of the component. Positive sign means horizontal focusing."[p$1704,p1$1704],Format->Help2HTML`o
B$];System["mv -f "//out$1704//" "//equ$1704]];Exit[]]];"\n\nwhere L is the effective length of the component. Positive sign means 
horizontal focusing."[1,Max[p0$1704,0]]//"<img  class=\"eqs\" SRC=\""//equ$1704//"\" />"//Help2HTML`oy$["\n\nwhere L is the effecti
ve length of the component. Positive sign means horizontal focusing."[p2$1704,-1]]]
</PRE>
<PRE>See also:
 <A HREF=#L94>L</A></PRE>
<LI>
<H3><A NAME=L179>
SK19</A></H3>
<PRE>The skew 40-pole magnetic field component (times the length L).
<img  class="eqs" SRC="SADHelp_img/equ_149.svg" />If[{},Help2HTML`oA$["\n\nwhere L is the length of the component. Positive sign me
ans a horizontally focusing magnet rotated around z-axis by -90/20 degree, i.e., ROTATE = 4.5 DEG ."],p$1708=1+p$1708[[1,2]];p1$170
8=StringPosition["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotated around z-a
xis by -90/20 degree, i.e., ROTATE = 4.5 DEG ."[p$1708,-1],">::",1];p1$1708=If[p1$1708==={},157,-2+p$1708+p1$1708[[1,1]]];neq=Which
["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotated around z-axis by -90/20 de
gree, i.e., ROTATE = 4.5 DEG ."[p$1708,4+p$1708]==="Text[",lx$1708:=Help2HTML`oa$;p$1708=5+p$1708;p1$1708-=1;p2$1708=5+p1$1708;p0$1
708=-9+p$1708;If[(pe$1708=StringPosition["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing m
agnet rotated around z-axis by -90/20 degree, i.e., ROTATE = 4.5 DEG ."[p$1708,-2],";;;"])<=>{},{Max[0,-1+ToExpression["\n\nwhere L
 is the length of the component. Positive sign means a horizontally focusing magnet rotated around z-axis by -90/20 degree, i.e., R
OTATE = 4.5 DEG ."[p$1708+pe$1708[[1,2]],p1$1708]]],p1$1708=-2+p$1708+pe$1708[[1,1]]}[[1]],0],1,lx$1708:=Help2HTML`o9$;p2$1708=4+p1
$1708;p0$1708=-4+p$1708;0];If[(equ$1708=Help2HTML`o8$["\n\nwhere L is the length of the component. Positive sign means a horizontal
ly focusing magnet rotated around z-axis by -90/20 degree, i.e., ROTATE = 4.5 DEG ."[p$1708,p1$1708]])===Undefined,equ$1708="SADHel
p_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["\n\nwhere L is the length of the component. Positive sign mea
ns a horizontally focusing magnet rotated around z-axis by -90/20 degree, i.e., ROTATE = 4.5 DEG ."[p$1708,p1$1708]]=equ$1708;LaTeX
`ob$+=neq,--LaTeX`ob$;With[{lx$1708},out$1708=lx$1708@Typeset["\n\nwhere L is the length of the component. Positive sign means a ho
rizontally focusing magnet rotated around z-axis by -90/20 degree, i.e., ROTATE = 4.5 DEG ."[p$1708,p1$1708],Format->Help2HTML`oB$]
;System["mv -f "//out$1708//" "//equ$1708]];Exit[]]];"\n\nwhere L is the length of the component. Positive sign means a horizontall
y focusing magnet rotated around z-axis by -90/20 degree, i.e., ROTATE = 4.5 DEG ."[1,Max[p0$1708,0]]//"<img  class=\"eqs\" SRC=\""
//equ$1708//"\" />"//Help2HTML`oy$["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet 
rotated around z-axis by -90/20 degree, i.e., ROTATE = 4.5 DEG ."[p2$1708,-1]]]
</PRE>
<PRE>See also:
 <A HREF=#L94>L</A></PRE>
<LI>
<H3><A NAME=L180>
K20</A></H3>
<PRE>The normal 42-pole magnetic field component (times the length L).

<img  class="eqs" SRC="SADHelp_img/equ_150.svg" />If[{},Help2HTML`oA$["\n\nwhere L is the effective length of the component. Positi
ve sign means horizontal focusing."],p$1712=1+p$1712[[1,2]];p1$1712=StringPosition["\n\nwhere L is the effective length of the comp
onent. Positive sign means horizontal focusing."[p$1712,-1],">::",1];p1$1712=If[p1$1712==={},92,-2+p$1712+p1$1712[[1,1]]];neq=Which
["\n\nwhere L is the effective length of the component. Positive sign means horizontal focusing."[p$1712,4+p$1712]==="Text[",lx$171
2:=Help2HTML`oa$;p$1712=5+p$1712;p1$1712-=1;p2$1712=5+p1$1712;p0$1712=-9+p$1712;If[(pe$1712=StringPosition["\n\nwhere L is the effe
ctive length of the component. Positive sign means horizontal focusing."[p$1712,-2],";;;"])<=>{},{Max[0,-1+ToExpression["\n\nwhere 
L is the effective length of the component. Positive sign means horizontal focusing."[p$1712+pe$1712[[1,2]],p1$1712]]],p1$1712=-2+p
$1712+pe$1712[[1,1]]}[[1]],0],1,lx$1712:=Help2HTML`o9$;p2$1712=4+p1$1712;p0$1712=-4+p$1712;0];If[(equ$1712=Help2HTML`o8$["\n\nwhere
 L is the effective length of the component. Positive sign means horizontal focusing."[p$1712,p1$1712]])===Undefined,equ$1712="SADH
elp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["\n\nwhere L is the effective length of the component. Posit
ive sign means horizontal focusing."[p$1712,p1$1712]]=equ$1712;LaTeX`ob$+=neq,--LaTeX`ob$;With[{lx$1712},out$1712=lx$1712@Typeset["
\n\nwhere L is the effective length of the component. Positive sign means horizontal focusing."[p$1712,p1$1712],Format->Help2HTML`o
B$];System["mv -f "//out$1712//" "//equ$1712]];Exit[]]];"\n\nwhere L is the effective length of the component. Positive sign means 
horizontal focusing."[1,Max[p0$1712,0]]//"<img  class=\"eqs\" SRC=\""//equ$1712//"\" />"//Help2HTML`oy$["\n\nwhere L is the effecti
ve length of the component. Positive sign means horizontal focusing."[p2$1712,-1]]]
</PRE>
<PRE>See also:
 <A HREF=#L94>L</A></PRE>
<LI>
<H3><A NAME=L181>
SK20</A></H3>
<PRE>The skew 42-pole magnetic field component (times the length L).
<img  class="eqs" SRC="SADHelp_img/equ_151.svg" />If[{},Help2HTML`oA$["\n\nwhere L is the length of the component. Positive sign me
ans a horizontally focusing magnet rotated around z-axis by -90/21 degree, i.e., ROTATE = 4.285714285714286 DEG ."],p$1716=1+p$1716
[[1,2]];p1$1716=StringPosition["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rota
ted around z-axis by -90/21 degree, i.e., ROTATE = 4.285714285714286 DEG ."[p$1716,-1],">::",1];p1$1716=If[p1$1716==={},171,-2+p$17
16+p1$1716[[1,1]]];neq=Which["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotate
d around z-axis by -90/21 degree, i.e., ROTATE = 4.285714285714286 DEG ."[p$1716,4+p$1716]==="Text[",lx$1716:=Help2HTML`oa$;p$1716=
5+p$1716;p1$1716-=1;p2$1716=5+p1$1716;p0$1716=-9+p$1716;If[(pe$1716=StringPosition["\n\nwhere L is the length of the component. Pos
itive sign means a horizontally focusing magnet rotated around z-axis by -90/21 degree, i.e., ROTATE = 4.285714285714286 DEG ."[p$1
716,-2],";;;"])<=>{},{Max[0,-1+ToExpression["\n\nwhere L is the length of the component. Positive sign means a horizontally focusin
g magnet rotated around z-axis by -90/21 degree, i.e., ROTATE = 4.285714285714286 DEG ."[p$1716+pe$1716[[1,2]],p1$1716]]],p1$1716=-
2+p$1716+pe$1716[[1,1]]}[[1]],0],1,lx$1716:=Help2HTML`o9$;p2$1716=4+p1$1716;p0$1716=-4+p$1716;0];If[(equ$1716=Help2HTML`o8$["\n\nwh
ere L is the length of the component. Positive sign means a horizontally focusing magnet rotated around z-axis by -90/21 degree, i.
e., ROTATE = 4.285714285714286 DEG ."[p$1716,p1$1716]])===Undefined,equ$1716="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If
[Fork[],Help2HTML`o8$["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotated aroun
d z-axis by -90/21 degree, i.e., ROTATE = 4.285714285714286 DEG ."[p$1716,p1$1716]]=equ$1716;LaTeX`ob$+=neq,--LaTeX`ob$;With[{lx$17
16},out$1716=lx$1716@Typeset["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotate
d around z-axis by -90/21 degree, i.e., ROTATE = 4.285714285714286 DEG ."[p$1716,p1$1716],Format->Help2HTML`oB$];System["mv -f "//o
ut$1716//" "//equ$1716]];Exit[]]];"\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet r
otated around z-axis by -90/21 degree, i.e., ROTATE = 4.285714285714286 DEG ."[1,Max[p0$1716,0]]//"<img  class=\"eqs\" SRC=\""//equ
$1716//"\" />"//Help2HTML`oy$["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotat
ed around z-axis by -90/21 degree, i.e., ROTATE = 4.285714285714286 DEG ."[p2$1716,-1]]]
</PRE>
<PRE>See also:
 <A HREF=#L94>L</A></PRE>
<LI>
<H3><A NAME=L182>
K21</A></H3>
<PRE>The normal 44-pole magnetic field component (times the length L).

<img  class="eqs" SRC="SADHelp_img/equ_152.svg" />If[{},Help2HTML`oA$["\n\nwhere L is the effective length of the component. Positi
ve sign means horizontal focusing."],p$1720=1+p$1720[[1,2]];p1$1720=StringPosition["\n\nwhere L is the effective length of the comp
onent. Positive sign means horizontal focusing."[p$1720,-1],">::",1];p1$1720=If[p1$1720==={},92,-2+p$1720+p1$1720[[1,1]]];neq=Which
["\n\nwhere L is the effective length of the component. Positive sign means horizontal focusing."[p$1720,4+p$1720]==="Text[",lx$172
0:=Help2HTML`oa$;p$1720=5+p$1720;p1$1720-=1;p2$1720=5+p1$1720;p0$1720=-9+p$1720;If[(pe$1720=StringPosition["\n\nwhere L is the effe
ctive length of the component. Positive sign means horizontal focusing."[p$1720,-2],";;;"])<=>{},{Max[0,-1+ToExpression["\n\nwhere 
L is the effective length of the component. Positive sign means horizontal focusing."[p$1720+pe$1720[[1,2]],p1$1720]]],p1$1720=-2+p
$1720+pe$1720[[1,1]]}[[1]],0],1,lx$1720:=Help2HTML`o9$;p2$1720=4+p1$1720;p0$1720=-4+p$1720;0];If[(equ$1720=Help2HTML`o8$["\n\nwhere
 L is the effective length of the component. Positive sign means horizontal focusing."[p$1720,p1$1720]])===Undefined,equ$1720="SADH
elp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["\n\nwhere L is the effective length of the component. Posit
ive sign means horizontal focusing."[p$1720,p1$1720]]=equ$1720;LaTeX`ob$+=neq,--LaTeX`ob$;With[{lx$1720},out$1720=lx$1720@Typeset["
\n\nwhere L is the effective length of the component. Positive sign means horizontal focusing."[p$1720,p1$1720],Format->Help2HTML`o
B$];System["mv -f "//out$1720//" "//equ$1720]];Exit[]]];"\n\nwhere L is the effective length of the component. Positive sign means 
horizontal focusing."[1,Max[p0$1720,0]]//"<img  class=\"eqs\" SRC=\""//equ$1720//"\" />"//Help2HTML`oy$["\n\nwhere L is the effecti
ve length of the component. Positive sign means horizontal focusing."[p2$1720,-1]]]
</PRE>
<PRE>See also:
 <A HREF=#L94>L</A></PRE>
<LI>
<H3><A NAME=L183>
SK21</A></H3>
<PRE>The skew 44-pole magnetic field component (times the length L).
<img  class="eqs" SRC="SADHelp_img/equ_153.svg" />If[{},Help2HTML`oA$["\n\nwhere L is the length of the component. Positive sign me
ans a horizontally focusing magnet rotated around z-axis by -90/22 degree, i.e., ROTATE = 4.090909090909091 DEG ."],p$1724=1+p$1724
[[1,2]];p1$1724=StringPosition["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rota
ted around z-axis by -90/22 degree, i.e., ROTATE = 4.090909090909091 DEG ."[p$1724,-1],">::",1];p1$1724=If[p1$1724==={},171,-2+p$17
24+p1$1724[[1,1]]];neq=Which["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotate
d around z-axis by -90/22 degree, i.e., ROTATE = 4.090909090909091 DEG ."[p$1724,4+p$1724]==="Text[",lx$1724:=Help2HTML`oa$;p$1724=
5+p$1724;p1$1724-=1;p2$1724=5+p1$1724;p0$1724=-9+p$1724;If[(pe$1724=StringPosition["\n\nwhere L is the length of the component. Pos
itive sign means a horizontally focusing magnet rotated around z-axis by -90/22 degree, i.e., ROTATE = 4.090909090909091 DEG ."[p$1
724,-2],";;;"])<=>{},{Max[0,-1+ToExpression["\n\nwhere L is the length of the component. Positive sign means a horizontally focusin
g magnet rotated around z-axis by -90/22 degree, i.e., ROTATE = 4.090909090909091 DEG ."[p$1724+pe$1724[[1,2]],p1$1724]]],p1$1724=-
2+p$1724+pe$1724[[1,1]]}[[1]],0],1,lx$1724:=Help2HTML`o9$;p2$1724=4+p1$1724;p0$1724=-4+p$1724;0];If[(equ$1724=Help2HTML`o8$["\n\nwh
ere L is the length of the component. Positive sign means a horizontally focusing magnet rotated around z-axis by -90/22 degree, i.
e., ROTATE = 4.090909090909091 DEG ."[p$1724,p1$1724]])===Undefined,equ$1724="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If
[Fork[],Help2HTML`o8$["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotated aroun
d z-axis by -90/22 degree, i.e., ROTATE = 4.090909090909091 DEG ."[p$1724,p1$1724]]=equ$1724;LaTeX`ob$+=neq,--LaTeX`ob$;With[{lx$17
24},out$1724=lx$1724@Typeset["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotate
d around z-axis by -90/22 degree, i.e., ROTATE = 4.090909090909091 DEG ."[p$1724,p1$1724],Format->Help2HTML`oB$];System["mv -f "//o
ut$1724//" "//equ$1724]];Exit[]]];"\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet r
otated around z-axis by -90/22 degree, i.e., ROTATE = 4.090909090909091 DEG ."[1,Max[p0$1724,0]]//"<img  class=\"eqs\" SRC=\""//equ
$1724//"\" />"//Help2HTML`oy$["\n\nwhere L is the length of the component. Positive sign means a horizontally focusing magnet rotat
ed around z-axis by -90/22 degree, i.e., ROTATE = 4.090909090909091 DEG ."[p2$1724,-1]]]
</PRE>
<PRE>See also:
 <A HREF=#L94>L</A></PRE>
<LI>
<H3><A NAME=L184>
AE1</A></H3>
<PRE>If[{},
Help2HTML`oA$["The absolute face angle at the entrance. The effective face angle is E1 * ANGLE + AE1, and a positive angle at the \
entrance corresponds to a surface with dx/ds > 0."],
p$1727=1+p$1727[[1,2]];p1$1727=StringPosition["The absolute face angle at the entrance. The effective face angle is E1 * ANGLE + A\
E1, and a positive angle at the entrance corresponds to a surface with dx/ds > 0."[p$1727,-1],">::",1];
   p1$1727=If[p1$1727==={},164,-2+p$1727+p1$1727[[1,1]]];
neq=Which["The absolute face angle at the entrance. The effective face angle is E1 * ANGLE + AE1, and a positive angle at the entr\
ance corresponds to a surface with dx/ds > 0."[p$1727,4+p$1727]==="Text[",
    lx$1727:=Help2HTML`oa$;p$1727=5+p$1727;p1$1727-=1;p2$1727=5+p1$1727;p0$1727=-9+p$1727;
If[(pe$1727=StringPosition["The absolute face angle at the entrance. The effective face angle is E1 * ANGLE + AE1, and a positive \
angle at the entrance corresponds to a surface with dx/ds > 0."[p$1727,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["The absolute face angle at the entrance. The effective face angle is E1 * ANGLE + AE1, and a positive angle at th\
e entrance corresponds to a surface with dx/ds > 0."[p$1727+pe$1727[[1,2]],p1$1727]]],
        p1$1727=-2+p$1727+pe$1727[[1,1]]}[[
       1]],
      0],
    1,lx$1727:=Help2HTML`o9$;p2$1727=4+p1$1727;p0$1727=-4+p$1727;0];
  If[(equ$1727=
Help2HTML`o8$["The absolute face angle at the entrance. The effective face angle is E1 * ANGLE + AE1, and a positive angle at the \
entrance corresponds to a surface with dx/ds > 0."[p$1727,p1$1727]])===
    Undefined,
equ$1727="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["The absolute face angle at the entrance. The\
 effective face angle is E1 * ANGLE + AE1, and a positive angle at the entrance corresponds to a surface with dx/ds > 0."[p$1727,
         p1$1727]]=
       equ$1727;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1727},out$1727=lx$1727@Typeset["The absolute face angle at the entrance. The effective face angle is E1 * ANGLE + AE1, an\
d a positive angle at the entrance corresponds to a surface with dx/ds > 0."[p$1727,p1$1727],Format->Help2HTML`oB$];
        System["mv -f "//out$1727//" "//equ$1727]];
      Exit[]]];
   "The absolute face angle at the entrance. The effective face angle is E1 * ANGLE + AE1, and a positive angle at the entrance co\
rresponds to a surface with dx/ds > 0."[1,Max[p0$1727,0]]//"<img  class=\"eqs\" SRC=\""//equ$1727//"\" />"//
Help2HTML`oy$["The absolute face angle at the entrance. The effective face angle is E1 * ANGLE + AE1, and a positive angle at the \
entrance corresponds to a surface with dx/ds > 0."[p2$1727,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L86>E1</A> <A HREF=#L79>AE2</A> <A HREF=#L80>ANGLE</A></PRE>
<LI>
<H3><A NAME=L185>
AE2</A></H3>
<PRE>If[{},
Help2HTML`oA$["The absolute face-angle at the exit to the bending angle. The effective face angle is E2 * ANGLE + AE2, and a posit\
ive angle at the exit corresponds to a surface with dx/ds &lt 0."],
p$1730=1+p$1730[[1,2]];p1$1730=StringPosition["The absolute face-angle at the exit to the bending angle. The effective face angle \
is E2 * ANGLE + AE2, and a positive angle at the exit corresponds to a surface with dx/ds &lt 0."[p$1730,-1],">::",1];
   p1$1730=If[p1$1730==={},179,-2+p$1730+p1$1730[[1,1]]];
neq=Which["The absolute face-angle at the exit to the bending angle. The effective face angle is E2 * ANGLE + AE2, and a positive \
angle at the exit corresponds to a surface with dx/ds &lt 0."[p$1730,4+p$1730]==="Text[",
    lx$1730:=Help2HTML`oa$;p$1730=5+p$1730;p1$1730-=1;p2$1730=5+p1$1730;p0$1730=-9+p$1730;
If[(pe$1730=StringPosition["The absolute face-angle at the exit to the bending angle. The effective face angle is E2 * ANGLE + AE2\
, and a positive angle at the exit corresponds to a surface with dx/ds &lt 0."[p$1730,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["The absolute face-angle at the exit to the bending angle. The effective face angle is E2 * ANGLE + AE2, and a pos\
itive angle at the exit corresponds to a surface with dx/ds &lt 0."[p$1730+pe$1730[[1,2]],p1$1730]]],
        p1$1730=-2+p$1730+pe$1730[[1,1]]}[[
       1]],
      0],
    1,lx$1730:=Help2HTML`o9$;p2$1730=4+p1$1730;p0$1730=-4+p$1730;0];
  If[(equ$1730=
Help2HTML`o8$["The absolute face-angle at the exit to the bending angle. The effective face angle is E2 * ANGLE + AE2, and a posit\
ive angle at the exit corresponds to a surface with dx/ds &lt 0."[p$1730,p1$1730]])===
    Undefined,
equ$1730="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["The absolute face-angle at the exit to the b\
ending angle. The effective face angle is E2 * ANGLE + AE2, and a positive angle at the exit corresponds to a surface with dx/ds &\
lt 0."[p$1730,p1$1730]]=
       equ$1730;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1730},out$1730=lx$1730@Typeset["The absolute face-angle at the exit to the bending angle. The effective face angle is E2 \
* ANGLE + AE2, and a positive angle at the exit corresponds to a surface with dx/ds &lt 0."[p$1730,p1$1730],Format->Help2HTML`oB$];
        System["mv -f "//out$1730//" "//equ$1730]];
      Exit[]]];
   "The absolute face-angle at the exit to the bending angle. The effective face angle is E2 * ANGLE + AE2, and a positive angle a\
t the exit corresponds to a surface with dx/ds &lt 0."[1,Max[p0$1730,0]]//"<img  class=\"eqs\" SRC=\""//equ$1730//"\" />"//
   Help2HTML`oy$["The absolute face-angle at the exit to the bending angle. The effective face angle is E2 * ANGLE + AE2, and a po\
sitive angle at the exit corresponds to a surface with dx/ds &lt 0."[p2$1730,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L87>E2</A> <A HREF=#L78>AE1</A> <A HREF=#L80>ANGLE</A></PRE>
<LI>
<H3><A NAME=L186>
ANGLE</A></H3>
<PRE>If[{},
Help2HTML`oA$["The bending angle. If positive, it bends the orbit in x-s plane toward negative-x-direction. ANGLE determines the g\
eometry of the beam line, while K0 represents a dipole kick on top of the bending angle given by ANGLE, i.e., the total deflection\
 of the beam is given of ANGLE + K0."],
p$1733=1+p$1733[[1,2]];p1$1733=StringPosition["The bending angle. If positive, it bends the orbit in x-s plane toward negative-x-d\
irection. ANGLE determines the geometry of the beam line, while K0 represents a dipole kick on top of the bending angle given by A\
NGLE, i.e., the total deflection of the beam is given of ANGLE + K0."[p$1733,-1],">::",1];
   p1$1733=If[p1$1733==={},281,-2+p$1733+p1$1733[[1,1]]];
neq=Which["The bending angle. If positive, it bends the orbit in x-s plane toward negative-x-direction. ANGLE determines the geome\
try of the beam line, while K0 represents a dipole kick on top of the bending angle given by ANGLE, i.e., the total deflection of \
the beam is given of ANGLE + K0."[p$1733,4+p$1733]==="Text[",
    lx$1733:=Help2HTML`oa$;p$1733=5+p$1733;p1$1733-=1;p2$1733=5+p1$1733;p0$1733=-9+p$1733;
If[(pe$1733=StringPosition["The bending angle. If positive, it bends the orbit in x-s plane toward negative-x-direction. ANGLE det\
ermines the geometry of the beam line, while K0 represents a dipole kick on top of the bending angle given by ANGLE, i.e., the tot\
al deflection of the beam is given of ANGLE + K0."[p$1733,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["The bending angle. If positive, it bends the orbit in x-s plane toward negative-x-direction. ANGLE determines the\
 geometry of the beam line, while K0 represents a dipole kick on top of the bending angle given by ANGLE, i.e., the total deflecti\
on of the beam is given of ANGLE + K0."[p$1733+pe$1733[[1,2]],p1$1733]]],
        p1$1733=-2+p$1733+pe$1733[[1,1]]}[[
       1]],
      0],
    1,lx$1733:=Help2HTML`o9$;p2$1733=4+p1$1733;p0$1733=-4+p$1733;0];
  If[(equ$1733=
Help2HTML`o8$["The bending angle. If positive, it bends the orbit in x-s plane toward negative-x-direction. ANGLE determines the g\
eometry of the beam line, while K0 represents a dipole kick on top of the bending angle given by ANGLE, i.e., the total deflection\
 of the beam is given of ANGLE + K0."[p$1733,p1$1733]])===
    Undefined,
equ$1733="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["The bending angle. If positive, it bends the\
 orbit in x-s plane toward negative-x-direction. ANGLE determines the geometry of the beam line, while K0 represents a dipole kick\
 on top of the bending angle given by ANGLE, i.e., the total deflection of the beam is given of ANGLE + K0."[p$1733,p1$1733]]=
       equ$1733;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1733},out$1733=lx$1733@Typeset["The bending angle. If positive, it bends the orbit in x-s plane toward negative-x-directi\
on. ANGLE determines the geometry of the beam line, while K0 represents a dipole kick on top of the bending angle given by ANGLE, \
i.e., the total deflection of the beam is given of ANGLE + K0."[p$1733,p1$1733],Format->Help2HTML`oB$];
        System["mv -f "//out$1733//" "//equ$1733]];
      Exit[]]];
   "The bending angle. If positive, it bends the orbit in x-s plane toward negative-x-direction. ANGLE determines the geometry of \
the beam line, while K0 represents a dipole kick on top of the bending angle given by ANGLE, i.e., the total deflection of the bea\
m is given of ANGLE + K0."[1,Max[p0$1733,0]]//"<img  class=\"eqs\" SRC=\""//equ$1733//"\" />"//
Help2HTML`oy$["The bending angle. If positive, it bends the orbit in x-s plane toward negative-x-direction. ANGLE determines the g\
eometry of the beam line, while K0 represents a dipole kick on top of the bending angle given by ANGLE, i.e., the total deflection\
 of the beam is given of ANGLE + K0."[p2$1733,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L92>K0</A></PRE>
<LI>
<H3><A NAME=L187>
DISFRIN</A></H3>
<PRE>If[{},
Help2HTML`oA$["If nonzero, the nonlinear maxwellian fringe is suppressed. The effects of DISFRIN and FRINGE are summarized as\n\n \
                  DISFRIN=0                   DISFRIN<>0\n             Nonlinear      Linear       Nonlinear     Linear\nFRINGE=0 \
   entr & exit      none          none         none\nFRINGE=1       entr          entr          none         entr\nFRINGE=2       \
exit          exit          none         exit\nFRINGE=3    entr & exit   entr & exit      none      entr & exit\n\n"],
 p$1736=1+p$1736[[1,2]];
p1$1736=StringPosition["If nonzero, the nonlinear maxwellian fringe is suppressed. The effects of DISFRIN and FRINGE are summarize\
d as\n\n                   DISFRIN=0                   DISFRIN<>0\n             Nonlinear      Linear       Nonlinear     Linear\n\
FRINGE=0    entr & exit      none          none         none\nFRINGE=1       entr          entr          none         entr\nFRINGE\
=2       exit          exit          none         exit\nFRINGE=3    entr & exit   entr & exit      none      entr & exit\n\n"[p
     $1736,-1],
    ">::",1];
   p1$1736=If[p1$1736==={},481,-2+p$1736+p1$1736[[1,1]]];
neq=Which["If nonzero, the nonlinear maxwellian fringe is suppressed. The effects of DISFRIN and FRINGE are summarized as\n\n     \
              DISFRIN=0                   DISFRIN<>0\n             Nonlinear      Linear       Nonlinear     Linear\nFRINGE=0    e\
ntr & exit      none          none         none\nFRINGE=1       entr          entr          none         entr\nFRINGE=2       exit\
          exit          none         exit\nFRINGE=3    entr & exit   entr & exit      none      entr & exit\n\n"[p$1736,4+p$1736
      ]===
     "Text[",
lx$1736:=Help2HTML`oa$;p$1736=5+p$1736;p1$1736-=1;p2$1736=5+p1$1736;p0$1736=-9+p$1736;If[(pe$1736=StringPosition["If nonzero, the \
nonlinear maxwellian fringe is suppressed. The effects of DISFRIN and FRINGE are summarized as\n\n                   DISFRIN=0    \
               DISFRIN<>0\n             Nonlinear      Linear       Nonlinear     Linear\nFRINGE=0    entr & exit      none       \
   none         none\nFRINGE=1       entr          entr          none         entr\nFRINGE=2       exit          exit          non\
e         exit\nFRINGE=3    entr & exit   entr & exit      none      entr & exit\n\n"[p$1736,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["If nonzero, the nonlinear maxwellian fringe is suppressed. The effects of DISFRIN and FRINGE are summarized as\n\\
n                   DISFRIN=0                   DISFRIN<>0\n             Nonlinear      Linear       Nonlinear     Linear\nFRINGE=\
0    entr & exit      none          none         none\nFRINGE=1       entr          entr          none         entr\nFRINGE=2     \
  exit          exit          none         exit\nFRINGE=3    entr & exit   entr & exit      none      entr & exit\n\n"[p$1736+
            pe$1736[[1,2]],
           p1$1736]]],
        p1$1736=-2+p$1736+pe$1736[[1,1]]}[[
       1]],
      0],
    1,lx$1736:=Help2HTML`o9$;p2$1736=4+p1$1736;p0$1736=-4+p$1736;0];
  If[(equ$1736=
Help2HTML`o8$["If nonzero, the nonlinear maxwellian fringe is suppressed. The effects of DISFRIN and FRINGE are summarized as\n\n \
                  DISFRIN=0                   DISFRIN<>0\n             Nonlinear      Linear       Nonlinear     Linear\nFRINGE=0 \
   entr & exit      none          none         none\nFRINGE=1       entr          entr          none         entr\nFRINGE=2       \
exit          exit          none         exit\nFRINGE=3    entr & exit   entr & exit      none      entr & exit\n\n"[p$1736,p1$1736
       ]])===
    Undefined,
equ$1736="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["If nonzero, the nonlinear maxwellian fringe \
is suppressed. The effects of DISFRIN and FRINGE are summarized as\n\n                   DISFRIN=0                   DISFRIN<>0\n \
            Nonlinear      Linear       Nonlinear     Linear\nFRINGE=0    entr & exit      none          none         none\nFRINGE\
=1       entr          entr          none         entr\nFRINGE=2       exit          exit          none         exit\nFRINGE=3    \
entr & exit   entr & exit      none      entr & exit\n\n"[p$1736,p1$1736]]=
       equ$1736;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1736},out$1736=lx$1736@Typeset["If nonzero, the nonlinear maxwellian fringe is suppressed. The effects of DISFRIN and FRI\
NGE are summarized as\n\n                   DISFRIN=0                   DISFRIN<>0\n             Nonlinear      Linear       Nonli\
near     Linear\nFRINGE=0    entr & exit      none          none         none\nFRINGE=1       entr          entr          none    \
     entr\nFRINGE=2       exit          exit          none         exit\nFRINGE=3    entr & exit   entr & exit      none      entr\
 & exit\n\n"[p$1736,p1$1736],Format->Help2HTML`oB$];
        System["mv -f "//out$1736//" "//equ$1736]];
      Exit[]]];
   "If nonzero, the nonlinear maxwellian fringe is suppressed. The effects of DISFRIN and FRINGE are summarized as\n\n            \
       DISFRIN=0                   DISFRIN<>0\n             Nonlinear      Linear       Nonlinear     Linear\nFRINGE=0    entr & e\
xit      none          none         none\nFRINGE=1       entr          entr          none         entr\nFRINGE=2       exit       \
   exit          none         exit\nFRINGE=3    entr & exit   entr & exit      none      entr & exit\n\n"[1,Max[p0$1736,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$1736//"\" />"//
Help2HTML`oy$["If nonzero, the nonlinear maxwellian fringe is suppressed. The effects of DISFRIN and FRINGE are summarized as\n\n \
                  DISFRIN=0                   DISFRIN<>0\n             Nonlinear      Linear       Nonlinear     Linear\nFRINGE=0 \
   entr & exit      none          none         none\nFRINGE=1       entr          entr          none         entr\nFRINGE=2       \
exit          exit          none         exit\nFRINGE=3    entr & exit   entr & exit      none      entr & exit\n\n"[p2$1736,-1]]
 ]
</PRE>
<PRE>See also:
 <A HREF=#L91>FRINGE</A></PRE>
<LI>
<H3><A NAME=L188>
DISRAD</A></H3>
<PRE>If[{},Help2HTML`oA$["If nonzero, the synchrotron radiation in the particle-tracking is inhibited."],
 p$1739=1+p$1739[[1,2]];p1$1739=
   StringPosition["If nonzero, the synchrotron radiation in the particle-tracking is inhibited."[p$1739,-1],">::",1];
  p1$1739=If[p1$1739==={},76,-2+p$1739+p1$1739[[1,1]]];
  neq=Which["If nonzero, the synchrotron radiation in the particle-tracking is inhibited."[p$1739,4+p$1739]==="Text[",
    lx$1739:=Help2HTML`oa$;p$1739=5+p$1739;p1$1739-=1;p2$1739=5+p1$1739;p0$1739=-9+p$1739;
     If[(pe$1739=StringPosition["If nonzero, the synchrotron radiation in the particle-tracking is inhibited."[p$1739,-2],";;;"]
        )<=>
       {},
      {Max[0,
        -1+ToExpression["If nonzero, the synchrotron radiation in the particle-tracking is inhibited."[p$1739+pe$1739[[1,2]],p1
           $1739]]],
        p1$1739=-2+p$1739+pe$1739[[1,1]]}[[
       1]],
      0],
    1,lx$1739:=Help2HTML`o9$;p2$1739=4+p1$1739;p0$1739=-4+p$1739;0];
  If[(equ$1739=Help2HTML`o8$["If nonzero, the synchrotron radiation in the particle-tracking is inhibited."[p$1739,p1$1739]])===
    Undefined,
   equ$1739="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "If nonzero, the synchrotron radiation in the particle-tracking is inhibited."[p$1739,p1$1739]]=
       equ$1739;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$1739},out$1739=lx$1739@Typeset["If nonzero, the synchrotron radiation in the particle-tracking is inhibited."[p$1739
           ,p1$1739],Format->Help2HTML`oB$];
        System["mv -f "//out$1739//" "//equ$1739]];
      Exit[]]];
   "If nonzero, the synchrotron radiation in the particle-tracking is inhibited."[1,Max[p0$1739,0]]//"<img  class=\"eqs\" SRC=\""//
   equ$1739//"\" />"//Help2HTML`oy$["If nonzero, the synchrotron radiation in the particle-tracking is inhibited."[p2$1739,-1]]
 ]
</PRE>
<PRE>See also:
 <A HREF=#L337>RAD</A></PRE>
<LI>
<H3><A NAME=L189>
DPHI</A></H3>
<PRE>Relative phase offset. The stable synchrotron phase above the transition is near PHI = 0. The acceleration is given as 

<img  class="eqs" SRC="SADHelp_img/equ_100.svg" />If[{},Help2HTML`oA$["\n\nwhere ts is the equilibrium time determined by the valan
ce between the acceleration and the radiation loss around the ring. DPHI is not taken into account to determine the design momentum
 p0(s)."],p$1743=1+p$1743[[1,2]];p1$1743=StringPosition["\n\nwhere ts is the equilibrium time determined by the valance between the
 acceleration and the radiation loss around the ring. DPHI is not taken into account to determine the design momentum p0(s)."[p$174
3,-1],">::",1];p1$1743=If[p1$1743==={},196,-2+p$1743+p1$1743[[1,1]]];neq=Which["\n\nwhere ts is the equilibrium time determined by 
the valance between the acceleration and the radiation loss around the ring. DPHI is not taken into account to determine the design
 momentum p0(s)."[p$1743,4+p$1743]==="Text[",lx$1743:=Help2HTML`oa$;p$1743=5+p$1743;p1$1743-=1;p2$1743=5+p1$1743;p0$1743=-9+p$1743;
If[(pe$1743=StringPosition["\n\nwhere ts is the equilibrium time determined by the valance between the acceleration and the radiati
on loss around the ring. DPHI is not taken into account to determine the design momentum p0(s)."[p$1743,-2],";;;"])<=>{},{Max[0,-1+
ToExpression["\n\nwhere ts is the equilibrium time determined by the valance between the acceleration and the radiation loss around
 the ring. DPHI is not taken into account to determine the design momentum p0(s)."[p$1743+pe$1743[[1,2]],p1$1743]]],p1$1743=-2+p$17
43+pe$1743[[1,1]]}[[1]],0],1,lx$1743:=Help2HTML`o9$;p2$1743=4+p1$1743;p0$1743=-4+p$1743;0];If[(equ$1743=Help2HTML`o8$["\n\nwhere ts
 is the equilibrium time determined by the valance between the acceleration and the radiation loss around the ring. DPHI is not tak
en into account to determine the design momentum p0(s)."[p$1743,p1$1743]])===Undefined,equ$1743="SADHelp_img/equ_"//++LaTeX`ob$//".
"//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["\n\nwhere ts is the equilibrium time determined by the valance between the acceleration a
nd the radiation loss around the ring. DPHI is not taken into account to determine the design momentum p0(s)."[p$1743,p1$1743]]=equ
$1743;LaTeX`ob$+=neq,--LaTeX`ob$;With[{lx$1743},out$1743=lx$1743@Typeset["\n\nwhere ts is the equilibrium time determined by the va
lance between the acceleration and the radiation loss around the ring. DPHI is not taken into account to determine the design momen
tum p0(s)."[p$1743,p1$1743],Format->Help2HTML`oB$];System["mv -f "//out$1743//" "//equ$1743]];Exit[]]];"\n\nwhere ts is the equilib
rium time determined by the valance between the acceleration and the radiation loss around the ring. DPHI is not taken into account
 to determine the design momentum p0(s)."[1,Max[p0$1743,0]]//"<img  class=\"eqs\" SRC=\""//equ$1743//"\" />"//Help2HTML`oy$["\n\nwh
ere ts is the equilibrium time determined by the valance between the acceleration and the radiation loss around the ring. DPHI is n
ot taken into account to determine the design momentum p0(s)."[p2$1743,-1]]]
</PRE>
<PRE>See also:
 <A HREF=#L103>FREQ</A> <A HREF=#L111>VOLT</A> <A HREF=#L100>DVOLT</A> <A HREF=#L109>V1</A> V20 <A HREF=#L110>V11</A></PRE>
<LI>
<H3><A NAME=L190>
DVOLT</A></H3>
<PRE>If[{},Help2HTML`oA$["Additional accelerating peak voltage to be added to Volt, without affecting the design momentum p0(s)."],
 p$1746=1+p$1746[[1,2]];
  p1$1746=StringPosition["Additional accelerating peak voltage to be added to Volt, without affecting the design momentum p0(s)."[
     p$1746,-1],
    ">::",1];
   p1$1746=If[p1$1746==={},102,-2+p$1746+p1$1746[[1,1]]];
  neq=Which["Additional accelerating peak voltage to be added to Volt, without affecting the design momentum p0(s)."[p$1746,
      4+p$1746]===
     "Text[",
    lx$1746:=Help2HTML`oa$;p$1746=5+p$1746;p1$1746-=1;p2$1746=5+p1$1746;p0$1746=-9+p$1746;If[(pe$1746=StringPosition[
         "Additional accelerating peak voltage to be added to Volt, without affecting the design momentum p0(s)."[p$1746,-2],";;;"]
        )<=>
       {},
      {Max[0,
        -1+ToExpression["Additional accelerating peak voltage to be added to Volt, without affecting the design momentum p0(s)."[
            p$1746+pe$1746[[1,2]],
           p1$1746]]],
        p1$1746=-2+p$1746+pe$1746[[1,1]]}[[
       1]],
      0],
    1,lx$1746:=Help2HTML`o9$;p2$1746=4+p1$1746;p0$1746=-4+p$1746;0];
  If[(equ$1746=
     Help2HTML`o8$["Additional accelerating peak voltage to be added to Volt, without affecting the design momentum p0(s)."[p$1746,
       p1$1746]])===
    Undefined,
   equ$1746="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "Additional accelerating peak voltage to be added to Volt, without affecting the design momentum p0(s)."[p$1746,p1$1746]]=
       equ$1746;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$1746},out$1746=lx$1746@Typeset[
          "Additional accelerating peak voltage to be added to Volt, without affecting the design momentum p0(s)."[p$1746,p1$1746],
          Format->Help2HTML`oB$];
        System["mv -f "//out$1746//" "//equ$1746]];
      Exit[]]];
   "Additional accelerating peak voltage to be added to Volt, without affecting the design momentum p0(s)."[1,Max[p0$1746,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$1746//"\" />"//
   Help2HTML`oy$["Additional accelerating peak voltage to be added to Volt, without affecting the design momentum p0(s)."[p2$1746,
     -1]]
]</PRE>
<PRE>See also:
 <A HREF=#L111>VOLT</A></PRE>
<LI>
<H3><A NAME=L191>
E1</A></H3>
<PRE>If[{},
Help2HTML`oA$["The ratio of the face-angle at the entrance to the bending angle. The effective face angle is E1 * ANGLE + AE1, and\
 a positive angle at the entrance corresponds to a surface with dx/ds > 0. For example, a symmetrically-placed rectangular magnet \
has\n E1 = 0.5 and E2 = 0.5."],
p$1749=1+p$1749[[1,2]];p1$1749=StringPosition["The ratio of the face-angle at the entrance to the bending angle. The effective fac\
e angle is E1 * ANGLE + AE1, and a positive angle at the entrance corresponds to a surface with dx/ds > 0. For example, a symmetri\
cally-placed rectangular magnet has\n E1 = 0.5 and E2 = 0.5."[p$1749,-1],">::",1];
   p1$1749=If[p1$1749==={},272,-2+p$1749+p1$1749[[1,1]]];
neq=Which["The ratio of the face-angle at the entrance to the bending angle. The effective face angle is E1 * ANGLE + AE1, and a p\
ositive angle at the entrance corresponds to a surface with dx/ds > 0. For example, a symmetrically-placed rectangular magnet has\\
n E1 = 0.5 and E2 = 0.5."[p$1749,4+p$1749]==="Text[",
    lx$1749:=Help2HTML`oa$;p$1749=5+p$1749;p1$1749-=1;p2$1749=5+p1$1749;p0$1749=-9+p$1749;
If[(pe$1749=StringPosition["The ratio of the face-angle at the entrance to the bending angle. The effective face angle is E1 * ANG\
LE + AE1, and a positive angle at the entrance corresponds to a surface with dx/ds > 0. For example, a symmetrically-placed rectan\
gular magnet has\n E1 = 0.5 and E2 = 0.5."[p$1749,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["The ratio of the face-angle at the entrance to the bending angle. The effective face angle is E1 * ANGLE + AE1, a\
nd a positive angle at the entrance corresponds to a surface with dx/ds > 0. For example, a symmetrically-placed rectangular magne\
t has\n E1 = 0.5 and E2 = 0.5."[p$1749+pe$1749[[1,2]],p1$1749]]],
        p1$1749=-2+p$1749+pe$1749[[1,1]]}[[
       1]],
      0],
    1,lx$1749:=Help2HTML`o9$;p2$1749=4+p1$1749;p0$1749=-4+p$1749;0];
  If[(equ$1749=
Help2HTML`o8$["The ratio of the face-angle at the entrance to the bending angle. The effective face angle is E1 * ANGLE + AE1, and\
 a positive angle at the entrance corresponds to a surface with dx/ds > 0. For example, a symmetrically-placed rectangular magnet \
has\n E1 = 0.5 and E2 = 0.5."[p$1749,p1$1749]])===
    Undefined,
equ$1749="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["The ratio of the face-angle at the entrance \
to the bending angle. The effective face angle is E1 * ANGLE + AE1, and a positive angle at the entrance corresponds to a surface \
with dx/ds > 0. For example, a symmetrically-placed rectangular magnet has\n E1 = 0.5 and E2 = 0.5."[p$1749,p1$1749]]=
       equ$1749;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1749},out$1749=lx$1749@Typeset["The ratio of the face-angle at the entrance to the bending angle. The effective face angl\
e is E1 * ANGLE + AE1, and a positive angle at the entrance corresponds to a surface with dx/ds > 0. For example, a symmetrically-\
placed rectangular magnet has\n E1 = 0.5 and E2 = 0.5."[p$1749,p1$1749],Format->Help2HTML`oB$];
        System["mv -f "//out$1749//" "//equ$1749]];
      Exit[]]];
   "The ratio of the face-angle at the entrance to the bending angle. The effective face angle is E1 * ANGLE + AE1, and a positive\
 angle at the entrance corresponds to a surface with dx/ds > 0. For example, a symmetrically-placed rectangular magnet has\n E1 = \
0.5 and E2 = 0.5."[1,Max[p0$1749,0]]//"<img  class=\"eqs\" SRC=\""//equ$1749//"\" />"//
Help2HTML`oy$["The ratio of the face-angle at the entrance to the bending angle. The effective face angle is E1 * ANGLE + AE1, and\
 a positive angle at the entrance corresponds to a surface with dx/ds > 0. For example, a symmetrically-placed rectangular magnet \
has\n E1 = 0.5 and E2 = 0.5."[p2$1749,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L78>AE1</A> <A HREF=#L87>E2</A> <A HREF=#L80>ANGLE</A></PRE>
<LI>
<H3><A NAME=L192>
E2</A></H3>
<PRE>If[{},
Help2HTML`oA$["The ratio of the face-angle at the exit to the bending angle. The effective face angle is E2 * ANGLE + AE2, and a p\
ositive angle at the exit corresponds to a surface with dx/ds &lt 0. For example, a symmetrically-placed rectangular magnet has E1\
 = 0.5 and E2 = 0.5."],
p$1752=1+p$1752[[1,2]];p1$1752=StringPosition["The ratio of the face-angle at the exit to the bending angle. The effective face an\
gle is E2 * ANGLE + AE2, and a positive angle at the exit corresponds to a surface with dx/ds &lt 0. For example, a symmetrically-\
placed rectangular magnet has E1 = 0.5 and E2 = 0.5."[p$1752,-1],">::",1];
   p1$1752=If[p1$1752==={},265,-2+p$1752+p1$1752[[1,1]]];
neq=Which["The ratio of the face-angle at the exit to the bending angle. The effective face angle is E2 * ANGLE + AE2, and a posit\
ive angle at the exit corresponds to a surface with dx/ds &lt 0. For example, a symmetrically-placed rectangular magnet has E1 = 0\
.5 and E2 = 0.5."[p$1752,4+p$1752]==="Text[",
    lx$1752:=Help2HTML`oa$;p$1752=5+p$1752;p1$1752-=1;p2$1752=5+p1$1752;p0$1752=-9+p$1752;If[(pe$1752=
StringPosition["The ratio of the face-angle at the exit to the bending angle. The effective face angle is E2 * ANGLE + AE2, and a \
positive angle at the exit corresponds to a surface with dx/ds &lt 0. For example, a symmetrically-placed rectangular magnet has E\
1 = 0.5 and E2 = 0.5."[p$1752,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["The ratio of the face-angle at the exit to the bending angle. The effective face angle is E2 * ANGLE + AE2, and a\
 positive angle at the exit corresponds to a surface with dx/ds &lt 0. For example, a symmetrically-placed rectangular magnet has \
E1 = 0.5 and E2 = 0.5."[p$1752+pe$1752[[1,2]],p1$1752]]],
        p1$1752=-2+p$1752+pe$1752[[1,1]]}[[
       1]],
      0],
    1,lx$1752:=Help2HTML`o9$;p2$1752=4+p1$1752;p0$1752=-4+p$1752;0];
  If[(equ$1752=
Help2HTML`o8$["The ratio of the face-angle at the exit to the bending angle. The effective face angle is E2 * ANGLE + AE2, and a p\
ositive angle at the exit corresponds to a surface with dx/ds &lt 0. For example, a symmetrically-placed rectangular magnet has E1\
 = 0.5 and E2 = 0.5."[p$1752,p1$1752]])===
    Undefined,
equ$1752="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["The ratio of the face-angle at the exit to t\
he bending angle. The effective face angle is E2 * ANGLE + AE2, and a positive angle at the exit corresponds to a surface with dx/\
ds &lt 0. For example, a symmetrically-placed rectangular magnet has E1 = 0.5 and E2 = 0.5."[p$1752,p1$1752]]=
       equ$1752;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1752},out$1752=lx$1752@Typeset["The ratio of the face-angle at the exit to the bending angle. The effective face angle is\
 E2 * ANGLE + AE2, and a positive angle at the exit corresponds to a surface with dx/ds &lt 0. For example, a symmetrically-placed\
 rectangular magnet has E1 = 0.5 and E2 = 0.5."[p$1752,p1$1752],Format->Help2HTML`oB$];
        System["mv -f "//out$1752//" "//equ$1752]];
      Exit[]]];
   "The ratio of the face-angle at the exit to the bending angle. The effective face angle is E2 * ANGLE + AE2, and a positive ang\
le at the exit corresponds to a surface with dx/ds &lt 0. For example, a symmetrically-placed rectangular magnet has E1 = 0.5 and \
E2 = 0.5."[1,Max[p0$1752,0]]//"<img  class=\"eqs\" SRC=\""//equ$1752//"\" />"//
Help2HTML`oy$["The ratio of the face-angle at the exit to the bending angle. The effective face angle is E2 * ANGLE + AE2, and a p\
ositive angle at the exit corresponds to a surface with dx/ds &lt 0. For example, a symmetrically-placed rectangular magnet has E1\
 = 0.5 and E2 = 0.5."[p2$1752,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L79>AE2</A> <A HREF=#L86>E1</A> <A HREF=#L80>ANGLE</A></PRE>
<LI>
<H3><A NAME=L193>
F1</A></H3>
<PRE><img  class="eqs" SRC="SADHelp_img/equ_154.svg" />If[{},Help2HTML`oA$["\n   The effects only in the first order of K1 is taken
 into account."],p$1756=1+p$1756[[1,2]];p1$1756=StringPosition["\n   The effects only in the first order of K1 is taken into accoun
t."[p$1756,-1],">::",1];p1$1756=If[p1$1756==={},68,-2+p$1756+p1$1756[[1,1]]];neq=Which["\n   The effects only in the first order of
 K1 is taken into account."[p$1756,4+p$1756]==="Text[",lx$1756:=Help2HTML`oa$;p$1756=5+p$1756;p1$1756-=1;p2$1756=5+p1$1756;p0$1756=
-9+p$1756;If[(pe$1756=StringPosition["\n   The effects only in the first order of K1 is taken into account."[p$1756,-2],";;;"])<=>{
},{Max[0,-1+ToExpression["\n   The effects only in the first order of K1 is taken into account."[p$1756+pe$1756[[1,2]],p1$1756]]],p
1$1756=-2+p$1756+pe$1756[[1,1]]}[[1]],0],1,lx$1756:=Help2HTML`o9$;p2$1756=4+p1$1756;p0$1756=-4+p$1756;0];If[(equ$1756=Help2HTML`o8$
["\n   The effects only in the first order of K1 is taken into account."[p$1756,p1$1756]])===Undefined,equ$1756="SADHelp_img/equ_"/
/++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["\n   The effects only in the first order of K1 is taken into account."[p$
1756,p1$1756]]=equ$1756;LaTeX`ob$+=neq,--LaTeX`ob$;With[{lx$1756},out$1756=lx$1756@Typeset["\n   The effects only in the first orde
r of K1 is taken into account."[p$1756,p1$1756],Format->Help2HTML`oB$];System["mv -f "//out$1756//" "//equ$1756]];Exit[]]];"\n   Th
e effects only in the first order of K1 is taken into account."[1,Max[p0$1756,0]]//"<img  class=\"eqs\" SRC=\""//equ$1756//"\" />"/
/Help2HTML`oy$["\n   The effects only in the first order of K1 is taken into account."[p2$1756,-1]]]
</PRE>
<PRE>See also:
 <A HREF=#L194>F2</A> <A HREF=#L91>FRINGE</A></PRE>
<LI>
<H3><A NAME=L194>
F2</A></H3>
<PRE><img  class="eqs" SRC="SADHelp_img/equ_154.svg" />If[{},Help2HTML`oA$["\n   The effects only in the first order of K1 is taken
 into account."],p$1760=1+p$1760[[1,2]];p1$1760=StringPosition["\n   The effects only in the first order of K1 is taken into accoun
t."[p$1760,-1],">::",1];p1$1760=If[p1$1760==={},68,-2+p$1760+p1$1760[[1,1]]];neq=Which["\n   The effects only in the first order of
 K1 is taken into account."[p$1760,4+p$1760]==="Text[",lx$1760:=Help2HTML`oa$;p$1760=5+p$1760;p1$1760-=1;p2$1760=5+p1$1760;p0$1760=
-9+p$1760;If[(pe$1760=StringPosition["\n   The effects only in the first order of K1 is taken into account."[p$1760,-2],";;;"])<=>{
},{Max[0,-1+ToExpression["\n   The effects only in the first order of K1 is taken into account."[p$1760+pe$1760[[1,2]],p1$1760]]],p
1$1760=-2+p$1760+pe$1760[[1,1]]}[[1]],0],1,lx$1760:=Help2HTML`o9$;p2$1760=4+p1$1760;p0$1760=-4+p$1760;0];If[(equ$1760=Help2HTML`o8$
["\n   The effects only in the first order of K1 is taken into account."[p$1760,p1$1760]])===Undefined,equ$1760="SADHelp_img/equ_"/
/++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["\n   The effects only in the first order of K1 is taken into account."[p$
1760,p1$1760]]=equ$1760;LaTeX`ob$+=neq,--LaTeX`ob$;With[{lx$1760},out$1760=lx$1760@Typeset["\n   The effects only in the first orde
r of K1 is taken into account."[p$1760,p1$1760],Format->Help2HTML`oB$];System["mv -f "//out$1760//" "//equ$1760]];Exit[]]];"\n   Th
e effects only in the first order of K1 is taken into account."[1,Max[p0$1760,0]]//"<img  class=\"eqs\" SRC=\""//equ$1760//"\" />"/
/Help2HTML`oy$["\n   The effects only in the first order of K1 is taken into account."[p2$1760,-1]]]
</PRE>
<PRE>See also:
 <A HREF=#L88>F1</A> <A HREF=#L91>FRINGE</A></PRE>
<LI>
<H3><A NAME=L195>
FB1</A></H3>
<PRE>If[{},Help2HTML`oA$["Linear Fringe length F1 for the K0 component at the entrance."],
 p$1763=1+p$1763[[1,2]];p1$1763=StringPosition["Linear Fringe length F1 for the K0 component at the entrance."[p$1763,-1],">::",1];
  p1$1763=If[p1$1763==={},61,-2+p$1763+p1$1763[[1,1]]];
  neq=Which["Linear Fringe length F1 for the K0 component at the entrance."[p$1763,4+p$1763]==="Text[",
    lx$1763:=Help2HTML`oa$;p$1763=5+p$1763;p1$1763-=1;p2$1763=5+p1$1763;p0$1763=-9+p$1763;
     If[(pe$1763=StringPosition["Linear Fringe length F1 for the K0 component at the entrance."[p$1763,-2],";;;"])<=>{},
      {Max[0,-1+ToExpression["Linear Fringe length F1 for the K0 component at the entrance."[p$1763+pe$1763[[1,2]],p1$1763]]],
       p1$1763=-2+p$1763+pe$1763[[1,1]]}[[1]],
      0],
    1,lx$1763:=Help2HTML`o9$;p2$1763=4+p1$1763;p0$1763=-4+p$1763;0];
  If[(equ$1763=Help2HTML`o8$["Linear Fringe length F1 for the K0 component at the entrance."[p$1763,p1$1763]])===Undefined,
   equ$1763="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["Linear Fringe length F1 for the K0 component at the entrance."[p$1763,p1$1763]]=equ$1763;
      LaTeX`ob$+=neq,
     --LaTeX`ob$;With[{lx$1763},out$1763=lx$1763@Typeset["Linear Fringe length F1 for the K0 component at the entrance."[p$1763,
           p1$1763],Format->Help2HTML`oB$];
        System["mv -f "//out$1763//" "//equ$1763]];
      Exit[]]];
   "Linear Fringe length F1 for the K0 component at the entrance."[1,Max[p0$1763,0]]//"<img  class=\"eqs\" SRC=\""//equ$1763//
   "\" />"//Help2HTML`oy$["Linear Fringe length F1 for the K0 component at the entrance."[p2$1763,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L77>BEND</A> <A HREF=#L88>F1</A> <A HREF=#L89>FB1</A></PRE>
<LI>
<H3><A NAME=L196>
FB2</A></H3>
<PRE>If[{},Help2HTML`oA$["Linear Fringe length F1 for the K0 component at the exit."],
 p$1766=1+p$1766[[1,2]];p1$1766=StringPosition["Linear Fringe length F1 for the K0 component at the exit."[p$1766,-1],">::",1];
  p1$1766=If[p1$1766==={},57,-2+p$1766+p1$1766[[1,1]]];
  neq=Which["Linear Fringe length F1 for the K0 component at the exit."[p$1766,4+p$1766]==="Text[",
    lx$1766:=Help2HTML`oa$;p$1766=5+p$1766;p1$1766-=1;p2$1766=5+p1$1766;p0$1766=-9+p$1766;
     If[(pe$1766=StringPosition["Linear Fringe length F1 for the K0 component at the exit."[p$1766,-2],";;;"])<=>{},
      {Max[0,-1+ToExpression["Linear Fringe length F1 for the K0 component at the exit."[p$1766+pe$1766[[1,2]],p1$1766]]],
       p1$1766=-2+p$1766+pe$1766[[1,1]]}[[1]],
      0],
    1,lx$1766:=Help2HTML`o9$;p2$1766=4+p1$1766;p0$1766=-4+p$1766;0];
  If[(equ$1766=Help2HTML`o8$["Linear Fringe length F1 for the K0 component at the exit."[p$1766,p1$1766]])===Undefined,
   equ$1766="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["Linear Fringe length F1 for the K0 component at the exit."[p$1766,p1$1766]]=equ$1766;LaTeX`ob$+=neq,
     --LaTeX`ob$;
      With[{lx$1766},out$1766=lx$1766@Typeset["Linear Fringe length F1 for the K0 component at the exit."[p$1766,p1$1766],
          Format->Help2HTML`oB$];
        System["mv -f "//out$1766//" "//equ$1766]];
      Exit[]]];
   "Linear Fringe length F1 for the K0 component at the exit."[1,Max[p0$1766,0]]//"<img  class=\"eqs\" SRC=\""//equ$1766//"\" />"//
   Help2HTML`oy$["Linear Fringe length F1 for the K0 component at the exit."[p2$1766,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L77>BEND</A> <A HREF=#L88>F1</A> <A HREF=#L90>FB2</A></PRE>
<LI>
<H3><A NAME=L197>
FREQ</A></H3>
<PRE> Rf frequency. If this keyword is nonzero, the keyword HARM is ignored.
<img  class="eqs" SRC="SADHelp_img/equ_100.svg" />
</PRE>
<PRE>See also:
 <A HREF=#L104>HARM</A></PRE>
<LI>
<H3><A NAME=L198>
FRINGE</A></H3>
<PRE>If[{},
Help2HTML`oA$["The effects of the linear fringe (characterized by F1 and F2), and the nonlinear Mexwellian fringe are controled as\
:\n\n                   DISFRIN=0                   DISFRIN<>0\n             Nonlinear      Linear       Nonlinear     Linear\nFRI\
NGE=0    entr & exit      none          none         none\nFRINGE=1       entr          entr          none         entr\nFRINGE=2 \
      exit          exit          none         exit\nFRINGE=3    entr & exit   entr & exit      none      entr & exit\n\n"],
 p$1772=1+p$1772[[1,2]];
p1$1772=StringPosition["The effects of the linear fringe (characterized by F1 and F2), and the nonlinear Mexwellian fringe are con\
troled as:\n\n                   DISFRIN=0                   DISFRIN<>0\n             Nonlinear      Linear       Nonlinear     Li\
near\nFRINGE=0    entr & exit      none          none         none\nFRINGE=1       entr          entr          none         entr\n\
FRINGE=2       exit          exit          none         exit\nFRINGE=3    entr & exit   entr & exit      none      entr & exit\n\n"
    [p$1772,-1],">::",1];
   p1$1772=If[p1$1772==={},487,-2+p$1772+p1$1772[[1,1]]];
neq=Which["The effects of the linear fringe (characterized by F1 and F2), and the nonlinear Mexwellian fringe are controled as:\n\\
n                   DISFRIN=0                   DISFRIN<>0\n             Nonlinear      Linear       Nonlinear     Linear\nFRINGE=\
0    entr & exit      none          none         none\nFRINGE=1       entr          entr          none         entr\nFRINGE=2     \
  exit          exit          none         exit\nFRINGE=3    entr & exit   entr & exit      none      entr & exit\n\n"[p$1772,
      4+p$1772]===
     "Text[",
lx$1772:=Help2HTML`oa$;p$1772=5+p$1772;p1$1772-=1;p2$1772=5+p1$1772;p0$1772=-9+p$1772;If[(pe$1772=StringPosition["The effects of t\
he linear fringe (characterized by F1 and F2), and the nonlinear Mexwellian fringe are controled as:\n\n                   DISFRIN\
=0                   DISFRIN<>0\n             Nonlinear      Linear       Nonlinear     Linear\nFRINGE=0    entr & exit      none \
         none         none\nFRINGE=1       entr          entr          none         entr\nFRINGE=2       exit          exit       \
   none         exit\nFRINGE=3    entr & exit   entr & exit      none      entr & exit\n\n"[p$1772,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["The effects of the linear fringe (characterized by F1 and F2), and the nonlinear Mexwellian fringe are controled \
as:\n\n                   DISFRIN=0                   DISFRIN<>0\n             Nonlinear      Linear       Nonlinear     Linear\nF\
RINGE=0    entr & exit      none          none         none\nFRINGE=1       entr          entr          none         entr\nFRINGE=\
2       exit          exit          none         exit\nFRINGE=3    entr & exit   entr & exit      none      entr & exit\n\n"[p$1772
            +pe$1772[[1,2]],
           p1$1772]]],
        p1$1772=-2+p$1772+pe$1772[[1,1]]}[[
       1]],
      0],
    1,lx$1772:=Help2HTML`o9$;p2$1772=4+p1$1772;p0$1772=-4+p$1772;0];
  If[(equ$1772=
Help2HTML`o8$["The effects of the linear fringe (characterized by F1 and F2), and the nonlinear Mexwellian fringe are controled as\
:\n\n                   DISFRIN=0                   DISFRIN<>0\n             Nonlinear      Linear       Nonlinear     Linear\nFRI\
NGE=0    entr & exit      none          none         none\nFRINGE=1       entr          entr          none         entr\nFRINGE=2 \
      exit          exit          none         exit\nFRINGE=3    entr & exit   entr & exit      none      entr & exit\n\n"[p$1772,
       p1$1772]])===
    Undefined,
equ$1772="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["The effects of the linear fringe (characteri\
zed by F1 and F2), and the nonlinear Mexwellian fringe are controled as:\n\n                   DISFRIN=0                   DISFRIN\
<>0\n             Nonlinear      Linear       Nonlinear     Linear\nFRINGE=0    entr & exit      none          none         none\n\
FRINGE=1       entr          entr          none         entr\nFRINGE=2       exit          exit          none         exit\nFRINGE\
=3    entr & exit   entr & exit      none      entr & exit\n\n"[p$1772,p1$1772]]=
       equ$1772;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1772},out$1772=lx$1772@Typeset["The effects of the linear fringe (characterized by F1 and F2), and the nonlinear Mexwelli\
an fringe are controled as:\n\n                   DISFRIN=0                   DISFRIN<>0\n             Nonlinear      Linear      \
 Nonlinear     Linear\nFRINGE=0    entr & exit      none          none         none\nFRINGE=1       entr          entr          no\
ne         entr\nFRINGE=2       exit          exit          none         exit\nFRINGE=3    entr & exit   entr & exit      none    \
  entr & exit\n\n"[p$1772,p1$1772],Format->Help2HTML`oB$];
        System["mv -f "//out$1772//" "//equ$1772]];
      Exit[]]];
   "The effects of the linear fringe (characterized by F1 and F2), and the nonlinear Mexwellian fringe are controled as:\n\n      \
             DISFRIN=0                   DISFRIN<>0\n             Nonlinear      Linear       Nonlinear     Linear\nFRINGE=0    en\
tr & exit      none          none         none\nFRINGE=1       entr          entr          none         entr\nFRINGE=2       exit \
         exit          none         exit\nFRINGE=3    entr & exit   entr & exit      none      entr & exit\n\n"[1,Max[p0$1772,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$1772//"\" />"//
Help2HTML`oy$["The effects of the linear fringe (characterized by F1 and F2), and the nonlinear Mexwellian fringe are controled as\
:\n\n                   DISFRIN=0                   DISFRIN<>0\n             Nonlinear      Linear       Nonlinear     Linear\nFRI\
NGE=0    entr & exit      none          none         none\nFRINGE=1       entr          entr          none         entr\nFRINGE=2 \
      exit          exit          none         exit\nFRINGE=3    entr & exit   entr & exit      none      entr & exit\n\n"[p2$1772,
     -1]]
]</PRE>
<PRE>See also:
 <A HREF=#L88>F1</A> <A HREF=#L194>F2</A> <A HREF=#L81>DISFRIN</A></PRE>
<LI>
<H3><A NAME=L199>
HARM</A></H3>
<PRE>If[{},Help2HTML`oA$[" A harmonic number. This is valid only when FREQ is zero."],
 p$1775=1+p$1775[[1,2]];p1$1775=StringPosition[" A harmonic number. This is valid only when FREQ is zero."[p$1775,-1],">::",1];
  p1$1775=If[p1$1775==={},57,-2+p$1775+p1$1775[[1,1]]];
  neq=Which[" A harmonic number. This is valid only when FREQ is zero."[p$1775,4+p$1775]==="Text[",
    lx$1775:=Help2HTML`oa$;p$1775=5+p$1775;p1$1775-=1;p2$1775=5+p1$1775;p0$1775=-9+p$1775;
     If[(pe$1775=StringPosition[" A harmonic number. This is valid only when FREQ is zero."[p$1775,-2],";;;"])<=>{},
      {Max[0,-1+ToExpression[" A harmonic number. This is valid only when FREQ is zero."[p$1775+pe$1775[[1,2]],p1$1775]]],
       p1$1775=-2+p$1775+pe$1775[[1,1]]}[[1]],
      0],
    1,lx$1775:=Help2HTML`o9$;p2$1775=4+p1$1775;p0$1775=-4+p$1775;0];
  If[(equ$1775=Help2HTML`o8$[" A harmonic number. This is valid only when FREQ is zero."[p$1775,p1$1775]])===Undefined,
   equ$1775="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$[" A harmonic number. This is valid only when FREQ is zero."[p$1775,p1$1775]]=equ$1775;LaTeX`ob$+=neq,
     --LaTeX`ob$;
      With[{lx$1775},out$1775=lx$1775@Typeset[" A harmonic number. This is valid only when FREQ is zero."[p$1775,p1$1775],
          Format->Help2HTML`oB$];
        System["mv -f "//out$1775//" "//equ$1775]];
      Exit[]]];
   " A harmonic number. This is valid only when FREQ is zero."[1,Max[p0$1775,0]]//"<img  class=\"eqs\" SRC=\""//equ$1775//"\" />"//
   Help2HTML`oy$[" A harmonic number. This is valid only when FREQ is zero."[p2$1775,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L103>FREQ</A></PRE>
<LI>
<H3><A NAME=L200>
L</A></H3>
<PRE>If[{},Help2HTML`oA$["The effective length."],
 p$1778=1+p$1778[[1,2]];p1$1778=StringPosition["The effective length."[p$1778,-1],">::",1];
  p1$1778=If[p1$1778==={},21,-2+p$1778+p1$1778[[1,1]]];
  neq=Which["The effective length."[p$1778,4+p$1778]==="Text[",lx$1778:=Help2HTML`oa$;p$1778=5+p$1778;p1$1778-=1;p2$1778=5+p1$1778;
     p0$1778=-9+p$1778;
     If[(pe$1778=StringPosition["The effective length."[p$1778,-2],";;;"])<=>{},{Max[0,-1+ToExpression["The effective length."[p
            $1778+pe$1778[[1,2]],
           p1$1778]]],
        p1$1778=-2+p$1778+pe$1778[[1,1]]}[[
       1]],
      0],
    1,lx$1778:=Help2HTML`o9$;p2$1778=4+p1$1778;p0$1778=-4+p$1778;0];
  If[(equ$1778=Help2HTML`o8$["The effective length."[p$1778,p1$1778]])===Undefined,
   equ$1778="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["The effective length."[p$1778,p1$1778]]=equ$1778;LaTeX`ob$+=neq,
     --LaTeX`ob$;With[{lx$1778},out$1778=lx$1778@Typeset["The effective length."[p$1778,p1$1778],Format->Help2HTML`oB$];
        System["mv -f "//out$1778//" "//equ$1778]];
      Exit[]]];
   "The effective length."[1,Max[p0$1778,0]]//"<img  class=\"eqs\" SRC=\""//equ$1778//"\" />"//
   Help2HTML`oy$["The effective length."[p2$1778,-1]]
]</PRE>
<LI>
<H3><A NAME=L201>
misalignments</A></H3>
<PRE>Misalignments of a MULT element are expressed by the keywords DX, DY, DZ, CHI1, CHI2, and ROTATE(=CHI3). They specify all misa
lignments of a rigid body,  At the entrance of MULT, the coordinates of a particle are transformed as

<img  class="eqs" SRC="SADHelp_img/equ_157.svg" />If[{},Help2HTML`oA$["\n\nwhere c1 and s1 are Cos[CHI1] and Sin[CHI1], etc. The in
verse is applied at the exit.\n   Those misalignments are also valid within a solenoid.\n   Other straight elements such as QUAD or
 THIN do not and will not have these full misalignment specifications, because they can be substituted by MULT.\n   The geometry of
 the design orbit is determined by the saved values of CHI1, CHI2, and DZ, while the current values are used for DX, DY, and ROTATE
."],p$1781=1+p$1781[[1,2]];p1$1781=StringPosition["\n\nwhere c1 and s1 are Cos[CHI1] and Sin[CHI1], etc. The inverse is applied at 
the exit.\n   Those misalignments are also valid within a solenoid.\n   Other straight elements such as QUAD or THIN do not and wil
l not have these full misalignment specifications, because they can be substituted by MULT.\n   The geometry of the design orbit is
 determined by the saved values of CHI1, CHI2, and DZ, while the current values are used for DX, DY, and ROTATE."[p$1781,-1],">::",
1];p1$1781=If[p1$1781==={},449,-2+p$1781+p1$1781[[1,1]]];neq=Which["\n\nwhere c1 and s1 are Cos[CHI1] and Sin[CHI1], etc. The inver
se is applied at the exit.\n   Those misalignments are also valid within a solenoid.\n   Other straight elements such as QUAD or TH
IN do not and will not have these full misalignment specifications, because they can be substituted by MULT.\n   The geometry of th
e design orbit is determined by the saved values of CHI1, CHI2, and DZ, while the current values are used for DX, DY, and ROTATE."[
p$1781,4+p$1781]==="Text[",lx$1781:=Help2HTML`oa$;p$1781=5+p$1781;p1$1781-=1;p2$1781=5+p1$1781;p0$1781=-9+p$1781;If[(pe$1781=String
Position["\n\nwhere c1 and s1 are Cos[CHI1] and Sin[CHI1], etc. The inverse is applied at the exit.\n   Those misalignments are als
o valid within a solenoid.\n   Other straight elements such as QUAD or THIN do not and will not have these full misalignment specif
ications, because they can be substituted by MULT.\n   The geometry of the design orbit is determined by the saved values of CHI1, 
CHI2, and DZ, while the current values are used for DX, DY, and ROTATE."[p$1781,-2],";;;"])<=>{},{Max[0,-1+ToExpression["\n\nwhere 
c1 and s1 are Cos[CHI1] and Sin[CHI1], etc. The inverse is applied at the exit.\n   Those misalignments are also valid within a sol
enoid.\n   Other straight elements such as QUAD or THIN do not and will not have these full misalignment specifications, because th
ey can be substituted by MULT.\n   The geometry of the design orbit is determined by the saved values of CHI1, CHI2, and DZ, while 
the current values are used for DX, DY, and ROTATE."[p$1781+pe$1781[[1,2]],p1$1781]]],p1$1781=-2+p$1781+pe$1781[[1,1]]}[[1]],0],1,l
x$1781:=Help2HTML`o9$;p2$1781=4+p1$1781;p0$1781=-4+p$1781;0];If[(equ$1781=Help2HTML`o8$["\n\nwhere c1 and s1 are Cos[CHI1] and Sin[
CHI1], etc. The inverse is applied at the exit.\n   Those misalignments are also valid within a solenoid.\n   Other straight elemen
ts such as QUAD or THIN do not and will not have these full misalignment specifications, because they can be substituted by MULT.\n
   The geometry of the design orbit is determined by the saved values of CHI1, CHI2, and DZ, while the current values are used for 
DX, DY, and ROTATE."[p$1781,p1$1781]])===Undefined,equ$1781="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML
`o8$["\n\nwhere c1 and s1 are Cos[CHI1] and Sin[CHI1], etc. The inverse is applied at the exit.\n   Those misalignments are also va
lid within a solenoid.\n   Other straight elements such as QUAD or THIN do not and will not have these full misalignment specificat
ions, because they can be substituted by MULT.\n   The geometry of the design orbit is determined by the saved values of CHI1, CHI2
, and DZ, while the current values are used for DX, DY, and ROTATE."[p$1781,p1$1781]]=equ$1781;LaTeX`ob$+=neq,--LaTeX`ob$;With[{lx$
1781},out$1781=lx$1781@Typeset["\n\nwhere c1 and s1 are Cos[CHI1] and Sin[CHI1], etc. The inverse is applied at the exit.\n   Those
 misalignments are also valid within a solenoid.\n   Other straight elements such as QUAD or THIN do not and will not have these fu
ll misalignment specifications, because they can be substituted by MULT.\n   The geometry of the design orbit is determined by the 
saved values of CHI1, CHI2, and DZ, while the current values are used for DX, DY, and ROTATE."[p$1781,p1$1781],Format->Help2HTML`oB
$];System["mv -f "//out$1781//" "//equ$1781]];Exit[]]];"\n\nwhere c1 and s1 are Cos[CHI1] and Sin[CHI1], etc. The inverse is applie
d at the exit.\n   Those misalignments are also valid within a solenoid.\n   Other straight elements such as QUAD or THIN do not an
d will not have these full misalignment specifications, because they can be substituted by MULT.\n   The geometry of the design orb
it is determined by the saved values of CHI1, CHI2, and DZ, while the current values are used for DX, DY, and ROTATE."[1,Max[p0$178
1,0]]//"<img  class=\"eqs\" SRC=\""//equ$1781//"\" />"//Help2HTML`oy$["\n\nwhere c1 and s1 are Cos[CHI1] and Sin[CHI1], etc. The in
verse is applied at the exit.\n   Those misalignments are also valid within a solenoid.\n   Other straight elements such as QUAD or
 THIN do not and will not have these full misalignment specifications, because they can be substituted by MULT.\n   The geometry of
 the design orbit is determined by the saved values of CHI1, CHI2, and DZ, while the current values are used for DX, DY, and ROTATE
."[p2$1781,-1]]]
</PRE>
<LI>
<H3><A NAME=L202>
multipole_with_nonzero_ANGLE</A></H3>
<PRE>The multipoles in MULT with nonzero ANGLE are defined by

<img  class="eqs" SRC="SADHelp_img/equ_158.svg" />If[{},Help2HTML`oA$["\nActually the summation is truncated at n + k <= 21 in the 
current version. While this definition converges to the regular one for multipoles when ANGLE -> 0, K0 and K1 of MULT are different
 from those of BEND."],p$1784=1+p$1784[[1,2]];p1$1784=StringPosition["\nActually the summation is truncated at n + k <= 21 in the c
urrent version. While this definition converges to the regular one for multipoles when ANGLE -> 0, K0 and K1 of MULT are different 
from those of BEND."[p$1784,-1],">::",1];p1$1784=If[p1$1784==={},210,-2+p$1784+p1$1784[[1,1]]];neq=Which["\nActually the summation 
is truncated at n + k <= 21 in the current version. While this definition converges to the regular one for multipoles when ANGLE ->
 0, K0 and K1 of MULT are different from those of BEND."[p$1784,4+p$1784]==="Text[",lx$1784:=Help2HTML`oa$;p$1784=5+p$1784;p1$1784-
=1;p2$1784=5+p1$1784;p0$1784=-9+p$1784;If[(pe$1784=StringPosition["\nActually the summation is truncated at n + k <= 21 in the curr
ent version. While this definition converges to the regular one for multipoles when ANGLE -> 0, K0 and K1 of MULT are different fro
m those of BEND."[p$1784,-2],";;;"])<=>{},{Max[0,-1+ToExpression["\nActually the summation is truncated at n + k <= 21 in the curre
nt version. While this definition converges to the regular one for multipoles when ANGLE -> 0, K0 and K1 of MULT are different from
 those of BEND."[p$1784+pe$1784[[1,2]],p1$1784]]],p1$1784=-2+p$1784+pe$1784[[1,1]]}[[1]],0],1,lx$1784:=Help2HTML`o9$;p2$1784=4+p1$1
784;p0$1784=-4+p$1784;0];If[(equ$1784=Help2HTML`o8$["\nActually the summation is truncated at n + k <= 21 in the current version. W
hile this definition converges to the regular one for multipoles when ANGLE -> 0, K0 and K1 of MULT are different from those of BEN
D."[p$1784,p1$1784]])===Undefined,equ$1784="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["\nActually 
the summation is truncated at n + k <= 21 in the current version. While this definition converges to the regular one for multipoles
 when ANGLE -> 0, K0 and K1 of MULT are different from those of BEND."[p$1784,p1$1784]]=equ$1784;LaTeX`ob$+=neq,--LaTeX`ob$;With[{l
x$1784},out$1784=lx$1784@Typeset["\nActually the summation is truncated at n + k <= 21 in the current version. While this definitio
n converges to the regular one for multipoles when ANGLE -> 0, K0 and K1 of MULT are different from those of BEND."[p$1784,p1$1784]
,Format->Help2HTML`oB$];System["mv -f "//out$1784//" "//equ$1784]];Exit[]]];"\nActually the summation is truncated at n + k <= 21 i
n the current version. While this definition converges to the regular one for multipoles when ANGLE -> 0, K0 and K1 of MULT are dif
ferent from those of BEND."[1,Max[p0$1784,0]]//"<img  class=\"eqs\" SRC=\""//equ$1784//"\" />"//Help2HTML`oy$["\nActually the summa
tion is truncated at n + k <= 21 in the current version. While this definition converges to the regular one for multipoles when ANG
LE -> 0, K0 and K1 of MULT are different from those of BEND."[p2$1784,-1]]]
</PRE>
<PRE>See also:
 <A HREF=#L80>ANGLE</A></PRE>
<LI>
<H3><A NAME=L203>
PHI</A></H3>
<PRE>Relative phase offset. The stable synchrotron phase above the transition is near PHI = 0. 
The acceleration is given as 

<img  class="eqs" SRC="SADHelp_img/equ_100.svg" />If[{},Help2HTML`oA$["\n\nwhere ts is the equilibrium time determined by the valan
ce between the acceleration and the radiation loss around the ring."],p$1788=1+p$1788[[1,2]];p1$1788=StringPosition["\n\nwhere ts i
s the equilibrium time determined by the valance between the acceleration and the radiation loss around the ring."[p$1788,-1],">::"
,1];p1$1788=If[p1$1788==={},125,-2+p$1788+p1$1788[[1,1]]];neq=Which["\n\nwhere ts is the equilibrium time determined by the valance
 between the acceleration and the radiation loss around the ring."[p$1788,4+p$1788]==="Text[",lx$1788:=Help2HTML`oa$;p$1788=5+p$178
8;p1$1788-=1;p2$1788=5+p1$1788;p0$1788=-9+p$1788;If[(pe$1788=StringPosition["\n\nwhere ts is the equilibrium time determined by the
 valance between the acceleration and the radiation loss around the ring."[p$1788,-2],";;;"])<=>{},{Max[0,-1+ToExpression["\n\nwher
e ts is the equilibrium time determined by the valance between the acceleration and the radiation loss around the ring."[p$1788+pe$
1788[[1,2]],p1$1788]]],p1$1788=-2+p$1788+pe$1788[[1,1]]}[[1]],0],1,lx$1788:=Help2HTML`o9$;p2$1788=4+p1$1788;p0$1788=-4+p$1788;0];If
[(equ$1788=Help2HTML`o8$["\n\nwhere ts is the equilibrium time determined by the valance between the acceleration and the radiation
 loss around the ring."[p$1788,p1$1788]])===Undefined,equ$1788="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2H
TML`o8$["\n\nwhere ts is the equilibrium time determined by the valance between the acceleration and the radiation loss around the 
ring."[p$1788,p1$1788]]=equ$1788;LaTeX`ob$+=neq,--LaTeX`ob$;With[{lx$1788},out$1788=lx$1788@Typeset["\n\nwhere ts is the equilibriu
m time determined by the valance between the acceleration and the radiation loss around the ring."[p$1788,p1$1788],Format->Help2HTM
L`oB$];System["mv -f "//out$1788//" "//equ$1788]];Exit[]]];"\n\nwhere ts is the equilibrium time determined by the valance between 
the acceleration and the radiation loss around the ring."[1,Max[p0$1788,0]]//"<img  class=\"eqs\" SRC=\""//equ$1788//"\" />"//Help2
HTML`oy$["\n\nwhere ts is the equilibrium time determined by the valance between the acceleration and the radiation loss around the
 ring."[p2$1788,-1]]]
</PRE>
<LI>
<H3><A NAME=L204>
RADIUS</A></H3>
<PRE>If[{},Help2HTML`oA$["Radius of the vacuum chamber. Effective when SPAC is ON."],
 p$1790=1+p$1790[[1,2]];p1$1790=StringPosition["Radius of the vacuum chamber. Effective when SPAC is ON."[p$1790,-1],">::",1];
  p1$1790=If[p1$1790==={},56,-2+p$1790+p1$1790[[1,1]]];
  neq=Which["Radius of the vacuum chamber. Effective when SPAC is ON."[p$1790,4+p$1790]==="Text[",
    lx$1790:=Help2HTML`oa$;p$1790=5+p$1790;p1$1790-=1;p2$1790=5+p1$1790;p0$1790=-9+p$1790;
     If[(pe$1790=StringPosition["Radius of the vacuum chamber. Effective when SPAC is ON."[p$1790,-2],";;;"])<=>{},
      {Max[0,-1+ToExpression["Radius of the vacuum chamber. Effective when SPAC is ON."[p$1790+pe$1790[[1,2]],p1$1790]]],
       p1$1790=-2+p$1790+pe$1790[[1,1]]}[[1]],
      0],
    1,lx$1790:=Help2HTML`o9$;p2$1790=4+p1$1790;p0$1790=-4+p$1790;0];
  If[(equ$1790=Help2HTML`o8$["Radius of the vacuum chamber. Effective when SPAC is ON."[p$1790,p1$1790]])===Undefined,
   equ$1790="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["Radius of the vacuum chamber. Effective when SPAC is ON."[p$1790,p1$1790]]=equ$1790;LaTeX`ob$+=neq,
     --LaTeX`ob$;
      With[{lx$1790},out$1790=lx$1790@Typeset["Radius of the vacuum chamber. Effective when SPAC is ON."[p$1790,p1$1790],
          Format->Help2HTML`oB$];
        System["mv -f "//out$1790//" "//equ$1790]];
      Exit[]]];
   "Radius of the vacuum chamber. Effective when SPAC is ON."[1,Max[p0$1790,0]]//"<img  class=\"eqs\" SRC=\""//equ$1790//"\" />"//
   Help2HTML`oy$["Radius of the vacuum chamber. Effective when SPAC is ON."[p2$1790,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L348>SPAC</A></PRE>
<LI>
<H3><A NAME=L205>
VOLT</A></H3>
<PRE>Accelerating peak voltage in Volt.
<img  class="eqs" SRC="SADHelp_img/equ_100.svg" />If[{},Help2HTML`oA$["\n\nwhere ts is the equilibrium time determined by the valan
ce between the acceleration and the radiation loss around the ring."],p$1794=1+p$1794[[1,2]];p1$1794=StringPosition["\n\nwhere ts i
s the equilibrium time determined by the valance between the acceleration and the radiation loss around the ring."[p$1794,-1],">::"
,1];p1$1794=If[p1$1794==={},125,-2+p$1794+p1$1794[[1,1]]];neq=Which["\n\nwhere ts is the equilibrium time determined by the valance
 between the acceleration and the radiation loss around the ring."[p$1794,4+p$1794]==="Text[",lx$1794:=Help2HTML`oa$;p$1794=5+p$179
4;p1$1794-=1;p2$1794=5+p1$1794;p0$1794=-9+p$1794;If[(pe$1794=StringPosition["\n\nwhere ts is the equilibrium time determined by the
 valance between the acceleration and the radiation loss around the ring."[p$1794,-2],";;;"])<=>{},{Max[0,-1+ToExpression["\n\nwher
e ts is the equilibrium time determined by the valance between the acceleration and the radiation loss around the ring."[p$1794+pe$
1794[[1,2]],p1$1794]]],p1$1794=-2+p$1794+pe$1794[[1,1]]}[[1]],0],1,lx$1794:=Help2HTML`o9$;p2$1794=4+p1$1794;p0$1794=-4+p$1794;0];If
[(equ$1794=Help2HTML`o8$["\n\nwhere ts is the equilibrium time determined by the valance between the acceleration and the radiation
 loss around the ring."[p$1794,p1$1794]])===Undefined,equ$1794="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2H
TML`o8$["\n\nwhere ts is the equilibrium time determined by the valance between the acceleration and the radiation loss around the 
ring."[p$1794,p1$1794]]=equ$1794;LaTeX`ob$+=neq,--LaTeX`ob$;With[{lx$1794},out$1794=lx$1794@Typeset["\n\nwhere ts is the equilibriu
m time determined by the valance between the acceleration and the radiation loss around the ring."[p$1794,p1$1794],Format->Help2HTM
L`oB$];System["mv -f "//out$1794//" "//equ$1794]];Exit[]]];"\n\nwhere ts is the equilibrium time determined by the valance between 
the acceleration and the radiation loss around the ring."[1,Max[p0$1794,0]]//"<img  class=\"eqs\" SRC=\""//equ$1794//"\" />"//Help2
HTML`oy$["\n\nwhere ts is the equilibrium time determined by the valance between the acceleration and the radiation loss around the
 ring."[p2$1794,-1]]]
</PRE>
<PRE>See also:
 <A HREF=#L100>DVOLT</A></PRE>
</UL>
<LI>
<H3><A NAME=L206>
OCT</A></H3>
<PRE>If[{},Help2HTML`oA$["A octupole magnet."],
 p$1797=1+p$1797[[1,2]];p1$1797=StringPosition["A octupole magnet."[p$1797,-1],">::",1];
  p1$1797=If[p1$1797==={},18,-2+p$1797+p1$1797[[1,1]]];
  neq=Which["A octupole magnet."[p$1797,4+p$1797]==="Text[",lx$1797:=Help2HTML`oa$;p$1797=5+p$1797;p1$1797-=1;p2$1797=5+p1$1797;
     p0$1797=-9+p$1797;
     If[(pe$1797=StringPosition["A octupole magnet."[p$1797,-2],";;;"])<=>{},{Max[0,-1+ToExpression["A octupole magnet."[p$1797+
            pe$1797[[1,2]],
           p1$1797]]],
        p1$1797=-2+p$1797+pe$1797[[1,1]]}[[
       1]],
      0],
    1,lx$1797:=Help2HTML`o9$;p2$1797=4+p1$1797;p0$1797=-4+p$1797;0];
  If[(equ$1797=Help2HTML`o8$["A octupole magnet."[p$1797,p1$1797]])===Undefined,
   equ$1797="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["A octupole magnet."[p$1797,p1$1797]]=equ$1797;LaTeX`ob$+=neq,
     --LaTeX`ob$;With[{lx$1797},out$1797=lx$1797@Typeset["A octupole magnet."[p$1797,p1$1797],Format->Help2HTML`oB$];
        System["mv -f "//out$1797//" "//equ$1797]];
      Exit[]]];
   "A octupole magnet."[1,Max[p0$1797,0]]//"<img  class=\"eqs\" SRC=\""//equ$1797//"\" />"//
   Help2HTML`oy$["A octupole magnet."[p2$1797,-1]]
]</PRE>
<UL>
<LI>
<H3><A NAME=L207>
DISFRIN</A></H3>
<PRE>If[{},Help2HTML`oA$["If nonzero, the nonlinear Maxwellian fringe is suppressed."],
 p$1799=1+p$1799[[1,2]];p1$1799=StringPosition["If nonzero, the nonlinear Maxwellian fringe is suppressed."[p$1799,-1],">::",1];
  p1$1799=If[p1$1799==={},58,-2+p$1799+p1$1799[[1,1]]];
  neq=Which["If nonzero, the nonlinear Maxwellian fringe is suppressed."[p$1799,4+p$1799]==="Text[",
    lx$1799:=Help2HTML`oa$;p$1799=5+p$1799;p1$1799-=1;p2$1799=5+p1$1799;p0$1799=-9+p$1799;
     If[(pe$1799=StringPosition["If nonzero, the nonlinear Maxwellian fringe is suppressed."[p$1799,-2],";;;"])<=>{},
      {Max[0,-1+ToExpression["If nonzero, the nonlinear Maxwellian fringe is suppressed."[p$1799+pe$1799[[1,2]],p1$1799]]],
       p1$1799=-2+p$1799+pe$1799[[1,1]]}[[1]],
      0],
    1,lx$1799:=Help2HTML`o9$;p2$1799=4+p1$1799;p0$1799=-4+p$1799;0];
  If[(equ$1799=Help2HTML`o8$["If nonzero, the nonlinear Maxwellian fringe is suppressed."[p$1799,p1$1799]])===Undefined,
   equ$1799="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["If nonzero, the nonlinear Maxwellian fringe is suppressed."[p$1799,p1$1799]]=equ$1799;LaTeX`ob$+=neq,
     --LaTeX`ob$;
      With[{lx$1799},out$1799=lx$1799@Typeset["If nonzero, the nonlinear Maxwellian fringe is suppressed."[p$1799,p1$1799],
          Format->Help2HTML`oB$];
        System["mv -f "//out$1799//" "//equ$1799]];
      Exit[]]];
   "If nonzero, the nonlinear Maxwellian fringe is suppressed."[1,Max[p0$1799,0]]//"<img  class=\"eqs\" SRC=\""//equ$1799//
   "\" />"//Help2HTML`oy$["If nonzero, the nonlinear Maxwellian fringe is suppressed."[p2$1799,-1]]
]</PRE>
<LI>
<H3><A NAME=L208>
DISRAD</A></H3>
<PRE>If[{},Help2HTML`oA$["If nonzero, the synchrotron radiation in the particle-tracking is inhibited."],
 p$1801=1+p$1801[[1,2]];p1$1801=
   StringPosition["If nonzero, the synchrotron radiation in the particle-tracking is inhibited."[p$1801,-1],">::",1];
  p1$1801=If[p1$1801==={},76,-2+p$1801+p1$1801[[1,1]]];
  neq=Which["If nonzero, the synchrotron radiation in the particle-tracking is inhibited."[p$1801,4+p$1801]==="Text[",
    lx$1801:=Help2HTML`oa$;p$1801=5+p$1801;p1$1801-=1;p2$1801=5+p1$1801;p0$1801=-9+p$1801;
     If[(pe$1801=StringPosition["If nonzero, the synchrotron radiation in the particle-tracking is inhibited."[p$1801,-2],";;;"]
        )<=>
       {},
      {Max[0,
        -1+ToExpression["If nonzero, the synchrotron radiation in the particle-tracking is inhibited."[p$1801+pe$1801[[1,2]],p1
           $1801]]],
        p1$1801=-2+p$1801+pe$1801[[1,1]]}[[
       1]],
      0],
    1,lx$1801:=Help2HTML`o9$;p2$1801=4+p1$1801;p0$1801=-4+p$1801;0];
  If[(equ$1801=Help2HTML`o8$["If nonzero, the synchrotron radiation in the particle-tracking is inhibited."[p$1801,p1$1801]])===
    Undefined,
   equ$1801="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "If nonzero, the synchrotron radiation in the particle-tracking is inhibited."[p$1801,p1$1801]]=
       equ$1801;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$1801},out$1801=lx$1801@Typeset["If nonzero, the synchrotron radiation in the particle-tracking is inhibited."[p$1801
           ,p1$1801],Format->Help2HTML`oB$];
        System["mv -f "//out$1801//" "//equ$1801]];
      Exit[]]];
   "If nonzero, the synchrotron radiation in the particle-tracking is inhibited."[1,Max[p0$1801,0]]//"<img  class=\"eqs\" SRC=\""//
   equ$1801//"\" />"//Help2HTML`oy$["If nonzero, the synchrotron radiation in the particle-tracking is inhibited."[p2$1801,-1]]
 ]
</PRE>
<PRE>See also:
 <A HREF=#L337>RAD</A></PRE>
<LI>
<H3><A NAME=L209>
DX</A></H3>
<PRE>If[{},Help2HTML`oA$["Horizontal displacement of magnet. This applied before the rotation by ROTATE."],
 p$1804=1+p$1804[[1,2]];p1$1804=
   StringPosition["Horizontal displacement of magnet. This applied before the rotation by ROTATE."[p$1804,-1],">::",1];
  p1$1804=If[p1$1804==={},78,-2+p$1804+p1$1804[[1,1]]];
  neq=Which["Horizontal displacement of magnet. This applied before the rotation by ROTATE."[p$1804,4+p$1804]==="Text[",
    lx$1804:=Help2HTML`oa$;p$1804=5+p$1804;p1$1804-=1;p2$1804=5+p1$1804;p0$1804=-9+p$1804;
     If[(pe$1804=StringPosition["Horizontal displacement of magnet. This applied before the rotation by ROTATE."[p$1804,-2],";;;"]
        )<=>
       {},
      {Max[0,
        -1+ToExpression["Horizontal displacement of magnet. This applied before the rotation by ROTATE."[p$1804+pe$1804[[1,2]],
           p1$1804]]],
        p1$1804=-2+p$1804+pe$1804[[1,1]]}[[
       1]],
      0],
    1,lx$1804:=Help2HTML`o9$;p2$1804=4+p1$1804;p0$1804=-4+p$1804;0];
  If[(equ$1804=Help2HTML`o8$["Horizontal displacement of magnet. This applied before the rotation by ROTATE."[p$1804,p1$1804]])===
    Undefined,
   equ$1804="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "Horizontal displacement of magnet. This applied before the rotation by ROTATE."[p$1804,p1$1804]]=
       equ$1804;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$1804},out$1804=lx$1804@Typeset["Horizontal displacement of magnet. This applied before the rotation by ROTATE."[p
           $1804,p1$1804],Format->Help2HTML`oB$];
        System["mv -f "//out$1804//" "//equ$1804]];
      Exit[]]];
   "Horizontal displacement of magnet. This applied before the rotation by ROTATE."[1,Max[p0$1804,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$1804//"\" />"//
   Help2HTML`oy$["Horizontal displacement of magnet. This applied before the rotation by ROTATE."[p2$1804,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L85>DY</A> <A HREF=#L95>ROTATE</A> <A HREF=#L83>DROTATE</A></PRE>
<LI>
<H3><A NAME=L210>
DY</A></H3>
<PRE>If[{},Help2HTML`oA$["Vertical displacement of magnet. This applied before the rotation by ROTATE."],
 p$1807=1+p$1807[[1,2]];p1$1807=
   StringPosition["Vertical displacement of magnet. This applied before the rotation by ROTATE."[p$1807,-1],">::",1];
  p1$1807=If[p1$1807==={},76,-2+p$1807+p1$1807[[1,1]]];
  neq=Which["Vertical displacement of magnet. This applied before the rotation by ROTATE."[p$1807,4+p$1807]==="Text[",
    lx$1807:=Help2HTML`oa$;p$1807=5+p$1807;p1$1807-=1;p2$1807=5+p1$1807;p0$1807=-9+p$1807;
     If[(pe$1807=StringPosition["Vertical displacement of magnet. This applied before the rotation by ROTATE."[p$1807,-2],";;;"]
        )<=>
       {},
      {Max[0,
        -1+ToExpression["Vertical displacement of magnet. This applied before the rotation by ROTATE."[p$1807+pe$1807[[1,2]],p1
           $1807]]],
        p1$1807=-2+p$1807+pe$1807[[1,1]]}[[
       1]],
      0],
    1,lx$1807:=Help2HTML`o9$;p2$1807=4+p1$1807;p0$1807=-4+p$1807;0];
  If[(equ$1807=Help2HTML`o8$["Vertical displacement of magnet. This applied before the rotation by ROTATE."[p$1807,p1$1807]])===
    Undefined,
   equ$1807="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "Vertical displacement of magnet. This applied before the rotation by ROTATE."[p$1807,p1$1807]]=
       equ$1807;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$1807},out$1807=lx$1807@Typeset["Vertical displacement of magnet. This applied before the rotation by ROTATE."[p$1807
           ,p1$1807],Format->Help2HTML`oB$];
        System["mv -f "//out$1807//" "//equ$1807]];
      Exit[]]];
   "Vertical displacement of magnet. This applied before the rotation by ROTATE."[1,Max[p0$1807,0]]//"<img  class=\"eqs\" SRC=\""//
   equ$1807//"\" />"//Help2HTML`oy$["Vertical displacement of magnet. This applied before the rotation by ROTATE."[p2$1807,-1]]
 ]
</PRE>
<PRE>See also:
 <A HREF=#L84>DX</A> <A HREF=#L95>ROTATE</A> <A HREF=#L83>DROTATE</A></PRE>
<LI>
<H3><A NAME=L211>
K3</A></H3>
<PRE>The normal octupole magnetic field component (times the length L).

<img  class="eqs" SRC="SADHelp_img/equ_118.svg" />If[{},Help2HTML`oA$["\n\nwhere L is the effective length of the component. Positi
ve sign means horizontal focusing."],p$1811=1+p$1811[[1,2]];p1$1811=StringPosition["\n\nwhere L is the effective length of the comp
onent. Positive sign means horizontal focusing."[p$1811,-1],">::",1];p1$1811=If[p1$1811==={},92,-2+p$1811+p1$1811[[1,1]]];neq=Which
["\n\nwhere L is the effective length of the component. Positive sign means horizontal focusing."[p$1811,4+p$1811]==="Text[",lx$181
1:=Help2HTML`oa$;p$1811=5+p$1811;p1$1811-=1;p2$1811=5+p1$1811;p0$1811=-9+p$1811;If[(pe$1811=StringPosition["\n\nwhere L is the effe
ctive length of the component. Positive sign means horizontal focusing."[p$1811,-2],";;;"])<=>{},{Max[0,-1+ToExpression["\n\nwhere 
L is the effective length of the component. Positive sign means horizontal focusing."[p$1811+pe$1811[[1,2]],p1$1811]]],p1$1811=-2+p
$1811+pe$1811[[1,1]]}[[1]],0],1,lx$1811:=Help2HTML`o9$;p2$1811=4+p1$1811;p0$1811=-4+p$1811;0];If[(equ$1811=Help2HTML`o8$["\n\nwhere
 L is the effective length of the component. Positive sign means horizontal focusing."[p$1811,p1$1811]])===Undefined,equ$1811="SADH
elp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["\n\nwhere L is the effective length of the component. Posit
ive sign means horizontal focusing."[p$1811,p1$1811]]=equ$1811;LaTeX`ob$+=neq,--LaTeX`ob$;With[{lx$1811},out$1811=lx$1811@Typeset["
\n\nwhere L is the effective length of the component. Positive sign means horizontal focusing."[p$1811,p1$1811],Format->Help2HTML`o
B$];System["mv -f "//out$1811//" "//equ$1811]];Exit[]]];"\n\nwhere L is the effective length of the component. Positive sign means 
horizontal focusing."[1,Max[p0$1811,0]]//"<img  class=\"eqs\" SRC=\""//equ$1811//"\" />"//Help2HTML`oy$["\n\nwhere L is the effecti
ve length of the component. Positive sign means horizontal focusing."[p2$1811,-1]]]
</PRE>
<PRE>See also:
 <A HREF=#L94>L</A></PRE>
<LI>
<H3><A NAME=L212>
L</A></H3>
<PRE>If[{},Help2HTML`oA$["The effective length."],
 p$1814=1+p$1814[[1,2]];p1$1814=StringPosition["The effective length."[p$1814,-1],">::",1];
  p1$1814=If[p1$1814==={},21,-2+p$1814+p1$1814[[1,1]]];
  neq=Which["The effective length."[p$1814,4+p$1814]==="Text[",lx$1814:=Help2HTML`oa$;p$1814=5+p$1814;p1$1814-=1;p2$1814=5+p1$1814;
     p0$1814=-9+p$1814;
     If[(pe$1814=StringPosition["The effective length."[p$1814,-2],";;;"])<=>{},{Max[0,-1+ToExpression["The effective length."[p
            $1814+pe$1814[[1,2]],
           p1$1814]]],
        p1$1814=-2+p$1814+pe$1814[[1,1]]}[[
       1]],
      0],
    1,lx$1814:=Help2HTML`o9$;p2$1814=4+p1$1814;p0$1814=-4+p$1814;0];
  If[(equ$1814=Help2HTML`o8$["The effective length."[p$1814,p1$1814]])===Undefined,
   equ$1814="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["The effective length."[p$1814,p1$1814]]=equ$1814;LaTeX`ob$+=neq,
     --LaTeX`ob$;With[{lx$1814},out$1814=lx$1814@Typeset["The effective length."[p$1814,p1$1814],Format->Help2HTML`oB$];
        System["mv -f "//out$1814//" "//equ$1814]];
      Exit[]]];
   "The effective length."[1,Max[p0$1814,0]]//"<img  class=\"eqs\" SRC=\""//equ$1814//"\" />"//
   Help2HTML`oy$["The effective length."[p2$1814,-1]]
]</PRE>
<LI>
<H3><A NAME=L213>
ROTATE</A></H3>
<PRE>If[{},
Help2HTML`oA$["Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet around the local s-axis by -(amo\
unt given by ROTATE), then place the component. At the exit rotate back the magnet around the local s-axis at the exit, then take \
out displacement."],
p$1816=1+p$1816[[1,2]];p1$1816=StringPosition["Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet \
around the local s-axis by -(amount given by ROTATE), then place the component. At the exit rotate back the magnet around the loca\
l s-axis at the exit, then take out displacement."[p$1816,-1],">::",1];
   p1$1816=If[p1$1816==={},262,-2+p$1816+p1$1816[[1,1]]];
neq=Which["Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet around the local s-axis by -(amount \
given by ROTATE), then place the component. At the exit rotate back the magnet around the local s-axis at the exit, then take out \
displacement."[p$1816,4+p$1816]==="Text[",
    lx$1816:=Help2HTML`oa$;p$1816=5+p$1816;p1$1816-=1;p2$1816=5+p1$1816;p0$1816=-9+p$1816;If[(pe$1816=
StringPosition["Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet around the local s-axis by -(am\
ount given by ROTATE), then place the component. At the exit rotate back the magnet around the local s-axis at the exit, then take\
 out displacement."[p$1816,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet around the local s-axis by -(a\
mount given by ROTATE), then place the component. At the exit rotate back the magnet around the local s-axis at the exit, then tak\
e out displacement."[p$1816+pe$1816[[1,2]],p1$1816]]],
        p1$1816=-2+p$1816+pe$1816[[1,1]]}[[
       1]],
      0],
    1,lx$1816:=Help2HTML`o9$;p2$1816=4+p1$1816;p0$1816=-4+p$1816;0];
  If[(equ$1816=
Help2HTML`o8$["Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet around the local s-axis by -(amo\
unt given by ROTATE), then place the component. At the exit rotate back the magnet around the local s-axis at the exit, then take \
out displacement."[p$1816,p1$1816]])===
    Undefined,
equ$1816="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Rotation in x-y plane. After displacing the \
magnet by DX and DY, rotate the magnet around the local s-axis by -(amount given by ROTATE), then place the component. At the exit\
 rotate back the magnet around the local s-axis at the exit, then take out displacement."[p$1816,p1$1816]]=
       equ$1816;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1816},out$1816=lx$1816@Typeset["Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet around\
 the local s-axis by -(amount given by ROTATE), then place the component. At the exit rotate back the magnet around the local s-ax\
is at the exit, then take out displacement."[p$1816,p1$1816],Format->Help2HTML`oB$];
        System["mv -f "//out$1816//" "//equ$1816]];
      Exit[]]];
   "Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet around the local s-axis by -(amount given b\
y ROTATE), then place the component. At the exit rotate back the magnet around the local s-axis at the exit, then take out displac\
ement."[1,Max[p0$1816,0]]//"<img  class=\"eqs\" SRC=\""//equ$1816//"\" />"//
Help2HTML`oy$["Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet around the local s-axis by -(amo\
unt given by ROTATE), then place the component. At the exit rotate back the magnet around the local s-axis at the exit, then take \
out displacement."[p2$1816,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L84>DX</A> <A HREF=#L85>DY</A> <A HREF=#L83>DROTATE</A></PRE>
<LI>
<H3><A NAME=L214>
transformation:THIN</A></H3>
<PRE><img  class="eqs" SRC="SADHelp_img/equ_159.svg" />
</PRE>
</UL>
<LI>
<H3><A NAME=L215>
QUAD</A></H3>
<PRE>If[{},Help2HTML`oA$["A quadrupole magnet."],
 p$1821=1+p$1821[[1,2]];p1$1821=StringPosition["A quadrupole magnet."[p$1821,-1],">::",1];
  p1$1821=If[p1$1821==={},20,-2+p$1821+p1$1821[[1,1]]];
  neq=Which["A quadrupole magnet."[p$1821,4+p$1821]==="Text[",lx$1821:=Help2HTML`oa$;p$1821=5+p$1821;p1$1821-=1;p2$1821=5+p1$1821;
     p0$1821=-9+p$1821;
     If[(pe$1821=StringPosition["A quadrupole magnet."[p$1821,-2],";;;"])<=>{},{Max[0,-1+ToExpression["A quadrupole magnet."[p$1821
            +pe$1821[[1,2]],
           p1$1821]]],
        p1$1821=-2+p$1821+pe$1821[[1,1]]}[[
       1]],
      0],
    1,lx$1821:=Help2HTML`o9$;p2$1821=4+p1$1821;p0$1821=-4+p$1821;0];
  If[(equ$1821=Help2HTML`o8$["A quadrupole magnet."[p$1821,p1$1821]])===Undefined,
   equ$1821="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["A quadrupole magnet."[p$1821,p1$1821]]=equ$1821;LaTeX`ob$+=neq,
     --LaTeX`ob$;With[{lx$1821},out$1821=lx$1821@Typeset["A quadrupole magnet."[p$1821,p1$1821],Format->Help2HTML`oB$];
        System["mv -f "//out$1821//" "//equ$1821]];
      Exit[]]];
   "A quadrupole magnet."[1,Max[p0$1821,0]]//"<img  class=\"eqs\" SRC=\""//equ$1821//"\" />"//
   Help2HTML`oy$["A quadrupole magnet."[p2$1821,-1]]
]</PRE>
<UL>
<LI>
<H3><A NAME=L216>
DISFRIN</A></H3>
<PRE>If[{},
Help2HTML`oA$["If nonzero, the nonlinear maxwellian fringe is suppressed. The effects of DISFRIN and FRINGE are summarized as\n\n \
                  DISFRIN=0                   DISFRIN<>0\n             Nonlinear      Linear       Nonlinear     Linear\nFRINGE=0 \
   entr & exit      none          none         none\nFRINGE=1       entr          entr          none         entr\nFRINGE=2       \
exit          exit          none         exit\nFRINGE=3    entr & exit   entr & exit      none      entr & exit\n\n"],
 p$1823=1+p$1823[[1,2]];
p1$1823=StringPosition["If nonzero, the nonlinear maxwellian fringe is suppressed. The effects of DISFRIN and FRINGE are summarize\
d as\n\n                   DISFRIN=0                   DISFRIN<>0\n             Nonlinear      Linear       Nonlinear     Linear\n\
FRINGE=0    entr & exit      none          none         none\nFRINGE=1       entr          entr          none         entr\nFRINGE\
=2       exit          exit          none         exit\nFRINGE=3    entr & exit   entr & exit      none      entr & exit\n\n"[p
     $1823,-1],
    ">::",1];
   p1$1823=If[p1$1823==={},481,-2+p$1823+p1$1823[[1,1]]];
neq=Which["If nonzero, the nonlinear maxwellian fringe is suppressed. The effects of DISFRIN and FRINGE are summarized as\n\n     \
              DISFRIN=0                   DISFRIN<>0\n             Nonlinear      Linear       Nonlinear     Linear\nFRINGE=0    e\
ntr & exit      none          none         none\nFRINGE=1       entr          entr          none         entr\nFRINGE=2       exit\
          exit          none         exit\nFRINGE=3    entr & exit   entr & exit      none      entr & exit\n\n"[p$1823,4+p$1823
      ]===
     "Text[",
lx$1823:=Help2HTML`oa$;p$1823=5+p$1823;p1$1823-=1;p2$1823=5+p1$1823;p0$1823=-9+p$1823;If[(pe$1823=StringPosition["If nonzero, the \
nonlinear maxwellian fringe is suppressed. The effects of DISFRIN and FRINGE are summarized as\n\n                   DISFRIN=0    \
               DISFRIN<>0\n             Nonlinear      Linear       Nonlinear     Linear\nFRINGE=0    entr & exit      none       \
   none         none\nFRINGE=1       entr          entr          none         entr\nFRINGE=2       exit          exit          non\
e         exit\nFRINGE=3    entr & exit   entr & exit      none      entr & exit\n\n"[p$1823,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["If nonzero, the nonlinear maxwellian fringe is suppressed. The effects of DISFRIN and FRINGE are summarized as\n\\
n                   DISFRIN=0                   DISFRIN<>0\n             Nonlinear      Linear       Nonlinear     Linear\nFRINGE=\
0    entr & exit      none          none         none\nFRINGE=1       entr          entr          none         entr\nFRINGE=2     \
  exit          exit          none         exit\nFRINGE=3    entr & exit   entr & exit      none      entr & exit\n\n"[p$1823+
            pe$1823[[1,2]],
           p1$1823]]],
        p1$1823=-2+p$1823+pe$1823[[1,1]]}[[
       1]],
      0],
    1,lx$1823:=Help2HTML`o9$;p2$1823=4+p1$1823;p0$1823=-4+p$1823;0];
  If[(equ$1823=
Help2HTML`o8$["If nonzero, the nonlinear maxwellian fringe is suppressed. The effects of DISFRIN and FRINGE are summarized as\n\n \
                  DISFRIN=0                   DISFRIN<>0\n             Nonlinear      Linear       Nonlinear     Linear\nFRINGE=0 \
   entr & exit      none          none         none\nFRINGE=1       entr          entr          none         entr\nFRINGE=2       \
exit          exit          none         exit\nFRINGE=3    entr & exit   entr & exit      none      entr & exit\n\n"[p$1823,p1$1823
       ]])===
    Undefined,
equ$1823="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["If nonzero, the nonlinear maxwellian fringe \
is suppressed. The effects of DISFRIN and FRINGE are summarized as\n\n                   DISFRIN=0                   DISFRIN<>0\n \
            Nonlinear      Linear       Nonlinear     Linear\nFRINGE=0    entr & exit      none          none         none\nFRINGE\
=1       entr          entr          none         entr\nFRINGE=2       exit          exit          none         exit\nFRINGE=3    \
entr & exit   entr & exit      none      entr & exit\n\n"[p$1823,p1$1823]]=
       equ$1823;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1823},out$1823=lx$1823@Typeset["If nonzero, the nonlinear maxwellian fringe is suppressed. The effects of DISFRIN and FRI\
NGE are summarized as\n\n                   DISFRIN=0                   DISFRIN<>0\n             Nonlinear      Linear       Nonli\
near     Linear\nFRINGE=0    entr & exit      none          none         none\nFRINGE=1       entr          entr          none    \
     entr\nFRINGE=2       exit          exit          none         exit\nFRINGE=3    entr & exit   entr & exit      none      entr\
 & exit\n\n"[p$1823,p1$1823],Format->Help2HTML`oB$];
        System["mv -f "//out$1823//" "//equ$1823]];
      Exit[]]];
   "If nonzero, the nonlinear maxwellian fringe is suppressed. The effects of DISFRIN and FRINGE are summarized as\n\n            \
       DISFRIN=0                   DISFRIN<>0\n             Nonlinear      Linear       Nonlinear     Linear\nFRINGE=0    entr & e\
xit      none          none         none\nFRINGE=1       entr          entr          none         entr\nFRINGE=2       exit       \
   exit          none         exit\nFRINGE=3    entr & exit   entr & exit      none      entr & exit\n\n"[1,Max[p0$1823,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$1823//"\" />"//
Help2HTML`oy$["If nonzero, the nonlinear maxwellian fringe is suppressed. The effects of DISFRIN and FRINGE are summarized as\n\n \
                  DISFRIN=0                   DISFRIN<>0\n             Nonlinear      Linear       Nonlinear     Linear\nFRINGE=0 \
   entr & exit      none          none         none\nFRINGE=1       entr          entr          none         entr\nFRINGE=2       \
exit          exit          none         exit\nFRINGE=3    entr & exit   entr & exit      none      entr & exit\n\n"[p2$1823,-1]]
 ]
</PRE>
<PRE>See also:
 <A HREF=#L91>FRINGE</A></PRE>
<LI>
<H3><A NAME=L217>
DISRAD</A></H3>
<PRE>If[{},Help2HTML`oA$["If nonzero, the synchrotron radiation in the particle-tracking is inhibited."],
 p$1826=1+p$1826[[1,2]];p1$1826=
   StringPosition["If nonzero, the synchrotron radiation in the particle-tracking is inhibited."[p$1826,-1],">::",1];
  p1$1826=If[p1$1826==={},76,-2+p$1826+p1$1826[[1,1]]];
  neq=Which["If nonzero, the synchrotron radiation in the particle-tracking is inhibited."[p$1826,4+p$1826]==="Text[",
    lx$1826:=Help2HTML`oa$;p$1826=5+p$1826;p1$1826-=1;p2$1826=5+p1$1826;p0$1826=-9+p$1826;
     If[(pe$1826=StringPosition["If nonzero, the synchrotron radiation in the particle-tracking is inhibited."[p$1826,-2],";;;"]
        )<=>
       {},
      {Max[0,
        -1+ToExpression["If nonzero, the synchrotron radiation in the particle-tracking is inhibited."[p$1826+pe$1826[[1,2]],p1
           $1826]]],
        p1$1826=-2+p$1826+pe$1826[[1,1]]}[[
       1]],
      0],
    1,lx$1826:=Help2HTML`o9$;p2$1826=4+p1$1826;p0$1826=-4+p$1826;0];
  If[(equ$1826=Help2HTML`o8$["If nonzero, the synchrotron radiation in the particle-tracking is inhibited."[p$1826,p1$1826]])===
    Undefined,
   equ$1826="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "If nonzero, the synchrotron radiation in the particle-tracking is inhibited."[p$1826,p1$1826]]=
       equ$1826;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$1826},out$1826=lx$1826@Typeset["If nonzero, the synchrotron radiation in the particle-tracking is inhibited."[p$1826
           ,p1$1826],Format->Help2HTML`oB$];
        System["mv -f "//out$1826//" "//equ$1826]];
      Exit[]]];
   "If nonzero, the synchrotron radiation in the particle-tracking is inhibited."[1,Max[p0$1826,0]]//"<img  class=\"eqs\" SRC=\""//
   equ$1826//"\" />"//Help2HTML`oy$["If nonzero, the synchrotron radiation in the particle-tracking is inhibited."[p2$1826,-1]]
 ]
</PRE>
<PRE>See also:
 <A HREF=#L337>RAD</A></PRE>
<LI>
<H3><A NAME=L218>
DX</A></H3>
<PRE>If[{},Help2HTML`oA$["Horizontal displacement of magnet. This applied before the rotation by ROTATE."],
 p$1829=1+p$1829[[1,2]];p1$1829=
   StringPosition["Horizontal displacement of magnet. This applied before the rotation by ROTATE."[p$1829,-1],">::",1];
  p1$1829=If[p1$1829==={},78,-2+p$1829+p1$1829[[1,1]]];
  neq=Which["Horizontal displacement of magnet. This applied before the rotation by ROTATE."[p$1829,4+p$1829]==="Text[",
    lx$1829:=Help2HTML`oa$;p$1829=5+p$1829;p1$1829-=1;p2$1829=5+p1$1829;p0$1829=-9+p$1829;
     If[(pe$1829=StringPosition["Horizontal displacement of magnet. This applied before the rotation by ROTATE."[p$1829,-2],";;;"]
        )<=>
       {},
      {Max[0,
        -1+ToExpression["Horizontal displacement of magnet. This applied before the rotation by ROTATE."[p$1829+pe$1829[[1,2]],
           p1$1829]]],
        p1$1829=-2+p$1829+pe$1829[[1,1]]}[[
       1]],
      0],
    1,lx$1829:=Help2HTML`o9$;p2$1829=4+p1$1829;p0$1829=-4+p$1829;0];
  If[(equ$1829=Help2HTML`o8$["Horizontal displacement of magnet. This applied before the rotation by ROTATE."[p$1829,p1$1829]])===
    Undefined,
   equ$1829="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "Horizontal displacement of magnet. This applied before the rotation by ROTATE."[p$1829,p1$1829]]=
       equ$1829;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$1829},out$1829=lx$1829@Typeset["Horizontal displacement of magnet. This applied before the rotation by ROTATE."[p
           $1829,p1$1829],Format->Help2HTML`oB$];
        System["mv -f "//out$1829//" "//equ$1829]];
      Exit[]]];
   "Horizontal displacement of magnet. This applied before the rotation by ROTATE."[1,Max[p0$1829,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$1829//"\" />"//
   Help2HTML`oy$["Horizontal displacement of magnet. This applied before the rotation by ROTATE."[p2$1829,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L85>DY</A> <A HREF=#L95>ROTATE</A> <A HREF=#L83>DROTATE</A></PRE>
<LI>
<H3><A NAME=L219>
DY</A></H3>
<PRE>If[{},Help2HTML`oA$["Vertical displacement of magnet. This applied before the rotation by ROTATE."],
 p$1832=1+p$1832[[1,2]];p1$1832=
   StringPosition["Vertical displacement of magnet. This applied before the rotation by ROTATE."[p$1832,-1],">::",1];
  p1$1832=If[p1$1832==={},76,-2+p$1832+p1$1832[[1,1]]];
  neq=Which["Vertical displacement of magnet. This applied before the rotation by ROTATE."[p$1832,4+p$1832]==="Text[",
    lx$1832:=Help2HTML`oa$;p$1832=5+p$1832;p1$1832-=1;p2$1832=5+p1$1832;p0$1832=-9+p$1832;
     If[(pe$1832=StringPosition["Vertical displacement of magnet. This applied before the rotation by ROTATE."[p$1832,-2],";;;"]
        )<=>
       {},
      {Max[0,
        -1+ToExpression["Vertical displacement of magnet. This applied before the rotation by ROTATE."[p$1832+pe$1832[[1,2]],p1
           $1832]]],
        p1$1832=-2+p$1832+pe$1832[[1,1]]}[[
       1]],
      0],
    1,lx$1832:=Help2HTML`o9$;p2$1832=4+p1$1832;p0$1832=-4+p$1832;0];
  If[(equ$1832=Help2HTML`o8$["Vertical displacement of magnet. This applied before the rotation by ROTATE."[p$1832,p1$1832]])===
    Undefined,
   equ$1832="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "Vertical displacement of magnet. This applied before the rotation by ROTATE."[p$1832,p1$1832]]=
       equ$1832;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$1832},out$1832=lx$1832@Typeset["Vertical displacement of magnet. This applied before the rotation by ROTATE."[p$1832
           ,p1$1832],Format->Help2HTML`oB$];
        System["mv -f "//out$1832//" "//equ$1832]];
      Exit[]]];
   "Vertical displacement of magnet. This applied before the rotation by ROTATE."[1,Max[p0$1832,0]]//"<img  class=\"eqs\" SRC=\""//
   equ$1832//"\" />"//Help2HTML`oy$["Vertical displacement of magnet. This applied before the rotation by ROTATE."[p2$1832,-1]]
 ]
</PRE>
<PRE>See also:
 <A HREF=#L84>DX</A> <A HREF=#L95>ROTATE</A> <A HREF=#L83>DROTATE</A></PRE>
<LI>
<H3><A NAME=L220>
F1</A></H3>
<PRE><img  class="eqs" SRC="SADHelp_img/equ_154.svg" />If[{},Help2HTML`oA$["\n   The effects only in the first order of K1 is taken
 into account."],p$1836=1+p$1836[[1,2]];p1$1836=StringPosition["\n   The effects only in the first order of K1 is taken into accoun
t."[p$1836,-1],">::",1];p1$1836=If[p1$1836==={},68,-2+p$1836+p1$1836[[1,1]]];neq=Which["\n   The effects only in the first order of
 K1 is taken into account."[p$1836,4+p$1836]==="Text[",lx$1836:=Help2HTML`oa$;p$1836=5+p$1836;p1$1836-=1;p2$1836=5+p1$1836;p0$1836=
-9+p$1836;If[(pe$1836=StringPosition["\n   The effects only in the first order of K1 is taken into account."[p$1836,-2],";;;"])<=>{
},{Max[0,-1+ToExpression["\n   The effects only in the first order of K1 is taken into account."[p$1836+pe$1836[[1,2]],p1$1836]]],p
1$1836=-2+p$1836+pe$1836[[1,1]]}[[1]],0],1,lx$1836:=Help2HTML`o9$;p2$1836=4+p1$1836;p0$1836=-4+p$1836;0];If[(equ$1836=Help2HTML`o8$
["\n   The effects only in the first order of K1 is taken into account."[p$1836,p1$1836]])===Undefined,equ$1836="SADHelp_img/equ_"/
/++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["\n   The effects only in the first order of K1 is taken into account."[p$
1836,p1$1836]]=equ$1836;LaTeX`ob$+=neq,--LaTeX`ob$;With[{lx$1836},out$1836=lx$1836@Typeset["\n   The effects only in the first orde
r of K1 is taken into account."[p$1836,p1$1836],Format->Help2HTML`oB$];System["mv -f "//out$1836//" "//equ$1836]];Exit[]]];"\n   Th
e effects only in the first order of K1 is taken into account."[1,Max[p0$1836,0]]//"<img  class=\"eqs\" SRC=\""//equ$1836//"\" />"/
/Help2HTML`oy$["\n   The effects only in the first order of K1 is taken into account."[p2$1836,-1]]]
</PRE>
<PRE>See also:
 <A HREF=#L194>F2</A> <A HREF=#L91>FRINGE</A></PRE>
<LI>
<H3><A NAME=L221>
F2</A></H3>
<PRE><img  class="eqs" SRC="SADHelp_img/equ_154.svg" />If[{},Help2HTML`oA$["\n   The effects only in the first order of K1 is taken
 into account."],p$1840=1+p$1840[[1,2]];p1$1840=StringPosition["\n   The effects only in the first order of K1 is taken into accoun
t."[p$1840,-1],">::",1];p1$1840=If[p1$1840==={},68,-2+p$1840+p1$1840[[1,1]]];neq=Which["\n   The effects only in the first order of
 K1 is taken into account."[p$1840,4+p$1840]==="Text[",lx$1840:=Help2HTML`oa$;p$1840=5+p$1840;p1$1840-=1;p2$1840=5+p1$1840;p0$1840=
-9+p$1840;If[(pe$1840=StringPosition["\n   The effects only in the first order of K1 is taken into account."[p$1840,-2],";;;"])<=>{
},{Max[0,-1+ToExpression["\n   The effects only in the first order of K1 is taken into account."[p$1840+pe$1840[[1,2]],p1$1840]]],p
1$1840=-2+p$1840+pe$1840[[1,1]]}[[1]],0],1,lx$1840:=Help2HTML`o9$;p2$1840=4+p1$1840;p0$1840=-4+p$1840;0];If[(equ$1840=Help2HTML`o8$
["\n   The effects only in the first order of K1 is taken into account."[p$1840,p1$1840]])===Undefined,equ$1840="SADHelp_img/equ_"/
/++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["\n   The effects only in the first order of K1 is taken into account."[p$
1840,p1$1840]]=equ$1840;LaTeX`ob$+=neq,--LaTeX`ob$;With[{lx$1840},out$1840=lx$1840@Typeset["\n   The effects only in the first orde
r of K1 is taken into account."[p$1840,p1$1840],Format->Help2HTML`oB$];System["mv -f "//out$1840//" "//equ$1840]];Exit[]]];"\n   Th
e effects only in the first order of K1 is taken into account."[1,Max[p0$1840,0]]//"<img  class=\"eqs\" SRC=\""//equ$1840//"\" />"/
/Help2HTML`oy$["\n   The effects only in the first order of K1 is taken into account."[p2$1840,-1]]]
</PRE>
<PRE>See also:
 <A HREF=#L88>F1</A> <A HREF=#L91>FRINGE</A></PRE>
<LI>
<H3><A NAME=L222>
FRINGE</A></H3>
<PRE>If[{},
Help2HTML`oA$["The effects of the linear fringe (characterized by F1 and F2), and the nonlinear Mexwellian fringe are controled as\
:\n\n                   DISFRIN=0                   DISFRIN<>0\n             Nonlinear      Linear       Nonlinear     Linear\nFRI\
NGE=0    entr & exit      none          none         none\nFRINGE=1       entr          entr          none         entr\nFRINGE=2 \
      exit          exit          none         exit\nFRINGE=3    entr & exit   entr & exit      none      entr & exit\n\n"],
 p$1843=1+p$1843[[1,2]];
p1$1843=StringPosition["The effects of the linear fringe (characterized by F1 and F2), and the nonlinear Mexwellian fringe are con\
troled as:\n\n                   DISFRIN=0                   DISFRIN<>0\n             Nonlinear      Linear       Nonlinear     Li\
near\nFRINGE=0    entr & exit      none          none         none\nFRINGE=1       entr          entr          none         entr\n\
FRINGE=2       exit          exit          none         exit\nFRINGE=3    entr & exit   entr & exit      none      entr & exit\n\n"
    [p$1843,-1],">::",1];
   p1$1843=If[p1$1843==={},487,-2+p$1843+p1$1843[[1,1]]];
neq=Which["The effects of the linear fringe (characterized by F1 and F2), and the nonlinear Mexwellian fringe are controled as:\n\\
n                   DISFRIN=0                   DISFRIN<>0\n             Nonlinear      Linear       Nonlinear     Linear\nFRINGE=\
0    entr & exit      none          none         none\nFRINGE=1       entr          entr          none         entr\nFRINGE=2     \
  exit          exit          none         exit\nFRINGE=3    entr & exit   entr & exit      none      entr & exit\n\n"[p$1843,
      4+p$1843]===
     "Text[",
lx$1843:=Help2HTML`oa$;p$1843=5+p$1843;p1$1843-=1;p2$1843=5+p1$1843;p0$1843=-9+p$1843;If[(pe$1843=StringPosition["The effects of t\
he linear fringe (characterized by F1 and F2), and the nonlinear Mexwellian fringe are controled as:\n\n                   DISFRIN\
=0                   DISFRIN<>0\n             Nonlinear      Linear       Nonlinear     Linear\nFRINGE=0    entr & exit      none \
         none         none\nFRINGE=1       entr          entr          none         entr\nFRINGE=2       exit          exit       \
   none         exit\nFRINGE=3    entr & exit   entr & exit      none      entr & exit\n\n"[p$1843,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["The effects of the linear fringe (characterized by F1 and F2), and the nonlinear Mexwellian fringe are controled \
as:\n\n                   DISFRIN=0                   DISFRIN<>0\n             Nonlinear      Linear       Nonlinear     Linear\nF\
RINGE=0    entr & exit      none          none         none\nFRINGE=1       entr          entr          none         entr\nFRINGE=\
2       exit          exit          none         exit\nFRINGE=3    entr & exit   entr & exit      none      entr & exit\n\n"[p$1843
            +pe$1843[[1,2]],
           p1$1843]]],
        p1$1843=-2+p$1843+pe$1843[[1,1]]}[[
       1]],
      0],
    1,lx$1843:=Help2HTML`o9$;p2$1843=4+p1$1843;p0$1843=-4+p$1843;0];
  If[(equ$1843=
Help2HTML`o8$["The effects of the linear fringe (characterized by F1 and F2), and the nonlinear Mexwellian fringe are controled as\
:\n\n                   DISFRIN=0                   DISFRIN<>0\n             Nonlinear      Linear       Nonlinear     Linear\nFRI\
NGE=0    entr & exit      none          none         none\nFRINGE=1       entr          entr          none         entr\nFRINGE=2 \
      exit          exit          none         exit\nFRINGE=3    entr & exit   entr & exit      none      entr & exit\n\n"[p$1843,
       p1$1843]])===
    Undefined,
equ$1843="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["The effects of the linear fringe (characteri\
zed by F1 and F2), and the nonlinear Mexwellian fringe are controled as:\n\n                   DISFRIN=0                   DISFRIN\
<>0\n             Nonlinear      Linear       Nonlinear     Linear\nFRINGE=0    entr & exit      none          none         none\n\
FRINGE=1       entr          entr          none         entr\nFRINGE=2       exit          exit          none         exit\nFRINGE\
=3    entr & exit   entr & exit      none      entr & exit\n\n"[p$1843,p1$1843]]=
       equ$1843;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1843},out$1843=lx$1843@Typeset["The effects of the linear fringe (characterized by F1 and F2), and the nonlinear Mexwelli\
an fringe are controled as:\n\n                   DISFRIN=0                   DISFRIN<>0\n             Nonlinear      Linear      \
 Nonlinear     Linear\nFRINGE=0    entr & exit      none          none         none\nFRINGE=1       entr          entr          no\
ne         entr\nFRINGE=2       exit          exit          none         exit\nFRINGE=3    entr & exit   entr & exit      none    \
  entr & exit\n\n"[p$1843,p1$1843],Format->Help2HTML`oB$];
        System["mv -f "//out$1843//" "//equ$1843]];
      Exit[]]];
   "The effects of the linear fringe (characterized by F1 and F2), and the nonlinear Mexwellian fringe are controled as:\n\n      \
             DISFRIN=0                   DISFRIN<>0\n             Nonlinear      Linear       Nonlinear     Linear\nFRINGE=0    en\
tr & exit      none          none         none\nFRINGE=1       entr          entr          none         entr\nFRINGE=2       exit \
         exit          none         exit\nFRINGE=3    entr & exit   entr & exit      none      entr & exit\n\n"[1,Max[p0$1843,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$1843//"\" />"//
Help2HTML`oy$["The effects of the linear fringe (characterized by F1 and F2), and the nonlinear Mexwellian fringe are controled as\
:\n\n                   DISFRIN=0                   DISFRIN<>0\n             Nonlinear      Linear       Nonlinear     Linear\nFRI\
NGE=0    entr & exit      none          none         none\nFRINGE=1       entr          entr          none         entr\nFRINGE=2 \
      exit          exit          none         exit\nFRINGE=3    entr & exit   entr & exit      none      entr & exit\n\n"[p2$1843,
     -1]]
]</PRE>
<PRE>See also:
 <A HREF=#L88>F1</A> <A HREF=#L194>F2</A> <A HREF=#L81>DISFRIN</A></PRE>
<LI>
<H3><A NAME=L223>
K1</A></H3>
<PRE>The normal quadrupole magnetic field component (times the length L).

<img  class="eqs" SRC="SADHelp_img/equ_92.svg" />If[{},Help2HTML`oA$["\n\nwhere L is the effective length of the component. Positiv
e sign means horizontal focusing."],p$1847=1+p$1847[[1,2]];p1$1847=StringPosition["\n\nwhere L is the effective length of the compo
nent. Positive sign means horizontal focusing."[p$1847,-1],">::",1];p1$1847=If[p1$1847==={},92,-2+p$1847+p1$1847[[1,1]]];neq=Which[
"\n\nwhere L is the effective length of the component. Positive sign means horizontal focusing."[p$1847,4+p$1847]==="Text[",lx$1847
:=Help2HTML`oa$;p$1847=5+p$1847;p1$1847-=1;p2$1847=5+p1$1847;p0$1847=-9+p$1847;If[(pe$1847=StringPosition["\n\nwhere L is the effec
tive length of the component. Positive sign means horizontal focusing."[p$1847,-2],";;;"])<=>{},{Max[0,-1+ToExpression["\n\nwhere L
 is the effective length of the component. Positive sign means horizontal focusing."[p$1847+pe$1847[[1,2]],p1$1847]]],p1$1847=-2+p$
1847+pe$1847[[1,1]]}[[1]],0],1,lx$1847:=Help2HTML`o9$;p2$1847=4+p1$1847;p0$1847=-4+p$1847;0];If[(equ$1847=Help2HTML`o8$["\n\nwhere 
L is the effective length of the component. Positive sign means horizontal focusing."[p$1847,p1$1847]])===Undefined,equ$1847="SADHe
lp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["\n\nwhere L is the effective length of the component. Positi
ve sign means horizontal focusing."[p$1847,p1$1847]]=equ$1847;LaTeX`ob$+=neq,--LaTeX`ob$;With[{lx$1847},out$1847=lx$1847@Typeset["\
n\nwhere L is the effective length of the component. Positive sign means horizontal focusing."[p$1847,p1$1847],Format->Help2HTML`oB
$];System["mv -f "//out$1847//" "//equ$1847]];Exit[]]];"\n\nwhere L is the effective length of the component. Positive sign means h
orizontal focusing."[1,Max[p0$1847,0]]//"<img  class=\"eqs\" SRC=\""//equ$1847//"\" />"//Help2HTML`oy$["\n\nwhere L is the effectiv
e length of the component. Positive sign means horizontal focusing."[p2$1847,-1]]]
</PRE>
<PRE>See also:
 <A HREF=#L94>L</A></PRE>
<LI>
<H3><A NAME=L224>
L</A></H3>
<PRE>If[{},Help2HTML`oA$["The effective length."],
 p$1850=1+p$1850[[1,2]];p1$1850=StringPosition["The effective length."[p$1850,-1],">::",1];
  p1$1850=If[p1$1850==={},21,-2+p$1850+p1$1850[[1,1]]];
  neq=Which["The effective length."[p$1850,4+p$1850]==="Text[",lx$1850:=Help2HTML`oa$;p$1850=5+p$1850;p1$1850-=1;p2$1850=5+p1$1850;
     p0$1850=-9+p$1850;
     If[(pe$1850=StringPosition["The effective length."[p$1850,-2],";;;"])<=>{},{Max[0,-1+ToExpression["The effective length."[p
            $1850+pe$1850[[1,2]],
           p1$1850]]],
        p1$1850=-2+p$1850+pe$1850[[1,1]]}[[
       1]],
      0],
    1,lx$1850:=Help2HTML`o9$;p2$1850=4+p1$1850;p0$1850=-4+p$1850;0];
  If[(equ$1850=Help2HTML`o8$["The effective length."[p$1850,p1$1850]])===Undefined,
   equ$1850="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["The effective length."[p$1850,p1$1850]]=equ$1850;LaTeX`ob$+=neq,
     --LaTeX`ob$;With[{lx$1850},out$1850=lx$1850@Typeset["The effective length."[p$1850,p1$1850],Format->Help2HTML`oB$];
        System["mv -f "//out$1850//" "//equ$1850]];
      Exit[]]];
   "The effective length."[1,Max[p0$1850,0]]//"<img  class=\"eqs\" SRC=\""//equ$1850//"\" />"//
   Help2HTML`oy$["The effective length."[p2$1850,-1]]
]</PRE>
<LI>
<H3><A NAME=L225>
ROTATE</A></H3>
<PRE>If[{},
Help2HTML`oA$["Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet around the local s-axis by -(amo\
unt given by ROTATE), then place the component. At the exit rotate back the magnet around the local s-axis at the exit, then take \
out displacement."],
p$1852=1+p$1852[[1,2]];p1$1852=StringPosition["Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet \
around the local s-axis by -(amount given by ROTATE), then place the component. At the exit rotate back the magnet around the loca\
l s-axis at the exit, then take out displacement."[p$1852,-1],">::",1];
   p1$1852=If[p1$1852==={},262,-2+p$1852+p1$1852[[1,1]]];
neq=Which["Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet around the local s-axis by -(amount \
given by ROTATE), then place the component. At the exit rotate back the magnet around the local s-axis at the exit, then take out \
displacement."[p$1852,4+p$1852]==="Text[",
    lx$1852:=Help2HTML`oa$;p$1852=5+p$1852;p1$1852-=1;p2$1852=5+p1$1852;p0$1852=-9+p$1852;If[(pe$1852=
StringPosition["Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet around the local s-axis by -(am\
ount given by ROTATE), then place the component. At the exit rotate back the magnet around the local s-axis at the exit, then take\
 out displacement."[p$1852,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet around the local s-axis by -(a\
mount given by ROTATE), then place the component. At the exit rotate back the magnet around the local s-axis at the exit, then tak\
e out displacement."[p$1852+pe$1852[[1,2]],p1$1852]]],
        p1$1852=-2+p$1852+pe$1852[[1,1]]}[[
       1]],
      0],
    1,lx$1852:=Help2HTML`o9$;p2$1852=4+p1$1852;p0$1852=-4+p$1852;0];
  If[(equ$1852=
Help2HTML`o8$["Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet around the local s-axis by -(amo\
unt given by ROTATE), then place the component. At the exit rotate back the magnet around the local s-axis at the exit, then take \
out displacement."[p$1852,p1$1852]])===
    Undefined,
equ$1852="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Rotation in x-y plane. After displacing the \
magnet by DX and DY, rotate the magnet around the local s-axis by -(amount given by ROTATE), then place the component. At the exit\
 rotate back the magnet around the local s-axis at the exit, then take out displacement."[p$1852,p1$1852]]=
       equ$1852;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1852},out$1852=lx$1852@Typeset["Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet around\
 the local s-axis by -(amount given by ROTATE), then place the component. At the exit rotate back the magnet around the local s-ax\
is at the exit, then take out displacement."[p$1852,p1$1852],Format->Help2HTML`oB$];
        System["mv -f "//out$1852//" "//equ$1852]];
      Exit[]]];
   "Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet around the local s-axis by -(amount given b\
y ROTATE), then place the component. At the exit rotate back the magnet around the local s-axis at the exit, then take out displac\
ement."[1,Max[p0$1852,0]]//"<img  class=\"eqs\" SRC=\""//equ$1852//"\" />"//
Help2HTML`oy$["Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet around the local s-axis by -(amo\
unt given by ROTATE), then place the component. At the exit rotate back the magnet around the local s-axis at the exit, then take \
out displacement."[p2$1852,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L84>DX</A> <A HREF=#L85>DY</A> <A HREF=#L83>DROTATE</A></PRE>
<LI>
<H3><A NAME=L226>
transformation:QUAD</A></H3>
<PRE>The transformation in a QUAD is a sequence of:

   (nonlinear fringe at entrance)
<img  class="eqs" SRC="SADHelp_img/equ_162.svg" />
   (linear fringe at entrance)
<img  class="eqs" SRC="SADHelp_img/equ_168.svg" />
   (body of quad)
<img  class="eqs" SRC="SADHelp_img/equ_175.svg" />
   (linear fringe at exit)

<img  class="eqs" SRC="SADHelp_img/equ_178.svg" />
   (nonlinear fringe at exit)
<img  class="eqs" SRC="SADHelp_img/equ_185.svg" />
</PRE>
<PRE>See also:
 <A HREF=#L46>Hamiltonian</A> <A HREF=#L47>2nd-order-Hamiltonian</A> <A HREF=#L48>solution-H2</A> <A HREF=#L49>solution-dH</A></PRE>
</UL>
<LI>
<H3><A NAME=L227>
SEXT</A></H3>
<PRE>If[{},Help2HTML`oA$["A sextupole magnet."],
 p$1862=1+p$1862[[1,2]];p1$1862=StringPosition["A sextupole magnet."[p$1862,-1],">::",1];
  p1$1862=If[p1$1862==={},19,-2+p$1862+p1$1862[[1,1]]];
  neq=Which["A sextupole magnet."[p$1862,4+p$1862]==="Text[",lx$1862:=Help2HTML`oa$;p$1862=5+p$1862;p1$1862-=1;p2$1862=5+p1$1862;
     p0$1862=-9+p$1862;
     If[(pe$1862=StringPosition["A sextupole magnet."[p$1862,-2],";;;"])<=>{},{Max[0,-1+ToExpression["A sextupole magnet."[p$1862+
            pe$1862[[1,2]],
           p1$1862]]],
        p1$1862=-2+p$1862+pe$1862[[1,1]]}[[
       1]],
      0],
    1,lx$1862:=Help2HTML`o9$;p2$1862=4+p1$1862;p0$1862=-4+p$1862;0];
  If[(equ$1862=Help2HTML`o8$["A sextupole magnet."[p$1862,p1$1862]])===Undefined,
   equ$1862="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["A sextupole magnet."[p$1862,p1$1862]]=equ$1862;LaTeX`ob$+=neq,
     --LaTeX`ob$;With[{lx$1862},out$1862=lx$1862@Typeset["A sextupole magnet."[p$1862,p1$1862],Format->Help2HTML`oB$];
        System["mv -f "//out$1862//" "//equ$1862]];
      Exit[]]];
   "A sextupole magnet."[1,Max[p0$1862,0]]//"<img  class=\"eqs\" SRC=\""//equ$1862//"\" />"//
   Help2HTML`oy$["A sextupole magnet."[p2$1862,-1]]
]</PRE>
<UL>
<LI>
<H3><A NAME=L228>
DISFRIN</A></H3>
<PRE>If[{},Help2HTML`oA$["If nonzero, the nonlinear Maxwellian fringe is suppressed."],
 p$1864=1+p$1864[[1,2]];p1$1864=StringPosition["If nonzero, the nonlinear Maxwellian fringe is suppressed."[p$1864,-1],">::",1];
  p1$1864=If[p1$1864==={},58,-2+p$1864+p1$1864[[1,1]]];
  neq=Which["If nonzero, the nonlinear Maxwellian fringe is suppressed."[p$1864,4+p$1864]==="Text[",
    lx$1864:=Help2HTML`oa$;p$1864=5+p$1864;p1$1864-=1;p2$1864=5+p1$1864;p0$1864=-9+p$1864;
     If[(pe$1864=StringPosition["If nonzero, the nonlinear Maxwellian fringe is suppressed."[p$1864,-2],";;;"])<=>{},
      {Max[0,-1+ToExpression["If nonzero, the nonlinear Maxwellian fringe is suppressed."[p$1864+pe$1864[[1,2]],p1$1864]]],
       p1$1864=-2+p$1864+pe$1864[[1,1]]}[[1]],
      0],
    1,lx$1864:=Help2HTML`o9$;p2$1864=4+p1$1864;p0$1864=-4+p$1864;0];
  If[(equ$1864=Help2HTML`o8$["If nonzero, the nonlinear Maxwellian fringe is suppressed."[p$1864,p1$1864]])===Undefined,
   equ$1864="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["If nonzero, the nonlinear Maxwellian fringe is suppressed."[p$1864,p1$1864]]=equ$1864;LaTeX`ob$+=neq,
     --LaTeX`ob$;
      With[{lx$1864},out$1864=lx$1864@Typeset["If nonzero, the nonlinear Maxwellian fringe is suppressed."[p$1864,p1$1864],
          Format->Help2HTML`oB$];
        System["mv -f "//out$1864//" "//equ$1864]];
      Exit[]]];
   "If nonzero, the nonlinear Maxwellian fringe is suppressed."[1,Max[p0$1864,0]]//"<img  class=\"eqs\" SRC=\""//equ$1864//
   "\" />"//Help2HTML`oy$["If nonzero, the nonlinear Maxwellian fringe is suppressed."[p2$1864,-1]]
]</PRE>
<LI>
<H3><A NAME=L229>
DISRAD</A></H3>
<PRE>If[{},Help2HTML`oA$["If nonzero, the synchrotron radiation in the particle-tracking is inhibited."],
 p$1866=1+p$1866[[1,2]];p1$1866=
   StringPosition["If nonzero, the synchrotron radiation in the particle-tracking is inhibited."[p$1866,-1],">::",1];
  p1$1866=If[p1$1866==={},76,-2+p$1866+p1$1866[[1,1]]];
  neq=Which["If nonzero, the synchrotron radiation in the particle-tracking is inhibited."[p$1866,4+p$1866]==="Text[",
    lx$1866:=Help2HTML`oa$;p$1866=5+p$1866;p1$1866-=1;p2$1866=5+p1$1866;p0$1866=-9+p$1866;
     If[(pe$1866=StringPosition["If nonzero, the synchrotron radiation in the particle-tracking is inhibited."[p$1866,-2],";;;"]
        )<=>
       {},
      {Max[0,
        -1+ToExpression["If nonzero, the synchrotron radiation in the particle-tracking is inhibited."[p$1866+pe$1866[[1,2]],p1
           $1866]]],
        p1$1866=-2+p$1866+pe$1866[[1,1]]}[[
       1]],
      0],
    1,lx$1866:=Help2HTML`o9$;p2$1866=4+p1$1866;p0$1866=-4+p$1866;0];
  If[(equ$1866=Help2HTML`o8$["If nonzero, the synchrotron radiation in the particle-tracking is inhibited."[p$1866,p1$1866]])===
    Undefined,
   equ$1866="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "If nonzero, the synchrotron radiation in the particle-tracking is inhibited."[p$1866,p1$1866]]=
       equ$1866;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$1866},out$1866=lx$1866@Typeset["If nonzero, the synchrotron radiation in the particle-tracking is inhibited."[p$1866
           ,p1$1866],Format->Help2HTML`oB$];
        System["mv -f "//out$1866//" "//equ$1866]];
      Exit[]]];
   "If nonzero, the synchrotron radiation in the particle-tracking is inhibited."[1,Max[p0$1866,0]]//"<img  class=\"eqs\" SRC=\""//
   equ$1866//"\" />"//Help2HTML`oy$["If nonzero, the synchrotron radiation in the particle-tracking is inhibited."[p2$1866,-1]]
 ]
</PRE>
<PRE>See also:
 <A HREF=#L337>RAD</A></PRE>
<LI>
<H3><A NAME=L230>
DX</A></H3>
<PRE>If[{},Help2HTML`oA$["Horizontal displacement of magnet. This applied before the rotation by ROTATE."],
 p$1869=1+p$1869[[1,2]];p1$1869=
   StringPosition["Horizontal displacement of magnet. This applied before the rotation by ROTATE."[p$1869,-1],">::",1];
  p1$1869=If[p1$1869==={},78,-2+p$1869+p1$1869[[1,1]]];
  neq=Which["Horizontal displacement of magnet. This applied before the rotation by ROTATE."[p$1869,4+p$1869]==="Text[",
    lx$1869:=Help2HTML`oa$;p$1869=5+p$1869;p1$1869-=1;p2$1869=5+p1$1869;p0$1869=-9+p$1869;
     If[(pe$1869=StringPosition["Horizontal displacement of magnet. This applied before the rotation by ROTATE."[p$1869,-2],";;;"]
        )<=>
       {},
      {Max[0,
        -1+ToExpression["Horizontal displacement of magnet. This applied before the rotation by ROTATE."[p$1869+pe$1869[[1,2]],
           p1$1869]]],
        p1$1869=-2+p$1869+pe$1869[[1,1]]}[[
       1]],
      0],
    1,lx$1869:=Help2HTML`o9$;p2$1869=4+p1$1869;p0$1869=-4+p$1869;0];
  If[(equ$1869=Help2HTML`o8$["Horizontal displacement of magnet. This applied before the rotation by ROTATE."[p$1869,p1$1869]])===
    Undefined,
   equ$1869="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "Horizontal displacement of magnet. This applied before the rotation by ROTATE."[p$1869,p1$1869]]=
       equ$1869;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$1869},out$1869=lx$1869@Typeset["Horizontal displacement of magnet. This applied before the rotation by ROTATE."[p
           $1869,p1$1869],Format->Help2HTML`oB$];
        System["mv -f "//out$1869//" "//equ$1869]];
      Exit[]]];
   "Horizontal displacement of magnet. This applied before the rotation by ROTATE."[1,Max[p0$1869,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$1869//"\" />"//
   Help2HTML`oy$["Horizontal displacement of magnet. This applied before the rotation by ROTATE."[p2$1869,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L85>DY</A> <A HREF=#L95>ROTATE</A> <A HREF=#L83>DROTATE</A></PRE>
<LI>
<H3><A NAME=L231>
DY</A></H3>
<PRE>If[{},Help2HTML`oA$["Vertical displacement of magnet. This applied before the rotation by ROTATE."],
 p$1872=1+p$1872[[1,2]];p1$1872=
   StringPosition["Vertical displacement of magnet. This applied before the rotation by ROTATE."[p$1872,-1],">::",1];
  p1$1872=If[p1$1872==={},76,-2+p$1872+p1$1872[[1,1]]];
  neq=Which["Vertical displacement of magnet. This applied before the rotation by ROTATE."[p$1872,4+p$1872]==="Text[",
    lx$1872:=Help2HTML`oa$;p$1872=5+p$1872;p1$1872-=1;p2$1872=5+p1$1872;p0$1872=-9+p$1872;
     If[(pe$1872=StringPosition["Vertical displacement of magnet. This applied before the rotation by ROTATE."[p$1872,-2],";;;"]
        )<=>
       {},
      {Max[0,
        -1+ToExpression["Vertical displacement of magnet. This applied before the rotation by ROTATE."[p$1872+pe$1872[[1,2]],p1
           $1872]]],
        p1$1872=-2+p$1872+pe$1872[[1,1]]}[[
       1]],
      0],
    1,lx$1872:=Help2HTML`o9$;p2$1872=4+p1$1872;p0$1872=-4+p$1872;0];
  If[(equ$1872=Help2HTML`o8$["Vertical displacement of magnet. This applied before the rotation by ROTATE."[p$1872,p1$1872]])===
    Undefined,
   equ$1872="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "Vertical displacement of magnet. This applied before the rotation by ROTATE."[p$1872,p1$1872]]=
       equ$1872;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$1872},out$1872=lx$1872@Typeset["Vertical displacement of magnet. This applied before the rotation by ROTATE."[p$1872
           ,p1$1872],Format->Help2HTML`oB$];
        System["mv -f "//out$1872//" "//equ$1872]];
      Exit[]]];
   "Vertical displacement of magnet. This applied before the rotation by ROTATE."[1,Max[p0$1872,0]]//"<img  class=\"eqs\" SRC=\""//
   equ$1872//"\" />"//Help2HTML`oy$["Vertical displacement of magnet. This applied before the rotation by ROTATE."[p2$1872,-1]]
 ]
</PRE>
<PRE>See also:
 <A HREF=#L84>DX</A> <A HREF=#L95>ROTATE</A> <A HREF=#L83>DROTATE</A></PRE>
<LI>
<H3><A NAME=L232>
K2</A></H3>
<PRE>The normal sextupole magnetic field component (times the length L).

<img  class="eqs" SRC="SADHelp_img/equ_116.svg" />If[{},Help2HTML`oA$["\n\nwhere L is the effective length of the component. Positi
ve sign means horizontal focusing."],p$1876=1+p$1876[[1,2]];p1$1876=StringPosition["\n\nwhere L is the effective length of the comp
onent. Positive sign means horizontal focusing."[p$1876,-1],">::",1];p1$1876=If[p1$1876==={},92,-2+p$1876+p1$1876[[1,1]]];neq=Which
["\n\nwhere L is the effective length of the component. Positive sign means horizontal focusing."[p$1876,4+p$1876]==="Text[",lx$187
6:=Help2HTML`oa$;p$1876=5+p$1876;p1$1876-=1;p2$1876=5+p1$1876;p0$1876=-9+p$1876;If[(pe$1876=StringPosition["\n\nwhere L is the effe
ctive length of the component. Positive sign means horizontal focusing."[p$1876,-2],";;;"])<=>{},{Max[0,-1+ToExpression["\n\nwhere 
L is the effective length of the component. Positive sign means horizontal focusing."[p$1876+pe$1876[[1,2]],p1$1876]]],p1$1876=-2+p
$1876+pe$1876[[1,1]]}[[1]],0],1,lx$1876:=Help2HTML`o9$;p2$1876=4+p1$1876;p0$1876=-4+p$1876;0];If[(equ$1876=Help2HTML`o8$["\n\nwhere
 L is the effective length of the component. Positive sign means horizontal focusing."[p$1876,p1$1876]])===Undefined,equ$1876="SADH
elp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["\n\nwhere L is the effective length of the component. Posit
ive sign means horizontal focusing."[p$1876,p1$1876]]=equ$1876;LaTeX`ob$+=neq,--LaTeX`ob$;With[{lx$1876},out$1876=lx$1876@Typeset["
\n\nwhere L is the effective length of the component. Positive sign means horizontal focusing."[p$1876,p1$1876],Format->Help2HTML`o
B$];System["mv -f "//out$1876//" "//equ$1876]];Exit[]]];"\n\nwhere L is the effective length of the component. Positive sign means 
horizontal focusing."[1,Max[p0$1876,0]]//"<img  class=\"eqs\" SRC=\""//equ$1876//"\" />"//Help2HTML`oy$["\n\nwhere L is the effecti
ve length of the component. Positive sign means horizontal focusing."[p2$1876,-1]]]
</PRE>
<PRE>See also:
 <A HREF=#L94>L</A></PRE>
<LI>
<H3><A NAME=L233>
L</A></H3>
<PRE>If[{},Help2HTML`oA$["The effective length."],
 p$1879=1+p$1879[[1,2]];p1$1879=StringPosition["The effective length."[p$1879,-1],">::",1];
  p1$1879=If[p1$1879==={},21,-2+p$1879+p1$1879[[1,1]]];
  neq=Which["The effective length."[p$1879,4+p$1879]==="Text[",lx$1879:=Help2HTML`oa$;p$1879=5+p$1879;p1$1879-=1;p2$1879=5+p1$1879;
     p0$1879=-9+p$1879;
     If[(pe$1879=StringPosition["The effective length."[p$1879,-2],";;;"])<=>{},{Max[0,-1+ToExpression["The effective length."[p
            $1879+pe$1879[[1,2]],
           p1$1879]]],
        p1$1879=-2+p$1879+pe$1879[[1,1]]}[[
       1]],
      0],
    1,lx$1879:=Help2HTML`o9$;p2$1879=4+p1$1879;p0$1879=-4+p$1879;0];
  If[(equ$1879=Help2HTML`o8$["The effective length."[p$1879,p1$1879]])===Undefined,
   equ$1879="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["The effective length."[p$1879,p1$1879]]=equ$1879;LaTeX`ob$+=neq,
     --LaTeX`ob$;With[{lx$1879},out$1879=lx$1879@Typeset["The effective length."[p$1879,p1$1879],Format->Help2HTML`oB$];
        System["mv -f "//out$1879//" "//equ$1879]];
      Exit[]]];
   "The effective length."[1,Max[p0$1879,0]]//"<img  class=\"eqs\" SRC=\""//equ$1879//"\" />"//
   Help2HTML`oy$["The effective length."[p2$1879,-1]]
]</PRE>
<LI>
<H3><A NAME=L234>
ROTATE</A></H3>
<PRE>If[{},
Help2HTML`oA$["Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet around the local s-axis by -(amo\
unt given by ROTATE), then place the component. At the exit rotate back the magnet around the local s-axis at the exit, then take \
out displacement."],
p$1881=1+p$1881[[1,2]];p1$1881=StringPosition["Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet \
around the local s-axis by -(amount given by ROTATE), then place the component. At the exit rotate back the magnet around the loca\
l s-axis at the exit, then take out displacement."[p$1881,-1],">::",1];
   p1$1881=If[p1$1881==={},262,-2+p$1881+p1$1881[[1,1]]];
neq=Which["Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet around the local s-axis by -(amount \
given by ROTATE), then place the component. At the exit rotate back the magnet around the local s-axis at the exit, then take out \
displacement."[p$1881,4+p$1881]==="Text[",
    lx$1881:=Help2HTML`oa$;p$1881=5+p$1881;p1$1881-=1;p2$1881=5+p1$1881;p0$1881=-9+p$1881;If[(pe$1881=
StringPosition["Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet around the local s-axis by -(am\
ount given by ROTATE), then place the component. At the exit rotate back the magnet around the local s-axis at the exit, then take\
 out displacement."[p$1881,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet around the local s-axis by -(a\
mount given by ROTATE), then place the component. At the exit rotate back the magnet around the local s-axis at the exit, then tak\
e out displacement."[p$1881+pe$1881[[1,2]],p1$1881]]],
        p1$1881=-2+p$1881+pe$1881[[1,1]]}[[
       1]],
      0],
    1,lx$1881:=Help2HTML`o9$;p2$1881=4+p1$1881;p0$1881=-4+p$1881;0];
  If[(equ$1881=
Help2HTML`o8$["Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet around the local s-axis by -(amo\
unt given by ROTATE), then place the component. At the exit rotate back the magnet around the local s-axis at the exit, then take \
out displacement."[p$1881,p1$1881]])===
    Undefined,
equ$1881="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Rotation in x-y plane. After displacing the \
magnet by DX and DY, rotate the magnet around the local s-axis by -(amount given by ROTATE), then place the component. At the exit\
 rotate back the magnet around the local s-axis at the exit, then take out displacement."[p$1881,p1$1881]]=
       equ$1881;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1881},out$1881=lx$1881@Typeset["Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet around\
 the local s-axis by -(amount given by ROTATE), then place the component. At the exit rotate back the magnet around the local s-ax\
is at the exit, then take out displacement."[p$1881,p1$1881],Format->Help2HTML`oB$];
        System["mv -f "//out$1881//" "//equ$1881]];
      Exit[]]];
   "Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet around the local s-axis by -(amount given b\
y ROTATE), then place the component. At the exit rotate back the magnet around the local s-axis at the exit, then take out displac\
ement."[1,Max[p0$1881,0]]//"<img  class=\"eqs\" SRC=\""//equ$1881//"\" />"//
Help2HTML`oy$["Rotation in x-y plane. After displacing the magnet by DX and DY, rotate the magnet around the local s-axis by -(amo\
unt given by ROTATE), then place the component. At the exit rotate back the magnet around the local s-axis at the exit, then take \
out displacement."[p2$1881,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L84>DX</A> <A HREF=#L85>DY</A> <A HREF=#L83>DROTATE</A></PRE>
<LI>
<H3><A NAME=L235>
transformation:THIN</A></H3>
<PRE><img  class="eqs" SRC="SADHelp_img/equ_191.svg" />
</PRE>
</UL>
<LI>
<H3><A NAME=L236>
SOL</A></H3>
<PRE>If[{},
Help2HTML`oA$["A solenoid. Unlike other elements, SOL elements inserted at boundaries or of a solenoid or at where the field chang\
es. Between SOL elements DRIFT, BEND(straight bend only), QUAD, and MULT elements can be inserted. The longitudinal field of the s\
olenoid overlaps on those elements.\n   In a SOL region, the coordinate is shifted on the axis of the solenoid, no matter how the \
design orbit bends there. The x-direction of the coordinate in a solenoid is so chosen as to CHI3 = 0. At the exit of a solenoid, \
the coordinate is shifted back to the design orbit, but the value of CHI3 is so determined as to set CHI3 zero at the nearest MARK\
 element which has GEO = 1 after the exit. The offset and orientation of the design orbit can be given by keywords DX, DY, DPX, DP\
Y at a SOL element with GEO = 1. SOL can be used to shift the coordinate to the actual orbit even without BZ. It is useful to defi\
ne the coordinate with magnets with DX and DY."],
p$1886=1+p$1886[[1,2]];p1$1886=StringPosition["A solenoid. Unlike other elements, SOL elements inserted at boundaries or of a sole\
noid or at where the field changes. Between SOL elements DRIFT, BEND(straight bend only), QUAD, and MULT elements can be inserted.\
 The longitudinal field of the solenoid overlaps on those elements.\n   In a SOL region, the coordinate is shifted on the axis of \
the solenoid, no matter how the design orbit bends there. The x-direction of the coordinate in a solenoid is so chosen as to CHI3 \
= 0. At the exit of a solenoid, the coordinate is shifted back to the design orbit, but the value of CHI3 is so determined as to s\
et CHI3 zero at the nearest MARK element which has GEO = 1 after the exit. The offset and orientation of the design orbit can be g\
iven by keywords DX, DY, DPX, DPY at a SOL element with GEO = 1. SOL can be used to shift the coordinate to the actual orbit even \
without BZ. It is useful to define the coordinate with magnets with DX and DY."[p$1886,-1],">::",1];
   p1$1886=If[p1$1886==={},940,-2+p$1886+p1$1886[[1,1]]];
neq=Which["A solenoid. Unlike other elements, SOL elements inserted at boundaries or of a solenoid or at where the field changes. \
Between SOL elements DRIFT, BEND(straight bend only), QUAD, and MULT elements can be inserted. The longitudinal field of the solen\
oid overlaps on those elements.\n   In a SOL region, the coordinate is shifted on the axis of the solenoid, no matter how the desi\
gn orbit bends there. The x-direction of the coordinate in a solenoid is so chosen as to CHI3 = 0. At the exit of a solenoid, the \
coordinate is shifted back to the design orbit, but the value of CHI3 is so determined as to set CHI3 zero at the nearest MARK ele\
ment which has GEO = 1 after the exit. The offset and orientation of the design orbit can be given by keywords DX, DY, DPX, DPY at\
 a SOL element with GEO = 1. SOL can be used to shift the coordinate to the actual orbit even without BZ. It is useful to define t\
he coordinate with magnets with DX and DY."[p$1886,4+p$1886]==="Text[",
    lx$1886:=Help2HTML`oa$;p$1886=5+p$1886;p1$1886-=1;p2$1886=5+p1$1886;p0$1886=-9+p$1886;
If[(pe$1886=StringPosition["A solenoid. Unlike other elements, SOL elements inserted at boundaries or of a solenoid or at where th\
e field changes. Between SOL elements DRIFT, BEND(straight bend only), QUAD, and MULT elements can be inserted. The longitudinal f\
ield of the solenoid overlaps on those elements.\n   In a SOL region, the coordinate is shifted on the axis of the solenoid, no ma\
tter how the design orbit bends there. The x-direction of the coordinate in a solenoid is so chosen as to CHI3 = 0. At the exit of\
 a solenoid, the coordinate is shifted back to the design orbit, but the value of CHI3 is so determined as to set CHI3 zero at the\
 nearest MARK element which has GEO = 1 after the exit. The offset and orientation of the design orbit can be given by keywords DX\
, DY, DPX, DPY at a SOL element with GEO = 1. SOL can be used to shift the coordinate to the actual orbit even without BZ. It is u\
seful to define the coordinate with magnets with DX and DY."[p$1886,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["A solenoid. Unlike other elements, SOL elements inserted at boundaries or of a solenoid or at where the field cha\
nges. Between SOL elements DRIFT, BEND(straight bend only), QUAD, and MULT elements can be inserted. The longitudinal field of the\
 solenoid overlaps on those elements.\n   In a SOL region, the coordinate is shifted on the axis of the solenoid, no matter how th\
e design orbit bends there. The x-direction of the coordinate in a solenoid is so chosen as to CHI3 = 0. At the exit of a solenoid\
, the coordinate is shifted back to the design orbit, but the value of CHI3 is so determined as to set CHI3 zero at the nearest MA\
RK element which has GEO = 1 after the exit. The offset and orientation of the design orbit can be given by keywords DX, DY, DPX, \
DPY at a SOL element with GEO = 1. SOL can be used to shift the coordinate to the actual orbit even without BZ. It is useful to de\
fine the coordinate with magnets with DX and DY."[p$1886+pe$1886[[1,2]],p1$1886]]],
        p1$1886=-2+p$1886+pe$1886[[1,1]]}[[
       1]],
      0],
    1,lx$1886:=Help2HTML`o9$;p2$1886=4+p1$1886;p0$1886=-4+p$1886;0];
  If[(equ$1886=
Help2HTML`o8$["A solenoid. Unlike other elements, SOL elements inserted at boundaries or of a solenoid or at where the field chang\
es. Between SOL elements DRIFT, BEND(straight bend only), QUAD, and MULT elements can be inserted. The longitudinal field of the s\
olenoid overlaps on those elements.\n   In a SOL region, the coordinate is shifted on the axis of the solenoid, no matter how the \
design orbit bends there. The x-direction of the coordinate in a solenoid is so chosen as to CHI3 = 0. At the exit of a solenoid, \
the coordinate is shifted back to the design orbit, but the value of CHI3 is so determined as to set CHI3 zero at the nearest MARK\
 element which has GEO = 1 after the exit. The offset and orientation of the design orbit can be given by keywords DX, DY, DPX, DP\
Y at a SOL element with GEO = 1. SOL can be used to shift the coordinate to the actual orbit even without BZ. It is useful to defi\
ne the coordinate with magnets with DX and DY."[p$1886,p1$1886]])===
    Undefined,
equ$1886="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["A solenoid. Unlike other elements, SOL eleme\
nts inserted at boundaries or of a solenoid or at where the field changes. Between SOL elements DRIFT, BEND(straight bend only), Q\
UAD, and MULT elements can be inserted. The longitudinal field of the solenoid overlaps on those elements.\n   In a SOL region, th\
e coordinate is shifted on the axis of the solenoid, no matter how the design orbit bends there. The x-direction of the coordinate\
 in a solenoid is so chosen as to CHI3 = 0. At the exit of a solenoid, the coordinate is shifted back to the design orbit, but the\
 value of CHI3 is so determined as to set CHI3 zero at the nearest MARK element which has GEO = 1 after the exit. The offset and o\
rientation of the design orbit can be given by keywords DX, DY, DPX, DPY at a SOL element with GEO = 1. SOL can be used to shift t\
he coordinate to the actual orbit even without BZ. It is useful to define the coordinate with magnets with DX and DY."[p$1886,
         p1$1886]]=
       equ$1886;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1886},out$1886=lx$1886@Typeset["A solenoid. Unlike other elements, SOL elements inserted at boundaries or of a solenoid o\
r at where the field changes. Between SOL elements DRIFT, BEND(straight bend only), QUAD, and MULT elements can be inserted. The l\
ongitudinal field of the solenoid overlaps on those elements.\n   In a SOL region, the coordinate is shifted on the axis of the so\
lenoid, no matter how the design orbit bends there. The x-direction of the coordinate in a solenoid is so chosen as to CHI3 = 0. A\
t the exit of a solenoid, the coordinate is shifted back to the design orbit, but the value of CHI3 is so determined as to set CHI\
3 zero at the nearest MARK element which has GEO = 1 after the exit. The offset and orientation of the design orbit can be given b\
y keywords DX, DY, DPX, DPY at a SOL element with GEO = 1. SOL can be used to shift the coordinate to the actual orbit even withou\
t BZ. It is useful to define the coordinate with magnets with DX and DY."[p$1886,p1$1886],Format->Help2HTML`oB$];
        System["mv -f "//out$1886//" "//equ$1886]];
      Exit[]]];
   "A solenoid. Unlike other elements, SOL elements inserted at boundaries or of a solenoid or at where the field changes. Between\
 SOL elements DRIFT, BEND(straight bend only), QUAD, and MULT elements can be inserted. The longitudinal field of the solenoid ove\
rlaps on those elements.\n   In a SOL region, the coordinate is shifted on the axis of the solenoid, no matter how the design orbi\
t bends there. The x-direction of the coordinate in a solenoid is so chosen as to CHI3 = 0. At the exit of a solenoid, the coordin\
ate is shifted back to the design orbit, but the value of CHI3 is so determined as to set CHI3 zero at the nearest MARK element wh\
ich has GEO = 1 after the exit. The offset and orientation of the design orbit can be given by keywords DX, DY, DPX, DPY at a SOL \
element with GEO = 1. SOL can be used to shift the coordinate to the actual orbit even without BZ. It is useful to define the coor\
dinate with magnets with DX and DY."[1,Max[p0$1886,0]]//"<img  class=\"eqs\" SRC=\""//equ$1886//"\" />"//
Help2HTML`oy$["A solenoid. Unlike other elements, SOL elements inserted at boundaries or of a solenoid or at where the field chang\
es. Between SOL elements DRIFT, BEND(straight bend only), QUAD, and MULT elements can be inserted. The longitudinal field of the s\
olenoid overlaps on those elements.\n   In a SOL region, the coordinate is shifted on the axis of the solenoid, no matter how the \
design orbit bends there. The x-direction of the coordinate in a solenoid is so chosen as to CHI3 = 0. At the exit of a solenoid, \
the coordinate is shifted back to the design orbit, but the value of CHI3 is so determined as to set CHI3 zero at the nearest MARK\
 element which has GEO = 1 after the exit. The offset and orientation of the design orbit can be given by keywords DX, DY, DPX, DP\
Y at a SOL element with GEO = 1. SOL can be used to shift the coordinate to the actual orbit even without BZ. It is useful to defi\
ne the coordinate with magnets with DX and DY."[p2$1886,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L468>geometric-functions</A> <A HREF=#L137>MARK</A></PRE>
<UL>
<LI>
<H3><A NAME=L237>
BOUND</A></H3>
<PRE>If[{},
 Help2HTML`oA$[
  "BOUND = 1 must be given at both sides of the boundaries of a solenoid, otherwise SOL only specifies the change of BZ"],
 p$1889=1+p$1889[[1,2]];
  p1$1889=StringPosition[
    "BOUND = 1 must be given at both sides of the boundaries of a solenoid, otherwise SOL only specifies the change of BZ"[p$1889,
     -1],
    ">::",1];
   p1$1889=If[p1$1889==={},116,-2+p$1889+p1$1889[[1,1]]];
  neq=Which["BOUND = 1 must be given at both sides of the boundaries of a solenoid, otherwise SOL only specifies the change of BZ"[
      p$1889,4+p$1889]===
     "Text[",
    lx$1889:=Help2HTML`oa$;p$1889=5+p$1889;p1$1889-=1;p2$1889=5+p1$1889;p0$1889=-9+p$1889;If[(pe$1889=StringPosition[
         "BOUND = 1 must be given at both sides of the boundaries of a solenoid, otherwise SOL only specifies the change of BZ"[p
          $1889,-2],
         ";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression[
          "BOUND = 1 must be given at both sides of the boundaries of a solenoid, otherwise SOL only specifies the change of BZ"[
            p$1889+pe$1889[[1,2]],
           p1$1889]]],
        p1$1889=-2+p$1889+pe$1889[[1,1]]}[[
       1]],
      0],
    1,lx$1889:=Help2HTML`o9$;p2$1889=4+p1$1889;p0$1889=-4+p$1889;0];
  If[(equ$1889=
     Help2HTML`o8$[
      "BOUND = 1 must be given at both sides of the boundaries of a solenoid, otherwise SOL only specifies the change of BZ"[p$1889
       ,p1$1889]])===
    Undefined,
   equ$1889="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "BOUND = 1 must be given at both sides of the boundaries of a solenoid, otherwise SOL only specifies the change of BZ"[p
         $1889,p1$1889]]=
       equ$1889;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$1889},out$1889=lx$1889@Typeset[
          "BOUND = 1 must be given at both sides of the boundaries of a solenoid, otherwise SOL only specifies the change of BZ"[
           p$1889,p1$1889],Format->Help2HTML`oB$];
        System["mv -f "//out$1889//" "//equ$1889]];
      Exit[]]];
  "BOUND = 1 must be given at both sides of the boundaries of a solenoid, otherwise SOL only specifies the change of BZ"[1,
    Max[p0$1889,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$1889//"\" />"//
   Help2HTML`oy$[
    "BOUND = 1 must be given at both sides of the boundaries of a solenoid, otherwise SOL only specifies the change of BZ"[p2$1889,
     -1]]
]</PRE>
<LI>
<H3><A NAME=L238>
BZ</A></H3>
<PRE>If[{},
Help2HTML`oA$["The longitudinal field of a solenoid. If a SOL is used with BOUND = 0 (default), only BZ is used to change the fiel\
d, and no coordinate transformation is applied."],
p$1891=1+p$1891[[1,2]];p1$1891=StringPosition["The longitudinal field of a solenoid. If a SOL is used with BOUND = 0 (default), on\
ly BZ is used to change the field, and no coordinate transformation is applied."[p$1891,-1],">::",1];
   p1$1891=If[p1$1891==={},162,-2+p$1891+p1$1891[[1,1]]];
neq=Which["The longitudinal field of a solenoid. If a SOL is used with BOUND = 0 (default), only BZ is used to change the field, a\
nd no coordinate transformation is applied."[p$1891,4+p$1891]==="Text[",
    lx$1891:=Help2HTML`oa$;p$1891=5+p$1891;p1$1891-=1;p2$1891=5+p1$1891;p0$1891=-9+p$1891;
If[(pe$1891=StringPosition["The longitudinal field of a solenoid. If a SOL is used with BOUND = 0 (default), only BZ is used to ch\
ange the field, and no coordinate transformation is applied."[p$1891,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["The longitudinal field of a solenoid. If a SOL is used with BOUND = 0 (default), only BZ is used to change the fi\
eld, and no coordinate transformation is applied."[p$1891+pe$1891[[1,2]],p1$1891]]],
        p1$1891=-2+p$1891+pe$1891[[1,1]]}[[
       1]],
      0],
    1,lx$1891:=Help2HTML`o9$;p2$1891=4+p1$1891;p0$1891=-4+p$1891;0];
  If[(equ$1891=
Help2HTML`o8$["The longitudinal field of a solenoid. If a SOL is used with BOUND = 0 (default), only BZ is used to change the fiel\
d, and no coordinate transformation is applied."[p$1891,p1$1891]])===
    Undefined,
equ$1891="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["The longitudinal field of a solenoid. If a S\
OL is used with BOUND = 0 (default), only BZ is used to change the field, and no coordinate transformation is applied."[p$1891,
         p1$1891]]=
       equ$1891;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1891},out$1891=lx$1891@Typeset["The longitudinal field of a solenoid. If a SOL is used with BOUND = 0 (default), only BZ \
is used to change the field, and no coordinate transformation is applied."[p$1891,p1$1891],Format->Help2HTML`oB$];
        System["mv -f "//out$1891//" "//equ$1891]];
      Exit[]]];
   "The longitudinal field of a solenoid. If a SOL is used with BOUND = 0 (default), only BZ is used to change the field, and no c\
oordinate transformation is applied."[1,Max[p0$1891,0]]//"<img  class=\"eqs\" SRC=\""//equ$1891//"\" />"//
Help2HTML`oy$["The longitudinal field of a solenoid. If a SOL is used with BOUND = 0 (default), only BZ is used to change the fiel\
d, and no coordinate transformation is applied."[p2$1891,-1]]
]</PRE>
<LI>
<H3><A NAME=L239>
DISFRIN</A></H3>
<PRE><img  class="eqs" SRC="SADHelp_img/equ_194.svg" />
</PRE>
<LI>
<H3><A NAME=L240>
DPX</A></H3>
<PRE>If[{},Help2HTML`oA$["An offset of the design ORBIT angle CHI1 relative to the solenoid axis at SOL with GEO = 1."],
 p$1895=1+p$1895[[1,2]];
  p1$1895=StringPosition["An offset of the design ORBIT angle CHI1 relative to the solenoid axis at SOL with GEO = 1."[p$1895,-1],
    ">::",1];
   p1$1895=If[p1$1895==={},91,-2+p$1895+p1$1895[[1,1]]];
  neq=Which["An offset of the design ORBIT angle CHI1 relative to the solenoid axis at SOL with GEO = 1."[p$1895,4+p$1895]===
     "Text[",
    lx$1895:=Help2HTML`oa$;p$1895=5+p$1895;p1$1895-=1;p2$1895=5+p1$1895;p0$1895=-9+p$1895;If[(pe$1895=StringPosition[
         "An offset of the design ORBIT angle CHI1 relative to the solenoid axis at SOL with GEO = 1."[p$1895,-2],";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression["An offset of the design ORBIT angle CHI1 relative to the solenoid axis at SOL with GEO = 1."[p$1895+pe
            $1895[[1,2]],
           p1$1895]]],
        p1$1895=-2+p$1895+pe$1895[[1,1]]}[[
       1]],
      0],
    1,lx$1895:=Help2HTML`o9$;p2$1895=4+p1$1895;p0$1895=-4+p$1895;0];
  If[(equ$1895=
     Help2HTML`o8$["An offset of the design ORBIT angle CHI1 relative to the solenoid axis at SOL with GEO = 1."[p$1895,p1$1895]]
     )===
    Undefined,
   equ$1895="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "An offset of the design ORBIT angle CHI1 relative to the solenoid axis at SOL with GEO = 1."[p$1895,p1$1895]]=
       equ$1895;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$1895},out$1895=lx$1895@Typeset[
          "An offset of the design ORBIT angle CHI1 relative to the solenoid axis at SOL with GEO = 1."[p$1895,p1$1895],
          Format->Help2HTML`oB$];
        System["mv -f "//out$1895//" "//equ$1895]];
      Exit[]]];
   "An offset of the design ORBIT angle CHI1 relative to the solenoid axis at SOL with GEO = 1."[1,Max[p0$1895,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$1895//"\" />"//
   Help2HTML`oy$["An offset of the design ORBIT angle CHI1 relative to the solenoid axis at SOL with GEO = 1."[p2$1895,-1]]
 ]
</PRE>
<PRE>See also:
 <A HREF=#L245>GEO</A> <A HREF=#L84>DX</A> <A HREF=#L85>DY</A> <A HREF=#L241>DPY</A> CHI1</PRE>
<LI>
<H3><A NAME=L241>
DPY</A></H3>
<PRE>If[{},Help2HTML`oA$["An offset of the design ORBIT angle CHI2 relative to the solenoid axis at SOL with GEO = 1."],
 p$1898=1+p$1898[[1,2]];
  p1$1898=StringPosition["An offset of the design ORBIT angle CHI2 relative to the solenoid axis at SOL with GEO = 1."[p$1898,-1],
    ">::",1];
   p1$1898=If[p1$1898==={},91,-2+p$1898+p1$1898[[1,1]]];
  neq=Which["An offset of the design ORBIT angle CHI2 relative to the solenoid axis at SOL with GEO = 1."[p$1898,4+p$1898]===
     "Text[",
    lx$1898:=Help2HTML`oa$;p$1898=5+p$1898;p1$1898-=1;p2$1898=5+p1$1898;p0$1898=-9+p$1898;If[(pe$1898=StringPosition[
         "An offset of the design ORBIT angle CHI2 relative to the solenoid axis at SOL with GEO = 1."[p$1898,-2],";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression["An offset of the design ORBIT angle CHI2 relative to the solenoid axis at SOL with GEO = 1."[p$1898+pe
            $1898[[1,2]],
           p1$1898]]],
        p1$1898=-2+p$1898+pe$1898[[1,1]]}[[
       1]],
      0],
    1,lx$1898:=Help2HTML`o9$;p2$1898=4+p1$1898;p0$1898=-4+p$1898;0];
  If[(equ$1898=
     Help2HTML`o8$["An offset of the design ORBIT angle CHI2 relative to the solenoid axis at SOL with GEO = 1."[p$1898,p1$1898]]
     )===
    Undefined,
   equ$1898="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "An offset of the design ORBIT angle CHI2 relative to the solenoid axis at SOL with GEO = 1."[p$1898,p1$1898]]=
       equ$1898;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$1898},out$1898=lx$1898@Typeset[
          "An offset of the design ORBIT angle CHI2 relative to the solenoid axis at SOL with GEO = 1."[p$1898,p1$1898],
          Format->Help2HTML`oB$];
        System["mv -f "//out$1898//" "//equ$1898]];
      Exit[]]];
   "An offset of the design ORBIT angle CHI2 relative to the solenoid axis at SOL with GEO = 1."[1,Max[p0$1898,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$1898//"\" />"//
   Help2HTML`oy$["An offset of the design ORBIT angle CHI2 relative to the solenoid axis at SOL with GEO = 1."[p2$1898,-1]]
 ]
</PRE>
<PRE>See also:
 <A HREF=#L245>GEO</A> <A HREF=#L84>DX</A> <A HREF=#L85>DY</A> <A HREF=#L240>DPX</A> CHI2</PRE>
<LI>
<H3><A NAME=L242>
DX</A></H3>
<PRE>If[{},Help2HTML`oA$["An x-offset of the design ORBIT relative to the solenoid center at SOL with GEO = 1."],
 p$1901=1+p$1901[[1,2]];
  p1$1901=StringPosition["An x-offset of the design ORBIT relative to the solenoid center at SOL with GEO = 1."[p$1901,-1],">::",
    1];
   p1$1901=If[p1$1901==={},84,-2+p$1901+p1$1901[[1,1]]];
  neq=Which["An x-offset of the design ORBIT relative to the solenoid center at SOL with GEO = 1."[p$1901,4+p$1901]==="Text[",
    lx$1901:=Help2HTML`oa$;p$1901=5+p$1901;p1$1901-=1;p2$1901=5+p1$1901;p0$1901=-9+p$1901;
     If[(pe$1901=StringPosition["An x-offset of the design ORBIT relative to the solenoid center at SOL with GEO = 1."[p$1901,-2],
         ";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression["An x-offset of the design ORBIT relative to the solenoid center at SOL with GEO = 1."[p$1901+pe$1901[[1,
             2]],
           p1$1901]]],
        p1$1901=-2+p$1901+pe$1901[[1,1]]}[[
       1]],
      0],
    1,lx$1901:=Help2HTML`o9$;p2$1901=4+p1$1901;p0$1901=-4+p$1901;0];
  If[(equ$1901=
     Help2HTML`o8$["An x-offset of the design ORBIT relative to the solenoid center at SOL with GEO = 1."[p$1901,p1$1901]])===
    Undefined,
   equ$1901="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "An x-offset of the design ORBIT relative to the solenoid center at SOL with GEO = 1."[p$1901,p1$1901]]=
       equ$1901;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$1901},out$1901=lx$1901@Typeset[
          "An x-offset of the design ORBIT relative to the solenoid center at SOL with GEO = 1."[p$1901,p1$1901],
          Format->Help2HTML`oB$];
        System["mv -f "//out$1901//" "//equ$1901]];
      Exit[]]];
   "An x-offset of the design ORBIT relative to the solenoid center at SOL with GEO = 1."[1,Max[p0$1901,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$1901//"\" />"//
   Help2HTML`oy$["An x-offset of the design ORBIT relative to the solenoid center at SOL with GEO = 1."[p2$1901,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L245>GEO</A> <A HREF=#L85>DY</A> <A HREF=#L240>DPX</A> <A HREF=#L241>DPY</A></PRE>
<LI>
<H3><A NAME=L243>
DY</A></H3>
<PRE>If[{},Help2HTML`oA$["A y-offset of the design ORBIT relative to the solenoid center at SOL with GEO = 1."],
 p$1904=1+p$1904[[1,2]];
  p1$1904=StringPosition["A y-offset of the design ORBIT relative to the solenoid center at SOL with GEO = 1."[p$1904,-1],">::",1];
  p1$1904=If[p1$1904==={},83,-2+p$1904+p1$1904[[1,1]]];
  neq=Which["A y-offset of the design ORBIT relative to the solenoid center at SOL with GEO = 1."[p$1904,4+p$1904]==="Text[",
    lx$1904:=Help2HTML`oa$;p$1904=5+p$1904;p1$1904-=1;p2$1904=5+p1$1904;p0$1904=-9+p$1904;
     If[(pe$1904=StringPosition["A y-offset of the design ORBIT relative to the solenoid center at SOL with GEO = 1."[p$1904,-2],
         ";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression["A y-offset of the design ORBIT relative to the solenoid center at SOL with GEO = 1."[p$1904+pe$1904[[1,2]]
            ,
           p1$1904]]],
        p1$1904=-2+p$1904+pe$1904[[1,1]]}[[
       1]],
      0],
    1,lx$1904:=Help2HTML`o9$;p2$1904=4+p1$1904;p0$1904=-4+p$1904;0];
  If[(equ$1904=Help2HTML`o8$["A y-offset of the design ORBIT relative to the solenoid center at SOL with GEO = 1."[p$1904,p1$1904]]
     )===
    Undefined,
   equ$1904="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "A y-offset of the design ORBIT relative to the solenoid center at SOL with GEO = 1."[p$1904,p1$1904]]=
       equ$1904;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$1904},out$1904=lx$1904@Typeset["A y-offset of the design ORBIT relative to the solenoid center at SOL with GEO = 1."
          [p$1904,p1$1904],Format->Help2HTML`oB$];
        System["mv -f "//out$1904//" "//equ$1904]];
      Exit[]]];
   "A y-offset of the design ORBIT relative to the solenoid center at SOL with GEO = 1."[1,Max[p0$1904,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$1904//"\" />"//
   Help2HTML`oy$["A y-offset of the design ORBIT relative to the solenoid center at SOL with GEO = 1."[p2$1904,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L245>GEO</A> <A HREF=#L84>DX</A> <A HREF=#L240>DPX</A> <A HREF=#L241>DPY</A></PRE>
<LI>
<H3><A NAME=L244>
F1</A></H3>
<PRE>If[{},
Help2HTML`oA$["The length of fringe of the solenoid field. It affects only the EMITTANCE calculation. If F1 = 0 (default), no radi\
ation arises at the fringe."],
p$1907=1+p$1907[[1,2]];p1$1907=StringPosition["The length of fringe of the solenoid field. It affects only the EMITTANCE calculati\
on. If F1 = 0 (default), no radiation arises at the fringe."[p$1907,-1],">::",1];
   p1$1907=If[p1$1907==={},142,-2+p$1907+p1$1907[[1,1]]];
neq=Which["The length of fringe of the solenoid field. It affects only the EMITTANCE calculation. If F1 = 0 (default), no radiatio\
n arises at the fringe."[p$1907,4+p$1907]==="Text[",
    lx$1907:=Help2HTML`oa$;p$1907=5+p$1907;p1$1907-=1;p2$1907=5+p1$1907;p0$1907=-9+p$1907;
If[(pe$1907=StringPosition["The length of fringe of the solenoid field. It affects only the EMITTANCE calculation. If F1 = 0 (defa\
ult), no radiation arises at the fringe."[p$1907,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["The length of fringe of the solenoid field. It affects only the EMITTANCE calculation. If F1 = 0 (default), no ra\
diation arises at the fringe."[p$1907+pe$1907[[1,2]],p1$1907]]],
        p1$1907=-2+p$1907+pe$1907[[1,1]]}[[
       1]],
      0],
    1,lx$1907:=Help2HTML`o9$;p2$1907=4+p1$1907;p0$1907=-4+p$1907;0];
  If[(equ$1907=
Help2HTML`o8$["The length of fringe of the solenoid field. It affects only the EMITTANCE calculation. If F1 = 0 (default), no radi\
ation arises at the fringe."[p$1907,p1$1907]])===
    Undefined,
equ$1907="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["The length of fringe of the solenoid field. \
It affects only the EMITTANCE calculation. If F1 = 0 (default), no radiation arises at the fringe."[p$1907,p1$1907]]=
       equ$1907;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1907},out$1907=lx$1907@Typeset["The length of fringe of the solenoid field. It affects only the EMITTANCE calculation. If\
 F1 = 0 (default), no radiation arises at the fringe."[p$1907,p1$1907],Format->Help2HTML`oB$];
        System["mv -f "//out$1907//" "//equ$1907]];
      Exit[]]];
   "The length of fringe of the solenoid field. It affects only the EMITTANCE calculation. If F1 = 0 (default), no radiation arise\
s at the fringe."[1,Max[p0$1907,0]]//"<img  class=\"eqs\" SRC=\""//equ$1907//"\" />"//
Help2HTML`oy$["The length of fringe of the solenoid field. It affects only the EMITTANCE calculation. If F1 = 0 (default), no radi\
ation arises at the fringe."[p2$1907,-1]]
]</PRE>
<LI>
<H3><A NAME=L245>
GEO</A></H3>
<PRE>If[{},
Help2HTML`oA$["One of boundaries (with GEO = 1) of a solenoid must have GEO = 1 to specify the alignment of the design orbit. At a\
 SOL element with GEO = 1, the design orbit is determined by DX, DY, DPX, DPY parameters"],
 p$1909=1+p$1909[[1,2]];p1$1909=StringPosition["One of boundaries (with GEO = 1) of a solenoid must have GEO = 1 to specify the al\
ignment of the design orbit. At a SOL element with GEO = 1, the design orbit is determined by DX, DY, DPX, DPY parameters"[p$1909,
     -1],
    ">::",1];
   p1$1909=If[p1$1909==={},203,-2+p$1909+p1$1909[[1,1]]];
neq=Which["One of boundaries (with GEO = 1) of a solenoid must have GEO = 1 to specify the alignment of the design orbit. At a SOL\
 element with GEO = 1, the design orbit is determined by DX, DY, DPX, DPY parameters"[p$1909,4+p$1909]==="Text[",
    lx$1909:=Help2HTML`oa$;p$1909=5+p$1909;p1$1909-=1;p2$1909=5+p1$1909;p0$1909=-9+p$1909;
If[(pe$1909=StringPosition["One of boundaries (with GEO = 1) of a solenoid must have GEO = 1 to specify the alignment of the desig\
n orbit. At a SOL element with GEO = 1, the design orbit is determined by DX, DY, DPX, DPY parameters"[p$1909,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["One of boundaries (with GEO = 1) of a solenoid must have GEO = 1 to specify the alignment of the design orbit. At\
 a SOL element with GEO = 1, the design orbit is determined by DX, DY, DPX, DPY parameters"[p$1909+pe$1909[[1,2]],p1$1909]]],
        p1$1909=-2+p$1909+pe$1909[[1,1]]}[[
       1]],
      0],
    1,lx$1909:=Help2HTML`o9$;p2$1909=4+p1$1909;p0$1909=-4+p$1909;0];
  If[(equ$1909=
Help2HTML`o8$["One of boundaries (with GEO = 1) of a solenoid must have GEO = 1 to specify the alignment of the design orbit. At a\
 SOL element with GEO = 1, the design orbit is determined by DX, DY, DPX, DPY parameters"[p$1909,p1$1909]])===
    Undefined,
equ$1909="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["One of boundaries (with GEO = 1) of a soleno\
id must have GEO = 1 to specify the alignment of the design orbit. At a SOL element with GEO = 1, the design orbit is determined b\
y DX, DY, DPX, DPY parameters"[p$1909,p1$1909]]=
       equ$1909;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1909},out$1909=lx$1909@Typeset["One of boundaries (with GEO = 1) of a solenoid must have GEO = 1 to specify the alignment\
 of the design orbit. At a SOL element with GEO = 1, the design orbit is determined by DX, DY, DPX, DPY parameters"[p$1909,p1$1909
           ],Format->Help2HTML`oB$];
        System["mv -f "//out$1909//" "//equ$1909]];
      Exit[]]];
   "One of boundaries (with GEO = 1) of a solenoid must have GEO = 1 to specify the alignment of the design orbit. At a SOL elemen\
t with GEO = 1, the design orbit is determined by DX, DY, DPX, DPY parameters"[1,Max[p0$1909,0]]//"<img  class=\"eqs\" SRC=\""//
   equ$1909//"\" />"//
Help2HTML`oy$["One of boundaries (with GEO = 1) of a solenoid must have GEO = 1 to specify the alignment of the design orbit. At a\
 SOL element with GEO = 1, the design orbit is determined by DX, DY, DPX, DPY parameters"[p2$1909,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L84>DX</A> <A HREF=#L85>DY</A> <A HREF=#L240>DPX</A> <A HREF=#L241>DPY</A> <A HREF=#L468>geometric-functions</A> <A HREF=#L56>DISPLAY(DISP)</A> GEOMRTRY(G) <A HREF=#L64>OGEOMETRY(OG)</A></PRE>
</UL>
</UL>
<H3><A NAME=L246>
expression</A></H3>
<PRE>If[{},
Help2HTML`oA$["An expression in FFS consists of a symbol, constants, and operators.\n\n>>> A symbol is a characters of any length \
starting with an alphabet or $.\n>>> There are two kinds of constants, real number and character-string.\n    real number is a num\
ber in fortran-line format.\n    character-string is a set of characters surrounded by \"\" or ''.\n    special-characters can be \
specified with backslash.\n>>> Available operators are (in the order of the priority):\n    #,##,\n    ?,\n    ::,\n    @,\n    []\
,\n    ++, --,\n    /@, //@, @@,\n    .,\n    ^,\n    *, /,\n    +, -,\n    ==, <>, >, <, >=, =>, <=, =<, \n    ===, <=>, \n    ~,\
 \n    &&,\n    ||,\n    .., ...,\n    |,\n    :,\n    ->, :>,\n    /., //.,\n    +=, -=, *=, /=,\n    &,\n    //,\n    /:,\n    =\
, :=, ^=, ^:=, =.\n    ;,\n    {}\nAn operator with higher priority is operated first. An expression enclosed in () is evaluated f\
irst. Most mathematical operations are threaded into a list, i.e., {a,b} + {c,d} gives {a + b,c + d}, etc.\n   Each operators can \
be used as a function using its name. For example, Plus[x,y] gives the same result as x + y."],
 p$1913=1+p$1913[[1,2]];p1$1913=StringPosition["An expression in FFS consists of a symbol, constants, and operators.\n\n>>> A symb\
ol is a characters of any length starting with an alphabet or $.\n>>> There are two kinds of constants, real number and character-\
string.\n    real number is a number in fortran-line format.\n    character-string is a set of characters surrounded by \"\" or ''\
.\n    special-characters can be specified with backslash.\n>>> Available operators are (in the order of the priority):\n    #,##,\
\n    ?,\n    ::,\n    @,\n    [],\n    ++, --,\n    /@, //@, @@,\n    .,\n    ^,\n    *, /,\n    +, -,\n    ==, <>, >, <, >=, =>,\
 <=, =<, \n    ===, <=>, \n    ~, \n    &&,\n    ||,\n    .., ...,\n    |,\n    :,\n    ->, :>,\n    /., //.,\n    +=, -=, *=, /=,\
\n    &,\n    //,\n    /:,\n    =, :=, ^=, ^:=, =.\n    ;,\n    {}\nAn operator with higher priority is operated first. An express\
ion enclosed in () is evaluated first. Most mathematical operations are threaded into a list, i.e., {a,b} + {c,d} gives {a + b,c +\
 d}, etc.\n   Each operators can be used as a function using its name. For example, Plus[x,y] gives the same result as x + y."[p
     $1913,-1],
    ">::",1];
   p1$1913=If[p1$1913==={},1078,-2+p$1913+p1$1913[[1,1]]];
neq=Which["An expression in FFS consists of a symbol, constants, and operators.\n\n>>> A symbol is a characters of any length star\
ting with an alphabet or $.\n>>> There are two kinds of constants, real number and character-string.\n    real number is a number \
in fortran-line format.\n    character-string is a set of characters surrounded by \"\" or ''.\n    special-characters can be spec\
ified with backslash.\n>>> Available operators are (in the order of the priority):\n    #,##,\n    ?,\n    ::,\n    @,\n    [],\n \
   ++, --,\n    /@, //@, @@,\n    .,\n    ^,\n    *, /,\n    +, -,\n    ==, <>, >, <, >=, =>, <=, =<, \n    ===, <=>, \n    ~, \n \
   &&,\n    ||,\n    .., ...,\n    |,\n    :,\n    ->, :>,\n    /., //.,\n    +=, -=, *=, /=,\n    &,\n    //,\n    /:,\n    =, :=\
, ^=, ^:=, =.\n    ;,\n    {}\nAn operator with higher priority is operated first. An expression enclosed in () is evaluated first\
. Most mathematical operations are threaded into a list, i.e., {a,b} + {c,d} gives {a + b,c + d}, etc.\n   Each operators can be u\
sed as a function using its name. For example, Plus[x,y] gives the same result as x + y."[p$1913,4+p$1913]==="Text[",
    lx$1913:=Help2HTML`oa$;p$1913=5+p$1913;p1$1913-=1;p2$1913=5+p1$1913;p0$1913=-9+p$1913;
If[(pe$1913=StringPosition["An expression in FFS consists of a symbol, constants, and operators.\n\n>>> A symbol is a characters o\
f any length starting with an alphabet or $.\n>>> There are two kinds of constants, real number and character-string.\n    real nu\
mber is a number in fortran-line format.\n    character-string is a set of characters surrounded by \"\" or ''.\n    special-chara\
cters can be specified with backslash.\n>>> Available operators are (in the order of the priority):\n    #,##,\n    ?,\n    ::,\n \
   @,\n    [],\n    ++, --,\n    /@, //@, @@,\n    .,\n    ^,\n    *, /,\n    +, -,\n    ==, <>, >, <, >=, =>, <=, =<, \n    ===, \
<=>, \n    ~, \n    &&,\n    ||,\n    .., ...,\n    |,\n    :,\n    ->, :>,\n    /., //.,\n    +=, -=, *=, /=,\n    &,\n    //,\n \
   /:,\n    =, :=, ^=, ^:=, =.\n    ;,\n    {}\nAn operator with higher priority is operated first. An expression enclosed in () i\
s evaluated first. Most mathematical operations are threaded into a list, i.e., {a,b} + {c,d} gives {a + b,c + d}, etc.\n   Each o\
perators can be used as a function using its name. For example, Plus[x,y] gives the same result as x + y."[p$1913,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["An expression in FFS consists of a symbol, constants, and operators.\n\n>>> A symbol is a characters of any lengt\
h starting with an alphabet or $.\n>>> There are two kinds of constants, real number and character-string.\n    real number is a n\
umber in fortran-line format.\n    character-string is a set of characters surrounded by \"\" or ''.\n    special-characters can b\
e specified with backslash.\n>>> Available operators are (in the order of the priority):\n    #,##,\n    ?,\n    ::,\n    @,\n    \
[],\n    ++, --,\n    /@, //@, @@,\n    .,\n    ^,\n    *, /,\n    +, -,\n    ==, <>, >, <, >=, =>, <=, =<, \n    ===, <=>, \n    \
~, \n    &&,\n    ||,\n    .., ...,\n    |,\n    :,\n    ->, :>,\n    /., //.,\n    +=, -=, *=, /=,\n    &,\n    //,\n    /:,\n   \
 =, :=, ^=, ^:=, =.\n    ;,\n    {}\nAn operator with higher priority is operated first. An expression enclosed in () is evaluated\
 first. Most mathematical operations are threaded into a list, i.e., {a,b} + {c,d} gives {a + b,c + d}, etc.\n   Each operators ca\
n be used as a function using its name. For example, Plus[x,y] gives the same result as x + y."[p$1913+pe$1913[[1,2]],p1$1913]]],
        p1$1913=-2+p$1913+pe$1913[[1,1]]}[[
       1]],
      0],
    1,lx$1913:=Help2HTML`o9$;p2$1913=4+p1$1913;p0$1913=-4+p$1913;0];
  If[(equ$1913=
Help2HTML`o8$["An expression in FFS consists of a symbol, constants, and operators.\n\n>>> A symbol is a characters of any length \
starting with an alphabet or $.\n>>> There are two kinds of constants, real number and character-string.\n    real number is a num\
ber in fortran-line format.\n    character-string is a set of characters surrounded by \"\" or ''.\n    special-characters can be \
specified with backslash.\n>>> Available operators are (in the order of the priority):\n    #,##,\n    ?,\n    ::,\n    @,\n    []\
,\n    ++, --,\n    /@, //@, @@,\n    .,\n    ^,\n    *, /,\n    +, -,\n    ==, <>, >, <, >=, =>, <=, =<, \n    ===, <=>, \n    ~,\
 \n    &&,\n    ||,\n    .., ...,\n    |,\n    :,\n    ->, :>,\n    /., //.,\n    +=, -=, *=, /=,\n    &,\n    //,\n    /:,\n    =\
, :=, ^=, ^:=, =.\n    ;,\n    {}\nAn operator with higher priority is operated first. An expression enclosed in () is evaluated f\
irst. Most mathematical operations are threaded into a list, i.e., {a,b} + {c,d} gives {a + b,c + d}, etc.\n   Each operators can \
be used as a function using its name. For example, Plus[x,y] gives the same result as x + y."[p$1913,p1$1913]])===
    Undefined,
equ$1913="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["An expression in FFS consists of a symbol, c\
onstants, and operators.\n\n>>> A symbol is a characters of any length starting with an alphabet or $.\n>>> There are two kinds of\
 constants, real number and character-string.\n    real number is a number in fortran-line format.\n    character-string is a set \
of characters surrounded by \"\" or ''.\n    special-characters can be specified with backslash.\n>>> Available operators are (in \
the order of the priority):\n    #,##,\n    ?,\n    ::,\n    @,\n    [],\n    ++, --,\n    /@, //@, @@,\n    .,\n    ^,\n    *, /,\
\n    +, -,\n    ==, <>, >, <, >=, =>, <=, =<, \n    ===, <=>, \n    ~, \n    &&,\n    ||,\n    .., ...,\n    |,\n    :,\n    ->, \
:>,\n    /., //.,\n    +=, -=, *=, /=,\n    &,\n    //,\n    /:,\n    =, :=, ^=, ^:=, =.\n    ;,\n    {}\nAn operator with higher \
priority is operated first. An expression enclosed in () is evaluated first. Most mathematical operations are threaded into a list\
, i.e., {a,b} + {c,d} gives {a + b,c + d}, etc.\n   Each operators can be used as a function using its name. For example, Plus[x,y\
] gives the same result as x + y."[p$1913,p1$1913]]=
       equ$1913;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1913},out$1913=lx$1913@Typeset["An expression in FFS consists of a symbol, constants, and operators.\n\n>>> A symbol is a\
 characters of any length starting with an alphabet or $.\n>>> There are two kinds of constants, real number and character-string.\
\n    real number is a number in fortran-line format.\n    character-string is a set of characters surrounded by \"\" or ''.\n    \
special-characters can be specified with backslash.\n>>> Available operators are (in the order of the priority):\n    #,##,\n    ?\
,\n    ::,\n    @,\n    [],\n    ++, --,\n    /@, //@, @@,\n    .,\n    ^,\n    *, /,\n    +, -,\n    ==, <>, >, <, >=, =>, <=, =<\
, \n    ===, <=>, \n    ~, \n    &&,\n    ||,\n    .., ...,\n    |,\n    :,\n    ->, :>,\n    /., //.,\n    +=, -=, *=, /=,\n    &\
,\n    //,\n    /:,\n    =, :=, ^=, ^:=, =.\n    ;,\n    {}\nAn operator with higher priority is operated first. An expression enc\
losed in () is evaluated first. Most mathematical operations are threaded into a list, i.e., {a,b} + {c,d} gives {a + b,c + d}, et\
c.\n   Each operators can be used as a function using its name. For example, Plus[x,y] gives the same result as x + y."[p$1913,
           p1$1913],Format->Help2HTML`oB$];
        System["mv -f "//out$1913//" "//equ$1913]];
      Exit[]]];
   "An expression in FFS consists of a symbol, constants, and operators.\n\n>>> A symbol is a characters of any length starting wi\
th an alphabet or $.\n>>> There are two kinds of constants, real number and character-string.\n    real number is a number in fort\
ran-line format.\n    character-string is a set of characters surrounded by \"\" or ''.\n    special-characters can be specified w\
ith backslash.\n>>> Available operators are (in the order of the priority):\n    #,##,\n    ?,\n    ::,\n    @,\n    [],\n    ++, \
--,\n    /@, //@, @@,\n    .,\n    ^,\n    *, /,\n    +, -,\n    ==, <>, >, <, >=, =>, <=, =<, \n    ===, <=>, \n    ~, \n    &&,\\
n    ||,\n    .., ...,\n    |,\n    :,\n    ->, :>,\n    /., //.,\n    +=, -=, *=, /=,\n    &,\n    //,\n    /:,\n    =, :=, ^=, ^\
:=, =.\n    ;,\n    {}\nAn operator with higher priority is operated first. An expression enclosed in () is evaluated first. Most \
mathematical operations are threaded into a list, i.e., {a,b} + {c,d} gives {a + b,c + d}, etc.\n   Each operators can be used as \
a function using its name. For example, Plus[x,y] gives the same result as x + y."[1,Max[p0$1913,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$1913//"\" />"//
Help2HTML`oy$["An expression in FFS consists of a symbol, constants, and operators.\n\n>>> A symbol is a characters of any length \
starting with an alphabet or $.\n>>> There are two kinds of constants, real number and character-string.\n    real number is a num\
ber in fortran-line format.\n    character-string is a set of characters surrounded by \"\" or ''.\n    special-characters can be \
specified with backslash.\n>>> Available operators are (in the order of the priority):\n    #,##,\n    ?,\n    ::,\n    @,\n    []\
,\n    ++, --,\n    /@, //@, @@,\n    .,\n    ^,\n    *, /,\n    +, -,\n    ==, <>, >, <, >=, =>, <=, =<, \n    ===, <=>, \n    ~,\
 \n    &&,\n    ||,\n    .., ...,\n    |,\n    :,\n    ->, :>,\n    /., //.,\n    +=, -=, *=, /=,\n    &,\n    //,\n    /:,\n    =\
, :=, ^=, ^:=, =.\n    ;,\n    {}\nAn operator with higher priority is operated first. An expression enclosed in () is evaluated f\
irst. Most mathematical operations are threaded into a list, i.e., {a,b} + {c,d} gives {a + b,c + d}, etc.\n   Each operators can \
be used as a function using its name. For example, Plus[x,y] gives the same result as x + y."[p2$1913,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L31>constants</A> <A HREF=#L358>functions</A> <A HREF=#L29>command-syntax</A> <A HREF=#L15>character-string</A></PRE>
<UL>
<LI>
<H3><A NAME=L247>
(-)</A></H3>
<PRE>If[{},Help2HTML`oA$["operator for subtraction or unary minus."],
 p$1916=1+p$1916[[1,2]];p1$1916=StringPosition["operator for subtraction or unary minus."[p$1916,-1],">::",1];
  p1$1916=If[p1$1916==={},40,-2+p$1916+p1$1916[[1,1]]];
  neq=Which["operator for subtraction or unary minus."[p$1916,4+p$1916]==="Text[",
    lx$1916:=Help2HTML`oa$;p$1916=5+p$1916;p1$1916-=1;p2$1916=5+p1$1916;p0$1916=-9+p$1916;
     If[(pe$1916=StringPosition["operator for subtraction or unary minus."[p$1916,-2],";;;"])<=>{},
      {Max[0,-1+ToExpression["operator for subtraction or unary minus."[p$1916+pe$1916[[1,2]],p1$1916]]],
       p1$1916=-2+p$1916+pe$1916[[1,1]]}[[1]],
      0],
    1,lx$1916:=Help2HTML`o9$;p2$1916=4+p1$1916;p0$1916=-4+p$1916;0];
  If[(equ$1916=Help2HTML`o8$["operator for subtraction or unary minus."[p$1916,p1$1916]])===Undefined,
   equ$1916="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["operator for subtraction or unary minus."[p$1916,p1$1916]]=equ$1916;LaTeX`ob$+=neq,
     --LaTeX`ob$;With[{lx$1916},
       out$1916=lx$1916@Typeset["operator for subtraction or unary minus."[p$1916,p1$1916],Format->Help2HTML`oB$];
        System["mv -f "//out$1916//" "//equ$1916]];
      Exit[]]];
   "operator for subtraction or unary minus."[1,Max[p0$1916,0]]//"<img  class=\"eqs\" SRC=\""//equ$1916//"\" />"//
   Help2HTML`oy$["operator for subtraction or unary minus."[p2$1916,-1]]
]</PRE>
<LI>
<H3><A NAME=L248>
(/)</A></H3>
<PRE>If[{},Help2HTML`oA$["operator for division."],
 p$1918=1+p$1918[[1,2]];p1$1918=StringPosition["operator for division."[p$1918,-1],">::",1];
  p1$1918=If[p1$1918==={},22,-2+p$1918+p1$1918[[1,1]]];
  neq=Which["operator for division."[p$1918,4+p$1918]==="Text[",lx$1918:=Help2HTML`oa$;p$1918=5+p$1918;p1$1918-=1;
     p2$1918=5+p1$1918;p0$1918=-9+p$1918;
     If[(pe$1918=StringPosition["operator for division."[p$1918,-2],";;;"])<=>{},{Max[0,-1+ToExpression["operator for division."[
            p$1918+pe$1918[[1,2]],
           p1$1918]]],
        p1$1918=-2+p$1918+pe$1918[[1,1]]}[[
       1]],
      0],
    1,lx$1918:=Help2HTML`o9$;p2$1918=4+p1$1918;p0$1918=-4+p$1918;0];
  If[(equ$1918=Help2HTML`o8$["operator for division."[p$1918,p1$1918]])===Undefined,
   equ$1918="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["operator for division."[p$1918,p1$1918]]=equ$1918;LaTeX`ob$+=neq,
     --LaTeX`ob$;With[{lx$1918},out$1918=lx$1918@Typeset["operator for division."[p$1918,p1$1918],Format->Help2HTML`oB$];
        System["mv -f "//out$1918//" "//equ$1918]];
      Exit[]]];
   "operator for division."[1,Max[p0$1918,0]]//"<img  class=\"eqs\" SRC=\""//equ$1918//"\" />"//
   Help2HTML`oy$["operator for division."[p2$1918,-1]]
]</PRE>
<LI>
<H3><A NAME=L249>
AddTo(+=)</A></H3>
<PRE>If[{},Help2HTML`oA$["a+=b is equivalent to a=a+b ."],
 p$1920=1+p$1920[[1,2]];p1$1920=StringPosition["a+=b is equivalent to a=a+b ."[p$1920,-1],">::",1];
  p1$1920=If[p1$1920==={},29,-2+p$1920+p1$1920[[1,1]]];
  neq=Which["a+=b is equivalent to a=a+b ."[p$1920,4+p$1920]==="Text[",lx$1920:=Help2HTML`oa$;p$1920=5+p$1920;p1$1920-=1;
     p2$1920=5+p1$1920;p0$1920=-9+p$1920;
     If[(pe$1920=StringPosition["a+=b is equivalent to a=a+b ."[p$1920,-2],";;;"])<=>{},{Max[0,
        -1+ToExpression["a+=b is equivalent to a=a+b ."[p$1920+pe$1920[[1,2]],p1$1920]]],p1$1920=-2+p$1920+pe$1920[[1,1]]}[[
       1]],
      0],
    1,lx$1920:=Help2HTML`o9$;p2$1920=4+p1$1920;p0$1920=-4+p$1920;0];
  If[(equ$1920=Help2HTML`o8$["a+=b is equivalent to a=a+b ."[p$1920,p1$1920]])===Undefined,
   equ$1920="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["a+=b is equivalent to a=a+b ."[p$1920,p1$1920]]=equ$1920;LaTeX`ob$+=neq,
     --LaTeX`ob$;With[{lx$1920},out$1920=lx$1920@Typeset["a+=b is equivalent to a=a+b ."[p$1920,p1$1920],Format->Help2HTML`oB$];
        System["mv -f "//out$1920//" "//equ$1920]];
      Exit[]]];
   "a+=b is equivalent to a=a+b ."[1,Max[p0$1920,0]]//"<img  class=\"eqs\" SRC=\""//equ$1920//"\" />"//
   Help2HTML`oy$["a+=b is equivalent to a=a+b ."[p2$1920,-1]]
]</PRE>
<LI>
<H3><A NAME=L250>
Alternatives(|)</A></H3>
<PRE>If[{},Help2HTML`oA$["a | b | ... represents a pattern which matches one of patterns a, b, ..."],
 p$1922=1+p$1922[[1,2]];p1$1922=
   StringPosition["a | b | ... represents a pattern which matches one of patterns a, b, ..."[p$1922,-1],">::",1];
  p1$1922=If[p1$1922==={},72,-2+p$1922+p1$1922[[1,1]]];
  neq=Which["a | b | ... represents a pattern which matches one of patterns a, b, ..."[p$1922,4+p$1922]==="Text[",
    lx$1922:=Help2HTML`oa$;p$1922=5+p$1922;p1$1922-=1;p2$1922=5+p1$1922;p0$1922=-9+p$1922;
     If[(pe$1922=StringPosition["a | b | ... represents a pattern which matches one of patterns a, b, ..."[p$1922,-2],";;;"])<=>{},
      {Max[0,
        -1+ToExpression["a | b | ... represents a pattern which matches one of patterns a, b, ..."[p$1922+pe$1922[[1,2]],p1$1922]]
        ],p1$1922=-2+p$1922+pe$1922[[1,1]]}[[
       1]],
      0],
    1,lx$1922:=Help2HTML`o9$;p2$1922=4+p1$1922;p0$1922=-4+p$1922;0];
  If[(equ$1922=Help2HTML`o8$["a | b | ... represents a pattern which matches one of patterns a, b, ..."[p$1922,p1$1922]])===
    Undefined,
   equ$1922="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "a | b | ... represents a pattern which matches one of patterns a, b, ..."[p$1922,p1$1922]]=
       equ$1922;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$1922},out$1922=lx$1922@Typeset["a | b | ... represents a pattern which matches one of patterns a, b, ..."[p$1922,
           p1$1922],Format->Help2HTML`oB$];
        System["mv -f "//out$1922//" "//equ$1922]];
      Exit[]]];
   "a | b | ... represents a pattern which matches one of patterns a, b, ..."[1,Max[p0$1922,0]]//"<img  class=\"eqs\" SRC=\""//
   equ$1922//"\" />"//Help2HTML`oy$["a | b | ... represents a pattern which matches one of patterns a, b, ..."[p2$1922,-1]]
 ]
</PRE>
<LI>
<H3><A NAME=L251>
And(&&)</A></H3>
<PRE>If[{},
 Help2HTML`oA$[
  " a && b returns True(==1) when both a and b are nonzero real,  False(==0) otherwise. b is not evaluated when a is zero."],
 p$1924=1+p$1924[[1,2]];
  p1$1924=StringPosition[
    " a && b returns True(==1) when both a and b are nonzero real,  False(==0) otherwise. b is not evaluated when a is zero."[p
     $1924,-1],
    ">::",1];
   p1$1924=If[p1$1924==={},119,-2+p$1924+p1$1924[[1,1]]];
  neq=Which[
     " a && b returns True(==1) when both a and b are nonzero real,  False(==0) otherwise. b is not evaluated when a is zero."[p
      $1924,4+p$1924]===
     "Text[",
    lx$1924:=Help2HTML`oa$;p$1924=5+p$1924;p1$1924-=1;p2$1924=5+p1$1924;p0$1924=-9+p$1924;If[(pe$1924=StringPosition[
         " a && b returns True(==1) when both a and b are nonzero real,  False(==0) otherwise. b is not evaluated when a is zero."[
          p$1924,-2],
         ";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression[
          " a && b returns True(==1) when both a and b are nonzero real,  False(==0) otherwise. b is not evaluated when a is zero."
          [p$1924+pe$1924[[1,2]],p1$1924]]],
        p1$1924=-2+p$1924+pe$1924[[1,1]]}[[
       1]],
      0],
    1,lx$1924:=Help2HTML`o9$;p2$1924=4+p1$1924;p0$1924=-4+p$1924;0];
  If[(equ$1924=
     Help2HTML`o8$[
      " a && b returns True(==1) when both a and b are nonzero real,  False(==0) otherwise. b is not evaluated when a is zero."[p
       $1924,p1$1924]])===
    Undefined,
   equ$1924="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        " a && b returns True(==1) when both a and b are nonzero real,  False(==0) otherwise. b is not evaluated when a is zero."[
         p$1924,p1$1924]]=
       equ$1924;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$1924},out$1924=lx$1924@Typeset[
          " a && b returns True(==1) when both a and b are nonzero real,  False(==0) otherwise. b is not evaluated when a is zero."
          [p$1924,p1$1924],Format->Help2HTML`oB$];
        System["mv -f "//out$1924//" "//equ$1924]];
      Exit[]]];
  " a && b returns True(==1) when both a and b are nonzero real,  False(==0) otherwise. b is not evaluated when a is zero."[1,
    Max[p0$1924,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$1924//"\" />"//
   Help2HTML`oy$[
    " a && b returns True(==1) when both a and b are nonzero real,  False(==0) otherwise. b is not evaluated when a is zero."[p2
     $1924,-1]]
]</PRE>
<LI>
<H3><A NAME=L252>
Apply (@@)</A></H3>
<PRE>If[{},Help2HTML`oA$["f@@a applies function f to subexpressions of a. f@@[a,level] specifies a levelspec to apply by level."],
 p$1926=1+p$1926[[1,2]];
  p1$1926=StringPosition["f@@a applies function f to subexpressions of a. f@@[a,level] specifies a levelspec to apply by level."[
     p$1926,-1],
    ">::",1];
   p1$1926=If[p1$1926==={},101,-2+p$1926+p1$1926[[1,1]]];
  neq=Which["f@@a applies function f to subexpressions of a. f@@[a,level] specifies a levelspec to apply by level."[p$1926,4+p$1926
      ]===
     "Text[",
    lx$1926:=Help2HTML`oa$;p$1926=5+p$1926;p1$1926-=1;p2$1926=5+p1$1926;p0$1926=-9+p$1926;If[(pe$1926=StringPosition[
         "f@@a applies function f to subexpressions of a. f@@[a,level] specifies a levelspec to apply by level."[p$1926,-2],";;;"]
        )<=>
       {},
      {Max[0,
        -1+ToExpression["f@@a applies function f to subexpressions of a. f@@[a,level] specifies a levelspec to apply by level."[p
            $1926+pe$1926[[1,2]],
           p1$1926]]],
        p1$1926=-2+p$1926+pe$1926[[1,1]]}[[
       1]],
      0],
    1,lx$1926:=Help2HTML`o9$;p2$1926=4+p1$1926;p0$1926=-4+p$1926;0];
  If[(equ$1926=
     Help2HTML`o8$["f@@a applies function f to subexpressions of a. f@@[a,level] specifies a levelspec to apply by level."[p$1926,
       p1$1926]])===
    Undefined,
   equ$1926="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "f@@a applies function f to subexpressions of a. f@@[a,level] specifies a levelspec to apply by level."[p$1926,p1$1926]]=
       equ$1926;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$1926},out$1926=lx$1926@Typeset[
          "f@@a applies function f to subexpressions of a. f@@[a,level] specifies a levelspec to apply by level."[p$1926,p1$1926],
          Format->Help2HTML`oB$];
        System["mv -f "//out$1926//" "//equ$1926]];
      Exit[]]];
   "f@@a applies function f to subexpressions of a. f@@[a,level] specifies a levelspec to apply by level."[1,Max[p0$1926,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$1926//"\" />"//
   Help2HTML`oy$["f@@a applies function f to subexpressions of a. f@@[a,level] specifies a levelspec to apply by level."[p2$1926,-1
     ]]
]</PRE>
<PRE>See also:
 <A HREF=#L368>Apply</A></PRE>
<LI>
<H3><A NAME=L253>
CompoundExpression(;)</A></H3>
<PRE>If[{},Help2HTML`oA$["a ; b evaluates a, then evaluates b and returns its result."],
 p$1929=1+p$1929[[1,2]];p1$1929=StringPosition["a ; b evaluates a, then evaluates b and returns its result."[p$1929,-1],">::",1];
  p1$1929=If[p1$1929==={},59,-2+p$1929+p1$1929[[1,1]]];
  neq=Which["a ; b evaluates a, then evaluates b and returns its result."[p$1929,4+p$1929]==="Text[",
    lx$1929:=Help2HTML`oa$;p$1929=5+p$1929;p1$1929-=1;p2$1929=5+p1$1929;p0$1929=-9+p$1929;
     If[(pe$1929=StringPosition["a ; b evaluates a, then evaluates b and returns its result."[p$1929,-2],";;;"])<=>{},
      {Max[0,-1+ToExpression["a ; b evaluates a, then evaluates b and returns its result."[p$1929+pe$1929[[1,2]],p1$1929]]],
       p1$1929=-2+p$1929+pe$1929[[1,1]]}[[1]],
      0],
    1,lx$1929:=Help2HTML`o9$;p2$1929=4+p1$1929;p0$1929=-4+p$1929;0];
  If[(equ$1929=Help2HTML`o8$["a ; b evaluates a, then evaluates b and returns its result."[p$1929,p1$1929]])===Undefined,
   equ$1929="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["a ; b evaluates a, then evaluates b and returns its result."[p$1929,p1$1929]]=equ$1929;
      LaTeX`ob$+=neq,
     --LaTeX`ob$;With[{lx$1929},out$1929=lx$1929@Typeset["a ; b evaluates a, then evaluates b and returns its result."[p$1929,
           p1$1929],Format->Help2HTML`oB$];
        System["mv -f "//out$1929//" "//equ$1929]];
      Exit[]]];
   "a ; b evaluates a, then evaluates b and returns its result."[1,Max[p0$1929,0]]//"<img  class=\"eqs\" SRC=\""//equ$1929//
   "\" />"//Help2HTML`oy$["a ; b evaluates a, then evaluates b and returns its result."[p2$1929,-1]]
]</PRE>
<LI>
<H3><A NAME=L254>
Decrement(--)</A></H3>
<PRE>If[{},
 Help2HTML`oA$["a-- decrements a by 1, returning the old value of a. --a decrements a by 1, returning the new value of a."],
 p$1931=1+p$1931[[1,2]];
  p1$1931=StringPosition[
    "a-- decrements a by 1, returning the old value of a. --a decrements a by 1, returning the new value of a."[p$1931,-1],">::",
    1];
   p1$1931=If[p1$1931==={},105,-2+p$1931+p1$1931[[1,1]]];
  neq=Which["a-- decrements a by 1, returning the old value of a. --a decrements a by 1, returning the new value of a."[p$1931,
      4+p$1931]===
     "Text[",
    lx$1931:=Help2HTML`oa$;p$1931=5+p$1931;p1$1931-=1;p2$1931=5+p1$1931;p0$1931=-9+p$1931;If[(pe$1931=StringPosition[
         "a-- decrements a by 1, returning the old value of a. --a decrements a by 1, returning the new value of a."[p$1931,-2],
         ";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression["a-- decrements a by 1, returning the old value of a. --a decrements a by 1, returning the new value of a."
          [p$1931+pe$1931[[1,2]],p1$1931]]],
        p1$1931=-2+p$1931+pe$1931[[1,1]]}[[
       1]],
      0],
    1,lx$1931:=Help2HTML`o9$;p2$1931=4+p1$1931;p0$1931=-4+p$1931;0];
  If[(equ$1931=
     Help2HTML`o8$["a-- decrements a by 1, returning the old value of a. --a decrements a by 1, returning the new value of a."[p
       $1931,p1$1931]])===
    Undefined,
   equ$1931="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "a-- decrements a by 1, returning the old value of a. --a decrements a by 1, returning the new value of a."[p$1931,p1$1931]
        ]=
       equ$1931;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$1931},out$1931=lx$1931@Typeset[
          "a-- decrements a by 1, returning the old value of a. --a decrements a by 1, returning the new value of a."[p$1931,
           p1$1931],Format->Help2HTML`oB$];
        System["mv -f "//out$1931//" "//equ$1931]];
      Exit[]]];
   "a-- decrements a by 1, returning the old value of a. --a decrements a by 1, returning the new value of a."[1,Max[p0$1931,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$1931//"\" />"//
   Help2HTML`oy$["a-- decrements a by 1, returning the old value of a. --a decrements a by 1, returning the new value of a."[p2
     $1931,-1]]
]</PRE>
<LI>
<H3><A NAME=L255>
DivideBy(/=)</A></H3>
<PRE>If[{},Help2HTML`oA$["a/=b is equivalent to a=a/b."],
 p$1933=1+p$1933[[1,2]];p1$1933=StringPosition["a/=b is equivalent to a=a/b."[p$1933,-1],">::",1];
  p1$1933=If[p1$1933==={},28,-2+p$1933+p1$1933[[1,1]]];
  neq=Which["a/=b is equivalent to a=a/b."[p$1933,4+p$1933]==="Text[",lx$1933:=Help2HTML`oa$;p$1933=5+p$1933;p1$1933-=1;
     p2$1933=5+p1$1933;p0$1933=-9+p$1933;
     If[(pe$1933=StringPosition["a/=b is equivalent to a=a/b."[p$1933,-2],";;;"])<=>{},{Max[0,-1+
         ToExpression["a/=b is equivalent to a=a/b."[p$1933+pe$1933[[1,2]],p1$1933]]],
        p1$1933=-2+p$1933+pe$1933[[1,1]]}[[
       1]],
      0],
    1,lx$1933:=Help2HTML`o9$;p2$1933=4+p1$1933;p0$1933=-4+p$1933;0];
  If[(equ$1933=Help2HTML`o8$["a/=b is equivalent to a=a/b."[p$1933,p1$1933]])===Undefined,
   equ$1933="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["a/=b is equivalent to a=a/b."[p$1933,p1$1933]]=equ$1933;LaTeX`ob$+=neq,
     --LaTeX`ob$;With[{lx$1933},out$1933=lx$1933@Typeset["a/=b is equivalent to a=a/b."[p$1933,p1$1933],Format->Help2HTML`oB$];
        System["mv -f "//out$1933//" "//equ$1933]];
      Exit[]]];
   "a/=b is equivalent to a=a/b."[1,Max[p0$1933,0]]//"<img  class=\"eqs\" SRC=\""//equ$1933//"\" />"//
   Help2HTML`oy$["a/=b is equivalent to a=a/b."[p2$1933,-1]]
]</PRE>
<LI>
<H3><A NAME=L256>
Dot(.)</A></H3>
<PRE>If[{},Help2HTML`oA$["a . b returns the inner product of a and b."],
 p$1935=1+p$1935[[1,2]];p1$1935=StringPosition["a . b returns the inner product of a and b."[p$1935,-1],">::",1];
  p1$1935=If[p1$1935==={},43,-2+p$1935+p1$1935[[1,1]]];
  neq=Which["a . b returns the inner product of a and b."[p$1935,4+p$1935]==="Text[",
    lx$1935:=Help2HTML`oa$;p$1935=5+p$1935;p1$1935-=1;p2$1935=5+p1$1935;p0$1935=-9+p$1935;
     If[(pe$1935=StringPosition["a . b returns the inner product of a and b."[p$1935,-2],";;;"])<=>{},
      {Max[0,-1+ToExpression["a . b returns the inner product of a and b."[p$1935+pe$1935[[1,2]],p1$1935]]],
       p1$1935=-2+p$1935+pe$1935[[1,1]]}[[1]],
      0],
    1,lx$1935:=Help2HTML`o9$;p2$1935=4+p1$1935;p0$1935=-4+p$1935;0];
  If[(equ$1935=Help2HTML`o8$["a . b returns the inner product of a and b."[p$1935,p1$1935]])===Undefined,
   equ$1935="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["a . b returns the inner product of a and b."[p$1935,p1$1935]]=equ$1935;LaTeX`ob$+=neq,
     --LaTeX`ob$;With[{lx$1935},
       out$1935=lx$1935@Typeset["a . b returns the inner product of a and b."[p$1935,p1$1935],Format->Help2HTML`oB$];
        System["mv -f "//out$1935//" "//equ$1935]];
      Exit[]]];
   "a . b returns the inner product of a and b."[1,Max[p0$1935,0]]//"<img  class=\"eqs\" SRC=\""//equ$1935//"\" />"//
   Help2HTML`oy$["a . b returns the inner product of a and b."[p2$1935,-1]]
]</PRE>
<LI>
<H3><A NAME=L257>
Equal(==)</A></H3>
<PRE>If[{},
Help2HTML`oA$["a == b returns True(==1) if a and b are both Real with the same value or a String with same length and value. If on\
e of a or b is a list, or both are lists with same size, returns a list of element-wise results."],
 p$1937=1+p$1937[[1,2]];p1$1937=StringPosition["a == b returns True(==1) if a and b are both Real with the same value or a String \
with same length and value. If one of a or b is a list, or both are lists with same size, returns a list of element-wise results."[
     p$1937,-1],
    ">::",1];
   p1$1937=If[p1$1937==={},211,-2+p$1937+p1$1937[[1,1]]];
neq=Which["a == b returns True(==1) if a and b are both Real with the same value or a String with same length and value. If one of\
 a or b is a list, or both are lists with same size, returns a list of element-wise results."[p$1937,4+p$1937]==="Text[",
    lx$1937:=Help2HTML`oa$;p$1937=5+p$1937;p1$1937-=1;p2$1937=5+p1$1937;p0$1937=-9+p$1937;
If[(pe$1937=StringPosition["a == b returns True(==1) if a and b are both Real with the same value or a String with same length and\
 value. If one of a or b is a list, or both are lists with same size, returns a list of element-wise results."[p$1937,-2],";;;"]
        )<=>
       {},
      {Max[0,
-1+ToExpression["a == b returns True(==1) if a and b are both Real with the same value or a String with same length and value. If \
one of a or b is a list, or both are lists with same size, returns a list of element-wise results."[p$1937+pe$1937[[1,2]],p1$1937]]
        ],p1$1937=-2+p$1937+pe$1937[[1,1]]}[[
       1]],
      0],
    1,lx$1937:=Help2HTML`o9$;p2$1937=4+p1$1937;p0$1937=-4+p$1937;0];
  If[(equ$1937=
Help2HTML`o8$["a == b returns True(==1) if a and b are both Real with the same value or a String with same length and value. If on\
e of a or b is a list, or both are lists with same size, returns a list of element-wise results."[p$1937,p1$1937]])===
    Undefined,
equ$1937="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["a == b returns True(==1) if a and b are both\
 Real with the same value or a String with same length and value. If one of a or b is a list, or both are lists with same size, re\
turns a list of element-wise results."[p$1937,p1$1937]]=
       equ$1937;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1937},out$1937=lx$1937@Typeset["a == b returns True(==1) if a and b are both Real with the same value or a String with sa\
me length and value. If one of a or b is a list, or both are lists with same size, returns a list of element-wise results."[p$1937,
           p1$1937],Format->Help2HTML`oB$];
        System["mv -f "//out$1937//" "//equ$1937]];
      Exit[]]];
   "a == b returns True(==1) if a and b are both Real with the same value or a String with same length and value. If one of a or b\
 is a list, or both are lists with same size, returns a list of element-wise results."[1,Max[p0$1937,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$1937//"\" />"//
Help2HTML`oy$["a == b returns True(==1) if a and b are both Real with the same value or a String with same length and value. If on\
e of a or b is a list, or both are lists with same size, returns a list of element-wise results."[p2$1937,-1]]
]</PRE>
<LI>
<H3><A NAME=L258>
Function(&)</A></H3>
<PRE>If[{},Help2HTML`oA$[" a & is a pure-function whose argument is specified #, #n, ##, ##n."],
 p$1939=1+p$1939[[1,2]];p1$1939=StringPosition[" a & is a pure-function whose argument is specified #, #n, ##, ##n."[p$1939,-1],
    ">::",1];
   p1$1939=If[p1$1939==={},67,-2+p$1939+p1$1939[[1,1]]];
  neq=Which[" a & is a pure-function whose argument is specified #, #n, ##, ##n."[p$1939,4+p$1939]==="Text[",
    lx$1939:=Help2HTML`oa$;p$1939=5+p$1939;p1$1939-=1;p2$1939=5+p1$1939;p0$1939=-9+p$1939;
     If[(pe$1939=StringPosition[" a & is a pure-function whose argument is specified #, #n, ##, ##n."[p$1939,-2],";;;"])<=>{},
      {Max[0,-1+ToExpression[" a & is a pure-function whose argument is specified #, #n, ##, ##n."[p$1939+pe$1939[[1,2]],p1$1939]]
        ],p1$1939=-2+p$1939+pe$1939[[1,1]]}[[
       1]],
      0],
    1,lx$1939:=Help2HTML`o9$;p2$1939=4+p1$1939;p0$1939=-4+p$1939;0];
  If[(equ$1939=Help2HTML`o8$[" a & is a pure-function whose argument is specified #, #n, ##, ##n."[p$1939,p1$1939]])===Undefined,
   equ$1939="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$[" a & is a pure-function whose argument is specified #, #n, ##, ##n."[p$1939,p1$1939]]=equ$1939;
      LaTeX`ob$+=neq,
     --LaTeX`ob$;With[{lx$1939},out$1939=lx$1939@Typeset[" a & is a pure-function whose argument is specified #, #n, ##, ##n."[p
           $1939,p1$1939],Format->Help2HTML`oB$];
        System["mv -f "//out$1939//" "//equ$1939]];
      Exit[]]];
   " a & is a pure-function whose argument is specified #, #n, ##, ##n."[1,Max[p0$1939,0]]//"<img  class=\"eqs\" SRC=\""//
   equ$1939//"\" />"//Help2HTML`oy$[" a & is a pure-function whose argument is specified #, #n, ##, ##n."[p2$1939,-1]]
]</PRE>
<PRE>See also:
 Slot(#) SlotSequence(##) <A HREF=#L358>functions</A> <A HREF=#L258>Function(&)</A></PRE>
<LI>
<H3><A NAME=L259>
Greater(>)</A></H3>
<PRE>If[{},
Help2HTML`oA$["If both a and b are real, a > b returns True if a is greater than b, False otherwise. If one of a or b is a list, o\
r both are lists with same size, returns a list of element-wise results."],
p$1942=1+p$1942[[1,2]];p1$1942=StringPosition["If both a and b are real, a > b returns True if a is greater than b, False otherwis\
e. If one of a or b is a list, or both are lists with same size, returns a list of element-wise results."[p$1942,-1],">::",1];
   p1$1942=If[p1$1942==={},187,-2+p$1942+p1$1942[[1,1]]];
neq=Which["If both a and b are real, a > b returns True if a is greater than b, False otherwise. If one of a or b is a list, or bo\
th are lists with same size, returns a list of element-wise results."[p$1942,4+p$1942]==="Text[",
    lx$1942:=Help2HTML`oa$;p$1942=5+p$1942;p1$1942-=1;p2$1942=5+p1$1942;p0$1942=-9+p$1942;
If[(pe$1942=StringPosition["If both a and b are real, a > b returns True if a is greater than b, False otherwise. If one of a or b\
 is a list, or both are lists with same size, returns a list of element-wise results."[p$1942,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["If both a and b are real, a > b returns True if a is greater than b, False otherwise. If one of a or b is a list,\
 or both are lists with same size, returns a list of element-wise results."[p$1942+pe$1942[[1,2]],p1$1942]]],
        p1$1942=-2+p$1942+pe$1942[[1,1]]}[[
       1]],
      0],
    1,lx$1942:=Help2HTML`o9$;p2$1942=4+p1$1942;p0$1942=-4+p$1942;0];
  If[(equ$1942=
Help2HTML`o8$["If both a and b are real, a > b returns True if a is greater than b, False otherwise. If one of a or b is a list, o\
r both are lists with same size, returns a list of element-wise results."[p$1942,p1$1942]])===
    Undefined,
equ$1942="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["If both a and b are real, a > b returns True\
 if a is greater than b, False otherwise. If one of a or b is a list, or both are lists with same size, returns a list of element-\
wise results."[p$1942,p1$1942]]=
       equ$1942;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1942},out$1942=lx$1942@Typeset["If both a and b are real, a > b returns True if a is greater than b, False otherwise. If \
one of a or b is a list, or both are lists with same size, returns a list of element-wise results."[p$1942,p1$1942],
          Format->Help2HTML`oB$];
        System["mv -f "//out$1942//" "//equ$1942]];
      Exit[]]];
   "If both a and b are real, a > b returns True if a is greater than b, False otherwise. If one of a or b is a list, or both are \
lists with same size, returns a list of element-wise results."[1,Max[p0$1942,0]]//"<img  class=\"eqs\" SRC=\""//equ$1942//"\" />"//
   Help2HTML`oy$["If both a and b are real, a > b returns True if a is greater than b, False otherwise. If one of a or b is a list\
, or both are lists with same size, returns a list of element-wise results."[p2$1942,-1]]
]</PRE>
<LI>
<H3><A NAME=L260>
GreaterEqual(>= or =>)</A></H3>
<PRE>If[{},
Help2HTML`oA$["If both a and b are real, a => b returns True if a is greater than or equal to b, False otherwise. If one of a or b\
 is a list, or both are lists with same size, returns a list of element-wise results."],
 p$1944=1+p$1944[[1,2]];p1$1944=StringPosition["If both a and b are real, a => b returns True if a is greater than or equal to b, \
False otherwise. If one of a or b is a list, or both are lists with same size, returns a list of element-wise results."[p$1944,-1],
    ">::",1];
   p1$1944=If[p1$1944==={},200,-2+p$1944+p1$1944[[1,1]]];
neq=Which["If both a and b are real, a => b returns True if a is greater than or equal to b, False otherwise. If one of a or b is \
a list, or both are lists with same size, returns a list of element-wise results."[p$1944,4+p$1944]==="Text[",
    lx$1944:=Help2HTML`oa$;p$1944=5+p$1944;p1$1944-=1;p2$1944=5+p1$1944;p0$1944=-9+p$1944;
If[(pe$1944=StringPosition["If both a and b are real, a => b returns True if a is greater than or equal to b, False otherwise. If \
one of a or b is a list, or both are lists with same size, returns a list of element-wise results."[p$1944,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["If both a and b are real, a => b returns True if a is greater than or equal to b, False otherwise. If one of a or\
 b is a list, or both are lists with same size, returns a list of element-wise results."[p$1944+pe$1944[[1,2]],p1$1944]]],
        p1$1944=-2+p$1944+pe$1944[[1,1]]}[[
       1]],
      0],
    1,lx$1944:=Help2HTML`o9$;p2$1944=4+p1$1944;p0$1944=-4+p$1944;0];
  If[(equ$1944=
Help2HTML`o8$["If both a and b are real, a => b returns True if a is greater than or equal to b, False otherwise. If one of a or b\
 is a list, or both are lists with same size, returns a list of element-wise results."[p$1944,p1$1944]])===
    Undefined,
equ$1944="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["If both a and b are real, a => b returns Tru\
e if a is greater than or equal to b, False otherwise. If one of a or b is a list, or both are lists with same size, returns a lis\
t of element-wise results."[p$1944,p1$1944]]=
       equ$1944;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1944},out$1944=lx$1944@Typeset["If both a and b are real, a => b returns True if a is greater than or equal to b, False o\
therwise. If one of a or b is a list, or both are lists with same size, returns a list of element-wise results."[p$1944,p1$1944],
          Format->Help2HTML`oB$];
        System["mv -f "//out$1944//" "//equ$1944]];
      Exit[]]];
   "If both a and b are real, a => b returns True if a is greater than or equal to b, False otherwise. If one of a or b is a list,\
 or both are lists with same size, returns a list of element-wise results."[1,Max[p0$1944,0]]//"<img  class=\"eqs\" SRC=\""//
   equ$1944//"\" />"//
Help2HTML`oy$["If both a and b are real, a => b returns True if a is greater than or equal to b, False otherwise. If one of a or b\
 is a list, or both are lists with same size, returns a list of element-wise results."[p2$1944,-1]]
]</PRE>
<LI>
<H3><A NAME=L261>
Increment(++)</A></H3>
<PRE>If[{},
 Help2HTML`oA$["a++ increments a by 1, returning the old value of a. ++a increments a by 1, returning the new value of a."],
 p$1946=1+p$1946[[1,2]];
  p1$1946=StringPosition[
    "a++ increments a by 1, returning the old value of a. ++a increments a by 1, returning the new value of a."[p$1946,-1],">::",
    1];
   p1$1946=If[p1$1946==={},105,-2+p$1946+p1$1946[[1,1]]];
  neq=Which["a++ increments a by 1, returning the old value of a. ++a increments a by 1, returning the new value of a."[p$1946,
      4+p$1946]===
     "Text[",
    lx$1946:=Help2HTML`oa$;p$1946=5+p$1946;p1$1946-=1;p2$1946=5+p1$1946;p0$1946=-9+p$1946;If[(pe$1946=StringPosition[
         "a++ increments a by 1, returning the old value of a. ++a increments a by 1, returning the new value of a."[p$1946,-2],
         ";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression["a++ increments a by 1, returning the old value of a. ++a increments a by 1, returning the new value of a."
          [p$1946+pe$1946[[1,2]],p1$1946]]],
        p1$1946=-2+p$1946+pe$1946[[1,1]]}[[
       1]],
      0],
    1,lx$1946:=Help2HTML`o9$;p2$1946=4+p1$1946;p0$1946=-4+p$1946;0];
  If[(equ$1946=
     Help2HTML`o8$["a++ increments a by 1, returning the old value of a. ++a increments a by 1, returning the new value of a."[p
       $1946,p1$1946]])===
    Undefined,
   equ$1946="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "a++ increments a by 1, returning the old value of a. ++a increments a by 1, returning the new value of a."[p$1946,p1$1946]
        ]=
       equ$1946;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$1946},out$1946=lx$1946@Typeset[
          "a++ increments a by 1, returning the old value of a. ++a increments a by 1, returning the new value of a."[p$1946,
           p1$1946],Format->Help2HTML`oB$];
        System["mv -f "//out$1946//" "//equ$1946]];
      Exit[]]];
   "a++ increments a by 1, returning the old value of a. ++a increments a by 1, returning the new value of a."[1,Max[p0$1946,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$1946//"\" />"//
   Help2HTML`oy$["a++ increments a by 1, returning the old value of a. ++a increments a by 1, returning the new value of a."[p2
     $1946,-1]]
]</PRE>
<LI>
<H3><A NAME=L262>
Less(<)</A></H3>
<PRE>If[{},
Help2HTML`oA$["If both a and b are real, a < b returns True if a is less than b, False otherwise. If one of a or b is a list, or b\
oth are lists with same size, returns a list of element-wise results."],
p$1948=1+p$1948[[1,2]];p1$1948=StringPosition["If both a and b are real, a < b returns True if a is less than b, False otherwise. \
If one of a or b is a list, or both are lists with same size, returns a list of element-wise results."[p$1948,-1],">::",1];
   p1$1948=If[p1$1948==={},184,-2+p$1948+p1$1948[[1,1]]];
neq=Which["If both a and b are real, a < b returns True if a is less than b, False otherwise. If one of a or b is a list, or both \
are lists with same size, returns a list of element-wise results."[p$1948,4+p$1948]==="Text[",
    lx$1948:=Help2HTML`oa$;p$1948=5+p$1948;p1$1948-=1;p2$1948=5+p1$1948;p0$1948=-9+p$1948;
If[(pe$1948=StringPosition["If both a and b are real, a < b returns True if a is less than b, False otherwise. If one of a or b is\
 a list, or both are lists with same size, returns a list of element-wise results."[p$1948,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["If both a and b are real, a < b returns True if a is less than b, False otherwise. If one of a or b is a list, or\
 both are lists with same size, returns a list of element-wise results."[p$1948+pe$1948[[1,2]],p1$1948]]],
        p1$1948=-2+p$1948+pe$1948[[1,1]]}[[
       1]],
      0],
    1,lx$1948:=Help2HTML`o9$;p2$1948=4+p1$1948;p0$1948=-4+p$1948;0];
  If[(equ$1948=
Help2HTML`o8$["If both a and b are real, a < b returns True if a is less than b, False otherwise. If one of a or b is a list, or b\
oth are lists with same size, returns a list of element-wise results."[p$1948,p1$1948]])===
    Undefined,
equ$1948="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["If both a and b are real, a < b returns True\
 if a is less than b, False otherwise. If one of a or b is a list, or both are lists with same size, returns a list of element-wis\
e results."[p$1948,p1$1948]]=
       equ$1948;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1948},out$1948=lx$1948@Typeset["If both a and b are real, a < b returns True if a is less than b, False otherwise. If one\
 of a or b is a list, or both are lists with same size, returns a list of element-wise results."[p$1948,p1$1948],
          Format->Help2HTML`oB$];
        System["mv -f "//out$1948//" "//equ$1948]];
      Exit[]]];
   "If both a and b are real, a < b returns True if a is less than b, False otherwise. If one of a or b is a list, or both are lis\
ts with same size, returns a list of element-wise results."[1,Max[p0$1948,0]]//"<img  class=\"eqs\" SRC=\""//equ$1948//"\" />"//
   Help2HTML`oy$["If both a and b are real, a < b returns True if a is less than b, False otherwise. If one of a or b is a list, o\
r both are lists with same size, returns a list of element-wise results."[p2$1948,-1]]
]</PRE>
<LI>
<H3><A NAME=L263>
LessEqual(<= or =<)</A></H3>
<PRE>If[{},
Help2HTML`oA$["If both a and b are real, a <= b returns True if a is less than or equal to b, False otherwise. If one of a or b is\
 a list, or both are lists with same size, returns a list of element-wise results."],
 p$1950=1+p$1950[[1,2]];p1$1950=StringPosition["If both a and b are real, a <= b returns True if a is less than or equal to b, Fal\
se otherwise. If one of a or b is a list, or both are lists with same size, returns a list of element-wise results."[p$1950,-1],
    ">::",1];
   p1$1950=If[p1$1950==={},197,-2+p$1950+p1$1950[[1,1]]];
neq=Which["If both a and b are real, a <= b returns True if a is less than or equal to b, False otherwise. If one of a or b is a l\
ist, or both are lists with same size, returns a list of element-wise results."[p$1950,4+p$1950]==="Text[",
    lx$1950:=Help2HTML`oa$;p$1950=5+p$1950;p1$1950-=1;p2$1950=5+p1$1950;p0$1950=-9+p$1950;
If[(pe$1950=StringPosition["If both a and b are real, a <= b returns True if a is less than or equal to b, False otherwise. If one\
 of a or b is a list, or both are lists with same size, returns a list of element-wise results."[p$1950,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["If both a and b are real, a <= b returns True if a is less than or equal to b, False otherwise. If one of a or b \
is a list, or both are lists with same size, returns a list of element-wise results."[p$1950+pe$1950[[1,2]],p1$1950]]],
        p1$1950=-2+p$1950+pe$1950[[1,1]]}[[
       1]],
      0],
    1,lx$1950:=Help2HTML`o9$;p2$1950=4+p1$1950;p0$1950=-4+p$1950;0];
  If[(equ$1950=
Help2HTML`o8$["If both a and b are real, a <= b returns True if a is less than or equal to b, False otherwise. If one of a or b is\
 a list, or both are lists with same size, returns a list of element-wise results."[p$1950,p1$1950]])===
    Undefined,
equ$1950="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["If both a and b are real, a <= b returns Tru\
e if a is less than or equal to b, False otherwise. If one of a or b is a list, or both are lists with same size, returns a list o\
f element-wise results."[p$1950,p1$1950]]=
       equ$1950;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1950},out$1950=lx$1950@Typeset["If both a and b are real, a <= b returns True if a is less than or equal to b, False othe\
rwise. If one of a or b is a list, or both are lists with same size, returns a list of element-wise results."[p$1950,p1$1950],
          Format->Help2HTML`oB$];
        System["mv -f "//out$1950//" "//equ$1950]];
      Exit[]]];
   "If both a and b are real, a <= b returns True if a is less than or equal to b, False otherwise. If one of a or b is a list, or\
 both are lists with same size, returns a list of element-wise results."[1,Max[p0$1950,0]]//"<img  class=\"eqs\" SRC=\""//
   equ$1950//"\" />"//
Help2HTML`oy$["If both a and b are real, a <= b returns True if a is less than or equal to b, False otherwise. If one of a or b is\
 a list, or both are lists with same size, returns a list of element-wise results."[p2$1950,-1]]
]</PRE>
<LI>
<H3><A NAME=L264>
List({})</A></H3>
<PRE>If[{},Help2HTML`oA$["{a,b,c...} is a list structure."],
 p$1952=1+p$1952[[1,2]];p1$1952=StringPosition["{a,b,c...} is a list structure."[p$1952,-1],">::",1];
  p1$1952=If[p1$1952==={},31,-2+p$1952+p1$1952[[1,1]]];
  neq=Which["{a,b,c...} is a list structure."[p$1952,4+p$1952]==="Text[",lx$1952:=Help2HTML`oa$;p$1952=5+p$1952;p1$1952-=1;
     p2$1952=5+p1$1952;p0$1952=-9+p$1952;
     If[(pe$1952=StringPosition["{a,b,c...} is a list structure."[p$1952,-2],";;;"])<=>{},{Max[0,
        -1+ToExpression["{a,b,c...} is a list structure."[p$1952+pe$1952[[1,2]],p1$1952]]],p1$1952=-2+p$1952+pe$1952[[1,1]]}[[
       1]],
      0],
    1,lx$1952:=Help2HTML`o9$;p2$1952=4+p1$1952;p0$1952=-4+p$1952;0];
  If[(equ$1952=Help2HTML`o8$["{a,b,c...} is a list structure."[p$1952,p1$1952]])===Undefined,
   equ$1952="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["{a,b,c...} is a list structure."[p$1952,p1$1952]]=equ$1952;LaTeX`ob$+=neq,
     --LaTeX`ob$;With[{lx$1952},out$1952=lx$1952@Typeset["{a,b,c...} is a list structure."[p$1952,p1$1952],Format->Help2HTML`oB$];
        System["mv -f "//out$1952//" "//equ$1952]];
      Exit[]]];
   "{a,b,c...} is a list structure."[1,Max[p0$1952,0]]//"<img  class=\"eqs\" SRC=\""//equ$1952//"\" />"//
   Help2HTML`oy$["{a,b,c...} is a list structure."[p2$1952,-1]]
]</PRE>
<LI>
<H3><A NAME=L265>
Map (/@)</A></H3>
<PRE>If[{},Help2HTML`oA$["f/@a maps function f to subexpressions of a. f/@[a,level] specifies a levelspec of map by level."],
 p$1954=1+p$1954[[1,2]];
  p1$1954=StringPosition["f/@a maps function f to subexpressions of a. f/@[a,level] specifies a levelspec of map by level."[p$1954,
     -1],
    ">::",1];
   p1$1954=If[p1$1954==={},96,-2+p$1954+p1$1954[[1,1]]];
  neq=Which["f/@a maps function f to subexpressions of a. f/@[a,level] specifies a levelspec of map by level."[p$1954,4+p$1954]===
     "Text[",
    lx$1954:=Help2HTML`oa$;p$1954=5+p$1954;p1$1954-=1;p2$1954=5+p1$1954;p0$1954=-9+p$1954;If[(pe$1954=StringPosition[
         "f/@a maps function f to subexpressions of a. f/@[a,level] specifies a levelspec of map by level."[p$1954,-2],";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression["f/@a maps function f to subexpressions of a. f/@[a,level] specifies a levelspec of map by level."[p$1954+
            pe$1954[[1,2]],
           p1$1954]]],
        p1$1954=-2+p$1954+pe$1954[[1,1]]}[[
       1]],
      0],
    1,lx$1954:=Help2HTML`o9$;p2$1954=4+p1$1954;p0$1954=-4+p$1954;0];
  If[(equ$1954=
     Help2HTML`o8$["f/@a maps function f to subexpressions of a. f/@[a,level] specifies a levelspec of map by level."[p$1954,
       p1$1954]])===
    Undefined,
   equ$1954="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "f/@a maps function f to subexpressions of a. f/@[a,level] specifies a levelspec of map by level."[p$1954,p1$1954]]=
       equ$1954;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$1954},out$1954=lx$1954@Typeset[
          "f/@a maps function f to subexpressions of a. f/@[a,level] specifies a levelspec of map by level."[p$1954,p1$1954],
          Format->Help2HTML`oB$];
        System["mv -f "//out$1954//" "//equ$1954]];
      Exit[]]];
   "f/@a maps function f to subexpressions of a. f/@[a,level] specifies a levelspec of map by level."[1,Max[p0$1954,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$1954//"\" />"//
   Help2HTML`oy$["f/@a maps function f to subexpressions of a. f/@[a,level] specifies a levelspec of map by level."[p2$1954,-1]]
 ]
</PRE>
<PRE>See also:
 <A HREF=#L375>Map</A></PRE>
<LI>
<H3><A NAME=L266>
MapAll(//@)</A></H3>
<PRE>If[{},
 Help2HTML`oA$[
  "f//@a maps function f to all subexpressions of a. f//@[a,Heads->True] maps including the heads of a and its subexpressions."],
 p$1957=1+p$1957[[1,2]];
  p1$1957=StringPosition[
    "f//@a maps function f to all subexpressions of a. f//@[a,Heads->True] maps including the heads of a and its subexpressions."[
     p$1957,-1],
    ">::",1];
   p1$1957=If[p1$1957==={},123,-2+p$1957+p1$1957[[1,1]]];
  neq=Which[
     "f//@a maps function f to all subexpressions of a. f//@[a,Heads->True] maps including the heads of a and its subexpressions."[
      p$1957,4+p$1957]===
     "Text[",
    lx$1957:=Help2HTML`oa$;p$1957=5+p$1957;p1$1957-=1;p2$1957=5+p1$1957;p0$1957=-9+p$1957;If[(pe$1957=StringPosition[
         "f//@a maps function f to all subexpressions of a. f//@[a,Heads->True] maps including the heads of a and its subexpressio\
ns."[p$1957,-2],";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression[
          "f//@a maps function f to all subexpressions of a. f//@[a,Heads->True] maps including the heads of a and its subexpressi\
ons."[p$1957+pe$1957[[1,2]],p1$1957]]],
        p1$1957=-2+p$1957+pe$1957[[1,1]]}[[
       1]],
      0],
    1,lx$1957:=Help2HTML`o9$;p2$1957=4+p1$1957;p0$1957=-4+p$1957;0];
  If[(equ$1957=
     Help2HTML`o8$[
      "f//@a maps function f to all subexpressions of a. f//@[a,Heads->True] maps including the heads of a and its subexpressions."
      [p$1957,p1$1957]])===
    Undefined,
   equ$1957="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "f//@a maps function f to all subexpressions of a. f//@[a,Heads->True] maps including the heads of a and its subexpression\
s."[p$1957,p1$1957]]=
       equ$1957;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$1957},out$1957=lx$1957@Typeset[
          "f//@a maps function f to all subexpressions of a. f//@[a,Heads->True] maps including the heads of a and its subexpressi\
ons."[p$1957,p1$1957],Format->Help2HTML`oB$];
        System["mv -f "//out$1957//" "//equ$1957]];
      Exit[]]];
  "f//@a maps function f to all subexpressions of a. f//@[a,Heads->True] maps including the heads of a and its subexpressions."[1,
    Max[p0$1957,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$1957//"\" />"//
   Help2HTML`oy$[
    "f//@a maps function f to all subexpressions of a. f//@[a,Heads->True] maps including the heads of a and its subexpressions."[
     p2$1957,-1]]
]</PRE>
<LI>
<H3><A NAME=L267>
Member(@)</A></H3>
<PRE>If[{},
 Help2HTML`oA$[
  "f@a refers the member a of an instance or a class f. Otherwise it is same as f[a]. f@g@h means (f@g)@h, and f@g[h] (f@g)[h]."],
 p$1959=1+p$1959[[1,2]];
  p1$1959=StringPosition[
    "f@a refers the member a of an instance or a class f. Otherwise it is same as f[a]. f@g@h means (f@g)@h, and f@g[h] (f@g)[h]."[
     p$1959,-1],
    ">::",1];
   p1$1959=If[p1$1959==={},124,-2+p$1959+p1$1959[[1,1]]];
  neq=Which[
     "f@a refers the member a of an instance or a class f. Otherwise it is same as f[a]. f@g@h means (f@g)@h, and f@g[h] (f@g)[h]."
     [p$1959,4+p$1959]==="Text[",
    lx$1959:=Help2HTML`oa$;p$1959=5+p$1959;p1$1959-=1;p2$1959=5+p1$1959;p0$1959=-9+p$1959;If[(pe$1959=StringPosition[
         "f@a refers the member a of an instance or a class f. Otherwise it is same as f[a]. f@g@h means (f@g)@h, and f@g[h] (f@g)\
[h]."[p$1959,-2],";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression[
          "f@a refers the member a of an instance or a class f. Otherwise it is same as f[a]. f@g@h means (f@g)@h, and f@g[h] (f@g\
)[h]."[p$1959+pe$1959[[1,2]],p1$1959]]],
        p1$1959=-2+p$1959+pe$1959[[1,1]]}[[
       1]],
      0],
    1,lx$1959:=Help2HTML`o9$;p2$1959=4+p1$1959;p0$1959=-4+p$1959;0];
  If[(equ$1959=
     Help2HTML`o8$[
      "f@a refers the member a of an instance or a class f. Otherwise it is same as f[a]. f@g@h means (f@g)@h, and f@g[h] (f@g)[h]\
."[p$1959,p1$1959]])===
    Undefined,
   equ$1959="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "f@a refers the member a of an instance or a class f. Otherwise it is same as f[a]. f@g@h means (f@g)@h, and f@g[h] (f@g)[\
h]."[p$1959,p1$1959]]=
       equ$1959;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$1959},out$1959=lx$1959@Typeset[
          "f@a refers the member a of an instance or a class f. Otherwise it is same as f[a]. f@g@h means (f@g)@h, and f@g[h] (f@g\
)[h]."[p$1959,p1$1959],Format->Help2HTML`oB$];
        System["mv -f "//out$1959//" "//equ$1959]];
      Exit[]]];
  "f@a refers the member a of an instance or a class f. Otherwise it is same as f[a]. f@g@h means (f@g)@h, and f@g[h] (f@g)[h]."[
    1,Max[p0$1959,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$1959//"\" />"//
   Help2HTML`oy$[
    "f@a refers the member a of an instance or a class f. Otherwise it is same as f[a]. f@g@h means (f@g)@h, and f@g[h] (f@g)[h]."[
     p2$1959,-1]]
]</PRE>
<LI>
<H3><A NAME=L268>
MessageName(::)</A></H3>
<PRE>If[{},
 Help2HTML`oA$[
  "symbol::tag returns a message associated with symbol and tag\n symbol::tag = message sets a message identified by symbol"],
 p$1961=1+p$1961[[1,2]];
  p1$1961=StringPosition[
    "symbol::tag returns a message associated with symbol and tag\n symbol::tag = message sets a message identified by symbol"[p
     $1961,-1],
    ">::",1];
   p1$1961=If[p1$1961==={},119,-2+p$1961+p1$1961[[1,1]]];
  neq=Which[
     "symbol::tag returns a message associated with symbol and tag\n symbol::tag = message sets a message identified by symbol"[p
      $1961,4+p$1961]===
     "Text[",
    lx$1961:=Help2HTML`oa$;p$1961=5+p$1961;p1$1961-=1;p2$1961=5+p1$1961;p0$1961=-9+p$1961;If[(pe$1961=StringPosition[
         "symbol::tag returns a message associated with symbol and tag\n symbol::tag = message sets a message identified by symbol"
         [p$1961,-2],";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression[
          "symbol::tag returns a message associated with symbol and tag\n symbol::tag = message sets a message identified by symbo\
l"[p$1961+pe$1961[[1,2]],p1$1961]]],
        p1$1961=-2+p$1961+pe$1961[[1,1]]}[[
       1]],
      0],
    1,lx$1961:=Help2HTML`o9$;p2$1961=4+p1$1961;p0$1961=-4+p$1961;0];
  If[(equ$1961=
     Help2HTML`o8$[
      "symbol::tag returns a message associated with symbol and tag\n symbol::tag = message sets a message identified by symbol"[
       p$1961,p1$1961]])===
    Undefined,
   equ$1961="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "symbol::tag returns a message associated with symbol and tag\n symbol::tag = message sets a message identified by symbol"[
         p$1961,p1$1961]]=
       equ$1961;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$1961},out$1961=lx$1961@Typeset[
          "symbol::tag returns a message associated with symbol and tag\n symbol::tag = message sets a message identified by symbo\
l"[p$1961,p1$1961],Format->Help2HTML`oB$];
        System["mv -f "//out$1961//" "//equ$1961]];
      Exit[]]];
  "symbol::tag returns a message associated with symbol and tag\n symbol::tag = message sets a message identified by symbol"[1,
    Max[p0$1961,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$1961//"\" />"//
   Help2HTML`oy$[
    "symbol::tag returns a message associated with symbol and tag\n symbol::tag = message sets a message identified by symbol"[p2
     $1961,-1]]
]</PRE>
<LI>
<H3><A NAME=L269>
Not(~)</A></H3>
<PRE>If[{},Help2HTML`oA$[" ~a returns True(==1) when a is zero, False(==0) when a is a nonzero real."],
 p$1963=1+p$1963[[1,2]];p1$1963=
   StringPosition[" ~a returns True(==1) when a is zero, False(==0) when a is a nonzero real."[p$1963,-1],">::",1];
  p1$1963=If[p1$1963==={},74,-2+p$1963+p1$1963[[1,1]]];
  neq=Which[" ~a returns True(==1) when a is zero, False(==0) when a is a nonzero real."[p$1963,4+p$1963]==="Text[",
    lx$1963:=Help2HTML`oa$;p$1963=5+p$1963;p1$1963-=1;p2$1963=5+p1$1963;p0$1963=-9+p$1963;
     If[(pe$1963=StringPosition[" ~a returns True(==1) when a is zero, False(==0) when a is a nonzero real."[p$1963,-2],";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression[" ~a returns True(==1) when a is zero, False(==0) when a is a nonzero real."[p$1963+pe$1963[[1,2]],p1$1963]
          ]],
        p1$1963=-2+p$1963+pe$1963[[1,1]]}[[
       1]],
      0],
    1,lx$1963:=Help2HTML`o9$;p2$1963=4+p1$1963;p0$1963=-4+p$1963;0];
  If[(equ$1963=Help2HTML`o8$[" ~a returns True(==1) when a is zero, False(==0) when a is a nonzero real."[p$1963,p1$1963]])===
    Undefined,
   equ$1963="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        " ~a returns True(==1) when a is zero, False(==0) when a is a nonzero real."[p$1963,p1$1963]]=
       equ$1963;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$1963},out$1963=lx$1963@Typeset[" ~a returns True(==1) when a is zero, False(==0) when a is a nonzero real."[p$1963,
           p1$1963],Format->Help2HTML`oB$];
        System["mv -f "//out$1963//" "//equ$1963]];
      Exit[]]];
   " ~a returns True(==1) when a is zero, False(==0) when a is a nonzero real."[1,Max[p0$1963,0]]//"<img  class=\"eqs\" SRC=\""//
   equ$1963//"\" />"//Help2HTML`oy$[" ~a returns True(==1) when a is zero, False(==0) when a is a nonzero real."[p2$1963,-1]]
 ]
</PRE>
<LI>
<H3><A NAME=L270>
Or(||)</A></H3>
<PRE>If[{},
 Help2HTML`oA$[
  "a || b returns True(==1) when a is nonzero real or b is nonzero real, False(==0) otherwise. b is not evaluated when a is nonzer\
o."],
 p$1965=1+p$1965[[1,2]];p1$1965=StringPosition[
    "a || b returns True(==1) when a is nonzero real or b is nonzero real, False(==0) otherwise. b is not evaluated when a is nonz\
ero."[p$1965,-1],">::",1];
   p1$1965=If[p1$1965==={},129,-2+p$1965+p1$1965[[1,1]]];
  neq=Which[
     "a || b returns True(==1) when a is nonzero real or b is nonzero real, False(==0) otherwise. b is not evaluated when a is non\
zero."[p$1965,4+p$1965]==="Text[",
    lx$1965:=Help2HTML`oa$;p$1965=5+p$1965;p1$1965-=1;p2$1965=5+p1$1965;p0$1965=-9+p$1965;If[(pe$1965=
        StringPosition[
         "a || b returns True(==1) when a is nonzero real or b is nonzero real, False(==0) otherwise. b is not evaluated when a is\
 nonzero."[p$1965,-2],";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression[
          "a || b returns True(==1) when a is nonzero real or b is nonzero real, False(==0) otherwise. b is not evaluated when a i\
s nonzero."[p$1965+pe$1965[[1,2]],p1$1965]]],
        p1$1965=-2+p$1965+pe$1965[[1,1]]}[[
       1]],
      0],
    1,lx$1965:=Help2HTML`o9$;p2$1965=4+p1$1965;p0$1965=-4+p$1965;0];
  If[(equ$1965=
     Help2HTML`o8$[
      "a || b returns True(==1) when a is nonzero real or b is nonzero real, False(==0) otherwise. b is not evaluated when a is no\
nzero."[p$1965,p1$1965]])===
    Undefined,
   equ$1965="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "a || b returns True(==1) when a is nonzero real or b is nonzero real, False(==0) otherwise. b is not evaluated when a is \
nonzero."[p$1965,p1$1965]]=
       equ$1965;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$1965},out$1965=lx$1965@Typeset[
          "a || b returns True(==1) when a is nonzero real or b is nonzero real, False(==0) otherwise. b is not evaluated when a i\
s nonzero."[p$1965,p1$1965],Format->Help2HTML`oB$];
        System["mv -f "//out$1965//" "//equ$1965]];
      Exit[]]];
  "a || b returns True(==1) when a is nonzero real or b is nonzero real, False(==0) otherwise. b is not evaluated when a is nonzer\
o."[1,Max[p0$1965,0]]//"<img  class=\"eqs\" SRC=\""//equ$1965//"\" />"//
   Help2HTML`oy$[
    "a || b returns True(==1) when a is nonzero real or b is nonzero real, False(==0) otherwise. b is not evaluated when a is nonz\
ero."[p2$1965,-1]]
]</PRE>
<LI>
<H3><A NAME=L271>
Part([[]])</A></H3>
<PRE>If[{},
Help2HTML`oA$["a[[b,..]] is a subexpression of an expression a.\n If an index is omitted or Null like as a[[,b]], Part returns a l\
ist of elements whose corresponding index takes the entire range. For instance,\n {{1, 2}, {3, 4}, {5, 6}}[[,2]] gives {2, 4, 6}."
  ],
p$1967=1+p$1967[[1,2]];p1$1967=StringPosition["a[[b,..]] is a subexpression of an expression a.\n If an index is omitted or Null l\
ike as a[[,b]], Part returns a list of elements whose corresponding index takes the entire range. For instance,\n {{1, 2}, {3, 4},\
 {5, 6}}[[,2]] gives {2, 4, 6}."[p$1967,-1],">::",1];
   p1$1967=If[p1$1967==={},242,-2+p$1967+p1$1967[[1,1]]];
neq=Which["a[[b,..]] is a subexpression of an expression a.\n If an index is omitted or Null like as a[[,b]], Part returns a list \
of elements whose corresponding index takes the entire range. For instance,\n {{1, 2}, {3, 4}, {5, 6}}[[,2]] gives {2, 4, 6}."[p
      $1967,4+p$1967]===
     "Text[",
lx$1967:=Help2HTML`oa$;p$1967=5+p$1967;p1$1967-=1;p2$1967=5+p1$1967;p0$1967=-9+p$1967;If[(pe$1967=StringPosition["a[[b,..]] is a s\
ubexpression of an expression a.\n If an index is omitted or Null like as a[[,b]], Part returns a list of elements whose correspon\
ding index takes the entire range. For instance,\n {{1, 2}, {3, 4}, {5, 6}}[[,2]] gives {2, 4, 6}."[p$1967,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["a[[b,..]] is a subexpression of an expression a.\n If an index is omitted or Null like as a[[,b]], Part returns a\
 list of elements whose corresponding index takes the entire range. For instance,\n {{1, 2}, {3, 4}, {5, 6}}[[,2]] gives {2, 4, 6}\
."[p$1967+pe$1967[[1,2]],p1$1967]]],
        p1$1967=-2+p$1967+pe$1967[[1,1]]}[[
       1]],
      0],
    1,lx$1967:=Help2HTML`o9$;p2$1967=4+p1$1967;p0$1967=-4+p$1967;0];
  If[(equ$1967=
Help2HTML`o8$["a[[b,..]] is a subexpression of an expression a.\n If an index is omitted or Null like as a[[,b]], Part returns a l\
ist of elements whose corresponding index takes the entire range. For instance,\n {{1, 2}, {3, 4}, {5, 6}}[[,2]] gives {2, 4, 6}."[
       p$1967,p1$1967]])===
    Undefined,
equ$1967="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["a[[b,..]] is a subexpression of an expressio\
n a.\n If an index is omitted or Null like as a[[,b]], Part returns a list of elements whose corresponding index takes the entire \
range. For instance,\n {{1, 2}, {3, 4}, {5, 6}}[[,2]] gives {2, 4, 6}."[p$1967,p1$1967]]=
       equ$1967;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1967},out$1967=lx$1967@Typeset["a[[b,..]] is a subexpression of an expression a.\n If an index is omitted or Null like as\
 a[[,b]], Part returns a list of elements whose corresponding index takes the entire range. For instance,\n {{1, 2}, {3, 4}, {5, 6\
}}[[,2]] gives {2, 4, 6}."[p$1967,p1$1967],Format->Help2HTML`oB$];
        System["mv -f "//out$1967//" "//equ$1967]];
      Exit[]]];
   "a[[b,..]] is a subexpression of an expression a.\n If an index is omitted or Null like as a[[,b]], Part returns a list of elem\
ents whose corresponding index takes the entire range. For instance,\n {{1, 2}, {3, 4}, {5, 6}}[[,2]] gives {2, 4, 6}."[1,
    Max[p0$1967,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$1967//"\" />"//
Help2HTML`oy$["a[[b,..]] is a subexpression of an expression a.\n If an index is omitted or Null like as a[[,b]], Part returns a l\
ist of elements whose corresponding index takes the entire range. For instance,\n {{1, 2}, {3, 4}, {5, 6}}[[,2]] gives {2, 4, 6}."[
     p2$1967,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L41>Part</A></PRE>
<LI>
<H3><A NAME=L272>
PatternTest(?)</A></H3>
<PRE>If[{},Help2HTML`oA$["pattern?test matches to an object which matches pattern then test[object] gives True."],
 p$1970=1+p$1970[[1,2]];
  p1$1970=StringPosition["pattern?test matches to an object which matches pattern then test[object] gives True."[p$1970,-1],">::",
    1];
   p1$1970=If[p1$1970==={},85,-2+p$1970+p1$1970[[1,1]]];
  neq=Which["pattern?test matches to an object which matches pattern then test[object] gives True."[p$1970,4+p$1970]==="Text[",
    lx$1970:=Help2HTML`oa$;p$1970=5+p$1970;p1$1970-=1;p2$1970=5+p1$1970;p0$1970=-9+p$1970;
     If[(pe$1970=StringPosition["pattern?test matches to an object which matches pattern then test[object] gives True."[p$1970,-2],
         ";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression["pattern?test matches to an object which matches pattern then test[object] gives True."[p$1970+pe$1970[[1,
             2]],
           p1$1970]]],
        p1$1970=-2+p$1970+pe$1970[[1,1]]}[[
       1]],
      0],
    1,lx$1970:=Help2HTML`o9$;p2$1970=4+p1$1970;p0$1970=-4+p$1970;0];
  If[(equ$1970=
     Help2HTML`o8$["pattern?test matches to an object which matches pattern then test[object] gives True."[p$1970,p1$1970]])===
    Undefined,
   equ$1970="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "pattern?test matches to an object which matches pattern then test[object] gives True."[p$1970,p1$1970]]=
       equ$1970;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$1970},out$1970=lx$1970@Typeset[
          "pattern?test matches to an object which matches pattern then test[object] gives True."[p$1970,p1$1970],
          Format->Help2HTML`oB$];
        System["mv -f "//out$1970//" "//equ$1970]];
      Exit[]]];
   "pattern?test matches to an object which matches pattern then test[object] gives True."[1,Max[p0$1970,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$1970//"\" />"//
   Help2HTML`oy$["pattern?test matches to an object which matches pattern then test[object] gives True."[p2$1970,-1]]
]</PRE>
<LI>
<H3><A NAME=L273>
Plus(+)</A></H3>
<PRE>If[{},
Help2HTML`oA$["a + b returns the sum of a and b. If one of a or b is a list, or both are lists with same size, returns a list of e\
lement-wise results."],
p$1972=1+p$1972[[1,2]];p1$1972=StringPosition["a + b returns the sum of a and b. If one of a or b is a list, or both are lists wit\
h same size, returns a list of element-wise results."[p$1972,-1],">::",1];
   p1$1972=If[p1$1972==={},135,-2+p$1972+p1$1972[[1,1]]];
neq=Which["a + b returns the sum of a and b. If one of a or b is a list, or both are lists with same size, returns a list of eleme\
nt-wise results."[p$1972,4+p$1972]==="Text[",
    lx$1972:=Help2HTML`oa$;p$1972=5+p$1972;p1$1972-=1;p2$1972=5+p1$1972;p0$1972=-9+p$1972;If[(pe$1972=
StringPosition["a + b returns the sum of a and b. If one of a or b is a list, or both are lists with same size, returns a list of \
element-wise results."[p$1972,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["a + b returns the sum of a and b. If one of a or b is a list, or both are lists with same size, returns a list of\
 element-wise results."[p$1972+pe$1972[[1,2]],p1$1972]]],
        p1$1972=-2+p$1972+pe$1972[[1,1]]}[[
       1]],
      0],
    1,lx$1972:=Help2HTML`o9$;p2$1972=4+p1$1972;p0$1972=-4+p$1972;0];
  If[(equ$1972=
Help2HTML`o8$["a + b returns the sum of a and b. If one of a or b is a list, or both are lists with same size, returns a list of e\
lement-wise results."[p$1972,p1$1972]])===
    Undefined,
equ$1972="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["a + b returns the sum of a and b. If one of \
a or b is a list, or both are lists with same size, returns a list of element-wise results."[p$1972,p1$1972]]=
       equ$1972;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1972},out$1972=lx$1972@Typeset["a + b returns the sum of a and b. If one of a or b is a list, or both are lists with same\
 size, returns a list of element-wise results."[p$1972,p1$1972],Format->Help2HTML`oB$];
        System["mv -f "//out$1972//" "//equ$1972]];
      Exit[]]];
   "a + b returns the sum of a and b. If one of a or b is a list, or both are lists with same size, returns a list of element-wise\
 results."[1,Max[p0$1972,0]]//"<img  class=\"eqs\" SRC=\""//equ$1972//"\" />"//
Help2HTML`oy$["a + b returns the sum of a and b. If one of a or b is a list, or both are lists with same size, returns a list of e\
lement-wise results."[p2$1972,-1]]
]</PRE>
<LI>
<H3><A NAME=L274>
Power(^)</A></H3>
<PRE>If[{},
Help2HTML`oA$["a ^ b returns the power of a to b. If one of a or b is a list, or both are lists with same size, returns a list of \
element-wise results."],
p$1974=1+p$1974[[1,2]];p1$1974=StringPosition["a ^ b returns the power of a to b. If one of a or b is a list, or both are lists wi\
th same size, returns a list of element-wise results."[p$1974,-1],">::",1];
   p1$1974=If[p1$1974==={},136,-2+p$1974+p1$1974[[1,1]]];
neq=Which["a ^ b returns the power of a to b. If one of a or b is a list, or both are lists with same size, returns a list of elem\
ent-wise results."[p$1974,4+p$1974]==="Text[",
    lx$1974:=Help2HTML`oa$;p$1974=5+p$1974;p1$1974-=1;p2$1974=5+p1$1974;p0$1974=-9+p$1974;
If[(pe$1974=StringPosition["a ^ b returns the power of a to b. If one of a or b is a list, or both are lists with same size, retur\
ns a list of element-wise results."[p$1974,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["a ^ b returns the power of a to b. If one of a or b is a list, or both are lists with same size, returns a list o\
f element-wise results."[p$1974+pe$1974[[1,2]],p1$1974]]],
        p1$1974=-2+p$1974+pe$1974[[1,1]]}[[
       1]],
      0],
    1,lx$1974:=Help2HTML`o9$;p2$1974=4+p1$1974;p0$1974=-4+p$1974;0];
  If[(equ$1974=
Help2HTML`o8$["a ^ b returns the power of a to b. If one of a or b is a list, or both are lists with same size, returns a list of \
element-wise results."[p$1974,p1$1974]])===
    Undefined,
equ$1974="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["a ^ b returns the power of a to b. If one of\
 a or b is a list, or both are lists with same size, returns a list of element-wise results."[p$1974,p1$1974]]=
       equ$1974;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1974},out$1974=lx$1974@Typeset["a ^ b returns the power of a to b. If one of a or b is a list, or both are lists with sam\
e size, returns a list of element-wise results."[p$1974,p1$1974],Format->Help2HTML`oB$];
        System["mv -f "//out$1974//" "//equ$1974]];
      Exit[]]];
   "a ^ b returns the power of a to b. If one of a or b is a list, or both are lists with same size, returns a list of element-wis\
e results."[1,Max[p0$1974,0]]//"<img  class=\"eqs\" SRC=\""//equ$1974//"\" />"//
Help2HTML`oy$["a ^ b returns the power of a to b. If one of a or b is a list, or both are lists with same size, returns a list of \
element-wise results."[p2$1974,-1]]
]</PRE>
<LI>
<H3><A NAME=L275>
Repeated(..)</A></H3>
<PRE>If[{},Help2HTML`oA$["p.. matches sequence of one ore more expressions, each matching p."],
 p$1976=1+p$1976[[1,2]];p1$1976=StringPosition["p.. matches sequence of one ore more expressions, each matching p."[p$1976,-1],
    ">::",1];
   p1$1976=If[p1$1976==={},66,-2+p$1976+p1$1976[[1,1]]];
  neq=Which["p.. matches sequence of one ore more expressions, each matching p."[p$1976,4+p$1976]==="Text[",
    lx$1976:=Help2HTML`oa$;p$1976=5+p$1976;p1$1976-=1;p2$1976=5+p1$1976;p0$1976=-9+p$1976;
     If[(pe$1976=StringPosition["p.. matches sequence of one ore more expressions, each matching p."[p$1976,-2],";;;"])<=>{},
      {Max[0,-1+ToExpression["p.. matches sequence of one ore more expressions, each matching p."[p$1976+pe$1976[[1,2]],p1$1976]]],
       p1$1976=-2+p$1976+pe$1976[[1,1]]}[[1]],
      0],
    1,lx$1976:=Help2HTML`o9$;p2$1976=4+p1$1976;p0$1976=-4+p$1976;0];
  If[(equ$1976=Help2HTML`o8$["p.. matches sequence of one ore more expressions, each matching p."[p$1976,p1$1976]])===Undefined,
   equ$1976="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["p.. matches sequence of one ore more expressions, each matching p."[p$1976,p1$1976]]=equ$1976;
      LaTeX`ob$+=neq,
     --LaTeX`ob$;With[{lx$1976},out$1976=lx$1976@Typeset["p.. matches sequence of one ore more expressions, each matching p."[p
           $1976,p1$1976],Format->Help2HTML`oB$];
        System["mv -f "//out$1976//" "//equ$1976]];
      Exit[]]];
   "p.. matches sequence of one ore more expressions, each matching p."[1,Max[p0$1976,0]]//"<img  class=\"eqs\" SRC=\""//equ$1976//
   "\" />"//Help2HTML`oy$["p.. matches sequence of one ore more expressions, each matching p."[p2$1976,-1]]
]</PRE>
<LI>
<H3><A NAME=L276>
RepeatedNull(...)</A></H3>
<PRE>If[{},Help2HTML`oA$["p... matches sequence of zero ore more expressions, each matching p."],
 p$1978=1+p$1978[[1,2]];p1$1978=StringPosition["p... matches sequence of zero ore more expressions, each matching p."[p$1978,-1],
    ">::",1];
   p1$1978=If[p1$1978==={},68,-2+p$1978+p1$1978[[1,1]]];
  neq=Which["p... matches sequence of zero ore more expressions, each matching p."[p$1978,4+p$1978]==="Text[",
    lx$1978:=Help2HTML`oa$;p$1978=5+p$1978;p1$1978-=1;p2$1978=5+p1$1978;p0$1978=-9+p$1978;
     If[(pe$1978=StringPosition["p... matches sequence of zero ore more expressions, each matching p."[p$1978,-2],";;;"])<=>{},
      {Max[0,-1+ToExpression["p... matches sequence of zero ore more expressions, each matching p."[p$1978+pe$1978[[1,2]],p1$1978]]
        ],p1$1978=-2+p$1978+pe$1978[[1,1]]}[[
       1]],
      0],
    1,lx$1978:=Help2HTML`o9$;p2$1978=4+p1$1978;p0$1978=-4+p$1978;0];
  If[(equ$1978=Help2HTML`o8$["p... matches sequence of zero ore more expressions, each matching p."[p$1978,p1$1978]])===Undefined,
   equ$1978="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["p... matches sequence of zero ore more expressions, each matching p."[p$1978,p1$1978]]=equ$1978;
      LaTeX`ob$+=neq,
     --LaTeX`ob$;With[{lx$1978},out$1978=lx$1978@Typeset["p... matches sequence of zero ore more expressions, each matching p."[p
           $1978,p1$1978],Format->Help2HTML`oB$];
        System["mv -f "//out$1978//" "//equ$1978]];
      Exit[]]];
   "p... matches sequence of zero ore more expressions, each matching p."[1,Max[p0$1978,0]]//"<img  class=\"eqs\" SRC=\""//
   equ$1978//"\" />"//Help2HTML`oy$["p... matches sequence of zero ore more expressions, each matching p."[p2$1978,-1]]
]</PRE>
<LI>
<H3><A NAME=L277>
ReplaceAll(/.)</A></H3>
<PRE>If[{},Help2HTML`oA$["expr/.rule replaces all subexpressions of expr using rule."],
 p$1980=1+p$1980[[1,2]];p1$1980=StringPosition["expr/.rule replaces all subexpressions of expr using rule."[p$1980,-1],">::",1];
  p1$1980=If[p1$1980==={},58,-2+p$1980+p1$1980[[1,1]]];
  neq=Which["expr/.rule replaces all subexpressions of expr using rule."[p$1980,4+p$1980]==="Text[",
    lx$1980:=Help2HTML`oa$;p$1980=5+p$1980;p1$1980-=1;p2$1980=5+p1$1980;p0$1980=-9+p$1980;
     If[(pe$1980=StringPosition["expr/.rule replaces all subexpressions of expr using rule."[p$1980,-2],";;;"])<=>{},
      {Max[0,-1+ToExpression["expr/.rule replaces all subexpressions of expr using rule."[p$1980+pe$1980[[1,2]],p1$1980]]],
       p1$1980=-2+p$1980+pe$1980[[1,1]]}[[1]],
      0],
    1,lx$1980:=Help2HTML`o9$;p2$1980=4+p1$1980;p0$1980=-4+p$1980;0];
  If[(equ$1980=Help2HTML`o8$["expr/.rule replaces all subexpressions of expr using rule."[p$1980,p1$1980]])===Undefined,
   equ$1980="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["expr/.rule replaces all subexpressions of expr using rule."[p$1980,p1$1980]]=equ$1980;LaTeX`ob$+=neq,
     --LaTeX`ob$;
      With[{lx$1980},out$1980=lx$1980@Typeset["expr/.rule replaces all subexpressions of expr using rule."[p$1980,p1$1980],
          Format->Help2HTML`oB$];
        System["mv -f "//out$1980//" "//equ$1980]];
      Exit[]]];
   "expr/.rule replaces all subexpressions of expr using rule."[1,Max[p0$1980,0]]//"<img  class=\"eqs\" SRC=\""//equ$1980//
   "\" />"//Help2HTML`oy$["expr/.rule replaces all subexpressions of expr using rule."[p2$1980,-1]]
]</PRE>
<LI>
<H3><A NAME=L278>
ReplaceRepeated(//.)</A></H3>
<PRE>If[{},Help2HTML`oA$["expr//.rule replaces all subexpressionso of expr using rule, while a replacement is performed."],
 p$1982=1+p$1982[[1,2]];
  p1$1982=StringPosition["expr//.rule replaces all subexpressionso of expr using rule, while a replacement is performed."[p$1982,-1
     ],
    ">::",1];
   p1$1982=If[p1$1982==={},94,-2+p$1982+p1$1982[[1,1]]];
  neq=Which["expr//.rule replaces all subexpressionso of expr using rule, while a replacement is performed."[p$1982,4+p$1982]===
     "Text[",
    lx$1982:=Help2HTML`oa$;p$1982=5+p$1982;p1$1982-=1;p2$1982=5+p1$1982;p0$1982=-9+p$1982;If[(pe$1982=StringPosition[
         "expr//.rule replaces all subexpressionso of expr using rule, while a replacement is performed."[p$1982,-2],";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression["expr//.rule replaces all subexpressionso of expr using rule, while a replacement is performed."[p$1982+
            pe$1982[[1,2]],
           p1$1982]]],
        p1$1982=-2+p$1982+pe$1982[[1,1]]}[[
       1]],
      0],
    1,lx$1982:=Help2HTML`o9$;p2$1982=4+p1$1982;p0$1982=-4+p$1982;0];
  If[(equ$1982=
     Help2HTML`o8$["expr//.rule replaces all subexpressionso of expr using rule, while a replacement is performed."[p$1982,p1$1982]
      ])===
    Undefined,
   equ$1982="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "expr//.rule replaces all subexpressionso of expr using rule, while a replacement is performed."[p$1982,p1$1982]]=
       equ$1982;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$1982},out$1982=lx$1982@Typeset[
          "expr//.rule replaces all subexpressionso of expr using rule, while a replacement is performed."[p$1982,p1$1982],
          Format->Help2HTML`oB$];
        System["mv -f "//out$1982//" "//equ$1982]];
      Exit[]]];
   "expr//.rule replaces all subexpressionso of expr using rule, while a replacement is performed."[1,Max[p0$1982,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$1982//"\" />"//
   Help2HTML`oy$["expr//.rule replaces all subexpressionso of expr using rule, while a replacement is performed."[p2$1982,-1]]
 ]
</PRE>
<LI>
<H3><A NAME=L279>
Rule(->)</A></H3>
<PRE>If[{},Help2HTML`oA$["pattern->expr represents a rule for ReplaceAll."],
 p$1984=1+p$1984[[1,2]];p1$1984=StringPosition["pattern->expr represents a rule for ReplaceAll."[p$1984,-1],">::",1];
  p1$1984=If[p1$1984==={},47,-2+p$1984+p1$1984[[1,1]]];
  neq=Which["pattern->expr represents a rule for ReplaceAll."[p$1984,4+p$1984]==="Text[",
    lx$1984:=Help2HTML`oa$;p$1984=5+p$1984;p1$1984-=1;p2$1984=5+p1$1984;p0$1984=-9+p$1984;
     If[(pe$1984=StringPosition["pattern->expr represents a rule for ReplaceAll."[p$1984,-2],";;;"])<=>{},
      {Max[0,-1+ToExpression["pattern->expr represents a rule for ReplaceAll."[p$1984+pe$1984[[1,2]],p1$1984]]],
       p1$1984=-2+p$1984+pe$1984[[1,1]]}[[1]],
      0],
    1,lx$1984:=Help2HTML`o9$;p2$1984=4+p1$1984;p0$1984=-4+p$1984;0];
  If[(equ$1984=Help2HTML`o8$["pattern->expr represents a rule for ReplaceAll."[p$1984,p1$1984]])===Undefined,
   equ$1984="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["pattern->expr represents a rule for ReplaceAll."[p$1984,p1$1984]]=equ$1984;LaTeX`ob$+=neq,
     --LaTeX`ob$;
      With[{lx$1984},out$1984=lx$1984@Typeset["pattern->expr represents a rule for ReplaceAll."[p$1984,p1$1984],Format->
           Help2HTML`oB$];
        System["mv -f "//out$1984//" "//equ$1984]];
      Exit[]]];
   "pattern->expr represents a rule for ReplaceAll."[1,Max[p0$1984,0]]//"<img  class=\"eqs\" SRC=\""//equ$1984//"\" />"//
   Help2HTML`oy$["pattern->expr represents a rule for ReplaceAll."[p2$1984,-1]]
]</PRE>
<LI>
<H3><A NAME=L280>
RuleDelayed(:>)</A></H3>
<PRE>If[{},Help2HTML`oA$["pattern:>expr represents a rule for ReplaceAll, where expr is kept unevaluated until the replacement."],
 p$1986=1+p$1986[[1,2]];
  p1$1986=StringPosition["pattern:>expr represents a rule for ReplaceAll, where expr is kept unevaluated until the replacement."[
     p$1986,-1],
    ">::",1];
   p1$1986=If[p1$1986==={},101,-2+p$1986+p1$1986[[1,1]]];
  neq=Which["pattern:>expr represents a rule for ReplaceAll, where expr is kept unevaluated until the replacement."[p$1986,4+p$1986
      ]===
     "Text[",
    lx$1986:=Help2HTML`oa$;p$1986=5+p$1986;p1$1986-=1;p2$1986=5+p1$1986;p0$1986=-9+p$1986;If[(pe$1986=StringPosition[
         "pattern:>expr represents a rule for ReplaceAll, where expr is kept unevaluated until the replacement."[p$1986,-2],";;;"]
        )<=>
       {},
      {Max[0,
        -1+ToExpression["pattern:>expr represents a rule for ReplaceAll, where expr is kept unevaluated until the replacement."[p
            $1986+pe$1986[[1,2]],
           p1$1986]]],
        p1$1986=-2+p$1986+pe$1986[[1,1]]}[[
       1]],
      0],
    1,lx$1986:=Help2HTML`o9$;p2$1986=4+p1$1986;p0$1986=-4+p$1986;0];
  If[(equ$1986=
     Help2HTML`o8$["pattern:>expr represents a rule for ReplaceAll, where expr is kept unevaluated until the replacement."[p$1986,
       p1$1986]])===
    Undefined,
   equ$1986="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "pattern:>expr represents a rule for ReplaceAll, where expr is kept unevaluated until the replacement."[p$1986,p1$1986]]=
       equ$1986;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$1986},out$1986=lx$1986@Typeset[
          "pattern:>expr represents a rule for ReplaceAll, where expr is kept unevaluated until the replacement."[p$1986,p1$1986],
          Format->Help2HTML`oB$];
        System["mv -f "//out$1986//" "//equ$1986]];
      Exit[]]];
   "pattern:>expr represents a rule for ReplaceAll, where expr is kept unevaluated until the replacement."[1,Max[p0$1986,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$1986//"\" />"//
   Help2HTML`oy$["pattern:>expr represents a rule for ReplaceAll, where expr is kept unevaluated until the replacement."[p2$1986,-1
     ]]
]</PRE>
<PRE>See also:
 Literal</PRE>
<LI>
<H3><A NAME=L281>
SameQ(===)</A></H3>
<PRE>If[{},Help2HTML`oA$["a === b returns True(==1) if a and b have the same type and same value, False(==0) otherwise."],
 p$1989=1+p$1989[[1,2]];
  p1$1989=StringPosition["a === b returns True(==1) if a and b have the same type and same value, False(==0) otherwise."[p$1989,-1
     ],
    ">::",1];
   p1$1989=If[p1$1989==={},93,-2+p$1989+p1$1989[[1,1]]];
  neq=Which["a === b returns True(==1) if a and b have the same type and same value, False(==0) otherwise."[p$1989,4+p$1989]===
     "Text[",
    lx$1989:=Help2HTML`oa$;p$1989=5+p$1989;p1$1989-=1;p2$1989=5+p1$1989;p0$1989=-9+p$1989;If[(pe$1989=StringPosition[
         "a === b returns True(==1) if a and b have the same type and same value, False(==0) otherwise."[p$1989,-2],";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression["a === b returns True(==1) if a and b have the same type and same value, False(==0) otherwise."[p$1989+
            pe$1989[[1,2]],
           p1$1989]]],
        p1$1989=-2+p$1989+pe$1989[[1,1]]}[[
       1]],
      0],
    1,lx$1989:=Help2HTML`o9$;p2$1989=4+p1$1989;p0$1989=-4+p$1989;0];
  If[(equ$1989=
     Help2HTML`o8$["a === b returns True(==1) if a and b have the same type and same value, False(==0) otherwise."[p$1989,p1$1989]]
     )===
    Undefined,
   equ$1989="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "a === b returns True(==1) if a and b have the same type and same value, False(==0) otherwise."[p$1989,p1$1989]]=
       equ$1989;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$1989},out$1989=lx$1989@Typeset[
          "a === b returns True(==1) if a and b have the same type and same value, False(==0) otherwise."[p$1989,p1$1989],
          Format->Help2HTML`oB$];
        System["mv -f "//out$1989//" "//equ$1989]];
      Exit[]]];
   "a === b returns True(==1) if a and b have the same type and same value, False(==0) otherwise."[1,Max[p0$1989,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$1989//"\" />"//
   Help2HTML`oy$["a === b returns True(==1) if a and b have the same type and same value, False(==0) otherwise."[p2$1989,-1]]
 ]
</PRE>
<LI>
<H3><A NAME=L282>
Sequence([])</A></H3>
<PRE>If[{},
Help2HTML`oA$["a[b,c,..] means a list of b, c,.. with the head a. It is evaluated as a function-reference when a is a function or \
a defined-function. When a is a list with head List, it is interpreted as a part specification of a list. When a is a character-st\
ring, it is interpreted as a substring specification. When a is an operator, it is an expression b (a) c (a) .. . When a is Null, \
it means a sequence."],
p$1991=1+p$1991[[1,2]];p1$1991=StringPosition["a[b,c,..] means a list of b, c,.. with the head a. It is evaluated as a function-re\
ference when a is a function or a defined-function. When a is a list with head List, it is interpreted as a part specification of \
a list. When a is a character-string, it is interpreted as a substring specification. When a is an operator, it is an expression b\
 (a) c (a) .. . When a is Null, it means a sequence."[p$1991,-1],">::",1];
   p1$1991=If[p1$1991==={},395,-2+p$1991+p1$1991[[1,1]]];
neq=Which["a[b,c,..] means a list of b, c,.. with the head a. It is evaluated as a function-reference when a is a function or a de\
fined-function. When a is a list with head List, it is interpreted as a part specification of a list. When a is a character-string\
, it is interpreted as a substring specification. When a is an operator, it is an expression b (a) c (a) .. . When a is Null, it m\
eans a sequence."[p$1991,4+p$1991]==="Text[",
    lx$1991:=Help2HTML`oa$;p$1991=5+p$1991;p1$1991-=1;p2$1991=5+p1$1991;p0$1991=-9+p$1991;If[(pe$1991=
StringPosition["a[b,c,..] means a list of b, c,.. with the head a. It is evaluated as a function-reference when a is a function or\
 a defined-function. When a is a list with head List, it is interpreted as a part specification of a list. When a is a character-s\
tring, it is interpreted as a substring specification. When a is an operator, it is an expression b (a) c (a) .. . When a is Null,\
 it means a sequence."[p$1991,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["a[b,c,..] means a list of b, c,.. with the head a. It is evaluated as a function-reference when a is a function o\
r a defined-function. When a is a list with head List, it is interpreted as a part specification of a list. When a is a character-\
string, it is interpreted as a substring specification. When a is an operator, it is an expression b (a) c (a) .. . When a is Null\
, it means a sequence."[p$1991+pe$1991[[1,2]],p1$1991]]],
        p1$1991=-2+p$1991+pe$1991[[1,1]]}[[
       1]],
      0],
    1,lx$1991:=Help2HTML`o9$;p2$1991=4+p1$1991;p0$1991=-4+p$1991;0];
  If[(equ$1991=
Help2HTML`o8$["a[b,c,..] means a list of b, c,.. with the head a. It is evaluated as a function-reference when a is a function or \
a defined-function. When a is a list with head List, it is interpreted as a part specification of a list. When a is a character-st\
ring, it is interpreted as a substring specification. When a is an operator, it is an expression b (a) c (a) .. . When a is Null, \
it means a sequence."[p$1991,p1$1991]])===
    Undefined,
equ$1991="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["a[b,c,..] means a list of b, c,.. with the h\
ead a. It is evaluated as a function-reference when a is a function or a defined-function. When a is a list with head List, it is \
interpreted as a part specification of a list. When a is a character-string, it is interpreted as a substring specification. When \
a is an operator, it is an expression b (a) c (a) .. . When a is Null, it means a sequence."[p$1991,p1$1991]]=
       equ$1991;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1991},out$1991=lx$1991@Typeset["a[b,c,..] means a list of b, c,.. with the head a. It is evaluated as a function-referenc\
e when a is a function or a defined-function. When a is a list with head List, it is interpreted as a part specification of a list\
. When a is a character-string, it is interpreted as a substring specification. When a is an operator, it is an expression b (a) c\
 (a) .. . When a is Null, it means a sequence."[p$1991,p1$1991],Format->Help2HTML`oB$];
        System["mv -f "//out$1991//" "//equ$1991]];
      Exit[]]];
   "a[b,c,..] means a list of b, c,.. with the head a. It is evaluated as a function-reference when a is a function or a defined-f\
unction. When a is a list with head List, it is interpreted as a part specification of a list. When a is a character-string, it is\
 interpreted as a substring specification. When a is an operator, it is an expression b (a) c (a) .. . When a is Null, it means a \
sequence."[1,Max[p0$1991,0]]//"<img  class=\"eqs\" SRC=\""//equ$1991//"\" />"//
Help2HTML`oy$["a[b,c,..] means a list of b, c,.. with the head a. It is evaluated as a function-reference when a is a function or \
a defined-function. When a is a list with head List, it is interpreted as a part specification of a list. When a is a character-st\
ring, it is interpreted as a substring specification. When a is an operator, it is an expression b (a) c (a) .. . When a is Null, \
it means a sequence."[p2$1991,-1]]
]</PRE>
<LI>
<H3><A NAME=L283>
Set(=)</A></H3>
<PRE>If[{},
Help2HTML`oA$["a = value sets the value b to the symbol a. {a,b,..}={v1,v2,..} sets a,b,c simultaneously. a[b,c,..]=v1 sets the pa\
rt of a[b,c,..] if a is a list. a[b,c,..] = expression defines the value a[b,c,..] if a is not a list."],
 p$1993=1+p$1993[[1,2]];p1$1993=
StringPosition["a = value sets the value b to the symbol a. {a,b,..}={v1,v2,..} sets a,b,c simultaneously. a[b,c,..]=v1 sets the p\
art of a[b,c,..] if a is a list. a[b,c,..] = expression defines the value a[b,c,..] if a is not a list."[p$1993,-1],">::",1];
   p1$1993=If[p1$1993==={},217,-2+p$1993+p1$1993[[1,1]]];
neq=Which["a = value sets the value b to the symbol a. {a,b,..}={v1,v2,..} sets a,b,c simultaneously. a[b,c,..]=v1 sets the part o\
f a[b,c,..] if a is a list. a[b,c,..] = expression defines the value a[b,c,..] if a is not a list."[p$1993,4+p$1993]==="Text[",
    lx$1993:=Help2HTML`oa$;p$1993=5+p$1993;p1$1993-=1;p2$1993=5+p1$1993;p0$1993=-9+p$1993;
If[(pe$1993=StringPosition["a = value sets the value b to the symbol a. {a,b,..}={v1,v2,..} sets a,b,c simultaneously. a[b,c,..]=v\
1 sets the part of a[b,c,..] if a is a list. a[b,c,..] = expression defines the value a[b,c,..] if a is not a list."[p$1993,-2],
         ";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["a = value sets the value b to the symbol a. {a,b,..}={v1,v2,..} sets a,b,c simultaneously. a[b,c,..]=v1 sets the \
part of a[b,c,..] if a is a list. a[b,c,..] = expression defines the value a[b,c,..] if a is not a list."[p$1993+pe$1993[[1,2]],
           p1$1993]]],
        p1$1993=-2+p$1993+pe$1993[[1,1]]}[[
       1]],
      0],
    1,lx$1993:=Help2HTML`o9$;p2$1993=4+p1$1993;p0$1993=-4+p$1993;0];
  If[(equ$1993=
Help2HTML`o8$["a = value sets the value b to the symbol a. {a,b,..}={v1,v2,..} sets a,b,c simultaneously. a[b,c,..]=v1 sets the pa\
rt of a[b,c,..] if a is a list. a[b,c,..] = expression defines the value a[b,c,..] if a is not a list."[p$1993,p1$1993]])===
    Undefined,
equ$1993="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["a = value sets the value b to the symbol a. \
{a,b,..}={v1,v2,..} sets a,b,c simultaneously. a[b,c,..]=v1 sets the part of a[b,c,..] if a is a list. a[b,c,..] = expression defi\
nes the value a[b,c,..] if a is not a list."[p$1993,p1$1993]]=
       equ$1993;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$1993},out$1993=lx$1993@Typeset["a = value sets the value b to the symbol a. {a,b,..}={v1,v2,..} sets a,b,c simultaneously\
. a[b,c,..]=v1 sets the part of a[b,c,..] if a is a list. a[b,c,..] = expression defines the value a[b,c,..] if a is not a list."[
           p$1993,p1$1993],Format->Help2HTML`oB$];
        System["mv -f "//out$1993//" "//equ$1993]];
      Exit[]]];
   "a = value sets the value b to the symbol a. {a,b,..}={v1,v2,..} sets a,b,c simultaneously. a[b,c,..]=v1 sets the part of a[b,c\
,..] if a is a list. a[b,c,..] = expression defines the value a[b,c,..] if a is not a list."[1,Max[p0$1993,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$1993//"\" />"//
Help2HTML`oy$["a = value sets the value b to the symbol a. {a,b,..}={v1,v2,..} sets a,b,c simultaneously. a[b,c,..]=v1 sets the pa\
rt of a[b,c,..] if a is a list. a[b,c,..] = expression defines the value a[b,c,..] if a is not a list."[p2$1993,-1]]
]</PRE>
<LI>
<H3><A NAME=L284>
SetDelayed(:=)</A></H3>
<PRE>If[{},Help2HTML`oA$["same as Set but the right hand side is not evaluated when it is set."],
 p$1995=1+p$1995[[1,2]];p1$1995=StringPosition["same as Set but the right hand side is not evaluated when it is set."[p$1995,-1],
    ">::",1];
   p1$1995=If[p1$1995==={},68,-2+p$1995+p1$1995[[1,1]]];
  neq=Which["same as Set but the right hand side is not evaluated when it is set."[p$1995,4+p$1995]==="Text[",
    lx$1995:=Help2HTML`oa$;p$1995=5+p$1995;p1$1995-=1;p2$1995=5+p1$1995;p0$1995=-9+p$1995;
     If[(pe$1995=StringPosition["same as Set but the right hand side is not evaluated when it is set."[p$1995,-2],";;;"])<=>{},
      {Max[0,-1+ToExpression["same as Set but the right hand side is not evaluated when it is set."[p$1995+pe$1995[[1,2]],p1$1995]]
        ],p1$1995=-2+p$1995+pe$1995[[1,1]]}[[
       1]],
      0],
    1,lx$1995:=Help2HTML`o9$;p2$1995=4+p1$1995;p0$1995=-4+p$1995;0];
  If[(equ$1995=Help2HTML`o8$["same as Set but the right hand side is not evaluated when it is set."[p$1995,p1$1995]])===Undefined,
   equ$1995="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["same as Set but the right hand side is not evaluated when it is set."[p$1995,p1$1995]]=equ$1995;
      LaTeX`ob$+=neq,
     --LaTeX`ob$;With[{lx$1995},out$1995=lx$1995@Typeset["same as Set but the right hand side is not evaluated when it is set."[p
           $1995,p1$1995],Format->Help2HTML`oB$];
        System["mv -f "//out$1995//" "//equ$1995]];
      Exit[]]];
   "same as Set but the right hand side is not evaluated when it is set."[1,Max[p0$1995,0]]//"<img  class=\"eqs\" SRC=\""//
   equ$1995//"\" />"//Help2HTML`oy$["same as Set but the right hand side is not evaluated when it is set."[p2$1995,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L283>Set(=)</A></PRE>
<LI>
<H3><A NAME=L285>
StringJoin (//)</A></H3>
<PRE>If[{},Help2HTML`oA$["a // b converts a and b to character-strings, then join them."],
 p$1998=1+p$1998[[1,2]];p1$1998=StringPosition["a // b converts a and b to character-strings, then join them."[p$1998,-1],">::",1];
  p1$1998=If[p1$1998==={},61,-2+p$1998+p1$1998[[1,1]]];
  neq=Which["a // b converts a and b to character-strings, then join them."[p$1998,4+p$1998]==="Text[",
    lx$1998:=Help2HTML`oa$;p$1998=5+p$1998;p1$1998-=1;p2$1998=5+p1$1998;p0$1998=-9+p$1998;
     If[(pe$1998=StringPosition["a // b converts a and b to character-strings, then join them."[p$1998,-2],";;;"])<=>{},
      {Max[0,-1+ToExpression["a // b converts a and b to character-strings, then join them."[p$1998+pe$1998[[1,2]],p1$1998]]],
       p1$1998=-2+p$1998+pe$1998[[1,1]]}[[1]],
      0],
    1,lx$1998:=Help2HTML`o9$;p2$1998=4+p1$1998;p0$1998=-4+p$1998;0];
  If[(equ$1998=Help2HTML`o8$["a // b converts a and b to character-strings, then join them."[p$1998,p1$1998]])===Undefined,
   equ$1998="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["a // b converts a and b to character-strings, then join them."[p$1998,p1$1998]]=equ$1998;
      LaTeX`ob$+=neq,
     --LaTeX`ob$;With[{lx$1998},out$1998=lx$1998@Typeset["a // b converts a and b to character-strings, then join them."[p$1998,
           p1$1998],Format->Help2HTML`oB$];
        System["mv -f "//out$1998//" "//equ$1998]];
      Exit[]]];
   "a // b converts a and b to character-strings, then join them."[1,Max[p0$1998,0]]//"<img  class=\"eqs\" SRC=\""//equ$1998//
   "\" />"//Help2HTML`oy$["a // b converts a and b to character-strings, then join them."[p2$1998,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L18>StringJoin</A></PRE>
<LI>
<H3><A NAME=L286>
SubtractFrom(-=)</A></H3>
<PRE>If[{},Help2HTML`oA$["a-=b is equivalent to a=a-b ."],
 p$2001=1+p$2001[[1,2]];p1$2001=StringPosition["a-=b is equivalent to a=a-b ."[p$2001,-1],">::",1];
  p1$2001=If[p1$2001==={},29,-2+p$2001+p1$2001[[1,1]]];
  neq=Which["a-=b is equivalent to a=a-b ."[p$2001,4+p$2001]==="Text[",lx$2001:=Help2HTML`oa$;p$2001=5+p$2001;p1$2001-=1;
     p2$2001=5+p1$2001;p0$2001=-9+p$2001;
     If[(pe$2001=StringPosition["a-=b is equivalent to a=a-b ."[p$2001,-2],";;;"])<=>{},{Max[0,
        -1+ToExpression["a-=b is equivalent to a=a-b ."[p$2001+pe$2001[[1,2]],p1$2001]]],p1$2001=-2+p$2001+pe$2001[[1,1]]}[[
       1]],
      0],
    1,lx$2001:=Help2HTML`o9$;p2$2001=4+p1$2001;p0$2001=-4+p$2001;0];
  If[(equ$2001=Help2HTML`o8$["a-=b is equivalent to a=a-b ."[p$2001,p1$2001]])===Undefined,
   equ$2001="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["a-=b is equivalent to a=a-b ."[p$2001,p1$2001]]=equ$2001;LaTeX`ob$+=neq,
     --LaTeX`ob$;With[{lx$2001},out$2001=lx$2001@Typeset["a-=b is equivalent to a=a-b ."[p$2001,p1$2001],Format->Help2HTML`oB$];
        System["mv -f "//out$2001//" "//equ$2001]];
      Exit[]]];
   "a-=b is equivalent to a=a-b ."[1,Max[p0$2001,0]]//"<img  class=\"eqs\" SRC=\""//equ$2001//"\" />"//
   Help2HTML`oy$["a-=b is equivalent to a=a-b ."[p2$2001,-1]]
]</PRE>
<LI>
<H3><A NAME=L287>
TagSet(/:)</A></H3>
<PRE>If[{},
Help2HTML`oA$["symb/:lhs = rhs sets rhs to lhs, associated with symbol symb. symb/:lhs := rhs sets rhs to lhs unevaluated, associa\
ted with symbol symb. symb/:lhs =. unsets lhs, associated with symbol symb."],
p$2003=1+p$2003[[1,2]];p1$2003=StringPosition["symb/:lhs = rhs sets rhs to lhs, associated with symbol symb. symb/:lhs := rhs sets\
 rhs to lhs unevaluated, associated with symbol symb. symb/:lhs =. unsets lhs, associated with symbol symb."[p$2003,-1],">::",1];
   p1$2003=If[p1$2003==={},190,-2+p$2003+p1$2003[[1,1]]];
neq=Which["symb/:lhs = rhs sets rhs to lhs, associated with symbol symb. symb/:lhs := rhs sets rhs to lhs unevaluated, associated \
with symbol symb. symb/:lhs =. unsets lhs, associated with symbol symb."[p$2003,4+p$2003]==="Text[",
    lx$2003:=Help2HTML`oa$;p$2003=5+p$2003;p1$2003-=1;p2$2003=5+p1$2003;p0$2003=-9+p$2003;
If[(pe$2003=StringPosition["symb/:lhs = rhs sets rhs to lhs, associated with symbol symb. symb/:lhs := rhs sets rhs to lhs unevalu\
ated, associated with symbol symb. symb/:lhs =. unsets lhs, associated with symbol symb."[p$2003,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["symb/:lhs = rhs sets rhs to lhs, associated with symbol symb. symb/:lhs := rhs sets rhs to lhs unevaluated, assoc\
iated with symbol symb. symb/:lhs =. unsets lhs, associated with symbol symb."[p$2003+pe$2003[[1,2]],p1$2003]]],
        p1$2003=-2+p$2003+pe$2003[[1,1]]}[[
       1]],
      0],
    1,lx$2003:=Help2HTML`o9$;p2$2003=4+p1$2003;p0$2003=-4+p$2003;0];
  If[(equ$2003=
Help2HTML`o8$["symb/:lhs = rhs sets rhs to lhs, associated with symbol symb. symb/:lhs := rhs sets rhs to lhs unevaluated, associa\
ted with symbol symb. symb/:lhs =. unsets lhs, associated with symbol symb."[p$2003,p1$2003]])===
    Undefined,
equ$2003="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["symb/:lhs = rhs sets rhs to lhs, associated \
with symbol symb. symb/:lhs := rhs sets rhs to lhs unevaluated, associated with symbol symb. symb/:lhs =. unsets lhs, associated w\
ith symbol symb."[p$2003,p1$2003]]=
       equ$2003;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2003},out$2003=lx$2003@Typeset["symb/:lhs = rhs sets rhs to lhs, associated with symbol symb. symb/:lhs := rhs sets rhs t\
o lhs unevaluated, associated with symbol symb. symb/:lhs =. unsets lhs, associated with symbol symb."[p$2003,p1$2003],
          Format->Help2HTML`oB$];
        System["mv -f "//out$2003//" "//equ$2003]];
      Exit[]]];
   "symb/:lhs = rhs sets rhs to lhs, associated with symbol symb. symb/:lhs := rhs sets rhs to lhs unevaluated, associated with sy\
mbol symb. symb/:lhs =. unsets lhs, associated with symbol symb."[1,Max[p0$2003,0]]//"<img  class=\"eqs\" SRC=\""//equ$2003//
   "\" />"//
Help2HTML`oy$["symb/:lhs = rhs sets rhs to lhs, associated with symbol symb. symb/:lhs := rhs sets rhs to lhs unevaluated, associa\
ted with symbol symb. symb/:lhs =. unsets lhs, associated with symbol symb."[p2$2003,-1]]
]</PRE>
<LI>
<H3><A NAME=L288>
Times(*)</A></H3>
<PRE>If[{},
Help2HTML`oA$["a * b returns the product of a and b. If one of a or b is a list, or both are lists with same size, returns a list \
of element-wise results."],
p$2005=1+p$2005[[1,2]];p1$2005=StringPosition["a * b returns the product of a and b. If one of a or b is a list, or both are lists\
 with same size, returns a list of element-wise results."[p$2005,-1],">::",1];
   p1$2005=If[p1$2005==={},139,-2+p$2005+p1$2005[[1,1]]];
neq=Which["a * b returns the product of a and b. If one of a or b is a list, or both are lists with same size, returns a list of e\
lement-wise results."[p$2005,4+p$2005]==="Text[",
    lx$2005:=Help2HTML`oa$;p$2005=5+p$2005;p1$2005-=1;p2$2005=5+p1$2005;p0$2005=-9+p$2005;
If[(pe$2005=StringPosition["a * b returns the product of a and b. If one of a or b is a list, or both are lists with same size, re\
turns a list of element-wise results."[p$2005,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["a * b returns the product of a and b. If one of a or b is a list, or both are lists with same size, returns a lis\
t of element-wise results."[p$2005+pe$2005[[1,2]],p1$2005]]],
        p1$2005=-2+p$2005+pe$2005[[1,1]]}[[
       1]],
      0],
    1,lx$2005:=Help2HTML`o9$;p2$2005=4+p1$2005;p0$2005=-4+p$2005;0];
  If[(equ$2005=
Help2HTML`o8$["a * b returns the product of a and b. If one of a or b is a list, or both are lists with same size, returns a list \
of element-wise results."[p$2005,p1$2005]])===
    Undefined,
equ$2005="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["a * b returns the product of a and b. If one\
 of a or b is a list, or both are lists with same size, returns a list of element-wise results."[p$2005,p1$2005]]=
       equ$2005;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2005},out$2005=lx$2005@Typeset["a * b returns the product of a and b. If one of a or b is a list, or both are lists with \
same size, returns a list of element-wise results."[p$2005,p1$2005],Format->Help2HTML`oB$];
        System["mv -f "//out$2005//" "//equ$2005]];
      Exit[]]];
   "a * b returns the product of a and b. If one of a or b is a list, or both are lists with same size, returns a list of element-\
wise results."[1,Max[p0$2005,0]]//"<img  class=\"eqs\" SRC=\""//equ$2005//"\" />"//
Help2HTML`oy$["a * b returns the product of a and b. If one of a or b is a list, or both are lists with same size, returns a list \
of element-wise results."[p2$2005,-1]]
]</PRE>
<LI>
<H3><A NAME=L289>
TimesBy(*=)</A></H3>
<PRE>If[{},Help2HTML`oA$["a*=b is equivalent to a=a*b ."],
 p$2007=1+p$2007[[1,2]];p1$2007=StringPosition["a*=b is equivalent to a=a*b ."[p$2007,-1],">::",1];
  p1$2007=If[p1$2007==={},29,-2+p$2007+p1$2007[[1,1]]];
  neq=Which["a*=b is equivalent to a=a*b ."[p$2007,4+p$2007]==="Text[",lx$2007:=Help2HTML`oa$;p$2007=5+p$2007;p1$2007-=1;
     p2$2007=5+p1$2007;p0$2007=-9+p$2007;
     If[(pe$2007=StringPosition["a*=b is equivalent to a=a*b ."[p$2007,-2],";;;"])<=>{},{Max[0,
        -1+ToExpression["a*=b is equivalent to a=a*b ."[p$2007+pe$2007[[1,2]],p1$2007]]],p1$2007=-2+p$2007+pe$2007[[1,1]]}[[
       1]],
      0],
    1,lx$2007:=Help2HTML`o9$;p2$2007=4+p1$2007;p0$2007=-4+p$2007;0];
  If[(equ$2007=Help2HTML`o8$["a*=b is equivalent to a=a*b ."[p$2007,p1$2007]])===Undefined,
   equ$2007="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["a*=b is equivalent to a=a*b ."[p$2007,p1$2007]]=equ$2007;LaTeX`ob$+=neq,
     --LaTeX`ob$;With[{lx$2007},out$2007=lx$2007@Typeset["a*=b is equivalent to a=a*b ."[p$2007,p1$2007],Format->Help2HTML`oB$];
        System["mv -f "//out$2007//" "//equ$2007]];
      Exit[]]];
   "a*=b is equivalent to a=a*b ."[1,Max[p0$2007,0]]//"<img  class=\"eqs\" SRC=\""//equ$2007//"\" />"//
   Help2HTML`oy$["a*=b is equivalent to a=a*b ."[p2$2007,-1]]
]</PRE>
<LI>
<H3><A NAME=L290>
Unequal(<>)</A></H3>
<PRE>If[{},
Help2HTML`oA$["a <> b returns True(==1) if a and b are both Real with different values or a String with different length or values\
. If one of a or b is a list, or both are lists with same size, returns a list of element-wise results."],
 p$2009=1+p$2009[[1,2]];p1$2009=
StringPosition["a <> b returns True(==1) if a and b are both Real with different values or a String with different length or value\
s. If one of a or b is a list, or both are lists with same size, returns a list of element-wise results."[p$2009,-1],">::",1];
   p1$2009=If[p1$2009==={},218,-2+p$2009+p1$2009[[1,1]]];
neq=Which["a <> b returns True(==1) if a and b are both Real with different values or a String with different length or values. If\
 one of a or b is a list, or both are lists with same size, returns a list of element-wise results."[p$2009,4+p$2009]==="Text[",
    lx$2009:=Help2HTML`oa$;p$2009=5+p$2009;p1$2009-=1;p2$2009=5+p1$2009;p0$2009=-9+p$2009;
If[(pe$2009=StringPosition["a <> b returns True(==1) if a and b are both Real with different values or a String with different len\
gth or values. If one of a or b is a list, or both are lists with same size, returns a list of element-wise results."[p$2009,-2],
         ";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["a <> b returns True(==1) if a and b are both Real with different values or a String with different length or valu\
es. If one of a or b is a list, or both are lists with same size, returns a list of element-wise results."[p$2009+pe$2009[[1,2]],
           p1$2009]]],
        p1$2009=-2+p$2009+pe$2009[[1,1]]}[[
       1]],
      0],
    1,lx$2009:=Help2HTML`o9$;p2$2009=4+p1$2009;p0$2009=-4+p$2009;0];
  If[(equ$2009=
Help2HTML`o8$["a <> b returns True(==1) if a and b are both Real with different values or a String with different length or values\
. If one of a or b is a list, or both are lists with same size, returns a list of element-wise results."[p$2009,p1$2009]])===
    Undefined,
equ$2009="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["a <> b returns True(==1) if a and b are both\
 Real with different values or a String with different length or values. If one of a or b is a list, or both are lists with same s\
ize, returns a list of element-wise results."[p$2009,p1$2009]]=
       equ$2009;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2009},out$2009=lx$2009@Typeset["a <> b returns True(==1) if a and b are both Real with different values or a String with \
different length or values. If one of a or b is a list, or both are lists with same size, returns a list of element-wise results."[
           p$2009,p1$2009],Format->Help2HTML`oB$];
        System["mv -f "//out$2009//" "//equ$2009]];
      Exit[]]];
   "a <> b returns True(==1) if a and b are both Real with different values or a String with different length or values. If one of\
 a or b is a list, or both are lists with same size, returns a list of element-wise results."[1,Max[p0$2009,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2009//"\" />"//
Help2HTML`oy$["a <> b returns True(==1) if a and b are both Real with different values or a String with different length or values\
. If one of a or b is a list, or both are lists with same size, returns a list of element-wise results."[p2$2009,-1]]
]</PRE>
<LI>
<H3><A NAME=L291>
UnsameQ(<=>)</A></H3>
<PRE>If[{},
 Help2HTML`oA$["a <=> b returns True(==1) if a and b have the different types or different values. False(==0) otherwise."],
 p$2011=1+p$2011[[1,2]];
  p1$2011=StringPosition["a <=> b returns True(==1) if a and b have the different types or different values. False(==0) otherwise."
    [p$2011,-1],">::",1];
   p1$2011=If[p1$2011==={},104,-2+p$2011+p1$2011[[1,1]]];
  neq=Which["a <=> b returns True(==1) if a and b have the different types or different values. False(==0) otherwise."[p$2011,
      4+p$2011]===
     "Text[",
    lx$2011:=Help2HTML`oa$;p$2011=5+p$2011;p1$2011-=1;p2$2011=5+p1$2011;p0$2011=-9+p$2011;If[(pe$2011=StringPosition[
         "a <=> b returns True(==1) if a and b have the different types or different values. False(==0) otherwise."[p$2011,-2],
         ";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression["a <=> b returns True(==1) if a and b have the different types or different values. False(==0) otherwise."[
            p$2011+pe$2011[[1,2]],
           p1$2011]]],
        p1$2011=-2+p$2011+pe$2011[[1,1]]}[[
       1]],
      0],
    1,lx$2011:=Help2HTML`o9$;p2$2011=4+p1$2011;p0$2011=-4+p$2011;0];
  If[(equ$2011=
     Help2HTML`o8$["a <=> b returns True(==1) if a and b have the different types or different values. False(==0) otherwise."[p
       $2011,p1$2011]])===
    Undefined,
   equ$2011="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "a <=> b returns True(==1) if a and b have the different types or different values. False(==0) otherwise."[p$2011,p1$2011]
        ]=
       equ$2011;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$2011},out$2011=lx$2011@Typeset[
          "a <=> b returns True(==1) if a and b have the different types or different values. False(==0) otherwise."[p$2011,p1$2011
           ],Format->Help2HTML`oB$];
        System["mv -f "//out$2011//" "//equ$2011]];
      Exit[]]];
   "a <=> b returns True(==1) if a and b have the different types or different values. False(==0) otherwise."[1,Max[p0$2011,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2011//"\" />"//
   Help2HTML`oy$["a <=> b returns True(==1) if a and b have the different types or different values. False(==0) otherwise."[p2$2011
     ,-1]]
]</PRE>
<LI>
<H3><A NAME=L292>
Unset(=.)</A></H3>
<PRE>If[{},Help2HTML`oA$["a=. clears the definition assigned to a."],
 p$2013=1+p$2013[[1,2]];p1$2013=StringPosition["a=. clears the definition assigned to a."[p$2013,-1],">::",1];
  p1$2013=If[p1$2013==={},40,-2+p$2013+p1$2013[[1,1]]];
  neq=Which["a=. clears the definition assigned to a."[p$2013,4+p$2013]==="Text[",
    lx$2013:=Help2HTML`oa$;p$2013=5+p$2013;p1$2013-=1;p2$2013=5+p1$2013;p0$2013=-9+p$2013;
     If[(pe$2013=StringPosition["a=. clears the definition assigned to a."[p$2013,-2],";;;"])<=>{},
      {Max[0,-1+ToExpression["a=. clears the definition assigned to a."[p$2013+pe$2013[[1,2]],p1$2013]]],
       p1$2013=-2+p$2013+pe$2013[[1,1]]}[[1]],
      0],
    1,lx$2013:=Help2HTML`o9$;p2$2013=4+p1$2013;p0$2013=-4+p$2013;0];
  If[(equ$2013=Help2HTML`o8$["a=. clears the definition assigned to a."[p$2013,p1$2013]])===Undefined,
   equ$2013="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["a=. clears the definition assigned to a."[p$2013,p1$2013]]=equ$2013;LaTeX`ob$+=neq,
     --LaTeX`ob$;With[{lx$2013},
       out$2013=lx$2013@Typeset["a=. clears the definition assigned to a."[p$2013,p1$2013],Format->Help2HTML`oB$];
        System["mv -f "//out$2013//" "//equ$2013]];
      Exit[]]];
   "a=. clears the definition assigned to a."[1,Max[p0$2013,0]]//"<img  class=\"eqs\" SRC=\""//equ$2013//"\" />"//
   Help2HTML`oy$["a=. clears the definition assigned to a."[p2$2013,-1]]
]</PRE>
<PRE>See also:
 Clear</PRE>
</UL>
<H3><A NAME=L293>
ELSE</A></H3>
<PRE>If[{},
Help2HTML`oA$["Usage: IF expr1 body1 [ELSEIF expr2 body2 [ELSEIF ..]] [ELSE body3] ENDIF\n\nThis is a FORTRAN77 like IF-structure.\
 If the expression expr1 is True(==1) or nonzero, executes commands in body1. If it is False(==0), skip commands until ELSE, ELSEI\
F or ENDIF appears at the same level of the IF-structure, and executes commands after ELSE or ENDIF, or executes the ELSEIF comman\
d. If expr1 is not a real number, an error message is printed and ignores the command line."],
 p$2016=1+p$2016[[1,2]];p1$2016=StringPosition["Usage: IF expr1 body1 [ELSEIF expr2 body2 [ELSEIF ..]] [ELSE body3] ENDIF\n\nThis \
is a FORTRAN77 like IF-structure. If the expression expr1 is True(==1) or nonzero, executes commands in body1. If it is False(==0)\
, skip commands until ELSE, ELSEIF or ENDIF appears at the same level of the IF-structure, and executes commands after ELSE or END\
IF, or executes the ELSEIF command. If expr1 is not a real number, an error message is printed and ignores the command line."[p
     $2016,-1],
    ">::",1];
   p1$2016=If[p1$2016==={},464,-2+p$2016+p1$2016[[1,1]]];
neq=Which["Usage: IF expr1 body1 [ELSEIF expr2 body2 [ELSEIF ..]] [ELSE body3] ENDIF\n\nThis is a FORTRAN77 like IF-structure. If \
the expression expr1 is True(==1) or nonzero, executes commands in body1. If it is False(==0), skip commands until ELSE, ELSEIF or\
 ENDIF appears at the same level of the IF-structure, and executes commands after ELSE or ENDIF, or executes the ELSEIF command. I\
f expr1 is not a real number, an error message is printed and ignores the command line."[p$2016,4+p$2016]==="Text[",
    lx$2016:=Help2HTML`oa$;p$2016=5+p$2016;p1$2016-=1;p2$2016=5+p1$2016;p0$2016=-9+p$2016;
If[(pe$2016=StringPosition["Usage: IF expr1 body1 [ELSEIF expr2 body2 [ELSEIF ..]] [ELSE body3] ENDIF\n\nThis is a FORTRAN77 like \
IF-structure. If the expression expr1 is True(==1) or nonzero, executes commands in body1. If it is False(==0), skip commands unti\
l ELSE, ELSEIF or ENDIF appears at the same level of the IF-structure, and executes commands after ELSE or ENDIF, or executes the \
ELSEIF command. If expr1 is not a real number, an error message is printed and ignores the command line."[p$2016,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Usage: IF expr1 body1 [ELSEIF expr2 body2 [ELSEIF ..]] [ELSE body3] ENDIF\n\nThis is a FORTRAN77 like IF-structur\
e. If the expression expr1 is True(==1) or nonzero, executes commands in body1. If it is False(==0), skip commands until ELSE, ELS\
EIF or ENDIF appears at the same level of the IF-structure, and executes commands after ELSE or ENDIF, or executes the ELSEIF comm\
and. If expr1 is not a real number, an error message is printed and ignores the command line."[p$2016+pe$2016[[1,2]],p1$2016]]],
        p1$2016=-2+p$2016+pe$2016[[1,1]]}[[
       1]],
      0],
    1,lx$2016:=Help2HTML`o9$;p2$2016=4+p1$2016;p0$2016=-4+p$2016;0];
  If[(equ$2016=
Help2HTML`o8$["Usage: IF expr1 body1 [ELSEIF expr2 body2 [ELSEIF ..]] [ELSE body3] ENDIF\n\nThis is a FORTRAN77 like IF-structure.\
 If the expression expr1 is True(==1) or nonzero, executes commands in body1. If it is False(==0), skip commands until ELSE, ELSEI\
F or ENDIF appears at the same level of the IF-structure, and executes commands after ELSE or ENDIF, or executes the ELSEIF comman\
d. If expr1 is not a real number, an error message is printed and ignores the command line."[p$2016,p1$2016]])===
    Undefined,
equ$2016="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Usage: IF expr1 body1 [ELSEIF expr2 body2 [E\
LSEIF ..]] [ELSE body3] ENDIF\n\nThis is a FORTRAN77 like IF-structure. If the expression expr1 is True(==1) or nonzero, executes \
commands in body1. If it is False(==0), skip commands until ELSE, ELSEIF or ENDIF appears at the same level of the IF-structure, a\
nd executes commands after ELSE or ENDIF, or executes the ELSEIF command. If expr1 is not a real number, an error message is print\
ed and ignores the command line."[p$2016,p1$2016]]=
       equ$2016;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2016},out$2016=lx$2016@Typeset["Usage: IF expr1 body1 [ELSEIF expr2 body2 [ELSEIF ..]] [ELSE body3] ENDIF\n\nThis is a FO\
RTRAN77 like IF-structure. If the expression expr1 is True(==1) or nonzero, executes commands in body1. If it is False(==0), skip \
commands until ELSE, ELSEIF or ENDIF appears at the same level of the IF-structure, and executes commands after ELSE or ENDIF, or \
executes the ELSEIF command. If expr1 is not a real number, an error message is printed and ignores the command line."[p$2016,
           p1$2016],Format->Help2HTML`oB$];
        System["mv -f "//out$2016//" "//equ$2016]];
      Exit[]]];
   "Usage: IF expr1 body1 [ELSEIF expr2 body2 [ELSEIF ..]] [ELSE body3] ENDIF\n\nThis is a FORTRAN77 like IF-structure. If the exp\
ression expr1 is True(==1) or nonzero, executes commands in body1. If it is False(==0), skip commands until ELSE, ELSEIF or ENDIF \
appears at the same level of the IF-structure, and executes commands after ELSE or ENDIF, or executes the ELSEIF command. If expr1\
 is not a real number, an error message is printed and ignores the command line."[1,Max[p0$2016,0]]//"<img  class=\"eqs\" SRC=\""//
   equ$2016//"\" />"//
Help2HTML`oy$["Usage: IF expr1 body1 [ELSEIF expr2 body2 [ELSEIF ..]] [ELSE body3] ENDIF\n\nThis is a FORTRAN77 like IF-structure.\
 If the expression expr1 is True(==1) or nonzero, executes commands in body1. If it is False(==0), skip commands until ELSE, ELSEI\
F or ENDIF appears at the same level of the IF-structure, and executes commands after ELSE or ENDIF, or executes the ELSEIF comman\
d. If expr1 is not a real number, an error message is printed and ignores the command line."[p2$2016,-1]]
]</PRE>
<PRE>See also:
 If <A HREF=#L294>ELSEIF</A> <A HREF=#L297>ENDIF</A></PRE>
<H3><A NAME=L294>
ELSEIF</A></H3>
<PRE>If[{},
Help2HTML`oA$["Usage: IF expr1 body1 [ELSEIF expr2 body2 [ELSEIF ..]] [ELSE body3] ENDIF\n\nThis is a FORTRAN77 like IF-structure.\
 If the expression expr1 is True(==1) or nonzero, executes commands in body1. If it is False(==0), skip commands until ELSE, ELSEI\
F or ENDIF appears at the same level of the IF-structure, and executes commands after ELSE or ENDIF, or executes the ELSEIF comman\
d. If expr1 is not a real number, an error message is printed and ignores the command line."],
 p$2019=1+p$2019[[1,2]];p1$2019=StringPosition["Usage: IF expr1 body1 [ELSEIF expr2 body2 [ELSEIF ..]] [ELSE body3] ENDIF\n\nThis \
is a FORTRAN77 like IF-structure. If the expression expr1 is True(==1) or nonzero, executes commands in body1. If it is False(==0)\
, skip commands until ELSE, ELSEIF or ENDIF appears at the same level of the IF-structure, and executes commands after ELSE or END\
IF, or executes the ELSEIF command. If expr1 is not a real number, an error message is printed and ignores the command line."[p
     $2019,-1],
    ">::",1];
   p1$2019=If[p1$2019==={},464,-2+p$2019+p1$2019[[1,1]]];
neq=Which["Usage: IF expr1 body1 [ELSEIF expr2 body2 [ELSEIF ..]] [ELSE body3] ENDIF\n\nThis is a FORTRAN77 like IF-structure. If \
the expression expr1 is True(==1) or nonzero, executes commands in body1. If it is False(==0), skip commands until ELSE, ELSEIF or\
 ENDIF appears at the same level of the IF-structure, and executes commands after ELSE or ENDIF, or executes the ELSEIF command. I\
f expr1 is not a real number, an error message is printed and ignores the command line."[p$2019,4+p$2019]==="Text[",
    lx$2019:=Help2HTML`oa$;p$2019=5+p$2019;p1$2019-=1;p2$2019=5+p1$2019;p0$2019=-9+p$2019;
If[(pe$2019=StringPosition["Usage: IF expr1 body1 [ELSEIF expr2 body2 [ELSEIF ..]] [ELSE body3] ENDIF\n\nThis is a FORTRAN77 like \
IF-structure. If the expression expr1 is True(==1) or nonzero, executes commands in body1. If it is False(==0), skip commands unti\
l ELSE, ELSEIF or ENDIF appears at the same level of the IF-structure, and executes commands after ELSE or ENDIF, or executes the \
ELSEIF command. If expr1 is not a real number, an error message is printed and ignores the command line."[p$2019,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Usage: IF expr1 body1 [ELSEIF expr2 body2 [ELSEIF ..]] [ELSE body3] ENDIF\n\nThis is a FORTRAN77 like IF-structur\
e. If the expression expr1 is True(==1) or nonzero, executes commands in body1. If it is False(==0), skip commands until ELSE, ELS\
EIF or ENDIF appears at the same level of the IF-structure, and executes commands after ELSE or ENDIF, or executes the ELSEIF comm\
and. If expr1 is not a real number, an error message is printed and ignores the command line."[p$2019+pe$2019[[1,2]],p1$2019]]],
        p1$2019=-2+p$2019+pe$2019[[1,1]]}[[
       1]],
      0],
    1,lx$2019:=Help2HTML`o9$;p2$2019=4+p1$2019;p0$2019=-4+p$2019;0];
  If[(equ$2019=
Help2HTML`o8$["Usage: IF expr1 body1 [ELSEIF expr2 body2 [ELSEIF ..]] [ELSE body3] ENDIF\n\nThis is a FORTRAN77 like IF-structure.\
 If the expression expr1 is True(==1) or nonzero, executes commands in body1. If it is False(==0), skip commands until ELSE, ELSEI\
F or ENDIF appears at the same level of the IF-structure, and executes commands after ELSE or ENDIF, or executes the ELSEIF comman\
d. If expr1 is not a real number, an error message is printed and ignores the command line."[p$2019,p1$2019]])===
    Undefined,
equ$2019="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Usage: IF expr1 body1 [ELSEIF expr2 body2 [E\
LSEIF ..]] [ELSE body3] ENDIF\n\nThis is a FORTRAN77 like IF-structure. If the expression expr1 is True(==1) or nonzero, executes \
commands in body1. If it is False(==0), skip commands until ELSE, ELSEIF or ENDIF appears at the same level of the IF-structure, a\
nd executes commands after ELSE or ENDIF, or executes the ELSEIF command. If expr1 is not a real number, an error message is print\
ed and ignores the command line."[p$2019,p1$2019]]=
       equ$2019;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2019},out$2019=lx$2019@Typeset["Usage: IF expr1 body1 [ELSEIF expr2 body2 [ELSEIF ..]] [ELSE body3] ENDIF\n\nThis is a FO\
RTRAN77 like IF-structure. If the expression expr1 is True(==1) or nonzero, executes commands in body1. If it is False(==0), skip \
commands until ELSE, ELSEIF or ENDIF appears at the same level of the IF-structure, and executes commands after ELSE or ENDIF, or \
executes the ELSEIF command. If expr1 is not a real number, an error message is printed and ignores the command line."[p$2019,
           p1$2019],Format->Help2HTML`oB$];
        System["mv -f "//out$2019//" "//equ$2019]];
      Exit[]]];
   "Usage: IF expr1 body1 [ELSEIF expr2 body2 [ELSEIF ..]] [ELSE body3] ENDIF\n\nThis is a FORTRAN77 like IF-structure. If the exp\
ression expr1 is True(==1) or nonzero, executes commands in body1. If it is False(==0), skip commands until ELSE, ELSEIF or ENDIF \
appears at the same level of the IF-structure, and executes commands after ELSE or ENDIF, or executes the ELSEIF command. If expr1\
 is not a real number, an error message is printed and ignores the command line."[1,Max[p0$2019,0]]//"<img  class=\"eqs\" SRC=\""//
   equ$2019//"\" />"//
Help2HTML`oy$["Usage: IF expr1 body1 [ELSEIF expr2 body2 [ELSEIF ..]] [ELSE body3] ENDIF\n\nThis is a FORTRAN77 like IF-structure.\
 If the expression expr1 is True(==1) or nonzero, executes commands in body1. If it is False(==0), skip commands until ELSE, ELSEI\
F or ENDIF appears at the same level of the IF-structure, and executes commands after ELSE or ENDIF, or executes the ELSEIF comman\
d. If expr1 is not a real number, an error message is printed and ignores the command line."[p2$2019,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L470>IF</A> <A HREF=#L293>ELSE</A> <A HREF=#L297>ENDIF</A></PRE>
<H3><A NAME=L295>
EMITTANCE(EMIT)</A></H3>
<PRE>Usage: (1) EMIT
       (2) EMIT dp

(1) EMIT calculates the closed orbit, the normal coordinate, and the equilibrium emittance assuming the current beam line is a posi
tron ring. One of EMITTANCE(EMIT), the Emittance[] function, or the EMIT command in the MAIN level are necessary to be done in prio
r to multi-turn tracking. See multi-turn-tracking.

(2) EMIT dp, where dp is |df_rf/f_rf|/(alpha_p == momentum compaction), does EMIT for five rf frequencies:

<img  class="eqs" SRC="SADHelp_img/equ_199.svg" />If[{},Help2HTML`oA$["\n\nthen prints out a table of the dependences of various qu
antities on the frequency shift.\n\n   The results of EMITTANCE(EMIT) are affected by flags COD, RADCOD, RFSW, INTRA, WSPAC, EMIOUT
, CODPLOT and special-variables MOMENTUM, CHARGE, FSHIFT, MINCOUP, PBUNCH. The flag TRPT or RING affects only Emittance[], as EMITT
ANCE(EMIT) automatically set RING.\n\n   EMITTANCE(EMIT) returns the equilibrium emittances in variables EMITX, EMITY, EMITZ, and t
he equilibrium bunch length in SIGZ, the relative momentum spread in SIGE, and the longitudinal equilibrium position DTSYNCH. Value
s Max[EMITk, MINCOUP*(EMITX+EMITY)] (k=X,Y) are used in the intrabeam calculaton, but variables EMITX and EMITY hold the original v
alue without MINCOUP.\n\n   The map used in EMIT is slightly different from that used in the tracking. For instance, the edge angle
 of a bend is approximated by a thin quad. If the edge angle is large and the curvature is small, EMIT may give a wrong answer. Thi
s will be corrected in near future."],p$2023=1+p$2023[[1,2]];p1$2023=StringPosition["\n\nthen prints out a table of the dependences
 of various quantities on the frequency shift.\n\n   The results of EMITTANCE(EMIT) are affected by flags COD, RADCOD, RFSW, INTRA,
 WSPAC, EMIOUT, CODPLOT and special-variables MOMENTUM, CHARGE, FSHIFT, MINCOUP, PBUNCH. The flag TRPT or RING affects only Emittan
ce[], as EMITTANCE(EMIT) automatically set RING.\n\n   EMITTANCE(EMIT) returns the equilibrium emittances in variables EMITX, EMITY
, EMITZ, and the equilibrium bunch length in SIGZ, the relative momentum spread in SIGE, and the longitudinal equilibrium position 
DTSYNCH. Values Max[EMITk, MINCOUP*(EMITX+EMITY)] (k=X,Y) are used in the intrabeam calculaton, but variables EMITX and EMITY hold 
the original value without MINCOUP.\n\n   The map used in EMIT is slightly different from that used in the tracking. For instance, 
the edge angle of a bend is approximated by a thin quad. If the edge angle is large and the curvature is small, EMIT may give a wro
ng answer. This will be corrected in near future."[p$2023,-1],">::",1];p1$2023=If[p1$2023==={},1004,-2+p$2023+p1$2023[[1,1]]];neq=W
hich["\n\nthen prints out a table of the dependences of various quantities on the frequency shift.\n\n   The results of EMITTANCE(E
MIT) are affected by flags COD, RADCOD, RFSW, INTRA, WSPAC, EMIOUT, CODPLOT and special-variables MOMENTUM, CHARGE, FSHIFT, MINCOUP
, PBUNCH. The flag TRPT or RING affects only Emittance[], as EMITTANCE(EMIT) automatically set RING.\n\n   EMITTANCE(EMIT) returns 
the equilibrium emittances in variables EMITX, EMITY, EMITZ, and the equilibrium bunch length in SIGZ, the relative momentum spread
 in SIGE, and the longitudinal equilibrium position DTSYNCH. Values Max[EMITk, MINCOUP*(EMITX+EMITY)] (k=X,Y) are used in the intra
beam calculaton, but variables EMITX and EMITY hold the original value without MINCOUP.\n\n   The map used in EMIT is slightly diff
erent from that used in the tracking. For instance, the edge angle of a bend is approximated by a thin quad. If the edge angle is l
arge and the curvature is small, EMIT may give a wrong answer. This will be corrected in near future."[p$2023,4+p$2023]==="Text[",l
x$2023:=Help2HTML`oa$;p$2023=5+p$2023;p1$2023-=1;p2$2023=5+p1$2023;p0$2023=-9+p$2023;If[(pe$2023=StringPosition["\n\nthen prints ou
t a table of the dependences of various quantities on the frequency shift.\n\n   The results of EMITTANCE(EMIT) are affected by fla
gs COD, RADCOD, RFSW, INTRA, WSPAC, EMIOUT, CODPLOT and special-variables MOMENTUM, CHARGE, FSHIFT, MINCOUP, PBUNCH. The flag TRPT 
or RING affects only Emittance[], as EMITTANCE(EMIT) automatically set RING.\n\n   EMITTANCE(EMIT) returns the equilibrium emittanc
es in variables EMITX, EMITY, EMITZ, and the equilibrium bunch length in SIGZ, the relative momentum spread in SIGE, and the longit
udinal equilibrium position DTSYNCH. Values Max[EMITk, MINCOUP*(EMITX+EMITY)] (k=X,Y) are used in the intrabeam calculaton, but var
iables EMITX and EMITY hold the original value without MINCOUP.\n\n   The map used in EMIT is slightly different from that used in 
the tracking. For instance, the edge angle of a bend is approximated by a thin quad. If the edge angle is large and the curvature i
s small, EMIT may give a wrong answer. This will be corrected in near future."[p$2023,-2],";;;"])<=>{},{Max[0,-1+ToExpression["\n\n
then prints out a table of the dependences of various quantities on the frequency shift.\n\n   The results of EMITTANCE(EMIT) are a
ffected by flags COD, RADCOD, RFSW, INTRA, WSPAC, EMIOUT, CODPLOT and special-variables MOMENTUM, CHARGE, FSHIFT, MINCOUP, PBUNCH. 
The flag TRPT or RING affects only Emittance[], as EMITTANCE(EMIT) automatically set RING.\n\n   EMITTANCE(EMIT) returns the equili
brium emittances in variables EMITX, EMITY, EMITZ, and the equilibrium bunch length in SIGZ, the relative momentum spread in SIGE, 
and the longitudinal equilibrium position DTSYNCH. Values Max[EMITk, MINCOUP*(EMITX+EMITY)] (k=X,Y) are used in the intrabeam calcu
laton, but variables EMITX and EMITY hold the original value without MINCOUP.\n\n   The map used in EMIT is slightly different from
 that used in the tracking. For instance, the edge angle of a bend is approximated by a thin quad. If the edge angle is large and t
he curvature is small, EMIT may give a wrong answer. This will be corrected in near future."[p$2023+pe$2023[[1,2]],p1$2023]]],p1$20
23=-2+p$2023+pe$2023[[1,1]]}[[1]],0],1,lx$2023:=Help2HTML`o9$;p2$2023=4+p1$2023;p0$2023=-4+p$2023;0];If[(equ$2023=Help2HTML`o8$["\n
\nthen prints out a table of the dependences of various quantities on the frequency shift.\n\n   The results of EMITTANCE(EMIT) are
 affected by flags COD, RADCOD, RFSW, INTRA, WSPAC, EMIOUT, CODPLOT and special-variables MOMENTUM, CHARGE, FSHIFT, MINCOUP, PBUNCH
. The flag TRPT or RING affects only Emittance[], as EMITTANCE(EMIT) automatically set RING.\n\n   EMITTANCE(EMIT) returns the equi
librium emittances in variables EMITX, EMITY, EMITZ, and the equilibrium bunch length in SIGZ, the relative momentum spread in SIGE
, and the longitudinal equilibrium position DTSYNCH. Values Max[EMITk, MINCOUP*(EMITX+EMITY)] (k=X,Y) are used in the intrabeam cal
culaton, but variables EMITX and EMITY hold the original value without MINCOUP.\n\n   The map used in EMIT is slightly different fr
om that used in the tracking. For instance, the edge angle of a bend is approximated by a thin quad. If the edge angle is large and
 the curvature is small, EMIT may give a wrong answer. This will be corrected in near future."[p$2023,p1$2023]])===Undefined,equ$20
23="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["\n\nthen prints out a table of the dependences of v
arious quantities on the frequency shift.\n\n   The results of EMITTANCE(EMIT) are affected by flags COD, RADCOD, RFSW, INTRA, WSPA
C, EMIOUT, CODPLOT and special-variables MOMENTUM, CHARGE, FSHIFT, MINCOUP, PBUNCH. The flag TRPT or RING affects only Emittance[],
 as EMITTANCE(EMIT) automatically set RING.\n\n   EMITTANCE(EMIT) returns the equilibrium emittances in variables EMITX, EMITY, EMI
TZ, and the equilibrium bunch length in SIGZ, the relative momentum spread in SIGE, and the longitudinal equilibrium position DTSYN
CH. Values Max[EMITk, MINCOUP*(EMITX+EMITY)] (k=X,Y) are used in the intrabeam calculaton, but variables EMITX and EMITY hold the o
riginal value without MINCOUP.\n\n   The map used in EMIT is slightly different from that used in the tracking. For instance, the e
dge angle of a bend is approximated by a thin quad. If the edge angle is large and the curvature is small, EMIT may give a wrong an
swer. This will be corrected in near future."[p$2023,p1$2023]]=equ$2023;LaTeX`ob$+=neq,--LaTeX`ob$;With[{lx$2023},out$2023=lx$2023@
Typeset["\n\nthen prints out a table of the dependences of various quantities on the frequency shift.\n\n   The results of EMITTANC
E(EMIT) are affected by flags COD, RADCOD, RFSW, INTRA, WSPAC, EMIOUT, CODPLOT and special-variables MOMENTUM, CHARGE, FSHIFT, MINC
OUP, PBUNCH. The flag TRPT or RING affects only Emittance[], as EMITTANCE(EMIT) automatically set RING.\n\n   EMITTANCE(EMIT) retur
ns the equilibrium emittances in variables EMITX, EMITY, EMITZ, and the equilibrium bunch length in SIGZ, the relative momentum spr
ead in SIGE, and the longitudinal equilibrium position DTSYNCH. Values Max[EMITk, MINCOUP*(EMITX+EMITY)] (k=X,Y) are used in the in
trabeam calculaton, but variables EMITX and EMITY hold the original value without MINCOUP.\n\n   The map used in EMIT is slightly d
ifferent from that used in the tracking. For instance, the edge angle of a bend is approximated by a thin quad. If the edge angle i
s large and the curvature is small, EMIT may give a wrong answer. This will be corrected in near future."[p$2023,p1$2023],Format->H
elp2HTML`oB$];System["mv -f "//out$2023//" "//equ$2023]];Exit[]]];"\n\nthen prints out a table of the dependences of various quanti
ties on the frequency shift.\n\n   The results of EMITTANCE(EMIT) are affected by flags COD, RADCOD, RFSW, INTRA, WSPAC, EMIOUT, CO
DPLOT and special-variables MOMENTUM, CHARGE, FSHIFT, MINCOUP, PBUNCH. The flag TRPT or RING affects only Emittance[], as EMITTANCE
(EMIT) automatically set RING.\n\n   EMITTANCE(EMIT) returns the equilibrium emittances in variables EMITX, EMITY, EMITZ, and the e
quilibrium bunch length in SIGZ, the relative momentum spread in SIGE, and the longitudinal equilibrium position DTSYNCH. Values Ma
x[EMITk, MINCOUP*(EMITX+EMITY)] (k=X,Y) are used in the intrabeam calculaton, but variables EMITX and EMITY hold the original value
 without MINCOUP.\n\n   The map used in EMIT is slightly different from that used in the tracking. For instance, the edge angle of 
a bend is approximated by a thin quad. If the edge angle is large and the curvature is small, EMIT may give a wrong answer. This wi
ll be corrected in near future."[1,Max[p0$2023,0]]//"<img  class=\"eqs\" SRC=\""//equ$2023//"\" />"//Help2HTML`oy$["\n\nthen prints
 out a table of the dependences of various quantities on the frequency shift.\n\n   The results of EMITTANCE(EMIT) are affected by 
flags COD, RADCOD, RFSW, INTRA, WSPAC, EMIOUT, CODPLOT and special-variables MOMENTUM, CHARGE, FSHIFT, MINCOUP, PBUNCH. The flag TR
PT or RING affects only Emittance[], as EMITTANCE(EMIT) automatically set RING.\n\n   EMITTANCE(EMIT) returns the equilibrium emitt
ances in variables EMITX, EMITY, EMITZ, and the equilibrium bunch length in SIGZ, the relative momentum spread in SIGE, and the lon
gitudinal equilibrium position DTSYNCH. Values Max[EMITk, MINCOUP*(EMITX+EMITY)] (k=X,Y) are used in the intrabeam calculaton, but 
variables EMITX and EMITY hold the original value without MINCOUP.\n\n   The map used in EMIT is slightly different from that used 
in the tracking. For instance, the edge angle of a bend is approximated by a thin quad. If the edge angle is large and the curvatur
e is small, EMIT may give a wrong answer. This will be corrected in near future."[p2$2023,-1]]]
</PRE>
<PRE>See also:
 <A HREF=#L474>multi-turn-tracking</A> <A HREF=#L52>extended-Twiss-parameters</A> <A HREF=#L307>COD</A> <A HREF=#L338>RADCOD</A> <A HREF=#L344>RFSW</A> <A HREF=#L325>INTRA</A> <A HREF=#L315>EMIOUT</A> <A HREF=#L357>WSPAC</A> <A HREF=#L308>CODPLOT</A>
 <A HREF=#L352>TRPT</A> <A HREF=#L531>MOMENTUM</A> <A HREF=#L503>CHARGE</A> <A HREF=#L522>FSHIFT</A> <A HREF=#L530>MINCOUP</A> <A HREF=#L540>PBUNCH</A> <A HREF=#L513>EMITX</A> <A HREF=#L515>EMITY</A> <A HREF=#L517>EMITZ</A> <A HREF=#L543>SIGE</A> <A HREF=#L544>SIGZ</A> <A HREF=#L508>DTSYNCH</A>
 <A HREF=#L389>Emittance</A> <A HREF=#L55>equilibrium-beam-envelope</A></PRE>
<H3><A NAME=L296>
END</A></H3>
<PRE>If[{},
Help2HTML`oA$["Closes the current output-stream and set the output stream to the standard output(6). It also suspends all the inpu\
t streams and switches to the standard input(5). Since this command affects all input and output streams, you may consider to use \
TERMINATE(TERM) or CLOSE(CLO) to suspend or close them selectively."],
p$2026=1+p$2026[[1,2]];p1$2026=StringPosition["Closes the current output-stream and set the output stream to the standard output(6\
). It also suspends all the input streams and switches to the standard input(5). Since this command affects all input and output s\
treams, you may consider to use TERMINATE(TERM) or CLOSE(CLO) to suspend or close them selectively."[p$2026,-1],">::",1];
   p1$2026=If[p1$2026==={},312,-2+p$2026+p1$2026[[1,1]]];
neq=Which["Closes the current output-stream and set the output stream to the standard output(6). It also suspends all the input st\
reams and switches to the standard input(5). Since this command affects all input and output streams, you may consider to use TERM\
INATE(TERM) or CLOSE(CLO) to suspend or close them selectively."[p$2026,4+p$2026]==="Text[",
    lx$2026:=Help2HTML`oa$;p$2026=5+p$2026;p1$2026-=1;p2$2026=5+p1$2026;p0$2026=-9+p$2026;
If[(pe$2026=StringPosition["Closes the current output-stream and set the output stream to the standard output(6). It also suspends\
 all the input streams and switches to the standard input(5). Since this command affects all input and output streams, you may con\
sider to use TERMINATE(TERM) or CLOSE(CLO) to suspend or close them selectively."[p$2026,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Closes the current output-stream and set the output stream to the standard output(6). It also suspends all the in\
put streams and switches to the standard input(5). Since this command affects all input and output streams, you may consider to us\
e TERMINATE(TERM) or CLOSE(CLO) to suspend or close them selectively."[p$2026+pe$2026[[1,2]],p1$2026]]],
        p1$2026=-2+p$2026+pe$2026[[1,1]]}[[
       1]],
      0],
    1,lx$2026:=Help2HTML`o9$;p2$2026=4+p1$2026;p0$2026=-4+p$2026;0];
  If[(equ$2026=
Help2HTML`o8$["Closes the current output-stream and set the output stream to the standard output(6). It also suspends all the inpu\
t streams and switches to the standard input(5). Since this command affects all input and output streams, you may consider to use \
TERMINATE(TERM) or CLOSE(CLO) to suspend or close them selectively."[p$2026,p1$2026]])===
    Undefined,
equ$2026="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Closes the current output-stream and set the\
 output stream to the standard output(6). It also suspends all the input streams and switches to the standard input(5). Since this\
 command affects all input and output streams, you may consider to use TERMINATE(TERM) or CLOSE(CLO) to suspend or close them sele\
ctively."[p$2026,p1$2026]]=
       equ$2026;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2026},out$2026=lx$2026@Typeset["Closes the current output-stream and set the output stream to the standard output(6). It \
also suspends all the input streams and switches to the standard input(5). Since this command affects all input and output streams\
, you may consider to use TERMINATE(TERM) or CLOSE(CLO) to suspend or close them selectively."[p$2026,p1$2026],
          Format->Help2HTML`oB$];
        System["mv -f "//out$2026//" "//equ$2026]];
      Exit[]]];
   "Closes the current output-stream and set the output stream to the standard output(6). It also suspends all the input streams a\
nd switches to the standard input(5). Since this command affects all input and output streams, you may consider to use TERMINATE(T\
ERM) or CLOSE(CLO) to suspend or close them selectively."[1,Max[p0$2026,0]]//"<img  class=\"eqs\" SRC=\""//equ$2026//"\" />"//
   Help2HTML`oy$["Closes the current output-stream and set the output stream to the standard output(6). It also suspends all the i\
nput streams and switches to the standard input(5). Since this command affects all input and output streams, you may consider to u\
se TERMINATE(TERM) or CLOSE(CLO) to suspend or close them selectively."[p2$2026,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L555>TERMINATE(TERM)</A> <A HREF=#L34>CLOSE(CLO)</A> <A HREF=#L471>INPUT(IN)</A> <A HREF=#L487>READ</A> <A HREF=#L480>OUTPUT(OUT)</A> <A HREF=#L3>APPEND(APP)</A></PRE>
<H3><A NAME=L297>
ENDIF</A></H3>
<PRE>If[{},
Help2HTML`oA$["Usage: IF expr1 body1 [ELSEIF expr2 body2 [ELSEIF ..]] [ELSE body3] ENDIF\n\nThis is a FORTRAN77 like IF-structure.\
 If the expression expr1 is True(==1) or nonzero, executes commands in body1. If it is False(==0), skip commands until ELSE, ELSEI\
F or ENDIF appears at the same level of the IF-structure, and executes commands after ELSE or ENDIF, or executes the ELSEIF comman\
d. If expr1 is not a real number, an error message is printed and ignores the command line."],
 p$2029=1+p$2029[[1,2]];p1$2029=StringPosition["Usage: IF expr1 body1 [ELSEIF expr2 body2 [ELSEIF ..]] [ELSE body3] ENDIF\n\nThis \
is a FORTRAN77 like IF-structure. If the expression expr1 is True(==1) or nonzero, executes commands in body1. If it is False(==0)\
, skip commands until ELSE, ELSEIF or ENDIF appears at the same level of the IF-structure, and executes commands after ELSE or END\
IF, or executes the ELSEIF command. If expr1 is not a real number, an error message is printed and ignores the command line."[p
     $2029,-1],
    ">::",1];
   p1$2029=If[p1$2029==={},464,-2+p$2029+p1$2029[[1,1]]];
neq=Which["Usage: IF expr1 body1 [ELSEIF expr2 body2 [ELSEIF ..]] [ELSE body3] ENDIF\n\nThis is a FORTRAN77 like IF-structure. If \
the expression expr1 is True(==1) or nonzero, executes commands in body1. If it is False(==0), skip commands until ELSE, ELSEIF or\
 ENDIF appears at the same level of the IF-structure, and executes commands after ELSE or ENDIF, or executes the ELSEIF command. I\
f expr1 is not a real number, an error message is printed and ignores the command line."[p$2029,4+p$2029]==="Text[",
    lx$2029:=Help2HTML`oa$;p$2029=5+p$2029;p1$2029-=1;p2$2029=5+p1$2029;p0$2029=-9+p$2029;
If[(pe$2029=StringPosition["Usage: IF expr1 body1 [ELSEIF expr2 body2 [ELSEIF ..]] [ELSE body3] ENDIF\n\nThis is a FORTRAN77 like \
IF-structure. If the expression expr1 is True(==1) or nonzero, executes commands in body1. If it is False(==0), skip commands unti\
l ELSE, ELSEIF or ENDIF appears at the same level of the IF-structure, and executes commands after ELSE or ENDIF, or executes the \
ELSEIF command. If expr1 is not a real number, an error message is printed and ignores the command line."[p$2029,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Usage: IF expr1 body1 [ELSEIF expr2 body2 [ELSEIF ..]] [ELSE body3] ENDIF\n\nThis is a FORTRAN77 like IF-structur\
e. If the expression expr1 is True(==1) or nonzero, executes commands in body1. If it is False(==0), skip commands until ELSE, ELS\
EIF or ENDIF appears at the same level of the IF-structure, and executes commands after ELSE or ENDIF, or executes the ELSEIF comm\
and. If expr1 is not a real number, an error message is printed and ignores the command line."[p$2029+pe$2029[[1,2]],p1$2029]]],
        p1$2029=-2+p$2029+pe$2029[[1,1]]}[[
       1]],
      0],
    1,lx$2029:=Help2HTML`o9$;p2$2029=4+p1$2029;p0$2029=-4+p$2029;0];
  If[(equ$2029=
Help2HTML`o8$["Usage: IF expr1 body1 [ELSEIF expr2 body2 [ELSEIF ..]] [ELSE body3] ENDIF\n\nThis is a FORTRAN77 like IF-structure.\
 If the expression expr1 is True(==1) or nonzero, executes commands in body1. If it is False(==0), skip commands until ELSE, ELSEI\
F or ENDIF appears at the same level of the IF-structure, and executes commands after ELSE or ENDIF, or executes the ELSEIF comman\
d. If expr1 is not a real number, an error message is printed and ignores the command line."[p$2029,p1$2029]])===
    Undefined,
equ$2029="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Usage: IF expr1 body1 [ELSEIF expr2 body2 [E\
LSEIF ..]] [ELSE body3] ENDIF\n\nThis is a FORTRAN77 like IF-structure. If the expression expr1 is True(==1) or nonzero, executes \
commands in body1. If it is False(==0), skip commands until ELSE, ELSEIF or ENDIF appears at the same level of the IF-structure, a\
nd executes commands after ELSE or ENDIF, or executes the ELSEIF command. If expr1 is not a real number, an error message is print\
ed and ignores the command line."[p$2029,p1$2029]]=
       equ$2029;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2029},out$2029=lx$2029@Typeset["Usage: IF expr1 body1 [ELSEIF expr2 body2 [ELSEIF ..]] [ELSE body3] ENDIF\n\nThis is a FO\
RTRAN77 like IF-structure. If the expression expr1 is True(==1) or nonzero, executes commands in body1. If it is False(==0), skip \
commands until ELSE, ELSEIF or ENDIF appears at the same level of the IF-structure, and executes commands after ELSE or ENDIF, or \
executes the ELSEIF command. If expr1 is not a real number, an error message is printed and ignores the command line."[p$2029,
           p1$2029],Format->Help2HTML`oB$];
        System["mv -f "//out$2029//" "//equ$2029]];
      Exit[]]];
   "Usage: IF expr1 body1 [ELSEIF expr2 body2 [ELSEIF ..]] [ELSE body3] ENDIF\n\nThis is a FORTRAN77 like IF-structure. If the exp\
ression expr1 is True(==1) or nonzero, executes commands in body1. If it is False(==0), skip commands until ELSE, ELSEIF or ENDIF \
appears at the same level of the IF-structure, and executes commands after ELSE or ENDIF, or executes the ELSEIF command. If expr1\
 is not a real number, an error message is printed and ignores the command line."[1,Max[p0$2029,0]]//"<img  class=\"eqs\" SRC=\""//
   equ$2029//"\" />"//
Help2HTML`oy$["Usage: IF expr1 body1 [ELSEIF expr2 body2 [ELSEIF ..]] [ELSE body3] ENDIF\n\nThis is a FORTRAN77 like IF-structure.\
 If the expression expr1 is True(==1) or nonzero, executes commands in body1. If it is False(==0), skip commands until ELSE, ELSEI\
F or ENDIF appears at the same level of the IF-structure, and executes commands after ELSE or ENDIF, or executes the ELSEIF comman\
d. If expr1 is not a real number, an error message is printed and ignores the command line."[p2$2029,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L470>IF</A> <A HREF=#L293>ELSE</A> <A HREF=#L294>ELSEIF</A></PRE>
<H3><A NAME=L298>
EXECUTE(EXEC)</A></H3>
<PRE>If[{},Help2HTML`oA$["Usage: EXEC character-string-expression\n\nexecutes the character-string-expression as FFS commands."],
 p$2032=1+p$2032[[1,2]];
  p1$2032=StringPosition["Usage: EXEC character-string-expression\n\nexecutes the character-string-expression as FFS commands."[p
     $2032,-1],
    ">::",1];
   p1$2032=If[p1$2032==={},98,-2+p$2032+p1$2032[[1,1]]];
  neq=Which["Usage: EXEC character-string-expression\n\nexecutes the character-string-expression as FFS commands."[p$2032,4+p$2032
      ]===
     "Text[",
    lx$2032:=Help2HTML`oa$;p$2032=5+p$2032;p1$2032-=1;p2$2032=5+p1$2032;p0$2032=-9+p$2032;If[(pe$2032=StringPosition[
         "Usage: EXEC character-string-expression\n\nexecutes the character-string-expression as FFS commands."[p$2032,-2],";;;"]
        )<=>
       {},
      {Max[0,
        -1+ToExpression["Usage: EXEC character-string-expression\n\nexecutes the character-string-expression as FFS commands."[p
            $2032+pe$2032[[1,2]],
           p1$2032]]],
        p1$2032=-2+p$2032+pe$2032[[1,1]]}[[
       1]],
      0],
    1,lx$2032:=Help2HTML`o9$;p2$2032=4+p1$2032;p0$2032=-4+p$2032;0];
  If[(equ$2032=
     Help2HTML`o8$["Usage: EXEC character-string-expression\n\nexecutes the character-string-expression as FFS commands."[p$2032,
       p1$2032]])===
    Undefined,
   equ$2032="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "Usage: EXEC character-string-expression\n\nexecutes the character-string-expression as FFS commands."[p$2032,p1$2032]]=
       equ$2032;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$2032},out$2032=lx$2032@Typeset[
          "Usage: EXEC character-string-expression\n\nexecutes the character-string-expression as FFS commands."[p$2032,p1$2032],
          Format->Help2HTML`oB$];
        System["mv -f "//out$2032//" "//equ$2032]];
      Exit[]]];
   "Usage: EXEC character-string-expression\n\nexecutes the character-string-expression as FFS commands."[1,Max[p0$2032,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2032//"\" />"//
   Help2HTML`oy$["Usage: EXEC character-string-expression\n\nexecutes the character-string-expression as FFS commands."[p2$2032,-1]
    ]
]</PRE>
<PRE>See also:
 <A HREF=#L246>expression</A> <A HREF=#L392>FFS</A> <A HREF=#L27>ToExpression</A></PRE>
<H3><A NAME=L299>
EXPAND</A></H3>
<PRE>If[{},
 Help2HTML`oA$[
  " EXPAND distributes all variable keys to each corresponding components. Individual deviations (machine errors) are cleared."],
 p$2035=1+p$2035[[1,2]];
  p1$2035=StringPosition[
    " EXPAND distributes all variable keys to each corresponding components. Individual deviations (machine errors) are cleared."[
     p$2035,-1],
    ">::",1];
   p1$2035=If[p1$2035==={},123,-2+p$2035+p1$2035[[1,1]]];
  neq=Which[
     " EXPAND distributes all variable keys to each corresponding components. Individual deviations (machine errors) are cleared."[
      p$2035,4+p$2035]===
     "Text[",
    lx$2035:=Help2HTML`oa$;p$2035=5+p$2035;p1$2035-=1;p2$2035=5+p1$2035;p0$2035=-9+p$2035;If[(pe$2035=StringPosition[
         " EXPAND distributes all variable keys to each corresponding components. Individual deviations (machine errors) are clear\
ed."[p$2035,-2],";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression[
          " EXPAND distributes all variable keys to each corresponding components. Individual deviations (machine errors) are clea\
red."[p$2035+pe$2035[[1,2]],p1$2035]]],
        p1$2035=-2+p$2035+pe$2035[[1,1]]}[[
       1]],
      0],
    1,lx$2035:=Help2HTML`o9$;p2$2035=4+p1$2035;p0$2035=-4+p$2035;0];
  If[(equ$2035=
     Help2HTML`o8$[
      " EXPAND distributes all variable keys to each corresponding components. Individual deviations (machine errors) are cleared."
      [p$2035,p1$2035]])===
    Undefined,
   equ$2035="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        " EXPAND distributes all variable keys to each corresponding components. Individual deviations (machine errors) are cleare\
d."[p$2035,p1$2035]]=
       equ$2035;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$2035},out$2035=lx$2035@Typeset[
          " EXPAND distributes all variable keys to each corresponding components. Individual deviations (machine errors) are clea\
red."[p$2035,p1$2035],Format->Help2HTML`oB$];
        System["mv -f "//out$2035//" "//equ$2035]];
      Exit[]]];
  " EXPAND distributes all variable keys to each corresponding components. Individual deviations (machine errors) are cleared."[1,
    Max[p0$2035,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2035//"\" />"//
   Help2HTML`oy$[
    " EXPAND distributes all variable keys to each corresponding components. Individual deviations (machine errors) are cleared."[
     p2$2035,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L469>GO</A> <A HREF=#L32>CALCULATE(CAL)</A> <A HREF=#L295>EMITTANCE(EMIT)</A></PRE>
<H3><A NAME=L300>
flags</A></H3>
<PRE>If[{},
Help2HTML`oA$["Usage: [NO]flag\n\nturns the flag on. If NO is prepended to flag, the flag is turned off. Some flags have antonym w\
hich works in the opposite way. Flags can be accessed in the function-syntax with the form ?flag, which returns True (=1) when the\
 flag is on, or False (=0) otherwise. Some flags can be accessed by the ON/OFF commands at the MAIN level.\n Status of all flags a\
re displayed by the STATUS(STAT) command."],
p$2038=1+p$2038[[1,2]];p1$2038=StringPosition["Usage: [NO]flag\n\nturns the flag on. If NO is prepended to flag, the flag is turne\
d off. Some flags have antonym which works in the opposite way. Flags can be accessed in the function-syntax with the form ?flag, \
which returns True (=1) when the flag is on, or False (=0) otherwise. Some flags can be accessed by the ON/OFF commands at the MAI\
N level.\n Status of all flags are displayed by the STATUS(STAT) command."[p$2038,-1],">::",1];
   p1$2038=If[p1$2038==={},413,-2+p$2038+p1$2038[[1,1]]];
neq=Which["Usage: [NO]flag\n\nturns the flag on. If NO is prepended to flag, the flag is turned off. Some flags have antonym which\
 works in the opposite way. Flags can be accessed in the function-syntax with the form ?flag, which returns True (=1) when the fla\
g is on, or False (=0) otherwise. Some flags can be accessed by the ON/OFF commands at the MAIN level.\n Status of all flags are d\
isplayed by the STATUS(STAT) command."[p$2038,4+p$2038]==="Text[",
    lx$2038:=Help2HTML`oa$;p$2038=5+p$2038;p1$2038-=1;p2$2038=5+p1$2038;p0$2038=-9+p$2038;
If[(pe$2038=StringPosition["Usage: [NO]flag\n\nturns the flag on. If NO is prepended to flag, the flag is turned off. Some flags h\
ave antonym which works in the opposite way. Flags can be accessed in the function-syntax with the form ?flag, which returns True \
(=1) when the flag is on, or False (=0) otherwise. Some flags can be accessed by the ON/OFF commands at the MAIN level.\n Status o\
f all flags are displayed by the STATUS(STAT) command."[p$2038,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Usage: [NO]flag\n\nturns the flag on. If NO is prepended to flag, the flag is turned off. Some flags have antonym\
 which works in the opposite way. Flags can be accessed in the function-syntax with the form ?flag, which returns True (=1) when t\
he flag is on, or False (=0) otherwise. Some flags can be accessed by the ON/OFF commands at the MAIN level.\n Status of all flags\
 are displayed by the STATUS(STAT) command."[p$2038+pe$2038[[1,2]],p1$2038]]],
        p1$2038=-2+p$2038+pe$2038[[1,1]]}[[
       1]],
      0],
    1,lx$2038:=Help2HTML`o9$;p2$2038=4+p1$2038;p0$2038=-4+p$2038;0];
  If[(equ$2038=
Help2HTML`o8$["Usage: [NO]flag\n\nturns the flag on. If NO is prepended to flag, the flag is turned off. Some flags have antonym w\
hich works in the opposite way. Flags can be accessed in the function-syntax with the form ?flag, which returns True (=1) when the\
 flag is on, or False (=0) otherwise. Some flags can be accessed by the ON/OFF commands at the MAIN level.\n Status of all flags a\
re displayed by the STATUS(STAT) command."[p$2038,p1$2038]])===
    Undefined,
equ$2038="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Usage: [NO]flag\n\nturns the flag on. If NO \
is prepended to flag, the flag is turned off. Some flags have antonym which works in the opposite way. Flags can be accessed in th\
e function-syntax with the form ?flag, which returns True (=1) when the flag is on, or False (=0) otherwise. Some flags can be acc\
essed by the ON/OFF commands at the MAIN level.\n Status of all flags are displayed by the STATUS(STAT) command."[p$2038,p1$2038]]=
       equ$2038;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2038},out$2038=lx$2038@Typeset["Usage: [NO]flag\n\nturns the flag on. If NO is prepended to flag, the flag is turned off.\
 Some flags have antonym which works in the opposite way. Flags can be accessed in the function-syntax with the form ?flag, which \
returns True (=1) when the flag is on, or False (=0) otherwise. Some flags can be accessed by the ON/OFF commands at the MAIN leve\
l.\n Status of all flags are displayed by the STATUS(STAT) command."[p$2038,p1$2038],Format->Help2HTML`oB$];
        System["mv -f "//out$2038//" "//equ$2038]];
      Exit[]]];
   "Usage: [NO]flag\n\nturns the flag on. If NO is prepended to flag, the flag is turned off. Some flags have antonym which works \
in the opposite way. Flags can be accessed in the function-syntax with the form ?flag, which returns True (=1) when the flag is on\
, or False (=0) otherwise. Some flags can be accessed by the ON/OFF commands at the MAIN level.\n Status of all flags are displaye\
d by the STATUS(STAT) command."[1,Max[p0$2038,0]]//"<img  class=\"eqs\" SRC=\""//equ$2038//"\" />"//
Help2HTML`oy$["Usage: [NO]flag\n\nturns the flag on. If NO is prepended to flag, the flag is turned off. Some flags have antonym w\
hich works in the opposite way. Flags can be accessed in the function-syntax with the form ?flag, which returns True (=1) when the\
 flag is on, or False (=0) otherwise. Some flags can be accessed by the ON/OFF commands at the MAIN level.\n Status of all flags a\
re displayed by the STATUS(STAT) command."[p2$2038,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L552>STATUS(STAT)</A> <A HREF=#L272>PatternTest(?)</A></PRE>
<UL>
<LI>
<H3><A NAME=L301>
ABSW</A></H3>
<PRE>If[{},
Help2HTML`oA$["ABSW or NORELW sets the weights of variable elements independent from their values in the matching. Otherwise they \
are weighted relatively."],
p$2041=1+p$2041[[1,2]];p1$2041=StringPosition["ABSW or NORELW sets the weights of variable elements independent from their values \
in the matching. Otherwise they are weighted relatively."[p$2041,-1],">::",1];
   p1$2041=If[p1$2041==={},139,-2+p$2041+p1$2041[[1,1]]];
neq=Which["ABSW or NORELW sets the weights of variable elements independent from their values in the matching. Otherwise they are \
weighted relatively."[p$2041,4+p$2041]==="Text[",
    lx$2041:=Help2HTML`oa$;p$2041=5+p$2041;p1$2041-=1;p2$2041=5+p1$2041;p0$2041=-9+p$2041;
If[(pe$2041=StringPosition["ABSW or NORELW sets the weights of variable elements independent from their values in the matching. Ot\
herwise they are weighted relatively."[p$2041,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["ABSW or NORELW sets the weights of variable elements independent from their values in the matching. Otherwise the\
y are weighted relatively."[p$2041+pe$2041[[1,2]],p1$2041]]],
        p1$2041=-2+p$2041+pe$2041[[1,1]]}[[
       1]],
      0],
    1,lx$2041:=Help2HTML`o9$;p2$2041=4+p1$2041;p0$2041=-4+p$2041;0];
  If[(equ$2041=
Help2HTML`o8$["ABSW or NORELW sets the weights of variable elements independent from their values in the matching. Otherwise they \
are weighted relatively."[p$2041,p1$2041]])===
    Undefined,
equ$2041="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["ABSW or NORELW sets the weights of variable \
elements independent from their values in the matching. Otherwise they are weighted relatively."[p$2041,p1$2041]]=
       equ$2041;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2041},out$2041=lx$2041@Typeset["ABSW or NORELW sets the weights of variable elements independent from their values in the\
 matching. Otherwise they are weighted relatively."[p$2041,p1$2041],Format->Help2HTML`oB$];
        System["mv -f "//out$2041//" "//equ$2041]];
      Exit[]]];
   "ABSW or NORELW sets the weights of variable elements independent from their values in the matching. Otherwise they are weighte\
d relatively."[1,Max[p0$2041,0]]//"<img  class=\"eqs\" SRC=\""//equ$2041//"\" />"//
Help2HTML`oy$["ABSW or NORELW sets the weights of variable elements independent from their values in the matching. Otherwise they \
are weighted relatively."[p2$2041,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L343>RELW</A></PRE>
<LI>
<H3><A NAME=L302>
BIPOL</A></H3>
<PRE>If[{},
Help2HTML`oA$["BIPOL or NOUNIPOL allows the change of sign of the value of the element during the matching. It affects the default\
 keywords of all elements. This is overridden by MIN, MAX specification or VariableRange of each element."],
 p$2044=1+p$2044[[1,2]];p1$2044=
StringPosition["BIPOL or NOUNIPOL allows the change of sign of the value of the element during the matching. It affects the defaul\
t keywords of all elements. This is overridden by MIN, MAX specification or VariableRange of each element."[p$2044,-1],">::",1];
   p1$2044=If[p1$2044==={},220,-2+p$2044+p1$2044[[1,1]]];
neq=Which["BIPOL or NOUNIPOL allows the change of sign of the value of the element during the matching. It affects the default key\
words of all elements. This is overridden by MIN, MAX specification or VariableRange of each element."[p$2044,4+p$2044]==="Text[",
    lx$2044:=Help2HTML`oa$;p$2044=5+p$2044;p1$2044-=1;p2$2044=5+p1$2044;p0$2044=-9+p$2044;
If[(pe$2044=StringPosition["BIPOL or NOUNIPOL allows the change of sign of the value of the element during the matching. It affect\
s the default keywords of all elements. This is overridden by MIN, MAX specification or VariableRange of each element."[p$2044,-2],
         ";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["BIPOL or NOUNIPOL allows the change of sign of the value of the element during the matching. It affects the defau\
lt keywords of all elements. This is overridden by MIN, MAX specification or VariableRange of each element."[p$2044+pe$2044[[1,2]],
           p1$2044]]],
        p1$2044=-2+p$2044+pe$2044[[1,1]]}[[
       1]],
      0],
    1,lx$2044:=Help2HTML`o9$;p2$2044=4+p1$2044;p0$2044=-4+p$2044;0];
  If[(equ$2044=
Help2HTML`o8$["BIPOL or NOUNIPOL allows the change of sign of the value of the element during the matching. It affects the default\
 keywords of all elements. This is overridden by MIN, MAX specification or VariableRange of each element."[p$2044,p1$2044]])===
    Undefined,
equ$2044="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["BIPOL or NOUNIPOL allows the change of sign \
of the value of the element during the matching. It affects the default keywords of all elements. This is overridden by MIN, MAX s\
pecification or VariableRange of each element."[p$2044,p1$2044]]=
       equ$2044;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2044},out$2044=lx$2044@Typeset["BIPOL or NOUNIPOL allows the change of sign of the value of the element during the matchi\
ng. It affects the default keywords of all elements. This is overridden by MIN, MAX specification or VariableRange of each element\
."[p$2044,p1$2044],Format->Help2HTML`oB$];
        System["mv -f "//out$2044//" "//equ$2044]];
      Exit[]]];
   "BIPOL or NOUNIPOL allows the change of sign of the value of the element during the matching. It affects the default keywords o\
f all elements. This is overridden by MIN, MAX specification or VariableRange of each element."[1,Max[p0$2044,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2044//"\" />"//
Help2HTML`oy$["BIPOL or NOUNIPOL allows the change of sign of the value of the element during the matching. It affects the default\
 keywords of all elements. This is overridden by MIN, MAX specification or VariableRange of each element."[p2$2044,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L355>UNIPOL</A> <A HREF=#L113>default-keyword</A> <A HREF=#L497>set-value-of-element</A> <A HREF=#L411>VariableRange</A></PRE>
<LI>
<H3><A NAME=L303>
CALC4D</A></H3>
<PRE>If[{},
Help2HTML`oA$["If CALC4D is on, the optics calculation in CAL and GO performs a 4x5 calculation (4D + dispersion). The antonyms is\
 CALC6D. The Default is CALC4D."],
p$2047=1+p$2047[[1,2]];p1$2047=StringPosition["If CALC4D is on, the optics calculation in CAL and GO performs a 4x5 calculation (4\
D + dispersion). The antonyms is CALC6D. The Default is CALC4D."[p$2047,-1],">::",1];
   p1$2047=If[p1$2047==={},146,-2+p$2047+p1$2047[[1,1]]];
neq=Which["If CALC4D is on, the optics calculation in CAL and GO performs a 4x5 calculation (4D + dispersion). The antonyms is CAL\
C6D. The Default is CALC4D."[p$2047,4+p$2047]==="Text[",
    lx$2047:=Help2HTML`oa$;p$2047=5+p$2047;p1$2047-=1;p2$2047=5+p1$2047;p0$2047=-9+p$2047;
If[(pe$2047=StringPosition["If CALC4D is on, the optics calculation in CAL and GO performs a 4x5 calculation (4D + dispersion). Th\
e antonyms is CALC6D. The Default is CALC4D."[p$2047,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["If CALC4D is on, the optics calculation in CAL and GO performs a 4x5 calculation (4D + dispersion). The antonyms \
is CALC6D. The Default is CALC4D."[p$2047+pe$2047[[1,2]],p1$2047]]],
        p1$2047=-2+p$2047+pe$2047[[1,1]]}[[
       1]],
      0],
    1,lx$2047:=Help2HTML`o9$;p2$2047=4+p1$2047;p0$2047=-4+p$2047;0];
  If[(equ$2047=
Help2HTML`o8$["If CALC4D is on, the optics calculation in CAL and GO performs a 4x5 calculation (4D + dispersion). The antonyms is\
 CALC6D. The Default is CALC4D."[p$2047,p1$2047]])===
    Undefined,
equ$2047="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["If CALC4D is on, the optics calculation in C\
AL and GO performs a 4x5 calculation (4D + dispersion). The antonyms is CALC6D. The Default is CALC4D."[p$2047,p1$2047]]=
       equ$2047;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2047},out$2047=lx$2047@Typeset["If CALC4D is on, the optics calculation in CAL and GO performs a 4x5 calculation (4D + di\
spersion). The antonyms is CALC6D. The Default is CALC4D."[p$2047,p1$2047],Format->Help2HTML`oB$];
        System["mv -f "//out$2047//" "//equ$2047]];
      Exit[]]];
   "If CALC4D is on, the optics calculation in CAL and GO performs a 4x5 calculation (4D + dispersion). The antonyms is CALC6D. Th\
e Default is CALC4D."[1,Max[p0$2047,0]]//"<img  class=\"eqs\" SRC=\""//equ$2047//"\" />"//
Help2HTML`oy$["If CALC4D is on, the optics calculation in CAL and GO performs a 4x5 calculation (4D + dispersion). The antonyms is\
 CALC6D. The Default is CALC4D."[p2$2047,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L304>CALC6D</A> <A HREF=#L32>CALCULATE(CAL)</A> <A HREF=#L469>GO</A></PRE>
<LI>
<H3><A NAME=L304>
CALC6D</A></H3>
<PRE>If[{},
Help2HTML`oA$["If CALC6D is on, the optics calculation in CAL and GO performs full 6D calculation, which may takes RADCOD into acc\
ount. The antonyms is CALC4D. The Default is CALC4D."],
p$2050=1+p$2050[[1,2]];p1$2050=StringPosition["If CALC6D is on, the optics calculation in CAL and GO performs full 6D calculation,\
 which may takes RADCOD into account. The antonyms is CALC4D. The Default is CALC4D."[p$2050,-1],">::",1];
   p1$2050=If[p1$2050==={},167,-2+p$2050+p1$2050[[1,1]]];
neq=Which["If CALC6D is on, the optics calculation in CAL and GO performs full 6D calculation, which may takes RADCOD into account\
. The antonyms is CALC4D. The Default is CALC4D."[p$2050,4+p$2050]==="Text[",
    lx$2050:=Help2HTML`oa$;p$2050=5+p$2050;p1$2050-=1;p2$2050=5+p1$2050;p0$2050=-9+p$2050;
If[(pe$2050=StringPosition["If CALC6D is on, the optics calculation in CAL and GO performs full 6D calculation, which may takes RA\
DCOD into account. The antonyms is CALC4D. The Default is CALC4D."[p$2050,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["If CALC6D is on, the optics calculation in CAL and GO performs full 6D calculation, which may takes RADCOD into a\
ccount. The antonyms is CALC4D. The Default is CALC4D."[p$2050+pe$2050[[1,2]],p1$2050]]],
        p1$2050=-2+p$2050+pe$2050[[1,1]]}[[
       1]],
      0],
    1,lx$2050:=Help2HTML`o9$;p2$2050=4+p1$2050;p0$2050=-4+p$2050;0];
  If[(equ$2050=
Help2HTML`o8$["If CALC6D is on, the optics calculation in CAL and GO performs full 6D calculation, which may takes RADCOD into acc\
ount. The antonyms is CALC4D. The Default is CALC4D."[p$2050,p1$2050]])===
    Undefined,
equ$2050="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["If CALC6D is on, the optics calculation in C\
AL and GO performs full 6D calculation, which may takes RADCOD into account. The antonyms is CALC4D. The Default is CALC4D."[p$2050
         ,p1$2050]]=
       equ$2050;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2050},out$2050=lx$2050@Typeset["If CALC6D is on, the optics calculation in CAL and GO performs full 6D calculation, which\
 may takes RADCOD into account. The antonyms is CALC4D. The Default is CALC4D."[p$2050,p1$2050],Format->Help2HTML`oB$];
        System["mv -f "//out$2050//" "//equ$2050]];
      Exit[]]];
   "If CALC6D is on, the optics calculation in CAL and GO performs full 6D calculation, which may takes RADCOD into account. The a\
ntonyms is CALC4D. The Default is CALC4D."[1,Max[p0$2050,0]]//"<img  class=\"eqs\" SRC=\""//equ$2050//"\" />"//
Help2HTML`oy$["If CALC6D is on, the optics calculation in CAL and GO performs full 6D calculation, which may takes RADCOD into acc\
ount. The antonyms is CALC4D. The Default is CALC4D."[p2$2050,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L303>CALC4D</A> <A HREF=#L32>CALCULATE(CAL)</A> <A HREF=#L469>GO</A></PRE>
<LI>
<H3><A NAME=L305>
CELL</A></H3>
<PRE>If[{},Help2HTML`oA$["CELL or NOINS sets the periodic condition in calculating the optical-functions."],
 p$2053=1+p$2053[[1,2]];p1$2053=
   StringPosition["CELL or NOINS sets the periodic condition in calculating the optical-functions."[p$2053,-1],">::",1];
  p1$2053=If[p1$2053==={},79,-2+p$2053+p1$2053[[1,1]]];
  neq=Which["CELL or NOINS sets the periodic condition in calculating the optical-functions."[p$2053,4+p$2053]==="Text[",
    lx$2053:=Help2HTML`oa$;p$2053=5+p$2053;p1$2053-=1;p2$2053=5+p1$2053;p0$2053=-9+p$2053;
     If[(pe$2053=StringPosition["CELL or NOINS sets the periodic condition in calculating the optical-functions."[p$2053,-2],";;;"]
        )<=>
       {},
      {Max[0,
        -1+ToExpression["CELL or NOINS sets the periodic condition in calculating the optical-functions."[p$2053+pe$2053[[1,2]],
           p1$2053]]],
        p1$2053=-2+p$2053+pe$2053[[1,1]]}[[
       1]],
      0],
    1,lx$2053:=Help2HTML`o9$;p2$2053=4+p1$2053;p0$2053=-4+p$2053;0];
  If[(equ$2053=Help2HTML`o8$["CELL or NOINS sets the periodic condition in calculating the optical-functions."[p$2053,p1$2053]])===
    Undefined,
   equ$2053="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "CELL or NOINS sets the periodic condition in calculating the optical-functions."[p$2053,p1$2053]]=
       equ$2053;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$2053},out$2053=lx$2053@Typeset["CELL or NOINS sets the periodic condition in calculating the optical-functions."[p
           $2053,p1$2053],Format->Help2HTML`oB$];
        System["mv -f "//out$2053//" "//equ$2053]];
      Exit[]]];
   "CELL or NOINS sets the periodic condition in calculating the optical-functions."[1,Max[p0$2053,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2053//"\" />"//
   Help2HTML`oy$["CELL or NOINS sets the periodic condition in calculating the optical-functions."[p2$2053,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L324>INS</A> <A HREF=#L32>CALCULATE(CAL)</A> <A HREF=#L469>GO</A> <A HREF=#L478>optical-functions</A> <A HREF=#L473>matching-function-commands</A></PRE>
<LI>
<H3><A NAME=L306>
CMPLOT</A></H3>
<PRE>If[{},
 Help2HTML`oA$["CMPLOT enables the shift of the center of mass at the beginning of the tracking. This is almost obsolete."],
 p$2056=1+p$2056[[1,2]];
  p1$2056=StringPosition[
    "CMPLOT enables the shift of the center of mass at the beginning of the tracking. This is almost obsolete."[p$2056,-1],">::",
    1];
   p1$2056=If[p1$2056==={},105,-2+p$2056+p1$2056[[1,1]]];
  neq=Which["CMPLOT enables the shift of the center of mass at the beginning of the tracking. This is almost obsolete."[p$2056,
      4+p$2056]===
     "Text[",
    lx$2056:=Help2HTML`oa$;p$2056=5+p$2056;p1$2056-=1;p2$2056=5+p1$2056;p0$2056=-9+p$2056;If[(pe$2056=StringPosition[
         "CMPLOT enables the shift of the center of mass at the beginning of the tracking. This is almost obsolete."[p$2056,-2],
         ";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression["CMPLOT enables the shift of the center of mass at the beginning of the tracking. This is almost obsolete."
          [p$2056+pe$2056[[1,2]],p1$2056]]],
        p1$2056=-2+p$2056+pe$2056[[1,1]]}[[
       1]],
      0],
    1,lx$2056:=Help2HTML`o9$;p2$2056=4+p1$2056;p0$2056=-4+p$2056;0];
  If[(equ$2056=
     Help2HTML`o8$["CMPLOT enables the shift of the center of mass at the beginning of the tracking. This is almost obsolete."[p
       $2056,p1$2056]])===
    Undefined,
   equ$2056="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "CMPLOT enables the shift of the center of mass at the beginning of the tracking. This is almost obsolete."[p$2056,p1$2056]
        ]=
       equ$2056;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$2056},out$2056=lx$2056@Typeset[
          "CMPLOT enables the shift of the center of mass at the beginning of the tracking. This is almost obsolete."[p$2056,
           p1$2056],Format->Help2HTML`oB$];
        System["mv -f "//out$2056//" "//equ$2056]];
      Exit[]]];
   "CMPLOT enables the shift of the center of mass at the beginning of the tracking. This is almost obsolete."[1,Max[p0$2056,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2056//"\" />"//
   Help2HTML`oy$["CMPLOT enables the shift of the center of mass at the beginning of the tracking. This is almost obsolete."[p2
     $2056,-1]]
]</PRE>
<LI>
<H3><A NAME=L307>
COD</A></H3>
<PRE>If[{},Help2HTML`oA$["COD turns on finding the closed-orbit in the emittance calculation. Accessible in MAIN level."],
 p$2058=1+p$2058[[1,2]];
  p1$2058=StringPosition["COD turns on finding the closed-orbit in the emittance calculation. Accessible in MAIN level."[p$2058,-1
     ],
    ">::",1];
   p1$2058=If[p1$2058==={},93,-2+p$2058+p1$2058[[1,1]]];
  neq=Which["COD turns on finding the closed-orbit in the emittance calculation. Accessible in MAIN level."[p$2058,4+p$2058]===
     "Text[",
    lx$2058:=Help2HTML`oa$;p$2058=5+p$2058;p1$2058-=1;p2$2058=5+p1$2058;p0$2058=-9+p$2058;If[(pe$2058=StringPosition[
         "COD turns on finding the closed-orbit in the emittance calculation. Accessible in MAIN level."[p$2058,-2],";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression["COD turns on finding the closed-orbit in the emittance calculation. Accessible in MAIN level."[p$2058+
            pe$2058[[1,2]],
           p1$2058]]],
        p1$2058=-2+p$2058+pe$2058[[1,1]]}[[
       1]],
      0],
    1,lx$2058:=Help2HTML`o9$;p2$2058=4+p1$2058;p0$2058=-4+p$2058;0];
  If[(equ$2058=
     Help2HTML`o8$["COD turns on finding the closed-orbit in the emittance calculation. Accessible in MAIN level."[p$2058,p1$2058]]
     )===
    Undefined,
   equ$2058="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "COD turns on finding the closed-orbit in the emittance calculation. Accessible in MAIN level."[p$2058,p1$2058]]=
       equ$2058;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$2058},out$2058=lx$2058@Typeset[
          "COD turns on finding the closed-orbit in the emittance calculation. Accessible in MAIN level."[p$2058,p1$2058],
          Format->Help2HTML`oB$];
        System["mv -f "//out$2058//" "//equ$2058]];
      Exit[]]];
   "COD turns on finding the closed-orbit in the emittance calculation. Accessible in MAIN level."[1,Max[p0$2058,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2058//"\" />"//
   Help2HTML`oy$["COD turns on finding the closed-orbit in the emittance calculation. Accessible in MAIN level."[p2$2058,-1]]
 ]
</PRE>
<PRE>See also:
 <A HREF=#L295>EMITTANCE(EMIT)</A></PRE>
<LI>
<H3><A NAME=L308>
CODPLOT</A></H3>
<PRE>If[{},
Help2HTML`oA$["CODPLOT lets the emittance calculation return the information on the closed-orbit, extended Twiss parameters, and t\
he beam size along the beam line into the FFS optics buffer, which can be shown by DISPLAY(DISP) or DRAW commands as well as Twiss\
 and OpticsPlot functions."],
p$2061=1+p$2061[[1,2]];p1$2061=StringPosition["CODPLOT lets the emittance calculation return the information on the closed-orbit, \
extended Twiss parameters, and the beam size along the beam line into the FFS optics buffer, which can be shown by DISPLAY(DISP) o\
r DRAW commands as well as Twiss and OpticsPlot functions."[p$2061,-1],">::",1];
   p1$2061=If[p1$2061==={},271,-2+p$2061+p1$2061[[1,1]]];
neq=Which["CODPLOT lets the emittance calculation return the information on the closed-orbit, extended Twiss parameters, and the b\
eam size along the beam line into the FFS optics buffer, which can be shown by DISPLAY(DISP) or DRAW commands as well as Twiss and\
 OpticsPlot functions."[p$2061,4+p$2061]==="Text[",
    lx$2061:=Help2HTML`oa$;p$2061=5+p$2061;p1$2061-=1;p2$2061=5+p1$2061;p0$2061=-9+p$2061;
If[(pe$2061=StringPosition["CODPLOT lets the emittance calculation return the information on the closed-orbit, extended Twiss para\
meters, and the beam size along the beam line into the FFS optics buffer, which can be shown by DISPLAY(DISP) or DRAW commands as \
well as Twiss and OpticsPlot functions."[p$2061,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["CODPLOT lets the emittance calculation return the information on the closed-orbit, extended Twiss parameters, and\
 the beam size along the beam line into the FFS optics buffer, which can be shown by DISPLAY(DISP) or DRAW commands as well as Twi\
ss and OpticsPlot functions."[p$2061+pe$2061[[1,2]],p1$2061]]],
        p1$2061=-2+p$2061+pe$2061[[1,1]]}[[
       1]],
      0],
    1,lx$2061:=Help2HTML`o9$;p2$2061=4+p1$2061;p0$2061=-4+p$2061;0];
  If[(equ$2061=
Help2HTML`o8$["CODPLOT lets the emittance calculation return the information on the closed-orbit, extended Twiss parameters, and t\
he beam size along the beam line into the FFS optics buffer, which can be shown by DISPLAY(DISP) or DRAW commands as well as Twiss\
 and OpticsPlot functions."[p$2061,p1$2061]])===
    Undefined,
equ$2061="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["CODPLOT lets the emittance calculation retur\
n the information on the closed-orbit, extended Twiss parameters, and the beam size along the beam line into the FFS optics buffer\
, which can be shown by DISPLAY(DISP) or DRAW commands as well as Twiss and OpticsPlot functions."[p$2061,p1$2061]]=
       equ$2061;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2061},out$2061=lx$2061@Typeset["CODPLOT lets the emittance calculation return the information on the closed-orbit, extend\
ed Twiss parameters, and the beam size along the beam line into the FFS optics buffer, which can be shown by DISPLAY(DISP) or DRAW\
 commands as well as Twiss and OpticsPlot functions."[p$2061,p1$2061],Format->Help2HTML`oB$];
        System["mv -f "//out$2061//" "//equ$2061]];
      Exit[]]];
   "CODPLOT lets the emittance calculation return the information on the closed-orbit, extended Twiss parameters, and the beam siz\
e along the beam line into the FFS optics buffer, which can be shown by DISPLAY(DISP) or DRAW commands as well as Twiss and Optics\
Plot functions."[1,Max[p0$2061,0]]//"<img  class=\"eqs\" SRC=\""//equ$2061//"\" />"//
Help2HTML`oy$["CODPLOT lets the emittance calculation return the information on the closed-orbit, extended Twiss parameters, and t\
he beam size along the beam line into the FFS optics buffer, which can be shown by DISPLAY(DISP) or DRAW commands as well as Twiss\
 and OpticsPlot functions."[p2$2061,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L295>EMITTANCE(EMIT)</A> <A HREF=#L56>DISPLAY(DISP)</A> <A HREF=#L72>DRAW</A> <A HREF=#L357>WSPAC</A> <A HREF=#L341>RADTAPER</A></PRE>
<LI>
<H3><A NAME=L309>
CONV</A></H3>
<PRE>If[{},
 Help2HTML`oA$[
  "CONV is a flag set by the CALCULATE(CAL) or GO commands. It becomes True when MatchingResidual is less than CONVERGENCE."],
 p$2064=1+p$2064[[1,2]];
  p1$2064=StringPosition[
    "CONV is a flag set by the CALCULATE(CAL) or GO commands. It becomes True when MatchingResidual is less than CONVERGENCE."[p
     $2064,-1],
    ">::",1];
   p1$2064=If[p1$2064==={},120,-2+p$2064+p1$2064[[1,1]]];
  neq=Which[
     "CONV is a flag set by the CALCULATE(CAL) or GO commands. It becomes True when MatchingResidual is less than CONVERGENCE."[p
      $2064,4+p$2064]===
     "Text[",
    lx$2064:=Help2HTML`oa$;p$2064=5+p$2064;p1$2064-=1;p2$2064=5+p1$2064;p0$2064=-9+p$2064;If[(pe$2064=StringPosition[
         "CONV is a flag set by the CALCULATE(CAL) or GO commands. It becomes True when MatchingResidual is less than CONVERGENCE."
         [p$2064,-2],";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression[
          "CONV is a flag set by the CALCULATE(CAL) or GO commands. It becomes True when MatchingResidual is less than CONVERGENCE\
."[p$2064+pe$2064[[1,2]],p1$2064]]],
        p1$2064=-2+p$2064+pe$2064[[1,1]]}[[
       1]],
      0],
    1,lx$2064:=Help2HTML`o9$;p2$2064=4+p1$2064;p0$2064=-4+p$2064;0];
  If[(equ$2064=
     Help2HTML`o8$[
      "CONV is a flag set by the CALCULATE(CAL) or GO commands. It becomes True when MatchingResidual is less than CONVERGENCE."[
       p$2064,p1$2064]])===
    Undefined,
   equ$2064="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "CONV is a flag set by the CALCULATE(CAL) or GO commands. It becomes True when MatchingResidual is less than CONVERGENCE."[
         p$2064,p1$2064]]=
       equ$2064;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$2064},out$2064=lx$2064@Typeset[
          "CONV is a flag set by the CALCULATE(CAL) or GO commands. It becomes True when MatchingResidual is less than CONVERGENCE\
."[p$2064,p1$2064],Format->Help2HTML`oB$];
        System["mv -f "//out$2064//" "//equ$2064]];
      Exit[]]];
  "CONV is a flag set by the CALCULATE(CAL) or GO commands. It becomes True when MatchingResidual is less than CONVERGENCE."[1,
    Max[p0$2064,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2064//"\" />"//
   Help2HTML`oy$[
    "CONV is a flag set by the CALCULATE(CAL) or GO commands. It becomes True when MatchingResidual is less than CONVERGENCE."[p2
     $2064,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L32>CALCULATE(CAL)</A> <A HREF=#L469>GO</A> <A HREF=#L528>MatchingResidual</A> <A HREF=#L504>CONVERGENCE</A></PRE>
<LI>
<H3><A NAME=L310>
CONVCASE</A></H3>
<PRE>If[{},
Help2HTML`oA$["When CONVCASE is on, FFS command line parser converts the input characters to the upper case.(Default on) CONVCASE \
actions for the element names and patterns CAN be overridden by PRSVCASE flag."],
p$2067=1+p$2067[[1,2]];p1$2067=StringPosition["When CONVCASE is on, FFS command line parser converts the input characters to the u\
pper case.(Default on) CONVCASE actions for the element names and patterns CAN be overridden by PRSVCASE flag."[p$2067,-1],">::",
    1];
   p1$2067=If[p1$2067==={},193,-2+p$2067+p1$2067[[1,1]]];
neq=Which["When CONVCASE is on, FFS command line parser converts the input characters to the upper case.(Default on) CONVCASE acti\
ons for the element names and patterns CAN be overridden by PRSVCASE flag."[p$2067,4+p$2067]==="Text[",
    lx$2067:=Help2HTML`oa$;p$2067=5+p$2067;p1$2067-=1;p2$2067=5+p1$2067;p0$2067=-9+p$2067;
If[(pe$2067=StringPosition["When CONVCASE is on, FFS command line parser converts the input characters to the upper case.(Default \
on) CONVCASE actions for the element names and patterns CAN be overridden by PRSVCASE flag."[p$2067,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["When CONVCASE is on, FFS command line parser converts the input characters to the upper case.(Default on) CONVCAS\
E actions for the element names and patterns CAN be overridden by PRSVCASE flag."[p$2067+pe$2067[[1,2]],p1$2067]]],
        p1$2067=-2+p$2067+pe$2067[[1,1]]}[[
       1]],
      0],
    1,lx$2067:=Help2HTML`o9$;p2$2067=4+p1$2067;p0$2067=-4+p$2067;0];
  If[(equ$2067=
Help2HTML`o8$["When CONVCASE is on, FFS command line parser converts the input characters to the upper case.(Default on) CONVCASE \
actions for the element names and patterns CAN be overridden by PRSVCASE flag."[p$2067,p1$2067]])===
    Undefined,
equ$2067="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["When CONVCASE is on, FFS command line parser\
 converts the input characters to the upper case.(Default on) CONVCASE actions for the element names and patterns CAN be overridde\
n by PRSVCASE flag."[p$2067,p1$2067]]=
       equ$2067;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2067},out$2067=lx$2067@Typeset["When CONVCASE is on, FFS command line parser converts the input characters to the upper c\
ase.(Default on) CONVCASE actions for the element names and patterns CAN be overridden by PRSVCASE flag."[p$2067,p1$2067],
          Format->Help2HTML`oB$];
        System["mv -f "//out$2067//" "//equ$2067]];
      Exit[]]];
   "When CONVCASE is on, FFS command line parser converts the input characters to the upper case.(Default on) CONVCASE actions for\
 the element names and patterns CAN be overridden by PRSVCASE flag."[1,Max[p0$2067,0]]//"<img  class=\"eqs\" SRC=\""//equ$2067//
   "\" />"//
Help2HTML`oy$["When CONVCASE is on, FFS command line parser converts the input characters to the upper case.(Default on) CONVCASE \
actions for the element names and patterns CAN be overridden by PRSVCASE flag."[p2$2067,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L334>PRSVCASE</A></PRE>
<LI>
<H3><A NAME=L311>
DAMPONLY</A></H3>
<PRE>If[{},Help2HTML`oA$["DAMPONLY is the antonym of FLUC."],
 p$2070=1+p$2070[[1,2]];p1$2070=StringPosition["DAMPONLY is the antonym of FLUC."[p$2070,-1],">::",1];
  p1$2070=If[p1$2070==={},32,-2+p$2070+p1$2070[[1,1]]];
  neq=Which["DAMPONLY is the antonym of FLUC."[p$2070,4+p$2070]==="Text[",lx$2070:=Help2HTML`oa$;p$2070=5+p$2070;p1$2070-=1;
     p2$2070=5+p1$2070;p0$2070=-9+p$2070;
     If[(pe$2070=StringPosition["DAMPONLY is the antonym of FLUC."[p$2070,-2],";;;"])<=>{},{Max[0,
        -1+ToExpression["DAMPONLY is the antonym of FLUC."[p$2070+pe$2070[[1,2]],p1$2070]]],p1$2070=-2+p$2070+pe$2070[[1,1]]}[[
       1]],
      0],
    1,lx$2070:=Help2HTML`o9$;p2$2070=4+p1$2070;p0$2070=-4+p$2070;0];
  If[(equ$2070=Help2HTML`o8$["DAMPONLY is the antonym of FLUC."[p$2070,p1$2070]])===Undefined,
   equ$2070="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["DAMPONLY is the antonym of FLUC."[p$2070,p1$2070]]=equ$2070;LaTeX`ob$+=neq,
     --LaTeX`ob$;With[{lx$2070},out$2070=lx$2070@Typeset["DAMPONLY is the antonym of FLUC."[p$2070,p1$2070],Format->Help2HTML`oB$];
        System["mv -f "//out$2070//" "//equ$2070]];
      Exit[]]];
   "DAMPONLY is the antonym of FLUC."[1,Max[p0$2070,0]]//"<img  class=\"eqs\" SRC=\""//equ$2070//"\" />"//
   Help2HTML`oy$["DAMPONLY is the antonym of FLUC."[p2$2070,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L318>FLUC</A></PRE>
<LI>
<H3><A NAME=L312>
DAPERT</A></H3>
<PRE>If[{},
Help2HTML`oA$["DAPERT enables the DAPERT procedure in the multi-turn tracking to obtain the dynamic aperture diagram. Accessible i\
n the MAIN level."],
p$2073=1+p$2073[[1,2]];p1$2073=StringPosition["DAPERT enables the DAPERT procedure in the multi-turn tracking to obtain the dynami\
c aperture diagram. Accessible in the MAIN level."[p$2073,-1],">::",1];
   p1$2073=If[p1$2073==={},132,-2+p$2073+p1$2073[[1,1]]];
neq=Which["DAPERT enables the DAPERT procedure in the multi-turn tracking to obtain the dynamic aperture diagram. Accessible in th\
e MAIN level."[p$2073,4+p$2073]==="Text[",
    lx$2073:=Help2HTML`oa$;p$2073=5+p$2073;p1$2073-=1;p2$2073=5+p1$2073;p0$2073=-9+p$2073;If[(pe$2073=
StringPosition["DAPERT enables the DAPERT procedure in the multi-turn tracking to obtain the dynamic aperture diagram. Accessible \
in the MAIN level."[p$2073,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["DAPERT enables the DAPERT procedure in the multi-turn tracking to obtain the dynamic aperture diagram. Accessible\
 in the MAIN level."[p$2073+pe$2073[[1,2]],p1$2073]]],
        p1$2073=-2+p$2073+pe$2073[[1,1]]}[[
       1]],
      0],
    1,lx$2073:=Help2HTML`o9$;p2$2073=4+p1$2073;p0$2073=-4+p$2073;0];
  If[(equ$2073=
Help2HTML`o8$["DAPERT enables the DAPERT procedure in the multi-turn tracking to obtain the dynamic aperture diagram. Accessible i\
n the MAIN level."[p$2073,p1$2073]])===
    Undefined,
equ$2073="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["DAPERT enables the DAPERT procedure in the m\
ulti-turn tracking to obtain the dynamic aperture diagram. Accessible in the MAIN level."[p$2073,p1$2073]]=
       equ$2073;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2073},out$2073=lx$2073@Typeset["DAPERT enables the DAPERT procedure in the multi-turn tracking to obtain the dynamic aper\
ture diagram. Accessible in the MAIN level."[p$2073,p1$2073],Format->Help2HTML`oB$];
        System["mv -f "//out$2073//" "//equ$2073]];
      Exit[]]];
   "DAPERT enables the DAPERT procedure in the multi-turn tracking to obtain the dynamic aperture diagram. Accessible in the MAIN \
level."[1,Max[p0$2073,0]]//"<img  class=\"eqs\" SRC=\""//equ$2073//"\" />"//
Help2HTML`oy$["DAPERT enables the DAPERT procedure in the multi-turn tracking to obtain the dynamic aperture diagram. Accessible i\
n the MAIN level."[p2$2073,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L358>functions</A> <A HREF=#L386>DynamicApertureSurvey</A></PRE>
<LI>
<H3><A NAME=L313>
DIFFRES</A></H3>
<PRE>If[{},
Help2HTML`oA$["In the case of CELL, if the total tune deviates across a difference resonance, it is counted as unstable. The defau\
lt is NODIFFRES."],
p$2076=1+p$2076[[1,2]];p1$2076=StringPosition["In the case of CELL, if the total tune deviates across a difference resonance, it i\
s counted as unstable. The default is NODIFFRES."[p$2076,-1],">::",1];
   p1$2076=If[p1$2076==={},131,-2+p$2076+p1$2076[[1,1]]];
neq=Which["In the case of CELL, if the total tune deviates across a difference resonance, it is counted as unstable. The default i\
s NODIFFRES."[p$2076,4+p$2076]==="Text[",
    lx$2076:=Help2HTML`oa$;p$2076=5+p$2076;p1$2076-=1;p2$2076=5+p1$2076;p0$2076=-9+p$2076;If[(pe$2076=
StringPosition["In the case of CELL, if the total tune deviates across a difference resonance, it is counted as unstable. The defa\
ult is NODIFFRES."[p$2076,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["In the case of CELL, if the total tune deviates across a difference resonance, it is counted as unstable. The def\
ault is NODIFFRES."[p$2076+pe$2076[[1,2]],p1$2076]]],
        p1$2076=-2+p$2076+pe$2076[[1,1]]}[[
       1]],
      0],
    1,lx$2076:=Help2HTML`o9$;p2$2076=4+p1$2076;p0$2076=-4+p$2076;0];
  If[(equ$2076=
Help2HTML`o8$["In the case of CELL, if the total tune deviates across a difference resonance, it is counted as unstable. The defau\
lt is NODIFFRES."[p$2076,p1$2076]])===
    Undefined,
equ$2076="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["In the case of CELL, if the total tune devia\
tes across a difference resonance, it is counted as unstable. The default is NODIFFRES."[p$2076,p1$2076]]=
       equ$2076;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2076},out$2076=lx$2076@Typeset["In the case of CELL, if the total tune deviates across a difference resonance, it is coun\
ted as unstable. The default is NODIFFRES."[p$2076,p1$2076],Format->Help2HTML`oB$];
        System["mv -f "//out$2076//" "//equ$2076]];
      Exit[]]];
   "In the case of CELL, if the total tune deviates across a difference resonance, it is counted as unstable. The default is NODIF\
FRES."[1,Max[p0$2076,0]]//"<img  class=\"eqs\" SRC=\""//equ$2076//"\" />"//
Help2HTML`oy$["In the case of CELL, if the total tune deviates across a difference resonance, it is counted as unstable. The defau\
lt is NODIFFRES."[p2$2076,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L326>INTRES</A> <A HREF=#L322>HALFRES</A> <A HREF=#L350>SUMRES</A> <A HREF=#L349>STABLE</A></PRE>
<LI>
<H3><A NAME=L314>
ECHO</A></H3>
<PRE>If[{},Help2HTML`oA$["ECHO enables the echo of the main input in the MAIN level."],
 p$2079=1+p$2079[[1,2]];p1$2079=StringPosition["ECHO enables the echo of the main input in the MAIN level."[p$2079,-1],">::",1];
  p1$2079=If[p1$2079==={},58,-2+p$2079+p1$2079[[1,1]]];
  neq=Which["ECHO enables the echo of the main input in the MAIN level."[p$2079,4+p$2079]==="Text[",
    lx$2079:=Help2HTML`oa$;p$2079=5+p$2079;p1$2079-=1;p2$2079=5+p1$2079;p0$2079=-9+p$2079;
     If[(pe$2079=StringPosition["ECHO enables the echo of the main input in the MAIN level."[p$2079,-2],";;;"])<=>{},
      {Max[0,-1+ToExpression["ECHO enables the echo of the main input in the MAIN level."[p$2079+pe$2079[[1,2]],p1$2079]]],
       p1$2079=-2+p$2079+pe$2079[[1,1]]}[[1]],
      0],
    1,lx$2079:=Help2HTML`o9$;p2$2079=4+p1$2079;p0$2079=-4+p$2079;0];
  If[(equ$2079=Help2HTML`o8$["ECHO enables the echo of the main input in the MAIN level."[p$2079,p1$2079]])===Undefined,
   equ$2079="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["ECHO enables the echo of the main input in the MAIN level."[p$2079,p1$2079]]=equ$2079;LaTeX`ob$+=neq,
     --LaTeX`ob$;
      With[{lx$2079},out$2079=lx$2079@Typeset["ECHO enables the echo of the main input in the MAIN level."[p$2079,p1$2079],
          Format->Help2HTML`oB$];
        System["mv -f "//out$2079//" "//equ$2079]];
      Exit[]]];
   "ECHO enables the echo of the main input in the MAIN level."[1,Max[p0$2079,0]]//"<img  class=\"eqs\" SRC=\""//equ$2079//
   "\" />"//Help2HTML`oy$["ECHO enables the echo of the main input in the MAIN level."[p2$2079,-1]]
]</PRE>
<LI>
<H3><A NAME=L315>
EMIOUT</A></H3>
<PRE>If[{},Help2HTML`oA$["EMIOUT turns on the extended output of emittance calculation.\nAccessible in the MAIN level."],
 p$2081=1+p$2081[[1,2]];
  p1$2081=StringPosition["EMIOUT turns on the extended output of emittance calculation.\nAccessible in the MAIN level."[p$2081,-1],
    ">::",1];
   p1$2081=If[p1$2081==={},91,-2+p$2081+p1$2081[[1,1]]];
  neq=Which["EMIOUT turns on the extended output of emittance calculation.\nAccessible in the MAIN level."[p$2081,4+p$2081]===
     "Text[",
    lx$2081:=Help2HTML`oa$;p$2081=5+p$2081;p1$2081-=1;p2$2081=5+p1$2081;p0$2081=-9+p$2081;If[(pe$2081=StringPosition[
         "EMIOUT turns on the extended output of emittance calculation.\nAccessible in the MAIN level."[p$2081,-2],";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression["EMIOUT turns on the extended output of emittance calculation.\nAccessible in the MAIN level."[p$2081+pe
            $2081[[1,2]],
           p1$2081]]],
        p1$2081=-2+p$2081+pe$2081[[1,1]]}[[
       1]],
      0],
    1,lx$2081:=Help2HTML`o9$;p2$2081=4+p1$2081;p0$2081=-4+p$2081;0];
  If[(equ$2081=
     Help2HTML`o8$["EMIOUT turns on the extended output of emittance calculation.\nAccessible in the MAIN level."[p$2081,p1$2081]]
     )===
    Undefined,
   equ$2081="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "EMIOUT turns on the extended output of emittance calculation.\nAccessible in the MAIN level."[p$2081,p1$2081]]=
       equ$2081;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$2081},out$2081=lx$2081@Typeset[
          "EMIOUT turns on the extended output of emittance calculation.\nAccessible in the MAIN level."[p$2081,p1$2081],
          Format->Help2HTML`oB$];
        System["mv -f "//out$2081//" "//equ$2081]];
      Exit[]]];
   "EMIOUT turns on the extended output of emittance calculation.\nAccessible in the MAIN level."[1,Max[p0$2081,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2081//"\" />"//
   Help2HTML`oy$["EMIOUT turns on the extended output of emittance calculation.\nAccessible in the MAIN level."[p2$2081,-1]]
 ]
</PRE>
<PRE>See also:
 <A HREF=#L295>EMITTANCE(EMIT)</A></PRE>
<LI>
<H3><A NAME=L316>
FFSPRMPT</A></H3>
<PRE>If[{},
Help2HTML`oA$["When FFSPRMPT is off(default) the input prompt is In[n]:= , where n is $Line+1. Otherwise the prompt is the traditi\
onal FFS prompt, showing the FIT location and the DISP range."],
p$2084=1+p$2084[[1,2]];p1$2084=StringPosition["When FFSPRMPT is off(default) the input prompt is In[n]:= , where n is $Line+1. Oth\
erwise the prompt is the traditional FFS prompt, showing the FIT location and the DISP range."[p$2084,-1],">::",1];
   p1$2084=If[p1$2084==={},176,-2+p$2084+p1$2084[[1,1]]];
neq=Which["When FFSPRMPT is off(default) the input prompt is In[n]:= , where n is $Line+1. Otherwise the prompt is the traditional\
 FFS prompt, showing the FIT location and the DISP range."[p$2084,4+p$2084]==="Text[",
    lx$2084:=Help2HTML`oa$;p$2084=5+p$2084;p1$2084-=1;p2$2084=5+p1$2084;p0$2084=-9+p$2084;
If[(pe$2084=StringPosition["When FFSPRMPT is off(default) the input prompt is In[n]:= , where n is $Line+1. Otherwise the prompt i\
s the traditional FFS prompt, showing the FIT location and the DISP range."[p$2084,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["When FFSPRMPT is off(default) the input prompt is In[n]:= , where n is $Line+1. Otherwise the prompt is the tradi\
tional FFS prompt, showing the FIT location and the DISP range."[p$2084+pe$2084[[1,2]],p1$2084]]],
        p1$2084=-2+p$2084+pe$2084[[1,1]]}[[
       1]],
      0],
    1,lx$2084:=Help2HTML`o9$;p2$2084=4+p1$2084;p0$2084=-4+p$2084;0];
  If[(equ$2084=
Help2HTML`o8$["When FFSPRMPT is off(default) the input prompt is In[n]:= , where n is $Line+1. Otherwise the prompt is the traditi\
onal FFS prompt, showing the FIT location and the DISP range."[p$2084,p1$2084]])===
    Undefined,
equ$2084="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["When FFSPRMPT is off(default) the input prom\
pt is In[n]:= , where n is $Line+1. Otherwise the prompt is the traditional FFS prompt, showing the FIT location and the DISP rang\
e."[p$2084,p1$2084]]=
       equ$2084;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2084},out$2084=lx$2084@Typeset["When FFSPRMPT is off(default) the input prompt is In[n]:= , where n is $Line+1. Otherwise\
 the prompt is the traditional FFS prompt, showing the FIT location and the DISP range."[p$2084,p1$2084],Format->Help2HTML`oB$];
        System["mv -f "//out$2084//" "//equ$2084]];
      Exit[]]];
   "When FFSPRMPT is off(default) the input prompt is In[n]:= , where n is $Line+1. Otherwise the prompt is the traditional FFS pr\
ompt, showing the FIT location and the DISP range."[1,Max[p0$2084,0]]//"<img  class=\"eqs\" SRC=\""//equ$2084//"\" />"//
   Help2HTML`oy$["When FFSPRMPT is off(default) the input prompt is In[n]:= , where n is $Line+1. Otherwise the prompt is the trad\
itional FFS prompt, showing the FIT location and the DISP range."[p2$2084,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L501>$Line</A> <A HREF=#L328>LOG</A></PRE>
<LI>
<H3><A NAME=L317>
FIXSEED</A></H3>
<PRE>If[{},
 Help2HTML`oA$["FIXSEED or NOMOVESEED disables the change of the seed of the random number generator after the particle tracking."
  ],
 p$2087=1+p$2087[[1,2]];p1$2087=StringPosition[
    "FIXSEED or NOMOVESEED disables the change of the seed of the random number generator after the particle tracking."[p$2087,-1],
    ">::",1];
   p1$2087=If[p1$2087==={},113,-2+p$2087+p1$2087[[1,1]]];
  neq=Which["FIXSEED or NOMOVESEED disables the change of the seed of the random number generator after the particle tracking."[p
      $2087,4+p$2087]===
     "Text[",
    lx$2087:=Help2HTML`oa$;p$2087=5+p$2087;p1$2087-=1;p2$2087=5+p1$2087;p0$2087=-9+p$2087;If[(pe$2087=StringPosition[
         "FIXSEED or NOMOVESEED disables the change of the seed of the random number generator after the particle tracking."[p$2087
          ,-2],
         ";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression[
          "FIXSEED or NOMOVESEED disables the change of the seed of the random number generator after the particle tracking."[p
            $2087+pe$2087[[1,2]],
           p1$2087]]],
        p1$2087=-2+p$2087+pe$2087[[1,1]]}[[
       1]],
      0],
    1,lx$2087:=Help2HTML`o9$;p2$2087=4+p1$2087;p0$2087=-4+p$2087;0];
  If[(equ$2087=
     Help2HTML`o8$[
      "FIXSEED or NOMOVESEED disables the change of the seed of the random number generator after the particle tracking."[p$2087,
       p1$2087]])===
    Undefined,
   equ$2087="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "FIXSEED or NOMOVESEED disables the change of the seed of the random number generator after the particle tracking."[p$2087,
         p1$2087]]=
       equ$2087;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$2087},out$2087=lx$2087@Typeset[
          "FIXSEED or NOMOVESEED disables the change of the seed of the random number generator after the particle tracking."[p
           $2087,p1$2087],Format->Help2HTML`oB$];
        System["mv -f "//out$2087//" "//equ$2087]];
      Exit[]]];
   "FIXSEED or NOMOVESEED disables the change of the seed of the random number generator after the particle tracking."[1,
    Max[p0$2087,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2087//"\" />"//
   Help2HTML`oy$[
    "FIXSEED or NOMOVESEED disables the change of the seed of the random number generator after the particle tracking."[p2$2087,-1]
    ]
]</PRE>
<PRE>See also:
 <A HREF=#L331>MOVESEED</A> <A HREF=#L476>MEASURE(MEA)</A> <A HREF=#L549>SEED</A></PRE>
<LI>
<H3><A NAME=L318>
FLUC</A></H3>
<PRE>If[{},
Help2HTML`oA$["FLUC or NODAMPONLY enables the diffusion due to synchrotron radiation in the particle tracking. Otherwise only the \
damping is enabled when RAD is ON."],
p$2090=1+p$2090[[1,2]];p1$2090=StringPosition["FLUC or NODAMPONLY enables the diffusion due to synchrotron radiation in the partic\
le tracking. Otherwise only the damping is enabled when RAD is ON."[p$2090,-1],">::",1];
   p1$2090=If[p1$2090==={},149,-2+p$2090+p1$2090[[1,1]]];
neq=Which["FLUC or NODAMPONLY enables the diffusion due to synchrotron radiation in the particle tracking. Otherwise only the damp\
ing is enabled when RAD is ON."[p$2090,4+p$2090]==="Text[",
    lx$2090:=Help2HTML`oa$;p$2090=5+p$2090;p1$2090-=1;p2$2090=5+p1$2090;p0$2090=-9+p$2090;
If[(pe$2090=StringPosition["FLUC or NODAMPONLY enables the diffusion due to synchrotron radiation in the particle tracking. Otherw\
ise only the damping is enabled when RAD is ON."[p$2090,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["FLUC or NODAMPONLY enables the diffusion due to synchrotron radiation in the particle tracking. Otherwise only th\
e damping is enabled when RAD is ON."[p$2090+pe$2090[[1,2]],p1$2090]]],
        p1$2090=-2+p$2090+pe$2090[[1,1]]}[[
       1]],
      0],
    1,lx$2090:=Help2HTML`o9$;p2$2090=4+p1$2090;p0$2090=-4+p$2090;0];
  If[(equ$2090=
Help2HTML`o8$["FLUC or NODAMPONLY enables the diffusion due to synchrotron radiation in the particle tracking. Otherwise only the \
damping is enabled when RAD is ON."[p$2090,p1$2090]])===
    Undefined,
equ$2090="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["FLUC or NODAMPONLY enables the diffusion due\
 to synchrotron radiation in the particle tracking. Otherwise only the damping is enabled when RAD is ON."[p$2090,p1$2090]]=
       equ$2090;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2090},out$2090=lx$2090@Typeset["FLUC or NODAMPONLY enables the diffusion due to synchrotron radiation in the particle tra\
cking. Otherwise only the damping is enabled when RAD is ON."[p$2090,p1$2090],Format->Help2HTML`oB$];
        System["mv -f "//out$2090//" "//equ$2090]];
      Exit[]]];
   "FLUC or NODAMPONLY enables the diffusion due to synchrotron radiation in the particle tracking. Otherwise only the damping is \
enabled when RAD is ON."[1,Max[p0$2090,0]]//"<img  class=\"eqs\" SRC=\""//equ$2090//"\" />"//
Help2HTML`oy$["FLUC or NODAMPONLY enables the diffusion due to synchrotron radiation in the particle tracking. Otherwise only the \
damping is enabled when RAD is ON."[p2$2090,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L311>DAMPONLY</A> <A HREF=#L337>RAD</A> <A HREF=#L338>RADCOD</A></PRE>
<LI>
<H3><A NAME=L319>
GAUSS</A></H3>
<PRE>If[{},
Help2HTML`oA$["GAUSS or NOUNIFORM sets the momentum distribution of the incoming beam to be Gaussian, otherwise uniform(square) di\
stribution is assumed. It affects the beam size calculated by Twiss parameters."],
p$2093=1+p$2093[[1,2]];p1$2093=StringPosition["GAUSS or NOUNIFORM sets the momentum distribution of the incoming beam to be Gaussi\
an, otherwise uniform(square) distribution is assumed. It affects the beam size calculated by Twiss parameters."[p$2093,-1],">::",
    1];
   p1$2093=If[p1$2093==={},194,-2+p$2093+p1$2093[[1,1]]];
neq=Which["GAUSS or NOUNIFORM sets the momentum distribution of the incoming beam to be Gaussian, otherwise uniform(square) distri\
bution is assumed. It affects the beam size calculated by Twiss parameters."[p$2093,4+p$2093]==="Text[",
    lx$2093:=Help2HTML`oa$;p$2093=5+p$2093;p1$2093-=1;p2$2093=5+p1$2093;p0$2093=-9+p$2093;
If[(pe$2093=StringPosition["GAUSS or NOUNIFORM sets the momentum distribution of the incoming beam to be Gaussian, otherwise unifo\
rm(square) distribution is assumed. It affects the beam size calculated by Twiss parameters."[p$2093,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["GAUSS or NOUNIFORM sets the momentum distribution of the incoming beam to be Gaussian, otherwise uniform(square) \
distribution is assumed. It affects the beam size calculated by Twiss parameters."[p$2093+pe$2093[[1,2]],p1$2093]]],
        p1$2093=-2+p$2093+pe$2093[[1,1]]}[[
       1]],
      0],
    1,lx$2093:=Help2HTML`o9$;p2$2093=4+p1$2093;p0$2093=-4+p$2093;0];
  If[(equ$2093=
Help2HTML`o8$["GAUSS or NOUNIFORM sets the momentum distribution of the incoming beam to be Gaussian, otherwise uniform(square) di\
stribution is assumed. It affects the beam size calculated by Twiss parameters."[p$2093,p1$2093]])===
    Undefined,
equ$2093="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["GAUSS or NOUNIFORM sets the momentum distrib\
ution of the incoming beam to be Gaussian, otherwise uniform(square) distribution is assumed. It affects the beam size calculated \
by Twiss parameters."[p$2093,p1$2093]]=
       equ$2093;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2093},out$2093=lx$2093@Typeset["GAUSS or NOUNIFORM sets the momentum distribution of the incoming beam to be Gaussian, ot\
herwise uniform(square) distribution is assumed. It affects the beam size calculated by Twiss parameters."[p$2093,p1$2093],
          Format->Help2HTML`oB$];
        System["mv -f "//out$2093//" "//equ$2093]];
      Exit[]]];
   "GAUSS or NOUNIFORM sets the momentum distribution of the incoming beam to be Gaussian, otherwise uniform(square) distribution \
is assumed. It affects the beam size calculated by Twiss parameters."[1,Max[p0$2093,0]]//"<img  class=\"eqs\" SRC=\""//equ$2093//
   "\" />"//
Help2HTML`oy$["GAUSS or NOUNIFORM sets the momentum distribution of the incoming beam to be Gaussian, otherwise uniform(square) di\
stribution is assumed. It affects the beam size calculated by Twiss parameters."[p2$2093,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L354>UNIFORM</A> <A HREF=#L476>MEASURE(MEA)</A> <A HREF=#L13>BEAMSIZE(BEAM)</A> <A HREF=#L500>special-variables</A> <A HREF=#L506>DP</A></PRE>
<LI>
<H3><A NAME=L320>
GEOCAL</A></H3>
<PRE>If[{},
Help2HTML`oA$["When GEOCAL is on(default), the geometry of the beam line is always updated by CALCULATE(CAL) or GO commands using \
the current values of components. The coordinate transformation by SOL is also updated. When GEOCAL is off, the geometry is never \
updated. It is useful to simulate misalignments within a solenoid, etc."],
p$2096=1+p$2096[[1,2]];p1$2096=StringPosition["When GEOCAL is on(default), the geometry of the beam line is always updated by CALC\
ULATE(CAL) or GO commands using the current values of components. The coordinate transformation by SOL is also updated. When GEOCA\
L is off, the geometry is never updated. It is useful to simulate misalignments within a solenoid, etc."[p$2096,-1],">::",1];
   p1$2096=If[p1$2096==={},316,-2+p$2096+p1$2096[[1,1]]];
neq=Which["When GEOCAL is on(default), the geometry of the beam line is always updated by CALCULATE(CAL) or GO commands using the \
current values of components. The coordinate transformation by SOL is also updated. When GEOCAL is off, the geometry is never upda\
ted. It is useful to simulate misalignments within a solenoid, etc."[p$2096,4+p$2096]==="Text[",
    lx$2096:=Help2HTML`oa$;p$2096=5+p$2096;p1$2096-=1;p2$2096=5+p1$2096;p0$2096=-9+p$2096;
If[(pe$2096=StringPosition["When GEOCAL is on(default), the geometry of the beam line is always updated by CALCULATE(CAL) or GO co\
mmands using the current values of components. The coordinate transformation by SOL is also updated. When GEOCAL is off, the geome\
try is never updated. It is useful to simulate misalignments within a solenoid, etc."[p$2096,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["When GEOCAL is on(default), the geometry of the beam line is always updated by CALCULATE(CAL) or GO commands usin\
g the current values of components. The coordinate transformation by SOL is also updated. When GEOCAL is off, the geometry is neve\
r updated. It is useful to simulate misalignments within a solenoid, etc."[p$2096+pe$2096[[1,2]],p1$2096]]],
        p1$2096=-2+p$2096+pe$2096[[1,1]]}[[
       1]],
      0],
    1,lx$2096:=Help2HTML`o9$;p2$2096=4+p1$2096;p0$2096=-4+p$2096;0];
  If[(equ$2096=
Help2HTML`o8$["When GEOCAL is on(default), the geometry of the beam line is always updated by CALCULATE(CAL) or GO commands using \
the current values of components. The coordinate transformation by SOL is also updated. When GEOCAL is off, the geometry is never \
updated. It is useful to simulate misalignments within a solenoid, etc."[p$2096,p1$2096]])===
    Undefined,
equ$2096="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["When GEOCAL is on(default), the geometry of \
the beam line is always updated by CALCULATE(CAL) or GO commands using the current values of components. The coordinate transforma\
tion by SOL is also updated. When GEOCAL is off, the geometry is never updated. It is useful to simulate misalignments within a so\
lenoid, etc."[p$2096,p1$2096]]=
       equ$2096;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2096},out$2096=lx$2096@Typeset["When GEOCAL is on(default), the geometry of the beam line is always updated by CALCULATE(\
CAL) or GO commands using the current values of components. The coordinate transformation by SOL is also updated. When GEOCAL is o\
ff, the geometry is never updated. It is useful to simulate misalignments within a solenoid, etc."[p$2096,p1$2096],
          Format->Help2HTML`oB$];
        System["mv -f "//out$2096//" "//equ$2096]];
      Exit[]]];
   "When GEOCAL is on(default), the geometry of the beam line is always updated by CALCULATE(CAL) or GO commands using the current\
 values of components. The coordinate transformation by SOL is also updated. When GEOCAL is off, the geometry is never updated. It\
 is useful to simulate misalignments within a solenoid, etc."[1,Max[p0$2096,0]]//"<img  class=\"eqs\" SRC=\""//equ$2096//"\" />"//
   Help2HTML`oy$["When GEOCAL is on(default), the geometry of the beam line is always updated by CALCULATE(CAL) or GO commands usi\
ng the current values of components. The coordinate transformation by SOL is also updated. When GEOCAL is off, the geometry is nev\
er updated. It is useful to simulate misalignments within a solenoid, etc."[p2$2096,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L321>GEOFIX</A> <A HREF=#L32>CALCULATE(CAL)</A> <A HREF=#L469>GO</A> <A HREF=#L236>SOL</A></PRE>
<LI>
<H3><A NAME=L321>
GEOFIX</A></H3>
<PRE>If[{},Help2HTML`oA$["GEOFIX is the antonym of GEOCAL."],
 p$2099=1+p$2099[[1,2]];p1$2099=StringPosition["GEOFIX is the antonym of GEOCAL."[p$2099,-1],">::",1];
  p1$2099=If[p1$2099==={},32,-2+p$2099+p1$2099[[1,1]]];
  neq=Which["GEOFIX is the antonym of GEOCAL."[p$2099,4+p$2099]==="Text[",lx$2099:=Help2HTML`oa$;p$2099=5+p$2099;p1$2099-=1;
     p2$2099=5+p1$2099;p0$2099=-9+p$2099;
     If[(pe$2099=StringPosition["GEOFIX is the antonym of GEOCAL."[p$2099,-2],";;;"])<=>{},{Max[0,
        -1+ToExpression["GEOFIX is the antonym of GEOCAL."[p$2099+pe$2099[[1,2]],p1$2099]]],p1$2099=-2+p$2099+pe$2099[[1,1]]}[[
       1]],
      0],
    1,lx$2099:=Help2HTML`o9$;p2$2099=4+p1$2099;p0$2099=-4+p$2099;0];
  If[(equ$2099=Help2HTML`o8$["GEOFIX is the antonym of GEOCAL."[p$2099,p1$2099]])===Undefined,
   equ$2099="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["GEOFIX is the antonym of GEOCAL."[p$2099,p1$2099]]=equ$2099;LaTeX`ob$+=neq,
     --LaTeX`ob$;With[{lx$2099},out$2099=lx$2099@Typeset["GEOFIX is the antonym of GEOCAL."[p$2099,p1$2099],Format->Help2HTML`oB$];
        System["mv -f "//out$2099//" "//equ$2099]];
      Exit[]]];
   "GEOFIX is the antonym of GEOCAL."[1,Max[p0$2099,0]]//"<img  class=\"eqs\" SRC=\""//equ$2099//"\" />"//
   Help2HTML`oy$["GEOFIX is the antonym of GEOCAL."[p2$2099,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L320>GEOCAL</A></PRE>
<LI>
<H3><A NAME=L322>
HALFRES</A></H3>
<PRE>If[{},
Help2HTML`oA$["In the case of CELL, if the total tune deviates across a half-integer resonance, or the traces is less than -2, it \
is counted as unstable (~?STABLE). Otherwise the optics is recognized as STABLE. The default is HALFRES."],
 p$2102=1+p$2102[[1,2]];p1$2102=
StringPosition["In the case of CELL, if the total tune deviates across a half-integer resonance, or the traces is less than -2, it\
 is counted as unstable (~?STABLE). Otherwise the optics is recognized as STABLE. The default is HALFRES."[p$2102,-1],">::",1];
   p1$2102=If[p1$2102==={},219,-2+p$2102+p1$2102[[1,1]]];
neq=Which["In the case of CELL, if the total tune deviates across a half-integer resonance, or the traces is less than -2, it is c\
ounted as unstable (~?STABLE). Otherwise the optics is recognized as STABLE. The default is HALFRES."[p$2102,4+p$2102]==="Text[",
    lx$2102:=Help2HTML`oa$;p$2102=5+p$2102;p1$2102-=1;p2$2102=5+p1$2102;p0$2102=-9+p$2102;
If[(pe$2102=StringPosition["In the case of CELL, if the total tune deviates across a half-integer resonance, or the traces is less\
 than -2, it is counted as unstable (~?STABLE). Otherwise the optics is recognized as STABLE. The default is HALFRES."[p$2102,-2],
         ";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["In the case of CELL, if the total tune deviates across a half-integer resonance, or the traces is less than -2, i\
t is counted as unstable (~?STABLE). Otherwise the optics is recognized as STABLE. The default is HALFRES."[p$2102+pe$2102[[1,2]],
           p1$2102]]],
        p1$2102=-2+p$2102+pe$2102[[1,1]]}[[
       1]],
      0],
    1,lx$2102:=Help2HTML`o9$;p2$2102=4+p1$2102;p0$2102=-4+p$2102;0];
  If[(equ$2102=
Help2HTML`o8$["In the case of CELL, if the total tune deviates across a half-integer resonance, or the traces is less than -2, it \
is counted as unstable (~?STABLE). Otherwise the optics is recognized as STABLE. The default is HALFRES."[p$2102,p1$2102]])===
    Undefined,
equ$2102="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["In the case of CELL, if the total tune devia\
tes across a half-integer resonance, or the traces is less than -2, it is counted as unstable (~?STABLE). Otherwise the optics is \
recognized as STABLE. The default is HALFRES."[p$2102,p1$2102]]=
       equ$2102;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2102},out$2102=lx$2102@Typeset["In the case of CELL, if the total tune deviates across a half-integer resonance, or the t\
races is less than -2, it is counted as unstable (~?STABLE). Otherwise the optics is recognized as STABLE. The default is HALFRES."
          [p$2102,p1$2102],Format->Help2HTML`oB$];
        System["mv -f "//out$2102//" "//equ$2102]];
      Exit[]]];
   "In the case of CELL, if the total tune deviates across a half-integer resonance, or the traces is less than -2, it is counted \
as unstable (~?STABLE). Otherwise the optics is recognized as STABLE. The default is HALFRES."[1,Max[p0$2102,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2102//"\" />"//
Help2HTML`oy$["In the case of CELL, if the total tune deviates across a half-integer resonance, or the traces is less than -2, it \
is counted as unstable (~?STABLE). Otherwise the optics is recognized as STABLE. The default is HALFRES."[p2$2102,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L326>INTRES</A> <A HREF=#L350>SUMRES</A> <A HREF=#L313>DIFFRES</A> <A HREF=#L349>STABLE</A></PRE>
<LI>
<H3><A NAME=L323>
IDEAL</A></H3>
<PRE>If[{},Help2HTML`oA$["IDEAL or NOREAL inhibits to use the component-specific deviations in the optics calculation."],
 p$2105=1+p$2105[[1,2]];
  p1$2105=StringPosition["IDEAL or NOREAL inhibits to use the component-specific deviations in the optics calculation."[p$2105,-1],
    ">::",1];
   p1$2105=If[p1$2105==={},92,-2+p$2105+p1$2105[[1,1]]];
  neq=Which["IDEAL or NOREAL inhibits to use the component-specific deviations in the optics calculation."[p$2105,4+p$2105]===
     "Text[",
    lx$2105:=Help2HTML`oa$;p$2105=5+p$2105;p1$2105-=1;p2$2105=5+p1$2105;p0$2105=-9+p$2105;If[(pe$2105=StringPosition[
         "IDEAL or NOREAL inhibits to use the component-specific deviations in the optics calculation."[p$2105,-2],";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression["IDEAL or NOREAL inhibits to use the component-specific deviations in the optics calculation."[p$2105+pe
            $2105[[1,2]],
           p1$2105]]],
        p1$2105=-2+p$2105+pe$2105[[1,1]]}[[
       1]],
      0],
    1,lx$2105:=Help2HTML`o9$;p2$2105=4+p1$2105;p0$2105=-4+p$2105;0];
  If[(equ$2105=
     Help2HTML`o8$["IDEAL or NOREAL inhibits to use the component-specific deviations in the optics calculation."[p$2105,p1$2105]]
     )===
    Undefined,
   equ$2105="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "IDEAL or NOREAL inhibits to use the component-specific deviations in the optics calculation."[p$2105,p1$2105]]=
       equ$2105;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$2105},out$2105=lx$2105@Typeset[
          "IDEAL or NOREAL inhibits to use the component-specific deviations in the optics calculation."[p$2105,p1$2105],
          Format->Help2HTML`oB$];
        System["mv -f "//out$2105//" "//equ$2105]];
      Exit[]]];
   "IDEAL or NOREAL inhibits to use the component-specific deviations in the optics calculation."[1,Max[p0$2105,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2105//"\" />"//
   Help2HTML`oy$["IDEAL or NOREAL inhibits to use the component-specific deviations in the optics calculation."[p2$2105,-1]]
 ]
</PRE>
<PRE>See also:
 <A HREF=#L342>REAL</A> <A HREF=#L32>CALCULATE(CAL)</A> <A HREF=#L469>GO</A></PRE>
<LI>
<H3><A NAME=L324>
INS</A></H3>
<PRE>If[{},Help2HTML`oA$["INS is the antonym of CELL."],
 p$2108=1+p$2108[[1,2]];p1$2108=StringPosition["INS is the antonym of CELL."[p$2108,-1],">::",1];
  p1$2108=If[p1$2108==={},27,-2+p$2108+p1$2108[[1,1]]];
  neq=Which["INS is the antonym of CELL."[p$2108,4+p$2108]==="Text[",lx$2108:=Help2HTML`oa$;p$2108=5+p$2108;p1$2108-=1;
     p2$2108=5+p1$2108;p0$2108=-9+p$2108;
     If[(pe$2108=StringPosition["INS is the antonym of CELL."[p$2108,-2],";;;"])<=>{},{Max[0,-1+
         ToExpression["INS is the antonym of CELL."[p$2108+pe$2108[[1,2]],p1$2108]]],
        p1$2108=-2+p$2108+pe$2108[[1,1]]}[[
       1]],
      0],
    1,lx$2108:=Help2HTML`o9$;p2$2108=4+p1$2108;p0$2108=-4+p$2108;0];
  If[(equ$2108=Help2HTML`o8$["INS is the antonym of CELL."[p$2108,p1$2108]])===Undefined,
   equ$2108="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["INS is the antonym of CELL."[p$2108,p1$2108]]=equ$2108;LaTeX`ob$+=neq,
     --LaTeX`ob$;With[{lx$2108},out$2108=lx$2108@Typeset["INS is the antonym of CELL."[p$2108,p1$2108],Format->Help2HTML`oB$];
        System["mv -f "//out$2108//" "//equ$2108]];
      Exit[]]];
   "INS is the antonym of CELL."[1,Max[p0$2108,0]]//"<img  class=\"eqs\" SRC=\""//equ$2108//"\" />"//
   Help2HTML`oy$["INS is the antonym of CELL."[p2$2108,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L305>CELL</A></PRE>
<LI>
<H3><A NAME=L325>
INTRA</A></H3>
<PRE>If[{},
 Help2HTML`oA$["INTRA turns on the calculation of intra-beam scattering in the emittance calculation. Accessible in MAIN level."],
 p$2111=1+p$2111[[1,2]];
  p1$2111=StringPosition[
    "INTRA turns on the calculation of intra-beam scattering in the emittance calculation. Accessible in MAIN level."[p$2111,-1],
    ">::",1];
   p1$2111=If[p1$2111==={},111,-2+p$2111+p1$2111[[1,1]]];
  neq=Which["INTRA turns on the calculation of intra-beam scattering in the emittance calculation. Accessible in MAIN level."[p
      $2111,4+p$2111]===
     "Text[",
    lx$2111:=Help2HTML`oa$;p$2111=5+p$2111;p1$2111-=1;p2$2111=5+p1$2111;p0$2111=-9+p$2111;If[(pe$2111=StringPosition[
         "INTRA turns on the calculation of intra-beam scattering in the emittance calculation. Accessible in MAIN level."[p$2111,
          -2],
         ";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression[
          "INTRA turns on the calculation of intra-beam scattering in the emittance calculation. Accessible in MAIN level."[p$2111+
            pe$2111[[1,2]],
           p1$2111]]],
        p1$2111=-2+p$2111+pe$2111[[1,1]]}[[
       1]],
      0],
    1,lx$2111:=Help2HTML`o9$;p2$2111=4+p1$2111;p0$2111=-4+p$2111;0];
  If[(equ$2111=
     Help2HTML`o8$[
      "INTRA turns on the calculation of intra-beam scattering in the emittance calculation. Accessible in MAIN level."[p$2111,
       p1$2111]])===
    Undefined,
   equ$2111="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "INTRA turns on the calculation of intra-beam scattering in the emittance calculation. Accessible in MAIN level."[p$2111,
         p1$2111]]=
       equ$2111;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$2111},out$2111=lx$2111@Typeset[
          "INTRA turns on the calculation of intra-beam scattering in the emittance calculation. Accessible in MAIN level."[p$2111,
           p1$2111],Format->Help2HTML`oB$];
        System["mv -f "//out$2111//" "//equ$2111]];
      Exit[]]];
   "INTRA turns on the calculation of intra-beam scattering in the emittance calculation. Accessible in MAIN level."[1,
    Max[p0$2111,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2111//"\" />"//
   Help2HTML`oy$["INTRA turns on the calculation of intra-beam scattering in the emittance calculation. Accessible in MAIN level."[
     p2$2111,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L295>EMITTANCE(EMIT)</A> <A HREF=#L389>Emittance</A> <A HREF=#L55>equilibrium-beam-envelope</A></PRE>
<LI>
<H3><A NAME=L326>
INTRES</A></H3>
<PRE>If[{},
Help2HTML`oA$["In the case of CELL, if the total tune deviates across an integer resonance, or the trace is larger than 2, it is c\
ounted as unstable (~?STABLE). Otherwise the optics is recognized as STABLE. The default is INTRES."],
 p$2114=1+p$2114[[1,2]];p1$2114=
StringPosition["In the case of CELL, if the total tune deviates across an integer resonance, or the trace is larger than 2, it is \
counted as unstable (~?STABLE). Otherwise the optics is recognized as STABLE. The default is INTRES."[p$2114,-1],">::",1];
   p1$2114=If[p1$2114==={},214,-2+p$2114+p1$2114[[1,1]]];
neq=Which["In the case of CELL, if the total tune deviates across an integer resonance, or the trace is larger than 2, it is count\
ed as unstable (~?STABLE). Otherwise the optics is recognized as STABLE. The default is INTRES."[p$2114,4+p$2114]==="Text[",
    lx$2114:=Help2HTML`oa$;p$2114=5+p$2114;p1$2114-=1;p2$2114=5+p1$2114;p0$2114=-9+p$2114;
If[(pe$2114=StringPosition["In the case of CELL, if the total tune deviates across an integer resonance, or the trace is larger th\
an 2, it is counted as unstable (~?STABLE). Otherwise the optics is recognized as STABLE. The default is INTRES."[p$2114,-2],";;;"]
        )<=>
       {},
      {Max[0,
-1+ToExpression["In the case of CELL, if the total tune deviates across an integer resonance, or the trace is larger than 2, it is\
 counted as unstable (~?STABLE). Otherwise the optics is recognized as STABLE. The default is INTRES."[p$2114+pe$2114[[1,2]],
           p1$2114]]],
        p1$2114=-2+p$2114+pe$2114[[1,1]]}[[
       1]],
      0],
    1,lx$2114:=Help2HTML`o9$;p2$2114=4+p1$2114;p0$2114=-4+p$2114;0];
  If[(equ$2114=
Help2HTML`o8$["In the case of CELL, if the total tune deviates across an integer resonance, or the trace is larger than 2, it is c\
ounted as unstable (~?STABLE). Otherwise the optics is recognized as STABLE. The default is INTRES."[p$2114,p1$2114]])===
    Undefined,
equ$2114="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["In the case of CELL, if the total tune devia\
tes across an integer resonance, or the trace is larger than 2, it is counted as unstable (~?STABLE). Otherwise the optics is reco\
gnized as STABLE. The default is INTRES."[p$2114,p1$2114]]=
       equ$2114;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2114},out$2114=lx$2114@Typeset["In the case of CELL, if the total tune deviates across an integer resonance, or the trace\
 is larger than 2, it is counted as unstable (~?STABLE). Otherwise the optics is recognized as STABLE. The default is INTRES."[p
           $2114,p1$2114],Format->Help2HTML`oB$];
        System["mv -f "//out$2114//" "//equ$2114]];
      Exit[]]];
   "In the case of CELL, if the total tune deviates across an integer resonance, or the trace is larger than 2, it is counted as u\
nstable (~?STABLE). Otherwise the optics is recognized as STABLE. The default is INTRES."[1,Max[p0$2114,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2114//"\" />"//
Help2HTML`oy$["In the case of CELL, if the total tune deviates across an integer resonance, or the trace is larger than 2, it is c\
ounted as unstable (~?STABLE). Otherwise the optics is recognized as STABLE. The default is INTRES."[p2$2114,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L322>HALFRES</A> <A HREF=#L350>SUMRES</A> <A HREF=#L313>DIFFRES</A> <A HREF=#L349>STABLE</A></PRE>
<LI>
<H3><A NAME=L327>
JITTER</A></H3>
<PRE>If[{},
Help2HTML`oA$["JITTER or NOQUIET allows jitter of the center-of-mass of the incoming beam in the case of TRPT. Otherwise the cente\
r-of-mass statistically fluctuates depending on the number of particles."],
p$2117=1+p$2117[[1,2]];p1$2117=StringPosition["JITTER or NOQUIET allows jitter of the center-of-mass of the incoming beam in the c\
ase of TRPT. Otherwise the center-of-mass statistically fluctuates depending on the number of particles."[p$2117,-1],">::",1];
   p1$2117=If[p1$2117==={},187,-2+p$2117+p1$2117[[1,1]]];
neq=Which["JITTER or NOQUIET allows jitter of the center-of-mass of the incoming beam in the case of TRPT. Otherwise the center-of\
-mass statistically fluctuates depending on the number of particles."[p$2117,4+p$2117]==="Text[",
    lx$2117:=Help2HTML`oa$;p$2117=5+p$2117;p1$2117-=1;p2$2117=5+p1$2117;p0$2117=-9+p$2117;
If[(pe$2117=StringPosition["JITTER or NOQUIET allows jitter of the center-of-mass of the incoming beam in the case of TRPT. Otherw\
ise the center-of-mass statistically fluctuates depending on the number of particles."[p$2117,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["JITTER or NOQUIET allows jitter of the center-of-mass of the incoming beam in the case of TRPT. Otherwise the cen\
ter-of-mass statistically fluctuates depending on the number of particles."[p$2117+pe$2117[[1,2]],p1$2117]]],
        p1$2117=-2+p$2117+pe$2117[[1,1]]}[[
       1]],
      0],
    1,lx$2117:=Help2HTML`o9$;p2$2117=4+p1$2117;p0$2117=-4+p$2117;0];
  If[(equ$2117=
Help2HTML`o8$["JITTER or NOQUIET allows jitter of the center-of-mass of the incoming beam in the case of TRPT. Otherwise the cente\
r-of-mass statistically fluctuates depending on the number of particles."[p$2117,p1$2117]])===
    Undefined,
equ$2117="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["JITTER or NOQUIET allows jitter of the cente\
r-of-mass of the incoming beam in the case of TRPT. Otherwise the center-of-mass statistically fluctuates depending on the number \
of particles."[p$2117,p1$2117]]=
       equ$2117;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2117},out$2117=lx$2117@Typeset["JITTER or NOQUIET allows jitter of the center-of-mass of the incoming beam in the case of\
 TRPT. Otherwise the center-of-mass statistically fluctuates depending on the number of particles."[p$2117,p1$2117],
          Format->Help2HTML`oB$];
        System["mv -f "//out$2117//" "//equ$2117]];
      Exit[]]];
   "JITTER or NOQUIET allows jitter of the center-of-mass of the incoming beam in the case of TRPT. Otherwise the center-of-mass s\
tatistically fluctuates depending on the number of particles."[1,Max[p0$2117,0]]//"<img  class=\"eqs\" SRC=\""//equ$2117//"\" />"//
   Help2HTML`oy$["JITTER or NOQUIET allows jitter of the center-of-mass of the incoming beam in the case of TRPT. Otherwise the ce\
nter-of-mass statistically fluctuates depending on the number of particles."[p2$2117,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L336>QUIET</A> <A HREF=#L476>MEASURE(MEA)</A> <A HREF=#L352>TRPT</A></PRE>
<LI>
<H3><A NAME=L328>
LOG</A></H3>
<PRE>If[{},Help2HTML`oA$["LOG enables the echo of all inputs in the MAIN level. Also suppresses the prompt in FFS."],
 p$2120=1+p$2120[[1,2]];
  p1$2120=StringPosition["LOG enables the echo of all inputs in the MAIN level. Also suppresses the prompt in FFS."[p$2120,-1],
    ">::",1];
   p1$2120=If[p1$2120==={},88,-2+p$2120+p1$2120[[1,1]]];
  neq=Which["LOG enables the echo of all inputs in the MAIN level. Also suppresses the prompt in FFS."[p$2120,4+p$2120]==="Text[",
    lx$2120:=Help2HTML`oa$;p$2120=5+p$2120;p1$2120-=1;p2$2120=5+p1$2120;p0$2120=-9+p$2120;
     If[(pe$2120=StringPosition["LOG enables the echo of all inputs in the MAIN level. Also suppresses the prompt in FFS."[p$2120,
          -2],
         ";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression["LOG enables the echo of all inputs in the MAIN level. Also suppresses the prompt in FFS."[p$2120+pe$2120[[
             1,2]],
           p1$2120]]],
        p1$2120=-2+p$2120+pe$2120[[1,1]]}[[
       1]],
      0],
    1,lx$2120:=Help2HTML`o9$;p2$2120=4+p1$2120;p0$2120=-4+p$2120;0];
  If[(equ$2120=
     Help2HTML`o8$["LOG enables the echo of all inputs in the MAIN level. Also suppresses the prompt in FFS."[p$2120,p1$2120]])===
    Undefined,
   equ$2120="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "LOG enables the echo of all inputs in the MAIN level. Also suppresses the prompt in FFS."[p$2120,p1$2120]]=
       equ$2120;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$2120},out$2120=lx$2120@Typeset[
          "LOG enables the echo of all inputs in the MAIN level. Also suppresses the prompt in FFS."[p$2120,p1$2120],
          Format->Help2HTML`oB$];
        System["mv -f "//out$2120//" "//equ$2120]];
      Exit[]]];
   "LOG enables the echo of all inputs in the MAIN level. Also suppresses the prompt in FFS."[1,Max[p0$2120,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2120//"\" />"//
   Help2HTML`oy$["LOG enables the echo of all inputs in the MAIN level. Also suppresses the prompt in FFS."[p2$2120,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L314>ECHO</A></PRE>
<LI>
<H3><A NAME=L329>
LOSSMAP</A></H3>
<PRE>If[{},
Help2HTML`oA$["If LOSSMAP is on, TrackParticles returns the location and turn where the particle lost is detected, in the 8/10th a\
nd 9/11th element of the result, for  NOPOL/POL, respectively. The default is NOLOSSMAP"],
 p$2123=1+p$2123[[1,2]];p1$2123=StringPosition["If LOSSMAP is on, TrackParticles returns the location and turn where the particle \
lost is detected, in the 8/10th and 9/11th element of the result, for  NOPOL/POL, respectively. The default is NOLOSSMAP"[p$2123,-1
     ],
    ">::",1];
   p1$2123=If[p1$2123==={},202,-2+p$2123+p1$2123[[1,1]]];
neq=Which["If LOSSMAP is on, TrackParticles returns the location and turn where the particle lost is detected, in the 8/10th and 9\
/11th element of the result, for  NOPOL/POL, respectively. The default is NOLOSSMAP"[p$2123,4+p$2123]==="Text[",
    lx$2123:=Help2HTML`oa$;p$2123=5+p$2123;p1$2123-=1;p2$2123=5+p1$2123;p0$2123=-9+p$2123;
If[(pe$2123=StringPosition["If LOSSMAP is on, TrackParticles returns the location and turn where the particle lost is detected, in\
 the 8/10th and 9/11th element of the result, for  NOPOL/POL, respectively. The default is NOLOSSMAP"[p$2123,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["If LOSSMAP is on, TrackParticles returns the location and turn where the particle lost is detected, in the 8/10th\
 and 9/11th element of the result, for  NOPOL/POL, respectively. The default is NOLOSSMAP"[p$2123+pe$2123[[1,2]],p1$2123]]],
        p1$2123=-2+p$2123+pe$2123[[1,1]]}[[
       1]],
      0],
    1,lx$2123:=Help2HTML`o9$;p2$2123=4+p1$2123;p0$2123=-4+p$2123;0];
  If[(equ$2123=
Help2HTML`o8$["If LOSSMAP is on, TrackParticles returns the location and turn where the particle lost is detected, in the 8/10th a\
nd 9/11th element of the result, for  NOPOL/POL, respectively. The default is NOLOSSMAP"[p$2123,p1$2123]])===
    Undefined,
equ$2123="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["If LOSSMAP is on, TrackParticles returns the\
 location and turn where the particle lost is detected, in the 8/10th and 9/11th element of the result, for  NOPOL/POL, respective\
ly. The default is NOLOSSMAP"[p$2123,p1$2123]]=
       equ$2123;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2123},out$2123=lx$2123@Typeset["If LOSSMAP is on, TrackParticles returns the location and turn where the particle lost is\
 detected, in the 8/10th and 9/11th element of the result, for  NOPOL/POL, respectively. The default is NOLOSSMAP"[p$2123,p1$2123],
          Format->Help2HTML`oB$];
        System["mv -f "//out$2123//" "//equ$2123]];
      Exit[]]];
   "If LOSSMAP is on, TrackParticles returns the location and turn where the particle lost is detected, in the 8/10th and 9/11th e\
lement of the result, for  NOPOL/POL, respectively. The default is NOLOSSMAP"[1,Max[p0$2123,0]]//"<img  class=\"eqs\" SRC=\""//
   equ$2123//"\" />"//
Help2HTML`oy$["If LOSSMAP is on, TrackParticles returns the location and turn where the particle lost is detected, in the 8/10th a\
nd 9/11th element of the result, for  NOPOL/POL, respectively. The default is NOLOSSMAP"[p2$2123,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L409>TrackParticles</A> <A HREF=#L333>POL</A></PRE>
<LI>
<H3><A NAME=L330>
LWAKE</A></H3>
<PRE>If[{},Help2HTML`oA$["LWAKE turns on optics calculation with Longitudinal WakeFunction"],
 p$2126=1+p$2126[[1,2]];p1$2126=StringPosition["LWAKE turns on optics calculation with Longitudinal WakeFunction"[p$2126,-1],">::",
    1];
   p1$2126=If[p1$2126==={},64,-2+p$2126+p1$2126[[1,1]]];
  neq=Which["LWAKE turns on optics calculation with Longitudinal WakeFunction"[p$2126,4+p$2126]==="Text[",
    lx$2126:=Help2HTML`oa$;p$2126=5+p$2126;p1$2126-=1;p2$2126=5+p1$2126;p0$2126=-9+p$2126;
     If[(pe$2126=StringPosition["LWAKE turns on optics calculation with Longitudinal WakeFunction"[p$2126,-2],";;;"])<=>{},
      {Max[0,-1+ToExpression["LWAKE turns on optics calculation with Longitudinal WakeFunction"[p$2126+pe$2126[[1,2]],p1$2126]]],
       p1$2126=-2+p$2126+pe$2126[[1,1]]}[[1]],
      0],
    1,lx$2126:=Help2HTML`o9$;p2$2126=4+p1$2126;p0$2126=-4+p$2126;0];
  If[(equ$2126=Help2HTML`o8$["LWAKE turns on optics calculation with Longitudinal WakeFunction"[p$2126,p1$2126]])===Undefined,
   equ$2126="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["LWAKE turns on optics calculation with Longitudinal WakeFunction"[p$2126,p1$2126]]=equ$2126;
      LaTeX`ob$+=neq,
     --LaTeX`ob$;With[{lx$2126},out$2126=lx$2126@Typeset["LWAKE turns on optics calculation with Longitudinal WakeFunction"[p$2126,
           p1$2126],Format->Help2HTML`oB$];
        System["mv -f "//out$2126//" "//equ$2126]];
      Exit[]]];
   "LWAKE turns on optics calculation with Longitudinal WakeFunction"[1,Max[p0$2126,0]]//"<img  class=\"eqs\" SRC=\""//equ$2126//
   "\" />"//Help2HTML`oy$["LWAKE turns on optics calculation with Longitudinal WakeFunction"[p2$2126,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L413>WakeFunction</A> <A HREF=#L409>TrackParticles</A> <A HREF=#L524>InitialOrbits</A> <A HREF=#L353>TWAKE</A></PRE>
<LI>
<H3><A NAME=L331>
MOVESEED</A></H3>
<PRE>If[{},Help2HTML`oA$["MOVESEED is the antonym of FIXSEED."],
 p$2129=1+p$2129[[1,2]];p1$2129=StringPosition["MOVESEED is the antonym of FIXSEED."[p$2129,-1],">::",1];
  p1$2129=If[p1$2129==={},35,-2+p$2129+p1$2129[[1,1]]];
  neq=Which["MOVESEED is the antonym of FIXSEED."[p$2129,4+p$2129]==="Text[",lx$2129:=Help2HTML`oa$;p$2129=5+p$2129;p1$2129-=1;
     p2$2129=5+p1$2129;p0$2129=-9+p$2129;
     If[(pe$2129=StringPosition["MOVESEED is the antonym of FIXSEED."[p$2129,-2],";;;"])<=>{},{Max[0,
        -1+ToExpression["MOVESEED is the antonym of FIXSEED."[p$2129+pe$2129[[1,2]],p1$2129]]],p1$2129=-2+p$2129+pe$2129[[1,1]]}[[
       1]],
      0],
    1,lx$2129:=Help2HTML`o9$;p2$2129=4+p1$2129;p0$2129=-4+p$2129;0];
  If[(equ$2129=Help2HTML`o8$["MOVESEED is the antonym of FIXSEED."[p$2129,p1$2129]])===Undefined,
   equ$2129="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["MOVESEED is the antonym of FIXSEED."[p$2129,p1$2129]]=equ$2129;LaTeX`ob$+=neq,
     --LaTeX`ob$;With[{lx$2129},
       out$2129=lx$2129@Typeset["MOVESEED is the antonym of FIXSEED."[p$2129,p1$2129],Format->Help2HTML`oB$];
        System["mv -f "//out$2129//" "//equ$2129]];
      Exit[]]];
   "MOVESEED is the antonym of FIXSEED."[1,Max[p0$2129,0]]//"<img  class=\"eqs\" SRC=\""//equ$2129//"\" />"//
   Help2HTML`oy$["MOVESEED is the antonym of FIXSEED."[p2$2129,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L317>FIXSEED</A></PRE>
<LI>
<H3><A NAME=L332>
PHOTONS</A></H3>
<PRE>If[{},
Help2HTML`oA$["When PHOTONS is ON (default is OFF), with RAD and FLUC, TrackParticles generates a list of all photons radiated thr\
ough the tracking. The list is assigned to a symbol PhotonList."],
p$2132=1+p$2132[[1,2]];p1$2132=StringPosition["When PHOTONS is ON (default is OFF), with RAD and FLUC, TrackParticles generates a \
list of all photons radiated through the tracking. The list is assigned to a symbol PhotonList."[p$2132,-1],">::",1];
   p1$2132=If[p1$2132==={},178,-2+p$2132+p1$2132[[1,1]]];
neq=Which["When PHOTONS is ON (default is OFF), with RAD and FLUC, TrackParticles generates a list of all photons radiated through\
 the tracking. The list is assigned to a symbol PhotonList."[p$2132,4+p$2132]==="Text[",
    lx$2132:=Help2HTML`oa$;p$2132=5+p$2132;p1$2132-=1;p2$2132=5+p1$2132;p0$2132=-9+p$2132;
If[(pe$2132=StringPosition["When PHOTONS is ON (default is OFF), with RAD and FLUC, TrackParticles generates a list of all photons\
 radiated through the tracking. The list is assigned to a symbol PhotonList."[p$2132,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["When PHOTONS is ON (default is OFF), with RAD and FLUC, TrackParticles generates a list of all photons radiated t\
hrough the tracking. The list is assigned to a symbol PhotonList."[p$2132+pe$2132[[1,2]],p1$2132]]],
        p1$2132=-2+p$2132+pe$2132[[1,1]]}[[
       1]],
      0],
    1,lx$2132:=Help2HTML`o9$;p2$2132=4+p1$2132;p0$2132=-4+p$2132;0];
  If[(equ$2132=
Help2HTML`o8$["When PHOTONS is ON (default is OFF), with RAD and FLUC, TrackParticles generates a list of all photons radiated thr\
ough the tracking. The list is assigned to a symbol PhotonList."[p$2132,p1$2132]])===
    Undefined,
equ$2132="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["When PHOTONS is ON (default is OFF), with RA\
D and FLUC, TrackParticles generates a list of all photons radiated through the tracking. The list is assigned to a symbol PhotonL\
ist."[p$2132,p1$2132]]=
       equ$2132;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2132},out$2132=lx$2132@Typeset["When PHOTONS is ON (default is OFF), with RAD and FLUC, TrackParticles generates a list o\
f all photons radiated through the tracking. The list is assigned to a symbol PhotonList."[p$2132,p1$2132],Format->Help2HTML`oB$];
        System["mv -f "//out$2132//" "//equ$2132]];
      Exit[]]];
   "When PHOTONS is ON (default is OFF), with RAD and FLUC, TrackParticles generates a list of all photons radiated through the tr\
acking. The list is assigned to a symbol PhotonList."[1,Max[p0$2132,0]]//"<img  class=\"eqs\" SRC=\""//equ$2132//"\" />"//
   Help2HTML`oy$["When PHOTONS is ON (default is OFF), with RAD and FLUC, TrackParticles generates a list of all photons radiated \
through the tracking. The list is assigned to a symbol PhotonList."[p2$2132,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L541>PhotonList</A> <A HREF=#L409>TrackParticles</A> <A HREF=#L337>RAD</A> <A HREF=#L318>FLUC</A></PRE>
<LI>
<H3><A NAME=L333>
POL</A></H3>
<PRE>If[{},Help2HTML`oA$["POL turns on spin tracking and the calculation of equilibrium polarization in EMIT/Emittance[]."],
 p$2135=1+p$2135[[1,2]];
  p1$2135=StringPosition["POL turns on spin tracking and the calculation of equilibrium polarization in EMIT/Emittance[]."[p$2135,
     -1],
    ">::",1];
   p1$2135=If[p1$2135==={},95,-2+p$2135+p1$2135[[1,1]]];
  neq=Which["POL turns on spin tracking and the calculation of equilibrium polarization in EMIT/Emittance[]."[p$2135,4+p$2135]===
     "Text[",
    lx$2135:=Help2HTML`oa$;p$2135=5+p$2135;p1$2135-=1;p2$2135=5+p1$2135;p0$2135=-9+p$2135;If[(pe$2135=StringPosition[
         "POL turns on spin tracking and the calculation of equilibrium polarization in EMIT/Emittance[]."[p$2135,-2],";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression["POL turns on spin tracking and the calculation of equilibrium polarization in EMIT/Emittance[]."[p$2135+
            pe$2135[[1,2]],
           p1$2135]]],
        p1$2135=-2+p$2135+pe$2135[[1,1]]}[[
       1]],
      0],
    1,lx$2135:=Help2HTML`o9$;p2$2135=4+p1$2135;p0$2135=-4+p$2135;0];
  If[(equ$2135=
     Help2HTML`o8$["POL turns on spin tracking and the calculation of equilibrium polarization in EMIT/Emittance[]."[p$2135,p1$2135
       ]])===
    Undefined,
   equ$2135="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "POL turns on spin tracking and the calculation of equilibrium polarization in EMIT/Emittance[]."[p$2135,p1$2135]]=
       equ$2135;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$2135},out$2135=lx$2135@Typeset[
          "POL turns on spin tracking and the calculation of equilibrium polarization in EMIT/Emittance[]."[p$2135,p1$2135],
          Format->Help2HTML`oB$];
        System["mv -f "//out$2135//" "//equ$2135]];
      Exit[]]];
   "POL turns on spin tracking and the calculation of equilibrium polarization in EMIT/Emittance[]."[1,Max[p0$2135,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2135//"\" />"//
   Help2HTML`oy$["POL turns on spin tracking and the calculation of equilibrium polarization in EMIT/Emittance[]."[p2$2135,-1]]
 ]
</PRE>
<PRE>See also:
 <A HREF=#L340>RADPOL</A> <A HREF=#L295>EMITTANCE(EMIT)</A> <A HREF=#L389>Emittance</A> <A HREF=#L409>TrackParticles</A></PRE>
<LI>
<H3><A NAME=L334>
PRSVCASE</A></H3>
<PRE>If[{},
 Help2HTML`oA$[
  "When PRSVCASE is on, FFS command line parser preserves the input characters for the element names and patterns.(Default off)"],
 p$2138=1+p$2138[[1,2]];
  p1$2138=StringPosition[
    "When PRSVCASE is on, FFS command line parser preserves the input characters for the element names and patterns.(Default off)"[
     p$2138,-1],
    ">::",1];
   p1$2138=If[p1$2138==={},124,-2+p$2138+p1$2138[[1,1]]];
  neq=Which[
     "When PRSVCASE is on, FFS command line parser preserves the input characters for the element names and patterns.(Default off)"
     [p$2138,4+p$2138]==="Text[",
    lx$2138:=Help2HTML`oa$;p$2138=5+p$2138;p1$2138-=1;p2$2138=5+p1$2138;p0$2138=-9+p$2138;If[(pe$2138=StringPosition[
         "When PRSVCASE is on, FFS command line parser preserves the input characters for the element names and patterns.(Default \
off)"[p$2138,-2],";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression[
          "When PRSVCASE is on, FFS command line parser preserves the input characters for the element names and patterns.(Default\
 off)"[p$2138+pe$2138[[1,2]],p1$2138]]],
        p1$2138=-2+p$2138+pe$2138[[1,1]]}[[
       1]],
      0],
    1,lx$2138:=Help2HTML`o9$;p2$2138=4+p1$2138;p0$2138=-4+p$2138;0];
  If[(equ$2138=
     Help2HTML`o8$[
      "When PRSVCASE is on, FFS command line parser preserves the input characters for the element names and patterns.(Default off\
)"[p$2138,p1$2138]])===
    Undefined,
   equ$2138="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "When PRSVCASE is on, FFS command line parser preserves the input characters for the element names and patterns.(Default o\
ff)"[p$2138,p1$2138]]=
       equ$2138;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$2138},out$2138=lx$2138@Typeset[
          "When PRSVCASE is on, FFS command line parser preserves the input characters for the element names and patterns.(Default\
 off)"[p$2138,p1$2138],Format->Help2HTML`oB$];
        System["mv -f "//out$2138//" "//equ$2138]];
      Exit[]]];
  "When PRSVCASE is on, FFS command line parser preserves the input characters for the element names and patterns.(Default off)"[
    1,Max[p0$2138,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2138//"\" />"//
   Help2HTML`oy$[
    "When PRSVCASE is on, FFS command line parser preserves the input characters for the element names and patterns.(Default off)"[
     p2$2138,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L310>CONVCASE</A></PRE>
<LI>
<H3><A NAME=L335>
PSPAC</A></H3>
<PRE>If[{},
Help2HTML`oA$["When on, performs space-charge simulation in a \"Particle-In-Cell\" method. PSPAC is effective in tracking only.\n \
  Do not confuse PSPAC with SPAC/WSPAC."],
p$2141=1+p$2141[[1,2]];p1$2141=StringPosition["When on, performs space-charge simulation in a \"Particle-In-Cell\" method. PSPAC i\
s effective in tracking only.\n   Do not confuse PSPAC with SPAC/WSPAC."[p$2141,-1],">::",1];
   p1$2141=If[p1$2141==={},151,-2+p$2141+p1$2141[[1,1]]];
neq=Which["When on, performs space-charge simulation in a \"Particle-In-Cell\" method. PSPAC is effective in tracking only.\n   Do\
 not confuse PSPAC with SPAC/WSPAC."[p$2141,4+p$2141]==="Text[",
    lx$2141:=Help2HTML`oa$;p$2141=5+p$2141;p1$2141-=1;p2$2141=5+p1$2141;p0$2141=-9+p$2141;
If[(pe$2141=StringPosition["When on, performs space-charge simulation in a \"Particle-In-Cell\" method. PSPAC is effective in trac\
king only.\n   Do not confuse PSPAC with SPAC/WSPAC."[p$2141,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["When on, performs space-charge simulation in a \"Particle-In-Cell\" method. PSPAC is effective in tracking only.\\
n   Do not confuse PSPAC with SPAC/WSPAC."[p$2141+pe$2141[[1,2]],p1$2141]]],
        p1$2141=-2+p$2141+pe$2141[[1,1]]}[[
       1]],
      0],
    1,lx$2141:=Help2HTML`o9$;p2$2141=4+p1$2141;p0$2141=-4+p$2141;0];
  If[(equ$2141=
Help2HTML`o8$["When on, performs space-charge simulation in a \"Particle-In-Cell\" method. PSPAC is effective in tracking only.\n \
  Do not confuse PSPAC with SPAC/WSPAC."[p$2141,p1$2141]])===
    Undefined,
equ$2141="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["When on, performs space-charge simulation in\
 a \"Particle-In-Cell\" method. PSPAC is effective in tracking only.\n   Do not confuse PSPAC with SPAC/WSPAC."[p$2141,p1$2141]]=
       equ$2141;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2141},out$2141=lx$2141@Typeset["When on, performs space-charge simulation in a \"Particle-In-Cell\" method. PSPAC is effe\
ctive in tracking only.\n   Do not confuse PSPAC with SPAC/WSPAC."[p$2141,p1$2141],Format->Help2HTML`oB$];
        System["mv -f "//out$2141//" "//equ$2141]];
      Exit[]]];
   "When on, performs space-charge simulation in a \"Particle-In-Cell\" method. PSPAC is effective in tracking only.\n   Do not co\
nfuse PSPAC with SPAC/WSPAC."[1,Max[p0$2141,0]]//"<img  class=\"eqs\" SRC=\""//equ$2141//"\" />"//
Help2HTML`oy$["When on, performs space-charge simulation in a \"Particle-In-Cell\" method. PSPAC is effective in tracking only.\n \
  Do not confuse PSPAC with SPAC/WSPAC."[p2$2141,-1]]
]</PRE>
<PRE>See also:
 PSPACNX PSPACNY PSPACNZ PSPACDX PSPACDY PSPACDZ</PRE>
<LI>
<H3><A NAME=L336>
QUIET</A></H3>
<PRE>If[{},Help2HTML`oA$["QUIET is the antonym of JITEER."],
 p$2144=1+p$2144[[1,2]];p1$2144=StringPosition["QUIET is the antonym of JITEER."[p$2144,-1],">::",1];
  p1$2144=If[p1$2144==={},31,-2+p$2144+p1$2144[[1,1]]];
  neq=Which["QUIET is the antonym of JITEER."[p$2144,4+p$2144]==="Text[",lx$2144:=Help2HTML`oa$;p$2144=5+p$2144;p1$2144-=1;
     p2$2144=5+p1$2144;p0$2144=-9+p$2144;
     If[(pe$2144=StringPosition["QUIET is the antonym of JITEER."[p$2144,-2],";;;"])<=>{},{Max[0,
        -1+ToExpression["QUIET is the antonym of JITEER."[p$2144+pe$2144[[1,2]],p1$2144]]],p1$2144=-2+p$2144+pe$2144[[1,1]]}[[
       1]],
      0],
    1,lx$2144:=Help2HTML`o9$;p2$2144=4+p1$2144;p0$2144=-4+p$2144;0];
  If[(equ$2144=Help2HTML`o8$["QUIET is the antonym of JITEER."[p$2144,p1$2144]])===Undefined,
   equ$2144="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["QUIET is the antonym of JITEER."[p$2144,p1$2144]]=equ$2144;LaTeX`ob$+=neq,
     --LaTeX`ob$;With[{lx$2144},out$2144=lx$2144@Typeset["QUIET is the antonym of JITEER."[p$2144,p1$2144],Format->Help2HTML`oB$];
        System["mv -f "//out$2144//" "//equ$2144]];
      Exit[]]];
   "QUIET is the antonym of JITEER."[1,Max[p0$2144,0]]//"<img  class=\"eqs\" SRC=\""//equ$2144//"\" />"//
   Help2HTML`oy$["QUIET is the antonym of JITEER."[p2$2144,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L327>JITTER</A></PRE>
<LI>
<H3><A NAME=L337>
RAD</A></H3>
<PRE>If[{},Help2HTML`oA$["RAD turns on the synchrotron radiation in the particle-tracking. Accessible in the MAIN level."],
 p$2147=1+p$2147[[1,2]];
  p1$2147=StringPosition["RAD turns on the synchrotron radiation in the particle-tracking. Accessible in the MAIN level."[p$2147,-1
     ],
    ">::",1];
   p1$2147=If[p1$2147==={},94,-2+p$2147+p1$2147[[1,1]]];
  neq=Which["RAD turns on the synchrotron radiation in the particle-tracking. Accessible in the MAIN level."[p$2147,4+p$2147]===
     "Text[",
    lx$2147:=Help2HTML`oa$;p$2147=5+p$2147;p1$2147-=1;p2$2147=5+p1$2147;p0$2147=-9+p$2147;If[(pe$2147=StringPosition[
         "RAD turns on the synchrotron radiation in the particle-tracking. Accessible in the MAIN level."[p$2147,-2],";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression["RAD turns on the synchrotron radiation in the particle-tracking. Accessible in the MAIN level."[p$2147+
            pe$2147[[1,2]],
           p1$2147]]],
        p1$2147=-2+p$2147+pe$2147[[1,1]]}[[
       1]],
      0],
    1,lx$2147:=Help2HTML`o9$;p2$2147=4+p1$2147;p0$2147=-4+p$2147;0];
  If[(equ$2147=
     Help2HTML`o8$["RAD turns on the synchrotron radiation in the particle-tracking. Accessible in the MAIN level."[p$2147,p1$2147]
      ])===
    Undefined,
   equ$2147="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "RAD turns on the synchrotron radiation in the particle-tracking. Accessible in the MAIN level."[p$2147,p1$2147]]=
       equ$2147;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$2147},out$2147=lx$2147@Typeset[
          "RAD turns on the synchrotron radiation in the particle-tracking. Accessible in the MAIN level."[p$2147,p1$2147],
          Format->Help2HTML`oB$];
        System["mv -f "//out$2147//" "//equ$2147]];
      Exit[]]];
   "RAD turns on the synchrotron radiation in the particle-tracking. Accessible in the MAIN level."[1,Max[p0$2147,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2147//"\" />"//
   Help2HTML`oy$["RAD turns on the synchrotron radiation in the particle-tracking. Accessible in the MAIN level."[p2$2147,-1]]
 ]
</PRE>
<PRE>See also:
 <A HREF=#L338>RADCOD</A> <A HREF=#L318>FLUC</A></PRE>
<LI>
<H3><A NAME=L338>
RADCOD</A></H3>
<PRE>If[{},
Help2HTML`oA$["RADCOD turns on the energy loss due to synchrotron radiation at the closed-orbit in the emittance calculation. Also\
 turns off the implicit acceleration in the tracking to compensate the energy loss automatically, in the case that TRPT is ON. Acc\
essible in MAIN level."],
p$2150=1+p$2150[[1,2]];p1$2150=StringPosition["RADCOD turns on the energy loss due to synchrotron radiation at the closed-orbit in\
 the emittance calculation. Also turns off the implicit acceleration in the tracking to compensate the energy loss automatically, \
in the case that TRPT is ON. Accessible in MAIN level."[p$2150,-1],">::",1];
   p1$2150=If[p1$2150==={},267,-2+p$2150+p1$2150[[1,1]]];
neq=Which["RADCOD turns on the energy loss due to synchrotron radiation at the closed-orbit in the emittance calculation. Also tur\
ns off the implicit acceleration in the tracking to compensate the energy loss automatically, in the case that TRPT is ON. Accessi\
ble in MAIN level."[p$2150,4+p$2150]==="Text[",
    lx$2150:=Help2HTML`oa$;p$2150=5+p$2150;p1$2150-=1;p2$2150=5+p1$2150;p0$2150=-9+p$2150;
If[(pe$2150=StringPosition["RADCOD turns on the energy loss due to synchrotron radiation at the closed-orbit in the emittance calc\
ulation. Also turns off the implicit acceleration in the tracking to compensate the energy loss automatically, in the case that TR\
PT is ON. Accessible in MAIN level."[p$2150,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["RADCOD turns on the energy loss due to synchrotron radiation at the closed-orbit in the emittance calculation. Al\
so turns off the implicit acceleration in the tracking to compensate the energy loss automatically, in the case that TRPT is ON. A\
ccessible in MAIN level."[p$2150+pe$2150[[1,2]],p1$2150]]],
        p1$2150=-2+p$2150+pe$2150[[1,1]]}[[
       1]],
      0],
    1,lx$2150:=Help2HTML`o9$;p2$2150=4+p1$2150;p0$2150=-4+p$2150;0];
  If[(equ$2150=
Help2HTML`o8$["RADCOD turns on the energy loss due to synchrotron radiation at the closed-orbit in the emittance calculation. Also\
 turns off the implicit acceleration in the tracking to compensate the energy loss automatically, in the case that TRPT is ON. Acc\
essible in MAIN level."[p$2150,p1$2150]])===
    Undefined,
equ$2150="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["RADCOD turns on the energy loss due to synch\
rotron radiation at the closed-orbit in the emittance calculation. Also turns off the implicit acceleration in the tracking to com\
pensate the energy loss automatically, in the case that TRPT is ON. Accessible in MAIN level."[p$2150,p1$2150]]=
       equ$2150;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2150},out$2150=lx$2150@Typeset["RADCOD turns on the energy loss due to synchrotron radiation at the closed-orbit in the e\
mittance calculation. Also turns off the implicit acceleration in the tracking to compensate the energy loss automatically, in the\
 case that TRPT is ON. Accessible in MAIN level."[p$2150,p1$2150],Format->Help2HTML`oB$];
        System["mv -f "//out$2150//" "//equ$2150]];
      Exit[]]];
   "RADCOD turns on the energy loss due to synchrotron radiation at the closed-orbit in the emittance calculation. Also turns off \
the implicit acceleration in the tracking to compensate the energy loss automatically, in the case that TRPT is ON. Accessible in \
MAIN level."[1,Max[p0$2150,0]]//"<img  class=\"eqs\" SRC=\""//equ$2150//"\" />"//
Help2HTML`oy$["RADCOD turns on the energy loss due to synchrotron radiation at the closed-orbit in the emittance calculation. Also\
 turns off the implicit acceleration in the tracking to compensate the energy loss automatically, in the case that TRPT is ON. Acc\
essible in MAIN level."[p2$2150,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L337>RAD</A> <A HREF=#L318>FLUC</A> <A HREF=#L352>TRPT</A></PRE>
<LI>
<H3><A NAME=L339>
RADLIGHT</A></H3>
<PRE>If[{},
Help2HTML`oA$["When RADLIGHT is on, the function TrackParticles returns a list of trajectories which are used to calculate the syn\
chrotron radiation field."],
p$2153=1+p$2153[[1,2]];p1$2153=StringPosition["When RADLIGHT is on, the function TrackParticles returns a list of trajectories whi\
ch are used to calculate the synchrotron radiation field."[p$2153,-1],">::",1];
   p1$2153=If[p1$2153==={},140,-2+p$2153+p1$2153[[1,1]]];
neq=Which["When RADLIGHT is on, the function TrackParticles returns a list of trajectories which are used to calculate the synchro\
tron radiation field."[p$2153,4+p$2153]==="Text[",
    lx$2153:=Help2HTML`oa$;p$2153=5+p$2153;p1$2153-=1;p2$2153=5+p1$2153;p0$2153=-9+p$2153;
If[(pe$2153=StringPosition["When RADLIGHT is on, the function TrackParticles returns a list of trajectories which are used to calc\
ulate the synchrotron radiation field."[p$2153,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["When RADLIGHT is on, the function TrackParticles returns a list of trajectories which are used to calculate the s\
ynchrotron radiation field."[p$2153+pe$2153[[1,2]],p1$2153]]],
        p1$2153=-2+p$2153+pe$2153[[1,1]]}[[
       1]],
      0],
    1,lx$2153:=Help2HTML`o9$;p2$2153=4+p1$2153;p0$2153=-4+p$2153;0];
  If[(equ$2153=
Help2HTML`o8$["When RADLIGHT is on, the function TrackParticles returns a list of trajectories which are used to calculate the syn\
chrotron radiation field."[p$2153,p1$2153]])===
    Undefined,
equ$2153="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["When RADLIGHT is on, the function TrackParti\
cles returns a list of trajectories which are used to calculate the synchrotron radiation field."[p$2153,p1$2153]]=
       equ$2153;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2153},out$2153=lx$2153@Typeset["When RADLIGHT is on, the function TrackParticles returns a list of trajectories which are\
 used to calculate the synchrotron radiation field."[p$2153,p1$2153],Format->Help2HTML`oB$];
        System["mv -f "//out$2153//" "//equ$2153]];
      Exit[]]];
   "When RADLIGHT is on, the function TrackParticles returns a list of trajectories which are used to calculate the synchrotron ra\
diation field."[1,Max[p0$2153,0]]//"<img  class=\"eqs\" SRC=\""//equ$2153//"\" />"//
Help2HTML`oy$["When RADLIGHT is on, the function TrackParticles returns a list of trajectories which are used to calculate the syn\
chrotron radiation field."[p2$2153,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L409>TrackParticles</A> <A HREF=#L402>RadiationField</A> <A HREF=#L403>RadiationSpectrum</A></PRE>
<LI>
<H3><A NAME=L340>
RADPOL</A></H3>
<PRE>If[{},Help2HTML`oA$["If POL is on, RADPOL turns on Sokolov-Ternov effect in tracking."],
 p$2156=1+p$2156[[1,2]];p1$2156=StringPosition["If POL is on, RADPOL turns on Sokolov-Ternov effect in tracking."[p$2156,-1],">::",
    1];
   p1$2156=If[p1$2156==={},64,-2+p$2156+p1$2156[[1,1]]];
  neq=Which["If POL is on, RADPOL turns on Sokolov-Ternov effect in tracking."[p$2156,4+p$2156]==="Text[",
    lx$2156:=Help2HTML`oa$;p$2156=5+p$2156;p1$2156-=1;p2$2156=5+p1$2156;p0$2156=-9+p$2156;
     If[(pe$2156=StringPosition["If POL is on, RADPOL turns on Sokolov-Ternov effect in tracking."[p$2156,-2],";;;"])<=>{},
      {Max[0,-1+ToExpression["If POL is on, RADPOL turns on Sokolov-Ternov effect in tracking."[p$2156+pe$2156[[1,2]],p1$2156]]],
       p1$2156=-2+p$2156+pe$2156[[1,1]]}[[1]],
      0],
    1,lx$2156:=Help2HTML`o9$;p2$2156=4+p1$2156;p0$2156=-4+p$2156;0];
  If[(equ$2156=Help2HTML`o8$["If POL is on, RADPOL turns on Sokolov-Ternov effect in tracking."[p$2156,p1$2156]])===Undefined,
   equ$2156="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["If POL is on, RADPOL turns on Sokolov-Ternov effect in tracking."[p$2156,p1$2156]]=equ$2156;
      LaTeX`ob$+=neq,
     --LaTeX`ob$;With[{lx$2156},out$2156=lx$2156@Typeset["If POL is on, RADPOL turns on Sokolov-Ternov effect in tracking."[p$2156,
           p1$2156],Format->Help2HTML`oB$];
        System["mv -f "//out$2156//" "//equ$2156]];
      Exit[]]];
   "If POL is on, RADPOL turns on Sokolov-Ternov effect in tracking."[1,Max[p0$2156,0]]//"<img  class=\"eqs\" SRC=\""//equ$2156//
   "\" />"//Help2HTML`oy$["If POL is on, RADPOL turns on Sokolov-Ternov effect in tracking."[p2$2156,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L333>POL</A></PRE>
<LI>
<H3><A NAME=L341>
RADTAPER</A></H3>
<PRE>If[{},
Help2HTML`oA$["Scales all magnets except for solenoids according to the local momentum (DDP) of the closed orbit. It uses the aver\
age of DDPs at the entrance and the exit. For tracking, RADCOD and ( CAL/GO with CALC6D or EMIT(Emittance[]) ) is necessary. CAL/G\
O with CALC4D will clear the necessary information for tracking with RADTAPER.\n RADTAPER sets the momentum deviation by the local\
 momentum of the closed orbit + an amount to satisfy the path length condition given by FSHIFT. The momentum deviation at the entr\
ance, DP0, is always maintained."],
p$2159=1+p$2159[[1,2]];p1$2159=StringPosition["Scales all magnets except for solenoids according to the local momentum (DDP) of th\
e closed orbit. It uses the average of DDPs at the entrance and the exit. For tracking, RADCOD and ( CAL/GO with CALC6D or EMIT(Em\
ittance[]) ) is necessary. CAL/GO with CALC4D will clear the necessary information for tracking with RADTAPER.\n RADTAPER sets the\
 momentum deviation by the local momentum of the closed orbit + an amount to satisfy the path length condition given by FSHIFT. Th\
e momentum deviation at the entrance, DP0, is always maintained."[p$2159,-1],">::",1];
   p1$2159=If[p1$2159==={},536,-2+p$2159+p1$2159[[1,1]]];
neq=Which["Scales all magnets except for solenoids according to the local momentum (DDP) of the closed orbit. It uses the average \
of DDPs at the entrance and the exit. For tracking, RADCOD and ( CAL/GO with CALC6D or EMIT(Emittance[]) ) is necessary. CAL/GO wi\
th CALC4D will clear the necessary information for tracking with RADTAPER.\n RADTAPER sets the momentum deviation by the local mom\
entum of the closed orbit + an amount to satisfy the path length condition given by FSHIFT. The momentum deviation at the entrance\
, DP0, is always maintained."[p$2159,4+p$2159]==="Text[",
    lx$2159:=Help2HTML`oa$;p$2159=5+p$2159;p1$2159-=1;p2$2159=5+p1$2159;p0$2159=-9+p$2159;
If[(pe$2159=StringPosition["Scales all magnets except for solenoids according to the local momentum (DDP) of the closed orbit. It \
uses the average of DDPs at the entrance and the exit. For tracking, RADCOD and ( CAL/GO with CALC6D or EMIT(Emittance[]) ) is nec\
essary. CAL/GO with CALC4D will clear the necessary information for tracking with RADTAPER.\n RADTAPER sets the momentum deviation\
 by the local momentum of the closed orbit + an amount to satisfy the path length condition given by FSHIFT. The momentum deviatio\
n at the entrance, DP0, is always maintained."[p$2159,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Scales all magnets except for solenoids according to the local momentum (DDP) of the closed orbit. It uses the av\
erage of DDPs at the entrance and the exit. For tracking, RADCOD and ( CAL/GO with CALC6D or EMIT(Emittance[]) ) is necessary. CAL\
/GO with CALC4D will clear the necessary information for tracking with RADTAPER.\n RADTAPER sets the momentum deviation by the loc\
al momentum of the closed orbit + an amount to satisfy the path length condition given by FSHIFT. The momentum deviation at the en\
trance, DP0, is always maintained."[p$2159+pe$2159[[1,2]],p1$2159]]],
        p1$2159=-2+p$2159+pe$2159[[1,1]]}[[
       1]],
      0],
    1,lx$2159:=Help2HTML`o9$;p2$2159=4+p1$2159;p0$2159=-4+p$2159;0];
  If[(equ$2159=
Help2HTML`o8$["Scales all magnets except for solenoids according to the local momentum (DDP) of the closed orbit. It uses the aver\
age of DDPs at the entrance and the exit. For tracking, RADCOD and ( CAL/GO with CALC6D or EMIT(Emittance[]) ) is necessary. CAL/G\
O with CALC4D will clear the necessary information for tracking with RADTAPER.\n RADTAPER sets the momentum deviation by the local\
 momentum of the closed orbit + an amount to satisfy the path length condition given by FSHIFT. The momentum deviation at the entr\
ance, DP0, is always maintained."[p$2159,p1$2159]])===
    Undefined,
equ$2159="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Scales all magnets except for solenoids acco\
rding to the local momentum (DDP) of the closed orbit. It uses the average of DDPs at the entrance and the exit. For tracking, RAD\
COD and ( CAL/GO with CALC6D or EMIT(Emittance[]) ) is necessary. CAL/GO with CALC4D will clear the necessary information for trac\
king with RADTAPER.\n RADTAPER sets the momentum deviation by the local momentum of the closed orbit + an amount to satisfy the pa\
th length condition given by FSHIFT. The momentum deviation at the entrance, DP0, is always maintained."[p$2159,p1$2159]]=
       equ$2159;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2159},out$2159=lx$2159@Typeset["Scales all magnets except for solenoids according to the local momentum (DDP) of the clos\
ed orbit. It uses the average of DDPs at the entrance and the exit. For tracking, RADCOD and ( CAL/GO with CALC6D or EMIT(Emittanc\
e[]) ) is necessary. CAL/GO with CALC4D will clear the necessary information for tracking with RADTAPER.\n RADTAPER sets the momen\
tum deviation by the local momentum of the closed orbit + an amount to satisfy the path length condition given by FSHIFT. The mome\
ntum deviation at the entrance, DP0, is always maintained."[p$2159,p1$2159],Format->Help2HTML`oB$];
        System["mv -f "//out$2159//" "//equ$2159]];
      Exit[]]];
   "Scales all magnets except for solenoids according to the local momentum (DDP) of the closed orbit. It uses the average of DDPs\
 at the entrance and the exit. For tracking, RADCOD and ( CAL/GO with CALC6D or EMIT(Emittance[]) ) is necessary. CAL/GO with CALC\
4D will clear the necessary information for tracking with RADTAPER.\n RADTAPER sets the momentum deviation by the local momentum o\
f the closed orbit + an amount to satisfy the path length condition given by FSHIFT. The momentum deviation at the entrance, DP0, \
is always maintained."[1,Max[p0$2159,0]]//"<img  class=\"eqs\" SRC=\""//equ$2159//"\" />"//
Help2HTML`oy$["Scales all magnets except for solenoids according to the local momentum (DDP) of the closed orbit. It uses the aver\
age of DDPs at the entrance and the exit. For tracking, RADCOD and ( CAL/GO with CALC6D or EMIT(Emittance[]) ) is necessary. CAL/G\
O with CALC4D will clear the necessary information for tracking with RADTAPER.\n RADTAPER sets the momentum deviation by the local\
 momentum of the closed orbit + an amount to satisfy the path length condition given by FSHIFT. The momentum deviation at the entr\
ance, DP0, is always maintained."[p2$2159,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L338>RADCOD</A> <A HREF=#L304>CALC6D</A> <A HREF=#L303>CALC4D</A> <A HREF=#L295>EMITTANCE(EMIT)</A> <A HREF=#L32>CALCULATE(CAL)</A> <A HREF=#L469>GO</A> <A HREF=#L507>DP0</A> <A HREF=#L522>FSHIFT</A></PRE>
<LI>
<H3><A NAME=L342>
REAL</A></H3>
<PRE>If[{},Help2HTML`oA$["REAL is the antonym of IDEAL."],
 p$2162=1+p$2162[[1,2]];p1$2162=StringPosition["REAL is the antonym of IDEAL."[p$2162,-1],">::",1];
  p1$2162=If[p1$2162==={},29,-2+p$2162+p1$2162[[1,1]]];
  neq=Which["REAL is the antonym of IDEAL."[p$2162,4+p$2162]==="Text[",lx$2162:=Help2HTML`oa$;p$2162=5+p$2162;p1$2162-=1;
     p2$2162=5+p1$2162;p0$2162=-9+p$2162;
     If[(pe$2162=StringPosition["REAL is the antonym of IDEAL."[p$2162,-2],";;;"])<=>{},{Max[0,
        -1+ToExpression["REAL is the antonym of IDEAL."[p$2162+pe$2162[[1,2]],p1$2162]]],p1$2162=-2+p$2162+pe$2162[[1,1]]}[[
       1]],
      0],
    1,lx$2162:=Help2HTML`o9$;p2$2162=4+p1$2162;p0$2162=-4+p$2162;0];
  If[(equ$2162=Help2HTML`o8$["REAL is the antonym of IDEAL."[p$2162,p1$2162]])===Undefined,
   equ$2162="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["REAL is the antonym of IDEAL."[p$2162,p1$2162]]=equ$2162;LaTeX`ob$+=neq,
     --LaTeX`ob$;With[{lx$2162},out$2162=lx$2162@Typeset["REAL is the antonym of IDEAL."[p$2162,p1$2162],Format->Help2HTML`oB$];
        System["mv -f "//out$2162//" "//equ$2162]];
      Exit[]]];
   "REAL is the antonym of IDEAL."[1,Max[p0$2162,0]]//"<img  class=\"eqs\" SRC=\""//equ$2162//"\" />"//
   Help2HTML`oy$["REAL is the antonym of IDEAL."[p2$2162,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L323>IDEAL</A></PRE>
<LI>
<H3><A NAME=L343>
RELW</A></H3>
<PRE>If[{},Help2HTML`oA$["RELW is the antonym of ABSW."],
 p$2165=1+p$2165[[1,2]];p1$2165=StringPosition["RELW is the antonym of ABSW."[p$2165,-1],">::",1];
  p1$2165=If[p1$2165==={},28,-2+p$2165+p1$2165[[1,1]]];
  neq=Which["RELW is the antonym of ABSW."[p$2165,4+p$2165]==="Text[",lx$2165:=Help2HTML`oa$;p$2165=5+p$2165;p1$2165-=1;
     p2$2165=5+p1$2165;p0$2165=-9+p$2165;
     If[(pe$2165=StringPosition["RELW is the antonym of ABSW."[p$2165,-2],";;;"])<=>{},{Max[0,-1+
         ToExpression["RELW is the antonym of ABSW."[p$2165+pe$2165[[1,2]],p1$2165]]],
        p1$2165=-2+p$2165+pe$2165[[1,1]]}[[
       1]],
      0],
    1,lx$2165:=Help2HTML`o9$;p2$2165=4+p1$2165;p0$2165=-4+p$2165;0];
  If[(equ$2165=Help2HTML`o8$["RELW is the antonym of ABSW."[p$2165,p1$2165]])===Undefined,
   equ$2165="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["RELW is the antonym of ABSW."[p$2165,p1$2165]]=equ$2165;LaTeX`ob$+=neq,
     --LaTeX`ob$;With[{lx$2165},out$2165=lx$2165@Typeset["RELW is the antonym of ABSW."[p$2165,p1$2165],Format->Help2HTML`oB$];
        System["mv -f "//out$2165//" "//equ$2165]];
      Exit[]]];
   "RELW is the antonym of ABSW."[1,Max[p0$2165,0]]//"<img  class=\"eqs\" SRC=\""//equ$2165//"\" />"//
   Help2HTML`oy$["RELW is the antonym of ABSW."[p2$2165,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L301>ABSW</A></PRE>
<LI>
<H3><A NAME=L344>
RFSW</A></H3>
<PRE>If[{},
Help2HTML`oA$["RFSW turns on the acceleration by CAVI and TCAVI element in the particle-tracking and the emittance calculation. Ac\
cessible in MAIN level, but FFS always turns RFSW on at the beginning of the session."],
 p$2168=1+p$2168[[1,2]];p1$2168=StringPosition["RFSW turns on the acceleration by CAVI and TCAVI element in the particle-tracking \
and the emittance calculation. Accessible in MAIN level, but FFS always turns RFSW on at the beginning of the session."[p$2168,-1],
    ">::",1];
   p1$2168=If[p1$2168==={},200,-2+p$2168+p1$2168[[1,1]]];
neq=Which["RFSW turns on the acceleration by CAVI and TCAVI element in the particle-tracking and the emittance calculation. Access\
ible in MAIN level, but FFS always turns RFSW on at the beginning of the session."[p$2168,4+p$2168]==="Text[",
    lx$2168:=Help2HTML`oa$;p$2168=5+p$2168;p1$2168-=1;p2$2168=5+p1$2168;p0$2168=-9+p$2168;
If[(pe$2168=StringPosition["RFSW turns on the acceleration by CAVI and TCAVI element in the particle-tracking and the emittance ca\
lculation. Accessible in MAIN level, but FFS always turns RFSW on at the beginning of the session."[p$2168,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["RFSW turns on the acceleration by CAVI and TCAVI element in the particle-tracking and the emittance calculation. \
Accessible in MAIN level, but FFS always turns RFSW on at the beginning of the session."[p$2168+pe$2168[[1,2]],p1$2168]]],
        p1$2168=-2+p$2168+pe$2168[[1,1]]}[[
       1]],
      0],
    1,lx$2168:=Help2HTML`o9$;p2$2168=4+p1$2168;p0$2168=-4+p$2168;0];
  If[(equ$2168=
Help2HTML`o8$["RFSW turns on the acceleration by CAVI and TCAVI element in the particle-tracking and the emittance calculation. Ac\
cessible in MAIN level, but FFS always turns RFSW on at the beginning of the session."[p$2168,p1$2168]])===
    Undefined,
equ$2168="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["RFSW turns on the acceleration by CAVI and T\
CAVI element in the particle-tracking and the emittance calculation. Accessible in MAIN level, but FFS always turns RFSW on at the\
 beginning of the session."[p$2168,p1$2168]]=
       equ$2168;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2168},out$2168=lx$2168@Typeset["RFSW turns on the acceleration by CAVI and TCAVI element in the particle-tracking and the\
 emittance calculation. Accessible in MAIN level, but FFS always turns RFSW on at the beginning of the session."[p$2168,p1$2168],
          Format->Help2HTML`oB$];
        System["mv -f "//out$2168//" "//equ$2168]];
      Exit[]]];
   "RFSW turns on the acceleration by CAVI and TCAVI element in the particle-tracking and the emittance calculation. Accessible in\
 MAIN level, but FFS always turns RFSW on at the beginning of the session."[1,Max[p0$2168,0]]//"<img  class=\"eqs\" SRC=\""//
   equ$2168//"\" />"//
Help2HTML`oy$["RFSW turns on the acceleration by CAVI and TCAVI element in the particle-tracking and the emittance calculation. Ac\
cessible in MAIN level, but FFS always turns RFSW on at the beginning of the session."[p2$2168,-1]]
]</PRE>
<LI>
<H3><A NAME=L345>
RING</A></H3>
<PRE>If[{},Help2HTML`oA$["RING is the antonym of TRPT."],
 p$2170=1+p$2170[[1,2]];p1$2170=StringPosition["RING is the antonym of TRPT."[p$2170,-1],">::",1];
  p1$2170=If[p1$2170==={},28,-2+p$2170+p1$2170[[1,1]]];
  neq=Which["RING is the antonym of TRPT."[p$2170,4+p$2170]==="Text[",lx$2170:=Help2HTML`oa$;p$2170=5+p$2170;p1$2170-=1;
     p2$2170=5+p1$2170;p0$2170=-9+p$2170;
     If[(pe$2170=StringPosition["RING is the antonym of TRPT."[p$2170,-2],";;;"])<=>{},{Max[0,-1+
         ToExpression["RING is the antonym of TRPT."[p$2170+pe$2170[[1,2]],p1$2170]]],
        p1$2170=-2+p$2170+pe$2170[[1,1]]}[[
       1]],
      0],
    1,lx$2170:=Help2HTML`o9$;p2$2170=4+p1$2170;p0$2170=-4+p$2170;0];
  If[(equ$2170=Help2HTML`o8$["RING is the antonym of TRPT."[p$2170,p1$2170]])===Undefined,
   equ$2170="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["RING is the antonym of TRPT."[p$2170,p1$2170]]=equ$2170;LaTeX`ob$+=neq,
     --LaTeX`ob$;With[{lx$2170},out$2170=lx$2170@Typeset["RING is the antonym of TRPT."[p$2170,p1$2170],Format->Help2HTML`oB$];
        System["mv -f "//out$2170//" "//equ$2170]];
      Exit[]]];
   "RING is the antonym of TRPT."[1,Max[p0$2170,0]]//"<img  class=\"eqs\" SRC=\""//equ$2170//"\" />"//
   Help2HTML`oy$["RING is the antonym of TRPT."[p2$2170,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L352>TRPT</A></PRE>
<LI>
<H3><A NAME=L346>
SELFCOD</A></H3>
<PRE>If[{},
Help2HTML`oA$["When on with WSPAC, in tracking, the space charge force is calculated relative to the center of mass of the current\
 set of particles each time. Otherwise(default) it is calculated relative to the closed orbit given by EMIT. SELFCOD is useful whe\
n the closed orbits given by EMIT and TRACK are different."],
p$2173=1+p$2173[[1,2]];p1$2173=StringPosition["When on with WSPAC, in tracking, the space charge force is calculated relative to t\
he center of mass of the current set of particles each time. Otherwise(default) it is calculated relative to the closed orbit give\
n by EMIT. SELFCOD is useful when the closed orbits given by EMIT and TRACK are different."[p$2173,-1],">::",1];
   p1$2173=If[p1$2173==={},303,-2+p$2173+p1$2173[[1,1]]];
neq=Which["When on with WSPAC, in tracking, the space charge force is calculated relative to the center of mass of the current set\
 of particles each time. Otherwise(default) it is calculated relative to the closed orbit given by EMIT. SELFCOD is useful when th\
e closed orbits given by EMIT and TRACK are different."[p$2173,4+p$2173]==="Text[",
    lx$2173:=Help2HTML`oa$;p$2173=5+p$2173;p1$2173-=1;p2$2173=5+p1$2173;p0$2173=-9+p$2173;
If[(pe$2173=StringPosition["When on with WSPAC, in tracking, the space charge force is calculated relative to the center of mass o\
f the current set of particles each time. Otherwise(default) it is calculated relative to the closed orbit given by EMIT. SELFCOD \
is useful when the closed orbits given by EMIT and TRACK are different."[p$2173,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["When on with WSPAC, in tracking, the space charge force is calculated relative to the center of mass of the curre\
nt set of particles each time. Otherwise(default) it is calculated relative to the closed orbit given by EMIT. SELFCOD is useful w\
hen the closed orbits given by EMIT and TRACK are different."[p$2173+pe$2173[[1,2]],p1$2173]]],
        p1$2173=-2+p$2173+pe$2173[[1,1]]}[[
       1]],
      0],
    1,lx$2173:=Help2HTML`o9$;p2$2173=4+p1$2173;p0$2173=-4+p$2173;0];
  If[(equ$2173=
Help2HTML`o8$["When on with WSPAC, in tracking, the space charge force is calculated relative to the center of mass of the current\
 set of particles each time. Otherwise(default) it is calculated relative to the closed orbit given by EMIT. SELFCOD is useful whe\
n the closed orbits given by EMIT and TRACK are different."[p$2173,p1$2173]])===
    Undefined,
equ$2173="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["When on with WSPAC, in tracking, the space c\
harge force is calculated relative to the center of mass of the current set of particles each time. Otherwise(default) it is calcu\
lated relative to the closed orbit given by EMIT. SELFCOD is useful when the closed orbits given by EMIT and TRACK are different."[
         p$2173,p1$2173]]=
       equ$2173;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2173},out$2173=lx$2173@Typeset["When on with WSPAC, in tracking, the space charge force is calculated relative to the cen\
ter of mass of the current set of particles each time. Otherwise(default) it is calculated relative to the closed orbit given by E\
MIT. SELFCOD is useful when the closed orbits given by EMIT and TRACK are different."[p$2173,p1$2173],Format->Help2HTML`oB$];
        System["mv -f "//out$2173//" "//equ$2173]];
      Exit[]]];
   "When on with WSPAC, in tracking, the space charge force is calculated relative to the center of mass of the current set of par\
ticles each time. Otherwise(default) it is calculated relative to the closed orbit given by EMIT. SELFCOD is useful when the close\
d orbits given by EMIT and TRACK are different."[1,Max[p0$2173,0]]//"<img  class=\"eqs\" SRC=\""//equ$2173//"\" />"//
   Help2HTML`oy$["When on with WSPAC, in tracking, the space charge force is calculated relative to the center of mass of the curr\
ent set of particles each time. Otherwise(default) it is calculated relative to the closed orbit given by EMIT. SELFCOD is useful \
when the closed orbits given by EMIT and TRACK are different."[p2$2173,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L357>WSPAC</A></PRE>
<LI>
<H3><A NAME=L347>
SORG</A></H3>
<PRE>If[{},Help2HTML`oA$["SORG sets the origin of S (design orbit length) at the location set by ORG."],
 p$2176=1+p$2176[[1,2]];p1$2176=
   StringPosition["SORG sets the origin of S (design orbit length) at the location set by ORG."[p$2176,-1],">::",1];
  p1$2176=If[p1$2176==={},75,-2+p$2176+p1$2176[[1,1]]];
  neq=Which["SORG sets the origin of S (design orbit length) at the location set by ORG."[p$2176,4+p$2176]==="Text[",
    lx$2176:=Help2HTML`oa$;p$2176=5+p$2176;p1$2176-=1;p2$2176=5+p1$2176;p0$2176=-9+p$2176;
     If[(pe$2176=StringPosition["SORG sets the origin of S (design orbit length) at the location set by ORG."[p$2176,-2],";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression["SORG sets the origin of S (design orbit length) at the location set by ORG."[p$2176+pe$2176[[1,2]],p1$2176
           ]]],
        p1$2176=-2+p$2176+pe$2176[[1,1]]}[[
       1]],
      0],
    1,lx$2176:=Help2HTML`o9$;p2$2176=4+p1$2176;p0$2176=-4+p$2176;0];
  If[(equ$2176=Help2HTML`o8$["SORG sets the origin of S (design orbit length) at the location set by ORG."[p$2176,p1$2176]])===
    Undefined,
   equ$2176="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "SORG sets the origin of S (design orbit length) at the location set by ORG."[p$2176,p1$2176]]=
       equ$2176;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$2176},out$2176=lx$2176@Typeset["SORG sets the origin of S (design orbit length) at the location set by ORG."[p$2176,
           p1$2176],Format->Help2HTML`oB$];
        System["mv -f "//out$2176//" "//equ$2176]];
      Exit[]]];
   "SORG sets the origin of S (design orbit length) at the location set by ORG."[1,Max[p0$2176,0]]//"<img  class=\"eqs\" SRC=\""//
   equ$2176//"\" />"//Help2HTML`oy$["SORG sets the origin of S (design orbit length) at the location set by ORG."[p2$2176,-1]]
 ]
</PRE>
<PRE>See also:
 <A HREF=#L479>ORG</A></PRE>
<LI>
<H3><A NAME=L348>
SPAC</A></H3>
<PRE>If[{},
Help2HTML`oA$["When SPAC is on, tracking is done with space charge effect. The actual number of particles in the beam and the numb\
er of macro particles are given by PBUNCH and NP, respectively. This calculation assumes a cylindrical symmetry of the chamber who\
se radius is given by RADIUS of DRIFT and MULT elements. If RADIUS is positive, an aperture is also set at RADIUS to make particle\
 loss. If RADIUS is zero, no space charge calculation is done. If RADIUS is negative, no space charge effect is taken, but the ape\
rture is set at -RADIUS.\n   Do not confuse SPAC with WSPAC."],
p$2179=1+p$2179[[1,2]];p1$2179=StringPosition["When SPAC is on, tracking is done with space charge effect. The actual number of pa\
rticles in the beam and the number of macro particles are given by PBUNCH and NP, respectively. This calculation assumes a cylindr\
ical symmetry of the chamber whose radius is given by RADIUS of DRIFT and MULT elements. If RADIUS is positive, an aperture is als\
o set at RADIUS to make particle loss. If RADIUS is zero, no space charge calculation is done. If RADIUS is negative, no space cha\
rge effect is taken, but the aperture is set at -RADIUS.\n   Do not confuse SPAC with WSPAC."[p$2179,-1],">::",1];
   p1$2179=If[p1$2179==={},564,-2+p$2179+p1$2179[[1,1]]];
neq=Which["When SPAC is on, tracking is done with space charge effect. The actual number of particles in the beam and the number o\
f macro particles are given by PBUNCH and NP, respectively. This calculation assumes a cylindrical symmetry of the chamber whose r\
adius is given by RADIUS of DRIFT and MULT elements. If RADIUS is positive, an aperture is also set at RADIUS to make particle los\
s. If RADIUS is zero, no space charge calculation is done. If RADIUS is negative, no space charge effect is taken, but the apertur\
e is set at -RADIUS.\n   Do not confuse SPAC with WSPAC."[p$2179,4+p$2179]==="Text[",
    lx$2179:=Help2HTML`oa$;p$2179=5+p$2179;p1$2179-=1;p2$2179=5+p1$2179;p0$2179=-9+p$2179;
If[(pe$2179=StringPosition["When SPAC is on, tracking is done with space charge effect. The actual number of particles in the beam\
 and the number of macro particles are given by PBUNCH and NP, respectively. This calculation assumes a cylindrical symmetry of th\
e chamber whose radius is given by RADIUS of DRIFT and MULT elements. If RADIUS is positive, an aperture is also set at RADIUS to \
make particle loss. If RADIUS is zero, no space charge calculation is done. If RADIUS is negative, no space charge effect is taken\
, but the aperture is set at -RADIUS.\n   Do not confuse SPAC with WSPAC."[p$2179,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["When SPAC is on, tracking is done with space charge effect. The actual number of particles in the beam and the nu\
mber of macro particles are given by PBUNCH and NP, respectively. This calculation assumes a cylindrical symmetry of the chamber w\
hose radius is given by RADIUS of DRIFT and MULT elements. If RADIUS is positive, an aperture is also set at RADIUS to make partic\
le loss. If RADIUS is zero, no space charge calculation is done. If RADIUS is negative, no space charge effect is taken, but the a\
perture is set at -RADIUS.\n   Do not confuse SPAC with WSPAC."[p$2179+pe$2179[[1,2]],p1$2179]]],
        p1$2179=-2+p$2179+pe$2179[[1,1]]}[[
       1]],
      0],
    1,lx$2179:=Help2HTML`o9$;p2$2179=4+p1$2179;p0$2179=-4+p$2179;0];
  If[(equ$2179=
Help2HTML`o8$["When SPAC is on, tracking is done with space charge effect. The actual number of particles in the beam and the numb\
er of macro particles are given by PBUNCH and NP, respectively. This calculation assumes a cylindrical symmetry of the chamber who\
se radius is given by RADIUS of DRIFT and MULT elements. If RADIUS is positive, an aperture is also set at RADIUS to make particle\
 loss. If RADIUS is zero, no space charge calculation is done. If RADIUS is negative, no space charge effect is taken, but the ape\
rture is set at -RADIUS.\n   Do not confuse SPAC with WSPAC."[p$2179,p1$2179]])===
    Undefined,
equ$2179="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["When SPAC is on, tracking is done with space\
 charge effect. The actual number of particles in the beam and the number of macro particles are given by PBUNCH and NP, respectiv\
ely. This calculation assumes a cylindrical symmetry of the chamber whose radius is given by RADIUS of DRIFT and MULT elements. If\
 RADIUS is positive, an aperture is also set at RADIUS to make particle loss. If RADIUS is zero, no space charge calculation is do\
ne. If RADIUS is negative, no space charge effect is taken, but the aperture is set at -RADIUS.\n   Do not confuse SPAC with WSPAC\
."[p$2179,p1$2179]]=
       equ$2179;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2179},out$2179=lx$2179@Typeset["When SPAC is on, tracking is done with space charge effect. The actual number of particle\
s in the beam and the number of macro particles are given by PBUNCH and NP, respectively. This calculation assumes a cylindrical s\
ymmetry of the chamber whose radius is given by RADIUS of DRIFT and MULT elements. If RADIUS is positive, an aperture is also set \
at RADIUS to make particle loss. If RADIUS is zero, no space charge calculation is done. If RADIUS is negative, no space charge ef\
fect is taken, but the aperture is set at -RADIUS.\n   Do not confuse SPAC with WSPAC."[p$2179,p1$2179],Format->Help2HTML`oB$];
        System["mv -f "//out$2179//" "//equ$2179]];
      Exit[]]];
   "When SPAC is on, tracking is done with space charge effect. The actual number of particles in the beam and the number of macro\
 particles are given by PBUNCH and NP, respectively. This calculation assumes a cylindrical symmetry of the chamber whose radius i\
s given by RADIUS of DRIFT and MULT elements. If RADIUS is positive, an aperture is also set at RADIUS to make particle loss. If R\
ADIUS is zero, no space charge calculation is done. If RADIUS is negative, no space charge effect is taken, but the aperture is se\
t at -RADIUS.\n   Do not confuse SPAC with WSPAC."[1,Max[p0$2179,0]]//"<img  class=\"eqs\" SRC=\""//equ$2179//"\" />"//
   Help2HTML`oy$["When SPAC is on, tracking is done with space charge effect. The actual number of particles in the beam and the n\
umber of macro particles are given by PBUNCH and NP, respectively. This calculation assumes a cylindrical symmetry of the chamber \
whose radius is given by RADIUS of DRIFT and MULT elements. If RADIUS is positive, an aperture is also set at RADIUS to make parti\
cle loss. If RADIUS is zero, no space charge calculation is done. If RADIUS is negative, no space charge effect is taken, but the \
aperture is set at -RADIUS.\n   Do not confuse SPAC with WSPAC."[p2$2179,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L534>NP</A> <A HREF=#L540>PBUNCH</A> <A HREF=#L357>WSPAC</A></PRE>
<LI>
<H3><A NAME=L349>
STABLE</A></H3>
<PRE>If[{},
Help2HTML`oA$["STABLE is a flag set by the CALCULATE(CAL) or GO commands in the case of CELL. It becomes True when the closed orbi\
t is found and the optics is stable in both x and y."],
p$2182=1+p$2182[[1,2]];p1$2182=StringPosition["STABLE is a flag set by the CALCULATE(CAL) or GO commands in the case of CELL. It b\
ecomes True when the closed orbit is found and the optics is stable in both x and y."[p$2182,-1],">::",1];
   p1$2182=If[p1$2182==={},167,-2+p$2182+p1$2182[[1,1]]];
neq=Which["STABLE is a flag set by the CALCULATE(CAL) or GO commands in the case of CELL. It becomes True when the closed orbit is\
 found and the optics is stable in both x and y."[p$2182,4+p$2182]==="Text[",
    lx$2182:=Help2HTML`oa$;p$2182=5+p$2182;p1$2182-=1;p2$2182=5+p1$2182;p0$2182=-9+p$2182;
If[(pe$2182=StringPosition["STABLE is a flag set by the CALCULATE(CAL) or GO commands in the case of CELL. It becomes True when th\
e closed orbit is found and the optics is stable in both x and y."[p$2182,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["STABLE is a flag set by the CALCULATE(CAL) or GO commands in the case of CELL. It becomes True when the closed or\
bit is found and the optics is stable in both x and y."[p$2182+pe$2182[[1,2]],p1$2182]]],
        p1$2182=-2+p$2182+pe$2182[[1,1]]}[[
       1]],
      0],
    1,lx$2182:=Help2HTML`o9$;p2$2182=4+p1$2182;p0$2182=-4+p$2182;0];
  If[(equ$2182=
Help2HTML`o8$["STABLE is a flag set by the CALCULATE(CAL) or GO commands in the case of CELL. It becomes True when the closed orbi\
t is found and the optics is stable in both x and y."[p$2182,p1$2182]])===
    Undefined,
equ$2182="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["STABLE is a flag set by the CALCULATE(CAL) o\
r GO commands in the case of CELL. It becomes True when the closed orbit is found and the optics is stable in both x and y."[p$2182
         ,p1$2182]]=
       equ$2182;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2182},out$2182=lx$2182@Typeset["STABLE is a flag set by the CALCULATE(CAL) or GO commands in the case of CELL. It becomes\
 True when the closed orbit is found and the optics is stable in both x and y."[p$2182,p1$2182],Format->Help2HTML`oB$];
        System["mv -f "//out$2182//" "//equ$2182]];
      Exit[]]];
   "STABLE is a flag set by the CALCULATE(CAL) or GO commands in the case of CELL. It becomes True when the closed orbit is found \
and the optics is stable in both x and y."[1,Max[p0$2182,0]]//"<img  class=\"eqs\" SRC=\""//equ$2182//"\" />"//
Help2HTML`oy$["STABLE is a flag set by the CALCULATE(CAL) or GO commands in the case of CELL. It becomes True when the closed orbi\
t is found and the optics is stable in both x and y."[p2$2182,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L32>CALCULATE(CAL)</A> <A HREF=#L469>GO</A> <A HREF=#L326>INTRES</A> <A HREF=#L322>HALFRES</A> <A HREF=#L350>SUMRES</A> <A HREF=#L313>DIFFRES</A></PRE>
<LI>
<H3><A NAME=L350>
SUMRES</A></H3>
<PRE>If[{},
 Help2HTML`oA$[
  "In the case of CELL, if the total tune deviates across a sum resonance, it is counted as unstable. The default is SUMRES."],
 p$2185=1+p$2185[[1,2]];
  p1$2185=StringPosition[
    "In the case of CELL, if the total tune deviates across a sum resonance, it is counted as unstable. The default is SUMRES."[p
     $2185,-1],
    ">::",1];
   p1$2185=If[p1$2185==={},121,-2+p$2185+p1$2185[[1,1]]];
  neq=Which[
     "In the case of CELL, if the total tune deviates across a sum resonance, it is counted as unstable. The default is SUMRES."[
      p$2185,4+p$2185]===
     "Text[",
    lx$2185:=Help2HTML`oa$;p$2185=5+p$2185;p1$2185-=1;p2$2185=5+p1$2185;p0$2185=-9+p$2185;If[(pe$2185=StringPosition[
         "In the case of CELL, if the total tune deviates across a sum resonance, it is counted as unstable. The default is SUMRES\
."[p$2185,-2],";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression[
          "In the case of CELL, if the total tune deviates across a sum resonance, it is counted as unstable. The default is SUMRE\
S."[p$2185+pe$2185[[1,2]],p1$2185]]],
        p1$2185=-2+p$2185+pe$2185[[1,1]]}[[
       1]],
      0],
    1,lx$2185:=Help2HTML`o9$;p2$2185=4+p1$2185;p0$2185=-4+p$2185;0];
  If[(equ$2185=
     Help2HTML`o8$[
      "In the case of CELL, if the total tune deviates across a sum resonance, it is counted as unstable. The default is SUMRES."[
       p$2185,p1$2185]])===
    Undefined,
   equ$2185="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "In the case of CELL, if the total tune deviates across a sum resonance, it is counted as unstable. The default is SUMRES."
        [p$2185,p1$2185]]=
       equ$2185;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$2185},out$2185=lx$2185@Typeset[
          "In the case of CELL, if the total tune deviates across a sum resonance, it is counted as unstable. The default is SUMRE\
S."[p$2185,p1$2185],Format->Help2HTML`oB$];
        System["mv -f "//out$2185//" "//equ$2185]];
      Exit[]]];
  "In the case of CELL, if the total tune deviates across a sum resonance, it is counted as unstable. The default is SUMRES."[1,
    Max[p0$2185,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2185//"\" />"//
   Help2HTML`oy$[
    "In the case of CELL, if the total tune deviates across a sum resonance, it is counted as unstable. The default is SUMRES."[
     p2$2185,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L326>INTRES</A> <A HREF=#L322>HALFRES</A> <A HREF=#L313>DIFFRES</A> <A HREF=#L349>STABLE</A></PRE>
<LI>
<H3><A NAME=L351>
SUS</A></H3>
<PRE>If[{},Help2HTML`oA$["If OFF, SUSPEND(SUSP) and END commands have no action. The default is ON."],
 p$2188=1+p$2188[[1,2]];p1$2188=
   StringPosition["If OFF, SUSPEND(SUSP) and END commands have no action. The default is ON."[p$2188,-1],">::",1];
  p1$2188=If[p1$2188==={},73,-2+p$2188+p1$2188[[1,1]]];
  neq=Which["If OFF, SUSPEND(SUSP) and END commands have no action. The default is ON."[p$2188,4+p$2188]==="Text[",
    lx$2188:=Help2HTML`oa$;p$2188=5+p$2188;p1$2188-=1;p2$2188=5+p1$2188;p0$2188=-9+p$2188;
     If[(pe$2188=StringPosition["If OFF, SUSPEND(SUSP) and END commands have no action. The default is ON."[p$2188,-2],";;;"])<=>{}
       ,
      {Max[0,
        -1+ToExpression["If OFF, SUSPEND(SUSP) and END commands have no action. The default is ON."[p$2188+pe$2188[[1,2]],p1$2188]]
        ],p1$2188=-2+p$2188+pe$2188[[1,1]]}[[
       1]],
      0],
    1,lx$2188:=Help2HTML`o9$;p2$2188=4+p1$2188;p0$2188=-4+p$2188;0];
  If[(equ$2188=Help2HTML`o8$["If OFF, SUSPEND(SUSP) and END commands have no action. The default is ON."[p$2188,p1$2188]])===
    Undefined,
   equ$2188="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "If OFF, SUSPEND(SUSP) and END commands have no action. The default is ON."[p$2188,p1$2188]]=
       equ$2188;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$2188},out$2188=lx$2188@Typeset["If OFF, SUSPEND(SUSP) and END commands have no action. The default is ON."[p$2188,
           p1$2188],Format->Help2HTML`oB$];
        System["mv -f "//out$2188//" "//equ$2188]];
      Exit[]]];
   "If OFF, SUSPEND(SUSP) and END commands have no action. The default is ON."[1,Max[p0$2188,0]]//"<img  class=\"eqs\" SRC=\""//
   equ$2188//"\" />"//Help2HTML`oy$["If OFF, SUSPEND(SUSP) and END commands have no action. The default is ON."[p2$2188,-1]]
 ]
</PRE>
<PRE>See also:
 <A HREF=#L554>SUSPEND(SUSP)</A> <A HREF=#L296>END</A></PRE>
<LI>
<H3><A NAME=L352>
TRPT</A></H3>
<PRE>If[{},
Help2HTML`oA$["TRPT or NORING declares that the beam line is a transport line, not a part of a storage ring. The nominal momentum \
be changed in the beam line due to acceleration. The default momentum distribution becomes uniform distribution. The default is RI\
NG or NOTRPT. TRPT affects Emittance[] to ignore equilibrium calculation for a transport line."],
 p$2191=1+p$2191[[1,2]];p1$2191=StringPosition["TRPT or NORING declares that the beam line is a transport line, not a part of a st\
orage ring. The nominal momentum be changed in the beam line due to acceleration. The default momentum distribution becomes unifor\
m distribution. The default is RING or NOTRPT. TRPT affects Emittance[] to ignore equilibrium calculation for a transport line."[
     p$2191,-1],
    ">::",1];
   p1$2191=If[p1$2191==={},339,-2+p$2191+p1$2191[[1,1]]];
neq=Which["TRPT or NORING declares that the beam line is a transport line, not a part of a storage ring. The nominal momentum be c\
hanged in the beam line due to acceleration. The default momentum distribution becomes uniform distribution. The default is RING o\
r NOTRPT. TRPT affects Emittance[] to ignore equilibrium calculation for a transport line."[p$2191,4+p$2191]==="Text[",
    lx$2191:=Help2HTML`oa$;p$2191=5+p$2191;p1$2191-=1;p2$2191=5+p1$2191;p0$2191=-9+p$2191;
If[(pe$2191=StringPosition["TRPT or NORING declares that the beam line is a transport line, not a part of a storage ring. The nomi\
nal momentum be changed in the beam line due to acceleration. The default momentum distribution becomes uniform distribution. The \
default is RING or NOTRPT. TRPT affects Emittance[] to ignore equilibrium calculation for a transport line."[p$2191,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["TRPT or NORING declares that the beam line is a transport line, not a part of a storage ring. The nominal momentu\
m be changed in the beam line due to acceleration. The default momentum distribution becomes uniform distribution. The default is \
RING or NOTRPT. TRPT affects Emittance[] to ignore equilibrium calculation for a transport line."[p$2191+pe$2191[[1,2]],p1$2191]]],
       p1$2191=-2+p$2191+pe$2191[[1,1]]}[[1]],
      0],
    1,lx$2191:=Help2HTML`o9$;p2$2191=4+p1$2191;p0$2191=-4+p$2191;0];
  If[(equ$2191=
Help2HTML`o8$["TRPT or NORING declares that the beam line is a transport line, not a part of a storage ring. The nominal momentum \
be changed in the beam line due to acceleration. The default momentum distribution becomes uniform distribution. The default is RI\
NG or NOTRPT. TRPT affects Emittance[] to ignore equilibrium calculation for a transport line."[p$2191,p1$2191]])===
    Undefined,
equ$2191="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["TRPT or NORING declares that the beam line i\
s a transport line, not a part of a storage ring. The nominal momentum be changed in the beam line due to acceleration. The defaul\
t momentum distribution becomes uniform distribution. The default is RING or NOTRPT. TRPT affects Emittance[] to ignore equilibriu\
m calculation for a transport line."[p$2191,p1$2191]]=
       equ$2191;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2191},out$2191=lx$2191@Typeset["TRPT or NORING declares that the beam line is a transport line, not a part of a storage r\
ing. The nominal momentum be changed in the beam line due to acceleration. The default momentum distribution becomes uniform distr\
ibution. The default is RING or NOTRPT. TRPT affects Emittance[] to ignore equilibrium calculation for a transport line."[p$2191,
           p1$2191],Format->Help2HTML`oB$];
        System["mv -f "//out$2191//" "//equ$2191]];
      Exit[]]];
   "TRPT or NORING declares that the beam line is a transport line, not a part of a storage ring. The nominal momentum be changed \
in the beam line due to acceleration. The default momentum distribution becomes uniform distribution. The default is RING or NOTRP\
T. TRPT affects Emittance[] to ignore equilibrium calculation for a transport line."[1,Max[p0$2191,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2191//"\" />"//
Help2HTML`oy$["TRPT or NORING declares that the beam line is a transport line, not a part of a storage ring. The nominal momentum \
be changed in the beam line due to acceleration. The default momentum distribution becomes uniform distribution. The default is RI\
NG or NOTRPT. TRPT affects Emittance[] to ignore equilibrium calculation for a transport line."[p2$2191,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L56>DISPLAY(DISP)</A> <A HREF=#L345>RING</A> <A HREF=#L354>UNIFORM</A> <A HREF=#L319>GAUSS</A></PRE>
<LI>
<H3><A NAME=L353>
TWAKE</A></H3>
<PRE>If[{},Help2HTML`oA$["TWAKE turns on optics calculation with Transverse WakeFunction"],
 p$2194=1+p$2194[[1,2]];p1$2194=StringPosition["TWAKE turns on optics calculation with Transverse WakeFunction"[p$2194,-1],">::",
    1];
   p1$2194=If[p1$2194==={},62,-2+p$2194+p1$2194[[1,1]]];
  neq=Which["TWAKE turns on optics calculation with Transverse WakeFunction"[p$2194,4+p$2194]==="Text[",
    lx$2194:=Help2HTML`oa$;p$2194=5+p$2194;p1$2194-=1;p2$2194=5+p1$2194;p0$2194=-9+p$2194;
     If[(pe$2194=StringPosition["TWAKE turns on optics calculation with Transverse WakeFunction"[p$2194,-2],";;;"])<=>{},
      {Max[0,-1+ToExpression["TWAKE turns on optics calculation with Transverse WakeFunction"[p$2194+pe$2194[[1,2]],p1$2194]]],
       p1$2194=-2+p$2194+pe$2194[[1,1]]}[[1]],
      0],
    1,lx$2194:=Help2HTML`o9$;p2$2194=4+p1$2194;p0$2194=-4+p$2194;0];
  If[(equ$2194=Help2HTML`o8$["TWAKE turns on optics calculation with Transverse WakeFunction"[p$2194,p1$2194]])===Undefined,
   equ$2194="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["TWAKE turns on optics calculation with Transverse WakeFunction"[p$2194,p1$2194]]=equ$2194;
      LaTeX`ob$+=neq,
     --LaTeX`ob$;With[{lx$2194},out$2194=lx$2194@Typeset["TWAKE turns on optics calculation with Transverse WakeFunction"[p$2194,
           p1$2194],Format->Help2HTML`oB$];
        System["mv -f "//out$2194//" "//equ$2194]];
      Exit[]]];
   "TWAKE turns on optics calculation with Transverse WakeFunction"[1,Max[p0$2194,0]]//"<img  class=\"eqs\" SRC=\""//equ$2194//
   "\" />"//Help2HTML`oy$["TWAKE turns on optics calculation with Transverse WakeFunction"[p2$2194,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L413>WakeFunction</A> <A HREF=#L409>TrackParticles</A> <A HREF=#L524>InitialOrbits</A> <A HREF=#L330>LWAKE</A></PRE>
<LI>
<H3><A NAME=L354>
UNIFORM</A></H3>
<PRE>If[{},
 Help2HTML`oA$["UNIFORM is the antonym of GAUSS. It assumes the momentum distribution to be a uniform(square) within +-DP."],
 p$2197=1+p$2197[[1,2]];
  p1$2197=StringPosition[
    "UNIFORM is the antonym of GAUSS. It assumes the momentum distribution to be a uniform(square) within +-DP."[p$2197,-1],">::",
    1];
   p1$2197=If[p1$2197==={},106,-2+p$2197+p1$2197[[1,1]]];
  neq=Which["UNIFORM is the antonym of GAUSS. It assumes the momentum distribution to be a uniform(square) within +-DP."[p$2197,
      4+p$2197]===
     "Text[",
    lx$2197:=Help2HTML`oa$;p$2197=5+p$2197;p1$2197-=1;p2$2197=5+p1$2197;p0$2197=-9+p$2197;If[(pe$2197=StringPosition[
         "UNIFORM is the antonym of GAUSS. It assumes the momentum distribution to be a uniform(square) within +-DP."[p$2197,-2],
         ";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression[
          "UNIFORM is the antonym of GAUSS. It assumes the momentum distribution to be a uniform(square) within +-DP."[p$2197+
            pe$2197[[1,2]],
           p1$2197]]],
        p1$2197=-2+p$2197+pe$2197[[1,1]]}[[
       1]],
      0],
    1,lx$2197:=Help2HTML`o9$;p2$2197=4+p1$2197;p0$2197=-4+p$2197;0];
  If[(equ$2197=
     Help2HTML`o8$["UNIFORM is the antonym of GAUSS. It assumes the momentum distribution to be a uniform(square) within +-DP."[p
       $2197,p1$2197]])===
    Undefined,
   equ$2197="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "UNIFORM is the antonym of GAUSS. It assumes the momentum distribution to be a uniform(square) within +-DP."[p$2197,p1$2197
         ]]=
       equ$2197;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$2197},out$2197=lx$2197@Typeset[
          "UNIFORM is the antonym of GAUSS. It assumes the momentum distribution to be a uniform(square) within +-DP."[p$2197,
           p1$2197],Format->Help2HTML`oB$];
        System["mv -f "//out$2197//" "//equ$2197]];
      Exit[]]];
   "UNIFORM is the antonym of GAUSS. It assumes the momentum distribution to be a uniform(square) within +-DP."[1,Max[p0$2197,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2197//"\" />"//
   Help2HTML`oy$["UNIFORM is the antonym of GAUSS. It assumes the momentum distribution to be a uniform(square) within +-DP."[p2
     $2197,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L319>GAUSS</A> <A HREF=#L352>TRPT</A></PRE>
<LI>
<H3><A NAME=L355>
UNIPOL</A></H3>
<PRE>If[{},Help2HTML`oA$["UNIPOL is the antonym of BIPOL."],
 p$2200=1+p$2200[[1,2]];p1$2200=StringPosition["UNIPOL is the antonym of BIPOL."[p$2200,-1],">::",1];
  p1$2200=If[p1$2200==={},31,-2+p$2200+p1$2200[[1,1]]];
  neq=Which["UNIPOL is the antonym of BIPOL."[p$2200,4+p$2200]==="Text[",lx$2200:=Help2HTML`oa$;p$2200=5+p$2200;p1$2200-=1;
     p2$2200=5+p1$2200;p0$2200=-9+p$2200;
     If[(pe$2200=StringPosition["UNIPOL is the antonym of BIPOL."[p$2200,-2],";;;"])<=>{},{Max[0,
        -1+ToExpression["UNIPOL is the antonym of BIPOL."[p$2200+pe$2200[[1,2]],p1$2200]]],p1$2200=-2+p$2200+pe$2200[[1,1]]}[[
       1]],
      0],
    1,lx$2200:=Help2HTML`o9$;p2$2200=4+p1$2200;p0$2200=-4+p$2200;0];
  If[(equ$2200=Help2HTML`o8$["UNIPOL is the antonym of BIPOL."[p$2200,p1$2200]])===Undefined,
   equ$2200="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["UNIPOL is the antonym of BIPOL."[p$2200,p1$2200]]=equ$2200;LaTeX`ob$+=neq,
     --LaTeX`ob$;With[{lx$2200},out$2200=lx$2200@Typeset["UNIPOL is the antonym of BIPOL."[p$2200,p1$2200],Format->Help2HTML`oB$];
        System["mv -f "//out$2200//" "//equ$2200]];
      Exit[]]];
   "UNIPOL is the antonym of BIPOL."[1,Max[p0$2200,0]]//"<img  class=\"eqs\" SRC=\""//equ$2200//"\" />"//
   Help2HTML`oy$["UNIPOL is the antonym of BIPOL."[p2$2200,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L302>BIPOL</A></PRE>
<LI>
<H3><A NAME=L356>
UNSTABLE</A></H3>
<PRE>If[{},Help2HTML`oA$["UNSTABLE is the antonym of STABLE."],
 p$2203=1+p$2203[[1,2]];p1$2203=StringPosition["UNSTABLE is the antonym of STABLE."[p$2203,-1],">::",1];
  p1$2203=If[p1$2203==={},34,-2+p$2203+p1$2203[[1,1]]];
  neq=Which["UNSTABLE is the antonym of STABLE."[p$2203,4+p$2203]==="Text[",lx$2203:=Help2HTML`oa$;p$2203=5+p$2203;p1$2203-=1;
     p2$2203=5+p1$2203;p0$2203=-9+p$2203;
     If[(pe$2203=StringPosition["UNSTABLE is the antonym of STABLE."[p$2203,-2],";;;"])<=>{},{Max[0,
        -1+ToExpression["UNSTABLE is the antonym of STABLE."[p$2203+pe$2203[[1,2]],p1$2203]]],p1$2203=-2+p$2203+pe$2203[[1,1]]}[[
       1]],
      0],
    1,lx$2203:=Help2HTML`o9$;p2$2203=4+p1$2203;p0$2203=-4+p$2203;0];
  If[(equ$2203=Help2HTML`o8$["UNSTABLE is the antonym of STABLE."[p$2203,p1$2203]])===Undefined,
   equ$2203="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["UNSTABLE is the antonym of STABLE."[p$2203,p1$2203]]=equ$2203;LaTeX`ob$+=neq,
     --LaTeX`ob$;With[{lx$2203},
       out$2203=lx$2203@Typeset["UNSTABLE is the antonym of STABLE."[p$2203,p1$2203],Format->Help2HTML`oB$];
        System["mv -f "//out$2203//" "//equ$2203]];
      Exit[]]];
   "UNSTABLE is the antonym of STABLE."[1,Max[p0$2203,0]]//"<img  class=\"eqs\" SRC=\""//equ$2203//"\" />"//
   Help2HTML`oy$["UNSTABLE is the antonym of STABLE."[p2$2203,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L349>STABLE</A></PRE>
<LI>
<H3><A NAME=L357>
WSPAC</A></H3>
<PRE>If[{},
Help2HTML`oA$["When on, performs space-charge simulation in a \"strong-weak\" mode. The beam size through the beam line is to be c\
alculated by EMIT with CODPLOT. The space-charge force is calculated assuming Gaussian distribution in all dimensions, and particl\
es/bunch given by PBUNCH. WSPAC is effective in optics and emittance calculations and tracking.\n   Do not confuse WSPAC with SPAC\
."],
p$2206=1+p$2206[[1,2]];p1$2206=StringPosition["When on, performs space-charge simulation in a \"strong-weak\" mode. The beam size \
through the beam line is to be calculated by EMIT with CODPLOT. The space-charge force is calculated assuming Gaussian distributio\
n in all dimensions, and particles/bunch given by PBUNCH. WSPAC is effective in optics and emittance calculations and tracking.\n \
  Do not confuse WSPAC with SPAC."[p$2206,-1],">::",1];
   p1$2206=If[p1$2206==={},373,-2+p$2206+p1$2206[[1,1]]];
neq=Which["When on, performs space-charge simulation in a \"strong-weak\" mode. The beam size through the beam line is to be calcu\
lated by EMIT with CODPLOT. The space-charge force is calculated assuming Gaussian distribution in all dimensions, and particles/b\
unch given by PBUNCH. WSPAC is effective in optics and emittance calculations and tracking.\n   Do not confuse WSPAC with SPAC."[
      p$2206,4+p$2206]===
     "Text[",
lx$2206:=Help2HTML`oa$;p$2206=5+p$2206;p1$2206-=1;p2$2206=5+p1$2206;p0$2206=-9+p$2206;If[(pe$2206=StringPosition["When on, perform\
s space-charge simulation in a \"strong-weak\" mode. The beam size through the beam line is to be calculated by EMIT with CODPLOT.\
 The space-charge force is calculated assuming Gaussian distribution in all dimensions, and particles/bunch given by PBUNCH. WSPAC\
 is effective in optics and emittance calculations and tracking.\n   Do not confuse WSPAC with SPAC."[p$2206,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["When on, performs space-charge simulation in a \"strong-weak\" mode. The beam size through the beam line is to be\
 calculated by EMIT with CODPLOT. The space-charge force is calculated assuming Gaussian distribution in all dimensions, and parti\
cles/bunch given by PBUNCH. WSPAC is effective in optics and emittance calculations and tracking.\n   Do not confuse WSPAC with SP\
AC."[p$2206+pe$2206[[1,2]],p1$2206]]],
        p1$2206=-2+p$2206+pe$2206[[1,1]]}[[
       1]],
      0],
    1,lx$2206:=Help2HTML`o9$;p2$2206=4+p1$2206;p0$2206=-4+p$2206;0];
  If[(equ$2206=
Help2HTML`o8$["When on, performs space-charge simulation in a \"strong-weak\" mode. The beam size through the beam line is to be c\
alculated by EMIT with CODPLOT. The space-charge force is calculated assuming Gaussian distribution in all dimensions, and particl\
es/bunch given by PBUNCH. WSPAC is effective in optics and emittance calculations and tracking.\n   Do not confuse WSPAC with SPAC\
."[p$2206,p1$2206]])===
    Undefined,
equ$2206="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["When on, performs space-charge simulation in\
 a \"strong-weak\" mode. The beam size through the beam line is to be calculated by EMIT with CODPLOT. The space-charge force is c\
alculated assuming Gaussian distribution in all dimensions, and particles/bunch given by PBUNCH. WSPAC is effective in optics and \
emittance calculations and tracking.\n   Do not confuse WSPAC with SPAC."[p$2206,p1$2206]]=
       equ$2206;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2206},out$2206=lx$2206@Typeset["When on, performs space-charge simulation in a \"strong-weak\" mode. The beam size throug\
h the beam line is to be calculated by EMIT with CODPLOT. The space-charge force is calculated assuming Gaussian distribution in a\
ll dimensions, and particles/bunch given by PBUNCH. WSPAC is effective in optics and emittance calculations and tracking.\n   Do n\
ot confuse WSPAC with SPAC."[p$2206,p1$2206],Format->Help2HTML`oB$];
        System["mv -f "//out$2206//" "//equ$2206]];
      Exit[]]];
   "When on, performs space-charge simulation in a \"strong-weak\" mode. The beam size through the beam line is to be calculated b\
y EMIT with CODPLOT. The space-charge force is calculated assuming Gaussian distribution in all dimensions, and particles/bunch gi\
ven by PBUNCH. WSPAC is effective in optics and emittance calculations and tracking.\n   Do not confuse WSPAC with SPAC."[1,
    Max[p0$2206,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2206//"\" />"//
Help2HTML`oy$["When on, performs space-charge simulation in a \"strong-weak\" mode. The beam size through the beam line is to be c\
alculated by EMIT with CODPLOT. The space-charge force is calculated assuming Gaussian distribution in all dimensions, and particl\
es/bunch given by PBUNCH. WSPAC is effective in optics and emittance calculations and tracking.\n   Do not confuse WSPAC with SPAC\
."[p2$2206,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L295>EMITTANCE(EMIT)</A> <A HREF=#L540>PBUNCH</A> <A HREF=#L308>CODPLOT</A> <A HREF=#L530>MINCOUP</A> <A HREF=#L346>SELFCOD</A> <A HREF=#L348>SPAC</A> <A HREF=#L55>equilibrium-beam-envelope</A></PRE>
</UL>
<H3><A NAME=L358>
functions</A></H3>
<PRE>If[{},
Help2HTML`oA$["FFS functions:\n\nConstants:\n   Degree GoldenRatio I INF* Infinity NaN* Pi SpeedOfLight\nElementary-functions:\n  \
 ArcCos ArcCosh ArcSin ArcSinh ArcTan ArcTanh Cos Cosh Exp Log Sin Sinh\n   Sqrt Tan Tanh\nSpecial-functions:\n   BesselI BesselJ \
BesselK BesselY BesselJZero Erf Erfc Factorial \n   Gamma LogGamma LogGamma1 GammaRegularized GammaRegularizedQ*\n   GammaRegulari\
zedP* GaussianCoulomb* GaussianCoulombU*\n   GaussianCoulombFitted* LegendreP*\nNumerical-functions:\n   Abs Ceiling Floor Max Min\
 MinMax* Mod Negative NonNegative Positive\n   Round Sign FractionalPart\nMatrix-operations:\n   Det Eigensystem IdentityMatrix In\
ner LinearSolve Outer SingularValues*\n   Transpose\nRandom-number:\n   GaussRandom* Random* SeedRandom\nComplex:\n   Arg Complex \
ComplexQ Conjugate Im Re\nRational:\n   Rational FromRational ContinuedFraction FromContinuedFraction SmallPrime\n   Numerator Den\
ominator\nFourier-Transformation:\n   Fourier InverseFourier\nData-Manipulation:\n   FindRoot Fit* NIntegrate* PolynomialFit* Spli\
ne*\nCalculus:\n   D NIntegrate\nMinimization:\n   DownhillSimplex*\nList-manipulations:\n   Append Complement Delete Depth Differ\
ence* Dimensions Drop Extract Flatten\n   FlattenAt HeldPart Insert Intersection Join Length Part Partition Prepend\n   Product Ra\
nge ReplacePart Rest Reverse RotateLeft RotateRight Select \n   Sort Sum Take Table Union\nCharacter-strings:\n   FromCharacterCod\
e CharacterPosition Characters DigitQ LetterQ StringDrop\n   StringFill* StringInsert StringLength StringPosition StringTrim*\n   \
Symbol SymbolName ToCharacterCode ToLowerCase ToUpperCase ToExpression\nFunctional-Operations:\n   Apply Cases Count DeleteCases I\
dentity FixedPoint* FixedPointList*\n   Fold Function Level Map MapAll MapAt MapIndexed MapThread Nest Position\n   Replace Scan S\
canThread* SelectCases* SwitchCases* Thread\nObject-oriented programing and context:\n   Begin BeginPackage Class* End EndPackage\\
nFlow-Control:\n   Break Catch Check Continue Do For Goto If Label Return Switch Throw Which\n   While\nTests:\n   AtomQ ComplexQ \
DirectoryQ* EvenQ FileQ* MatchQ MatrixQ MemberQ NearlySameQ* \n   Negative NonNegative NumberQ OddQ Order Positive RealQ StringQ* \
VectorQ\n   BoundQ* FBoundQ*\nInput/Output:\n   Close Flush* Get OpenRead OpenWrite OpenAppend Print Put Read ReadString SeekFile*\
\n   Short* StringToStream Write WriteString\nFile System:\n   CopyDirectory CopyFile CreateDirectory DeleteDirectory DeleteFile\n\
   DirectoryName FileByteCount FileDate FileNames FileType\n   RenameDirectory RenameFile SetFileDate ToFileName\nScoping:\n   Blo\
ck Module With*\nAttributes:\n   Attributes* Clear Evaluate Head Hold Literal Protect ReleaseHold\n   SetAttributes* Unevaluated U\
nprotect\nGUI Widget:\n   Window* PanedWindow* Frame* LabelFrame* Canvas* TextLabel* TextMessage*\n   Button* CheckButton* RadioBu\
tton* Menu* OptionMenu* MenuButton*\n   Entry* SpinBox* ListBox* ScrollBar* Scale* TextEditor*\nGraphics:\n   BeamPlot* ColumnPlot\
* HistoPlot* ListContourPlot ListDensityPlot \n   ListPlot Plot Show FitPlot* GeometryPlot* OpticsPlot* TkPhotoPutBlock*\nSystem I\
nterface:\n   Directory Environment GetEnv* GetGID* GetPID* GetUID* ProcessStatus* \n   SetDirectory SetEnv* System* TemporaryName\
* MkSecureTemp* RealPath*\nMultiprocessing:\n   BiPipe* Fork* OpenShared* Shared* Wait*\nUtilities:\n   Date DateString* Definitio\
n* FromDate* ToDate ToDateString* Pause\n   MemoryCheck* Message Off On Sleep TimeUsed Timing TracePrint\n\nFunctions listed above\
 work basically in the same way as Mathematica's \nexcept those marked by *.\n\nFFS-dedicated-functions:\n   BeamMatrix CalculateO\
ptics DynamicApertureSurvey Element Emittance FFS\n   FitValue FitWeight GeoBase LINE OptimizeOptics OrbitGeo RadiationField\n   R\
adiationSpectrum SymplecticJ SetElement TrackParticles Twiss VariableRange\n   SynchroBetaEmittance TouschekLifetime WakeFunction\\
nBeam-line-functions:\n   BeamLine BeamLineName ExtractBeamLine PrintBeamLine WriteBeamLine"],
 p$2209=1+p$2209[[1,2]];p1$2209=StringPosition["FFS functions:\n\nConstants:\n   Degree GoldenRatio I INF* Infinity NaN* Pi SpeedO\
fLight\nElementary-functions:\n   ArcCos ArcCosh ArcSin ArcSinh ArcTan ArcTanh Cos Cosh Exp Log Sin Sinh\n   Sqrt Tan Tanh\nSpecia\
l-functions:\n   BesselI BesselJ BesselK BesselY BesselJZero Erf Erfc Factorial \n   Gamma LogGamma LogGamma1 GammaRegularized Gam\
maRegularizedQ*\n   GammaRegularizedP* GaussianCoulomb* GaussianCoulombU*\n   GaussianCoulombFitted* LegendreP*\nNumerical-functio\
ns:\n   Abs Ceiling Floor Max Min MinMax* Mod Negative NonNegative Positive\n   Round Sign FractionalPart\nMatrix-operations:\n   \
Det Eigensystem IdentityMatrix Inner LinearSolve Outer SingularValues*\n   Transpose\nRandom-number:\n   GaussRandom* Random* Seed\
Random\nComplex:\n   Arg Complex ComplexQ Conjugate Im Re\nRational:\n   Rational FromRational ContinuedFraction FromContinuedFrac\
tion SmallPrime\n   Numerator Denominator\nFourier-Transformation:\n   Fourier InverseFourier\nData-Manipulation:\n   FindRoot Fit\
* NIntegrate* PolynomialFit* Spline*\nCalculus:\n   D NIntegrate\nMinimization:\n   DownhillSimplex*\nList-manipulations:\n   Appe\
nd Complement Delete Depth Difference* Dimensions Drop Extract Flatten\n   FlattenAt HeldPart Insert Intersection Join Length Part\
 Partition Prepend\n   Product Range ReplacePart Rest Reverse RotateLeft RotateRight Select \n   Sort Sum Take Table Union\nCharac\
ter-strings:\n   FromCharacterCode CharacterPosition Characters DigitQ LetterQ StringDrop\n   StringFill* StringInsert StringLengt\
h StringPosition StringTrim*\n   Symbol SymbolName ToCharacterCode ToLowerCase ToUpperCase ToExpression\nFunctional-Operations:\n \
  Apply Cases Count DeleteCases Identity FixedPoint* FixedPointList*\n   Fold Function Level Map MapAll MapAt MapIndexed MapThread\
 Nest Position\n   Replace Scan ScanThread* SelectCases* SwitchCases* Thread\nObject-oriented programing and context:\n   Begin Be\
ginPackage Class* End EndPackage\nFlow-Control:\n   Break Catch Check Continue Do For Goto If Label Return Switch Throw Which\n   \
While\nTests:\n   AtomQ ComplexQ DirectoryQ* EvenQ FileQ* MatchQ MatrixQ MemberQ NearlySameQ* \n   Negative NonNegative NumberQ Od\
dQ Order Positive RealQ StringQ* VectorQ\n   BoundQ* FBoundQ*\nInput/Output:\n   Close Flush* Get OpenRead OpenWrite OpenAppend Pr\
int Put Read ReadString SeekFile*\n   Short* StringToStream Write WriteString\nFile System:\n   CopyDirectory CopyFile CreateDirec\
tory DeleteDirectory DeleteFile\n   DirectoryName FileByteCount FileDate FileNames FileType\n   RenameDirectory RenameFile SetFile\
Date ToFileName\nScoping:\n   Block Module With*\nAttributes:\n   Attributes* Clear Evaluate Head Hold Literal Protect ReleaseHold\
\n   SetAttributes* Unevaluated Unprotect\nGUI Widget:\n   Window* PanedWindow* Frame* LabelFrame* Canvas* TextLabel* TextMessage*\
\n   Button* CheckButton* RadioButton* Menu* OptionMenu* MenuButton*\n   Entry* SpinBox* ListBox* ScrollBar* Scale* TextEditor*\nG\
raphics:\n   BeamPlot* ColumnPlot* HistoPlot* ListContourPlot ListDensityPlot \n   ListPlot Plot Show FitPlot* GeometryPlot* Optic\
sPlot* TkPhotoPutBlock*\nSystem Interface:\n   Directory Environment GetEnv* GetGID* GetPID* GetUID* ProcessStatus* \n   SetDirect\
ory SetEnv* System* TemporaryName* MkSecureTemp* RealPath*\nMultiprocessing:\n   BiPipe* Fork* OpenShared* Shared* Wait*\nUtilitie\
s:\n   Date DateString* Definition* FromDate* ToDate ToDateString* Pause\n   MemoryCheck* Message Off On Sleep TimeUsed Timing Tra\
cePrint\n\nFunctions listed above work basically in the same way as Mathematica's \nexcept those marked by *.\n\nFFS-dedicated-fun\
ctions:\n   BeamMatrix CalculateOptics DynamicApertureSurvey Element Emittance FFS\n   FitValue FitWeight GeoBase LINE OptimizeOpt\
ics OrbitGeo RadiationField\n   RadiationSpectrum SymplecticJ SetElement TrackParticles Twiss VariableRange\n   SynchroBetaEmittan\
ce TouschekLifetime WakeFunction\nBeam-line-functions:\n   BeamLine BeamLineName ExtractBeamLine PrintBeamLine WriteBeamLine"[p
     $2209,-1],
    ">::",1];
   p1$2209=If[p1$2209==={},3884,-2+p$2209+p1$2209[[1,1]]];
neq=Which["FFS functions:\n\nConstants:\n   Degree GoldenRatio I INF* Infinity NaN* Pi SpeedOfLight\nElementary-functions:\n   Arc\
Cos ArcCosh ArcSin ArcSinh ArcTan ArcTanh Cos Cosh Exp Log Sin Sinh\n   Sqrt Tan Tanh\nSpecial-functions:\n   BesselI BesselJ Bess\
elK BesselY BesselJZero Erf Erfc Factorial \n   Gamma LogGamma LogGamma1 GammaRegularized GammaRegularizedQ*\n   GammaRegularizedP\
* GaussianCoulomb* GaussianCoulombU*\n   GaussianCoulombFitted* LegendreP*\nNumerical-functions:\n   Abs Ceiling Floor Max Min Min\
Max* Mod Negative NonNegative Positive\n   Round Sign FractionalPart\nMatrix-operations:\n   Det Eigensystem IdentityMatrix Inner \
LinearSolve Outer SingularValues*\n   Transpose\nRandom-number:\n   GaussRandom* Random* SeedRandom\nComplex:\n   Arg Complex Comp\
lexQ Conjugate Im Re\nRational:\n   Rational FromRational ContinuedFraction FromContinuedFraction SmallPrime\n   Numerator Denomin\
ator\nFourier-Transformation:\n   Fourier InverseFourier\nData-Manipulation:\n   FindRoot Fit* NIntegrate* PolynomialFit* Spline*\\
nCalculus:\n   D NIntegrate\nMinimization:\n   DownhillSimplex*\nList-manipulations:\n   Append Complement Delete Depth Difference\
* Dimensions Drop Extract Flatten\n   FlattenAt HeldPart Insert Intersection Join Length Part Partition Prepend\n   Product Range \
ReplacePart Rest Reverse RotateLeft RotateRight Select \n   Sort Sum Take Table Union\nCharacter-strings:\n   FromCharacterCode Ch\
aracterPosition Characters DigitQ LetterQ StringDrop\n   StringFill* StringInsert StringLength StringPosition StringTrim*\n   Symb\
ol SymbolName ToCharacterCode ToLowerCase ToUpperCase ToExpression\nFunctional-Operations:\n   Apply Cases Count DeleteCases Ident\
ity FixedPoint* FixedPointList*\n   Fold Function Level Map MapAll MapAt MapIndexed MapThread Nest Position\n   Replace Scan ScanT\
hread* SelectCases* SwitchCases* Thread\nObject-oriented programing and context:\n   Begin BeginPackage Class* End EndPackage\nFlo\
w-Control:\n   Break Catch Check Continue Do For Goto If Label Return Switch Throw Which\n   While\nTests:\n   AtomQ ComplexQ Dire\
ctoryQ* EvenQ FileQ* MatchQ MatrixQ MemberQ NearlySameQ* \n   Negative NonNegative NumberQ OddQ Order Positive RealQ StringQ* Vect\
orQ\n   BoundQ* FBoundQ*\nInput/Output:\n   Close Flush* Get OpenRead OpenWrite OpenAppend Print Put Read ReadString SeekFile*\n  \
 Short* StringToStream Write WriteString\nFile System:\n   CopyDirectory CopyFile CreateDirectory DeleteDirectory DeleteFile\n   D\
irectoryName FileByteCount FileDate FileNames FileType\n   RenameDirectory RenameFile SetFileDate ToFileName\nScoping:\n   Block M\
odule With*\nAttributes:\n   Attributes* Clear Evaluate Head Hold Literal Protect ReleaseHold\n   SetAttributes* Unevaluated Unpro\
tect\nGUI Widget:\n   Window* PanedWindow* Frame* LabelFrame* Canvas* TextLabel* TextMessage*\n   Button* CheckButton* RadioButton\
* Menu* OptionMenu* MenuButton*\n   Entry* SpinBox* ListBox* ScrollBar* Scale* TextEditor*\nGraphics:\n   BeamPlot* ColumnPlot* Hi\
stoPlot* ListContourPlot ListDensityPlot \n   ListPlot Plot Show FitPlot* GeometryPlot* OpticsPlot* TkPhotoPutBlock*\nSystem Inter\
face:\n   Directory Environment GetEnv* GetGID* GetPID* GetUID* ProcessStatus* \n   SetDirectory SetEnv* System* TemporaryName* Mk\
SecureTemp* RealPath*\nMultiprocessing:\n   BiPipe* Fork* OpenShared* Shared* Wait*\nUtilities:\n   Date DateString* Definition* F\
romDate* ToDate ToDateString* Pause\n   MemoryCheck* Message Off On Sleep TimeUsed Timing TracePrint\n\nFunctions listed above wor\
k basically in the same way as Mathematica's \nexcept those marked by *.\n\nFFS-dedicated-functions:\n   BeamMatrix CalculateOptic\
s DynamicApertureSurvey Element Emittance FFS\n   FitValue FitWeight GeoBase LINE OptimizeOptics OrbitGeo RadiationField\n   Radia\
tionSpectrum SymplecticJ SetElement TrackParticles Twiss VariableRange\n   SynchroBetaEmittance TouschekLifetime WakeFunction\nBea\
m-line-functions:\n   BeamLine BeamLineName ExtractBeamLine PrintBeamLine WriteBeamLine"[p$2209,4+p$2209]==="Text[",
    lx$2209:=Help2HTML`oa$;p$2209=5+p$2209;p1$2209-=1;p2$2209=5+p1$2209;p0$2209=-9+p$2209;
If[(pe$2209=StringPosition["FFS functions:\n\nConstants:\n   Degree GoldenRatio I INF* Infinity NaN* Pi SpeedOfLight\nElementary-f\
unctions:\n   ArcCos ArcCosh ArcSin ArcSinh ArcTan ArcTanh Cos Cosh Exp Log Sin Sinh\n   Sqrt Tan Tanh\nSpecial-functions:\n   Bes\
selI BesselJ BesselK BesselY BesselJZero Erf Erfc Factorial \n   Gamma LogGamma LogGamma1 GammaRegularized GammaRegularizedQ*\n   \
GammaRegularizedP* GaussianCoulomb* GaussianCoulombU*\n   GaussianCoulombFitted* LegendreP*\nNumerical-functions:\n   Abs Ceiling \
Floor Max Min MinMax* Mod Negative NonNegative Positive\n   Round Sign FractionalPart\nMatrix-operations:\n   Det Eigensystem Iden\
tityMatrix Inner LinearSolve Outer SingularValues*\n   Transpose\nRandom-number:\n   GaussRandom* Random* SeedRandom\nComplex:\n  \
 Arg Complex ComplexQ Conjugate Im Re\nRational:\n   Rational FromRational ContinuedFraction FromContinuedFraction SmallPrime\n   \
Numerator Denominator\nFourier-Transformation:\n   Fourier InverseFourier\nData-Manipulation:\n   FindRoot Fit* NIntegrate* Polyno\
mialFit* Spline*\nCalculus:\n   D NIntegrate\nMinimization:\n   DownhillSimplex*\nList-manipulations:\n   Append Complement Delete\
 Depth Difference* Dimensions Drop Extract Flatten\n   FlattenAt HeldPart Insert Intersection Join Length Part Partition Prepend\n\
   Product Range ReplacePart Rest Reverse RotateLeft RotateRight Select \n   Sort Sum Take Table Union\nCharacter-strings:\n   Fro\
mCharacterCode CharacterPosition Characters DigitQ LetterQ StringDrop\n   StringFill* StringInsert StringLength StringPosition Str\
ingTrim*\n   Symbol SymbolName ToCharacterCode ToLowerCase ToUpperCase ToExpression\nFunctional-Operations:\n   Apply Cases Count \
DeleteCases Identity FixedPoint* FixedPointList*\n   Fold Function Level Map MapAll MapAt MapIndexed MapThread Nest Position\n   R\
eplace Scan ScanThread* SelectCases* SwitchCases* Thread\nObject-oriented programing and context:\n   Begin BeginPackage Class* En\
d EndPackage\nFlow-Control:\n   Break Catch Check Continue Do For Goto If Label Return Switch Throw Which\n   While\nTests:\n   At\
omQ ComplexQ DirectoryQ* EvenQ FileQ* MatchQ MatrixQ MemberQ NearlySameQ* \n   Negative NonNegative NumberQ OddQ Order Positive Re\
alQ StringQ* VectorQ\n   BoundQ* FBoundQ*\nInput/Output:\n   Close Flush* Get OpenRead OpenWrite OpenAppend Print Put Read ReadStr\
ing SeekFile*\n   Short* StringToStream Write WriteString\nFile System:\n   CopyDirectory CopyFile CreateDirectory DeleteDirectory\
 DeleteFile\n   DirectoryName FileByteCount FileDate FileNames FileType\n   RenameDirectory RenameFile SetFileDate ToFileName\nSco\
ping:\n   Block Module With*\nAttributes:\n   Attributes* Clear Evaluate Head Hold Literal Protect ReleaseHold\n   SetAttributes* \
Unevaluated Unprotect\nGUI Widget:\n   Window* PanedWindow* Frame* LabelFrame* Canvas* TextLabel* TextMessage*\n   Button* CheckBu\
tton* RadioButton* Menu* OptionMenu* MenuButton*\n   Entry* SpinBox* ListBox* ScrollBar* Scale* TextEditor*\nGraphics:\n   BeamPlo\
t* ColumnPlot* HistoPlot* ListContourPlot ListDensityPlot \n   ListPlot Plot Show FitPlot* GeometryPlot* OpticsPlot* TkPhotoPutBlo\
ck*\nSystem Interface:\n   Directory Environment GetEnv* GetGID* GetPID* GetUID* ProcessStatus* \n   SetDirectory SetEnv* System* \
TemporaryName* MkSecureTemp* RealPath*\nMultiprocessing:\n   BiPipe* Fork* OpenShared* Shared* Wait*\nUtilities:\n   Date DateStri\
ng* Definition* FromDate* ToDate ToDateString* Pause\n   MemoryCheck* Message Off On Sleep TimeUsed Timing TracePrint\n\nFunctions\
 listed above work basically in the same way as Mathematica's \nexcept those marked by *.\n\nFFS-dedicated-functions:\n   BeamMatr\
ix CalculateOptics DynamicApertureSurvey Element Emittance FFS\n   FitValue FitWeight GeoBase LINE OptimizeOptics OrbitGeo Radiati\
onField\n   RadiationSpectrum SymplecticJ SetElement TrackParticles Twiss VariableRange\n   SynchroBetaEmittance TouschekLifetime \
WakeFunction\nBeam-line-functions:\n   BeamLine BeamLineName ExtractBeamLine PrintBeamLine WriteBeamLine"[p$2209,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["FFS functions:\n\nConstants:\n   Degree GoldenRatio I INF* Infinity NaN* Pi SpeedOfLight\nElementary-functions:\n\
   ArcCos ArcCosh ArcSin ArcSinh ArcTan ArcTanh Cos Cosh Exp Log Sin Sinh\n   Sqrt Tan Tanh\nSpecial-functions:\n   BesselI Bessel\
J BesselK BesselY BesselJZero Erf Erfc Factorial \n   Gamma LogGamma LogGamma1 GammaRegularized GammaRegularizedQ*\n   GammaRegula\
rizedP* GaussianCoulomb* GaussianCoulombU*\n   GaussianCoulombFitted* LegendreP*\nNumerical-functions:\n   Abs Ceiling Floor Max M\
in MinMax* Mod Negative NonNegative Positive\n   Round Sign FractionalPart\nMatrix-operations:\n   Det Eigensystem IdentityMatrix \
Inner LinearSolve Outer SingularValues*\n   Transpose\nRandom-number:\n   GaussRandom* Random* SeedRandom\nComplex:\n   Arg Comple\
x ComplexQ Conjugate Im Re\nRational:\n   Rational FromRational ContinuedFraction FromContinuedFraction SmallPrime\n   Numerator D\
enominator\nFourier-Transformation:\n   Fourier InverseFourier\nData-Manipulation:\n   FindRoot Fit* NIntegrate* PolynomialFit* Sp\
line*\nCalculus:\n   D NIntegrate\nMinimization:\n   DownhillSimplex*\nList-manipulations:\n   Append Complement Delete Depth Diff\
erence* Dimensions Drop Extract Flatten\n   FlattenAt HeldPart Insert Intersection Join Length Part Partition Prepend\n   Product \
Range ReplacePart Rest Reverse RotateLeft RotateRight Select \n   Sort Sum Take Table Union\nCharacter-strings:\n   FromCharacterC\
ode CharacterPosition Characters DigitQ LetterQ StringDrop\n   StringFill* StringInsert StringLength StringPosition StringTrim*\n \
  Symbol SymbolName ToCharacterCode ToLowerCase ToUpperCase ToExpression\nFunctional-Operations:\n   Apply Cases Count DeleteCases\
 Identity FixedPoint* FixedPointList*\n   Fold Function Level Map MapAll MapAt MapIndexed MapThread Nest Position\n   Replace Scan\
 ScanThread* SelectCases* SwitchCases* Thread\nObject-oriented programing and context:\n   Begin BeginPackage Class* End EndPackag\
e\nFlow-Control:\n   Break Catch Check Continue Do For Goto If Label Return Switch Throw Which\n   While\nTests:\n   AtomQ Complex\
Q DirectoryQ* EvenQ FileQ* MatchQ MatrixQ MemberQ NearlySameQ* \n   Negative NonNegative NumberQ OddQ Order Positive RealQ StringQ\
* VectorQ\n   BoundQ* FBoundQ*\nInput/Output:\n   Close Flush* Get OpenRead OpenWrite OpenAppend Print Put Read ReadString SeekFil\
e*\n   Short* StringToStream Write WriteString\nFile System:\n   CopyDirectory CopyFile CreateDirectory DeleteDirectory DeleteFile\
\n   DirectoryName FileByteCount FileDate FileNames FileType\n   RenameDirectory RenameFile SetFileDate ToFileName\nScoping:\n   B\
lock Module With*\nAttributes:\n   Attributes* Clear Evaluate Head Hold Literal Protect ReleaseHold\n   SetAttributes* Unevaluated\
 Unprotect\nGUI Widget:\n   Window* PanedWindow* Frame* LabelFrame* Canvas* TextLabel* TextMessage*\n   Button* CheckButton* Radio\
Button* Menu* OptionMenu* MenuButton*\n   Entry* SpinBox* ListBox* ScrollBar* Scale* TextEditor*\nGraphics:\n   BeamPlot* ColumnPl\
ot* HistoPlot* ListContourPlot ListDensityPlot \n   ListPlot Plot Show FitPlot* GeometryPlot* OpticsPlot* TkPhotoPutBlock*\nSystem\
 Interface:\n   Directory Environment GetEnv* GetGID* GetPID* GetUID* ProcessStatus* \n   SetDirectory SetEnv* System* TemporaryNa\
me* MkSecureTemp* RealPath*\nMultiprocessing:\n   BiPipe* Fork* OpenShared* Shared* Wait*\nUtilities:\n   Date DateString* Definit\
ion* FromDate* ToDate ToDateString* Pause\n   MemoryCheck* Message Off On Sleep TimeUsed Timing TracePrint\n\nFunctions listed abo\
ve work basically in the same way as Mathematica's \nexcept those marked by *.\n\nFFS-dedicated-functions:\n   BeamMatrix Calculat\
eOptics DynamicApertureSurvey Element Emittance FFS\n   FitValue FitWeight GeoBase LINE OptimizeOptics OrbitGeo RadiationField\n  \
 RadiationSpectrum SymplecticJ SetElement TrackParticles Twiss VariableRange\n   SynchroBetaEmittance TouschekLifetime WakeFunctio\
n\nBeam-line-functions:\n   BeamLine BeamLineName ExtractBeamLine PrintBeamLine WriteBeamLine"[p$2209+pe$2209[[1,2]],p1$2209]]],
        p1$2209=-2+p$2209+pe$2209[[1,1]]}[[
       1]],
      0],
    1,lx$2209:=Help2HTML`o9$;p2$2209=4+p1$2209;p0$2209=-4+p$2209;0];
  If[(equ$2209=
Help2HTML`o8$["FFS functions:\n\nConstants:\n   Degree GoldenRatio I INF* Infinity NaN* Pi SpeedOfLight\nElementary-functions:\n  \
 ArcCos ArcCosh ArcSin ArcSinh ArcTan ArcTanh Cos Cosh Exp Log Sin Sinh\n   Sqrt Tan Tanh\nSpecial-functions:\n   BesselI BesselJ \
BesselK BesselY BesselJZero Erf Erfc Factorial \n   Gamma LogGamma LogGamma1 GammaRegularized GammaRegularizedQ*\n   GammaRegulari\
zedP* GaussianCoulomb* GaussianCoulombU*\n   GaussianCoulombFitted* LegendreP*\nNumerical-functions:\n   Abs Ceiling Floor Max Min\
 MinMax* Mod Negative NonNegative Positive\n   Round Sign FractionalPart\nMatrix-operations:\n   Det Eigensystem IdentityMatrix In\
ner LinearSolve Outer SingularValues*\n   Transpose\nRandom-number:\n   GaussRandom* Random* SeedRandom\nComplex:\n   Arg Complex \
ComplexQ Conjugate Im Re\nRational:\n   Rational FromRational ContinuedFraction FromContinuedFraction SmallPrime\n   Numerator Den\
ominator\nFourier-Transformation:\n   Fourier InverseFourier\nData-Manipulation:\n   FindRoot Fit* NIntegrate* PolynomialFit* Spli\
ne*\nCalculus:\n   D NIntegrate\nMinimization:\n   DownhillSimplex*\nList-manipulations:\n   Append Complement Delete Depth Differ\
ence* Dimensions Drop Extract Flatten\n   FlattenAt HeldPart Insert Intersection Join Length Part Partition Prepend\n   Product Ra\
nge ReplacePart Rest Reverse RotateLeft RotateRight Select \n   Sort Sum Take Table Union\nCharacter-strings:\n   FromCharacterCod\
e CharacterPosition Characters DigitQ LetterQ StringDrop\n   StringFill* StringInsert StringLength StringPosition StringTrim*\n   \
Symbol SymbolName ToCharacterCode ToLowerCase ToUpperCase ToExpression\nFunctional-Operations:\n   Apply Cases Count DeleteCases I\
dentity FixedPoint* FixedPointList*\n   Fold Function Level Map MapAll MapAt MapIndexed MapThread Nest Position\n   Replace Scan S\
canThread* SelectCases* SwitchCases* Thread\nObject-oriented programing and context:\n   Begin BeginPackage Class* End EndPackage\\
nFlow-Control:\n   Break Catch Check Continue Do For Goto If Label Return Switch Throw Which\n   While\nTests:\n   AtomQ ComplexQ \
DirectoryQ* EvenQ FileQ* MatchQ MatrixQ MemberQ NearlySameQ* \n   Negative NonNegative NumberQ OddQ Order Positive RealQ StringQ* \
VectorQ\n   BoundQ* FBoundQ*\nInput/Output:\n   Close Flush* Get OpenRead OpenWrite OpenAppend Print Put Read ReadString SeekFile*\
\n   Short* StringToStream Write WriteString\nFile System:\n   CopyDirectory CopyFile CreateDirectory DeleteDirectory DeleteFile\n\
   DirectoryName FileByteCount FileDate FileNames FileType\n   RenameDirectory RenameFile SetFileDate ToFileName\nScoping:\n   Blo\
ck Module With*\nAttributes:\n   Attributes* Clear Evaluate Head Hold Literal Protect ReleaseHold\n   SetAttributes* Unevaluated U\
nprotect\nGUI Widget:\n   Window* PanedWindow* Frame* LabelFrame* Canvas* TextLabel* TextMessage*\n   Button* CheckButton* RadioBu\
tton* Menu* OptionMenu* MenuButton*\n   Entry* SpinBox* ListBox* ScrollBar* Scale* TextEditor*\nGraphics:\n   BeamPlot* ColumnPlot\
* HistoPlot* ListContourPlot ListDensityPlot \n   ListPlot Plot Show FitPlot* GeometryPlot* OpticsPlot* TkPhotoPutBlock*\nSystem I\
nterface:\n   Directory Environment GetEnv* GetGID* GetPID* GetUID* ProcessStatus* \n   SetDirectory SetEnv* System* TemporaryName\
* MkSecureTemp* RealPath*\nMultiprocessing:\n   BiPipe* Fork* OpenShared* Shared* Wait*\nUtilities:\n   Date DateString* Definitio\
n* FromDate* ToDate ToDateString* Pause\n   MemoryCheck* Message Off On Sleep TimeUsed Timing TracePrint\n\nFunctions listed above\
 work basically in the same way as Mathematica's \nexcept those marked by *.\n\nFFS-dedicated-functions:\n   BeamMatrix CalculateO\
ptics DynamicApertureSurvey Element Emittance FFS\n   FitValue FitWeight GeoBase LINE OptimizeOptics OrbitGeo RadiationField\n   R\
adiationSpectrum SymplecticJ SetElement TrackParticles Twiss VariableRange\n   SynchroBetaEmittance TouschekLifetime WakeFunction\\
nBeam-line-functions:\n   BeamLine BeamLineName ExtractBeamLine PrintBeamLine WriteBeamLine"[p$2209,p1$2209]])===
    Undefined,
equ$2209="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["FFS functions:\n\nConstants:\n   Degree Gold\
enRatio I INF* Infinity NaN* Pi SpeedOfLight\nElementary-functions:\n   ArcCos ArcCosh ArcSin ArcSinh ArcTan ArcTanh Cos Cosh Exp \
Log Sin Sinh\n   Sqrt Tan Tanh\nSpecial-functions:\n   BesselI BesselJ BesselK BesselY BesselJZero Erf Erfc Factorial \n   Gamma L\
ogGamma LogGamma1 GammaRegularized GammaRegularizedQ*\n   GammaRegularizedP* GaussianCoulomb* GaussianCoulombU*\n   GaussianCoulom\
bFitted* LegendreP*\nNumerical-functions:\n   Abs Ceiling Floor Max Min MinMax* Mod Negative NonNegative Positive\n   Round Sign F\
ractionalPart\nMatrix-operations:\n   Det Eigensystem IdentityMatrix Inner LinearSolve Outer SingularValues*\n   Transpose\nRandom\
-number:\n   GaussRandom* Random* SeedRandom\nComplex:\n   Arg Complex ComplexQ Conjugate Im Re\nRational:\n   Rational FromRation\
al ContinuedFraction FromContinuedFraction SmallPrime\n   Numerator Denominator\nFourier-Transformation:\n   Fourier InverseFourie\
r\nData-Manipulation:\n   FindRoot Fit* NIntegrate* PolynomialFit* Spline*\nCalculus:\n   D NIntegrate\nMinimization:\n   Downhill\
Simplex*\nList-manipulations:\n   Append Complement Delete Depth Difference* Dimensions Drop Extract Flatten\n   FlattenAt HeldPar\
t Insert Intersection Join Length Part Partition Prepend\n   Product Range ReplacePart Rest Reverse RotateLeft RotateRight Select \
\n   Sort Sum Take Table Union\nCharacter-strings:\n   FromCharacterCode CharacterPosition Characters DigitQ LetterQ StringDrop\n \
  StringFill* StringInsert StringLength StringPosition StringTrim*\n   Symbol SymbolName ToCharacterCode ToLowerCase ToUpperCase T\
oExpression\nFunctional-Operations:\n   Apply Cases Count DeleteCases Identity FixedPoint* FixedPointList*\n   Fold Function Level\
 Map MapAll MapAt MapIndexed MapThread Nest Position\n   Replace Scan ScanThread* SelectCases* SwitchCases* Thread\nObject-oriente\
d programing and context:\n   Begin BeginPackage Class* End EndPackage\nFlow-Control:\n   Break Catch Check Continue Do For Goto I\
f Label Return Switch Throw Which\n   While\nTests:\n   AtomQ ComplexQ DirectoryQ* EvenQ FileQ* MatchQ MatrixQ MemberQ NearlySameQ\
* \n   Negative NonNegative NumberQ OddQ Order Positive RealQ StringQ* VectorQ\n   BoundQ* FBoundQ*\nInput/Output:\n   Close Flush\
* Get OpenRead OpenWrite OpenAppend Print Put Read ReadString SeekFile*\n   Short* StringToStream Write WriteString\nFile System:\\
n   CopyDirectory CopyFile CreateDirectory DeleteDirectory DeleteFile\n   DirectoryName FileByteCount FileDate FileNames FileType\\
n   RenameDirectory RenameFile SetFileDate ToFileName\nScoping:\n   Block Module With*\nAttributes:\n   Attributes* Clear Evaluate\
 Head Hold Literal Protect ReleaseHold\n   SetAttributes* Unevaluated Unprotect\nGUI Widget:\n   Window* PanedWindow* Frame* Label\
Frame* Canvas* TextLabel* TextMessage*\n   Button* CheckButton* RadioButton* Menu* OptionMenu* MenuButton*\n   Entry* SpinBox* Lis\
tBox* ScrollBar* Scale* TextEditor*\nGraphics:\n   BeamPlot* ColumnPlot* HistoPlot* ListContourPlot ListDensityPlot \n   ListPlot \
Plot Show FitPlot* GeometryPlot* OpticsPlot* TkPhotoPutBlock*\nSystem Interface:\n   Directory Environment GetEnv* GetGID* GetPID*\
 GetUID* ProcessStatus* \n   SetDirectory SetEnv* System* TemporaryName* MkSecureTemp* RealPath*\nMultiprocessing:\n   BiPipe* For\
k* OpenShared* Shared* Wait*\nUtilities:\n   Date DateString* Definition* FromDate* ToDate ToDateString* Pause\n   MemoryCheck* Me\
ssage Off On Sleep TimeUsed Timing TracePrint\n\nFunctions listed above work basically in the same way as Mathematica's \nexcept t\
hose marked by *.\n\nFFS-dedicated-functions:\n   BeamMatrix CalculateOptics DynamicApertureSurvey Element Emittance FFS\n   FitVa\
lue FitWeight GeoBase LINE OptimizeOptics OrbitGeo RadiationField\n   RadiationSpectrum SymplecticJ SetElement TrackParticles Twis\
s VariableRange\n   SynchroBetaEmittance TouschekLifetime WakeFunction\nBeam-line-functions:\n   BeamLine BeamLineName ExtractBeam\
Line PrintBeamLine WriteBeamLine"[p$2209,p1$2209]]=
       equ$2209;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2209},out$2209=lx$2209@Typeset["FFS functions:\n\nConstants:\n   Degree GoldenRatio I INF* Infinity NaN* Pi SpeedOfLight\\
nElementary-functions:\n   ArcCos ArcCosh ArcSin ArcSinh ArcTan ArcTanh Cos Cosh Exp Log Sin Sinh\n   Sqrt Tan Tanh\nSpecial-funct\
ions:\n   BesselI BesselJ BesselK BesselY BesselJZero Erf Erfc Factorial \n   Gamma LogGamma LogGamma1 GammaRegularized GammaRegul\
arizedQ*\n   GammaRegularizedP* GaussianCoulomb* GaussianCoulombU*\n   GaussianCoulombFitted* LegendreP*\nNumerical-functions:\n  \
 Abs Ceiling Floor Max Min MinMax* Mod Negative NonNegative Positive\n   Round Sign FractionalPart\nMatrix-operations:\n   Det Eig\
ensystem IdentityMatrix Inner LinearSolve Outer SingularValues*\n   Transpose\nRandom-number:\n   GaussRandom* Random* SeedRandom\\
nComplex:\n   Arg Complex ComplexQ Conjugate Im Re\nRational:\n   Rational FromRational ContinuedFraction FromContinuedFraction Sm\
allPrime\n   Numerator Denominator\nFourier-Transformation:\n   Fourier InverseFourier\nData-Manipulation:\n   FindRoot Fit* NInte\
grate* PolynomialFit* Spline*\nCalculus:\n   D NIntegrate\nMinimization:\n   DownhillSimplex*\nList-manipulations:\n   Append Comp\
lement Delete Depth Difference* Dimensions Drop Extract Flatten\n   FlattenAt HeldPart Insert Intersection Join Length Part Partit\
ion Prepend\n   Product Range ReplacePart Rest Reverse RotateLeft RotateRight Select \n   Sort Sum Take Table Union\nCharacter-str\
ings:\n   FromCharacterCode CharacterPosition Characters DigitQ LetterQ StringDrop\n   StringFill* StringInsert StringLength Strin\
gPosition StringTrim*\n   Symbol SymbolName ToCharacterCode ToLowerCase ToUpperCase ToExpression\nFunctional-Operations:\n   Apply\
 Cases Count DeleteCases Identity FixedPoint* FixedPointList*\n   Fold Function Level Map MapAll MapAt MapIndexed MapThread Nest P\
osition\n   Replace Scan ScanThread* SelectCases* SwitchCases* Thread\nObject-oriented programing and context:\n   Begin BeginPack\
age Class* End EndPackage\nFlow-Control:\n   Break Catch Check Continue Do For Goto If Label Return Switch Throw Which\n   While\n\
Tests:\n   AtomQ ComplexQ DirectoryQ* EvenQ FileQ* MatchQ MatrixQ MemberQ NearlySameQ* \n   Negative NonNegative NumberQ OddQ Orde\
r Positive RealQ StringQ* VectorQ\n   BoundQ* FBoundQ*\nInput/Output:\n   Close Flush* Get OpenRead OpenWrite OpenAppend Print Put\
 Read ReadString SeekFile*\n   Short* StringToStream Write WriteString\nFile System:\n   CopyDirectory CopyFile CreateDirectory De\
leteDirectory DeleteFile\n   DirectoryName FileByteCount FileDate FileNames FileType\n   RenameDirectory RenameFile SetFileDate To\
FileName\nScoping:\n   Block Module With*\nAttributes:\n   Attributes* Clear Evaluate Head Hold Literal Protect ReleaseHold\n   Se\
tAttributes* Unevaluated Unprotect\nGUI Widget:\n   Window* PanedWindow* Frame* LabelFrame* Canvas* TextLabel* TextMessage*\n   Bu\
tton* CheckButton* RadioButton* Menu* OptionMenu* MenuButton*\n   Entry* SpinBox* ListBox* ScrollBar* Scale* TextEditor*\nGraphics\
:\n   BeamPlot* ColumnPlot* HistoPlot* ListContourPlot ListDensityPlot \n   ListPlot Plot Show FitPlot* GeometryPlot* OpticsPlot* \
TkPhotoPutBlock*\nSystem Interface:\n   Directory Environment GetEnv* GetGID* GetPID* GetUID* ProcessStatus* \n   SetDirectory Set\
Env* System* TemporaryName* MkSecureTemp* RealPath*\nMultiprocessing:\n   BiPipe* Fork* OpenShared* Shared* Wait*\nUtilities:\n   \
Date DateString* Definition* FromDate* ToDate ToDateString* Pause\n   MemoryCheck* Message Off On Sleep TimeUsed Timing TracePrint\
\n\nFunctions listed above work basically in the same way as Mathematica's \nexcept those marked by *.\n\nFFS-dedicated-functions:\
\n   BeamMatrix CalculateOptics DynamicApertureSurvey Element Emittance FFS\n   FitValue FitWeight GeoBase LINE OptimizeOptics Orb\
itGeo RadiationField\n   RadiationSpectrum SymplecticJ SetElement TrackParticles Twiss VariableRange\n   SynchroBetaEmittance Tous\
chekLifetime WakeFunction\nBeam-line-functions:\n   BeamLine BeamLineName ExtractBeamLine PrintBeamLine WriteBeamLine"[p$2209,
           p1$2209],Format->Help2HTML`oB$];
        System["mv -f "//out$2209//" "//equ$2209]];
      Exit[]]];
   "FFS functions:\n\nConstants:\n   Degree GoldenRatio I INF* Infinity NaN* Pi SpeedOfLight\nElementary-functions:\n   ArcCos Arc\
Cosh ArcSin ArcSinh ArcTan ArcTanh Cos Cosh Exp Log Sin Sinh\n   Sqrt Tan Tanh\nSpecial-functions:\n   BesselI BesselJ BesselK Bes\
selY BesselJZero Erf Erfc Factorial \n   Gamma LogGamma LogGamma1 GammaRegularized GammaRegularizedQ*\n   GammaRegularizedP* Gauss\
ianCoulomb* GaussianCoulombU*\n   GaussianCoulombFitted* LegendreP*\nNumerical-functions:\n   Abs Ceiling Floor Max Min MinMax* Mo\
d Negative NonNegative Positive\n   Round Sign FractionalPart\nMatrix-operations:\n   Det Eigensystem IdentityMatrix Inner LinearS\
olve Outer SingularValues*\n   Transpose\nRandom-number:\n   GaussRandom* Random* SeedRandom\nComplex:\n   Arg Complex ComplexQ Co\
njugate Im Re\nRational:\n   Rational FromRational ContinuedFraction FromContinuedFraction SmallPrime\n   Numerator Denominator\nF\
ourier-Transformation:\n   Fourier InverseFourier\nData-Manipulation:\n   FindRoot Fit* NIntegrate* PolynomialFit* Spline*\nCalcul\
us:\n   D NIntegrate\nMinimization:\n   DownhillSimplex*\nList-manipulations:\n   Append Complement Delete Depth Difference* Dimen\
sions Drop Extract Flatten\n   FlattenAt HeldPart Insert Intersection Join Length Part Partition Prepend\n   Product Range Replace\
Part Rest Reverse RotateLeft RotateRight Select \n   Sort Sum Take Table Union\nCharacter-strings:\n   FromCharacterCode Character\
Position Characters DigitQ LetterQ StringDrop\n   StringFill* StringInsert StringLength StringPosition StringTrim*\n   Symbol Symb\
olName ToCharacterCode ToLowerCase ToUpperCase ToExpression\nFunctional-Operations:\n   Apply Cases Count DeleteCases Identity Fix\
edPoint* FixedPointList*\n   Fold Function Level Map MapAll MapAt MapIndexed MapThread Nest Position\n   Replace Scan ScanThread* \
SelectCases* SwitchCases* Thread\nObject-oriented programing and context:\n   Begin BeginPackage Class* End EndPackage\nFlow-Contr\
ol:\n   Break Catch Check Continue Do For Goto If Label Return Switch Throw Which\n   While\nTests:\n   AtomQ ComplexQ DirectoryQ*\
 EvenQ FileQ* MatchQ MatrixQ MemberQ NearlySameQ* \n   Negative NonNegative NumberQ OddQ Order Positive RealQ StringQ* VectorQ\n  \
 BoundQ* FBoundQ*\nInput/Output:\n   Close Flush* Get OpenRead OpenWrite OpenAppend Print Put Read ReadString SeekFile*\n   Short*\
 StringToStream Write WriteString\nFile System:\n   CopyDirectory CopyFile CreateDirectory DeleteDirectory DeleteFile\n   Director\
yName FileByteCount FileDate FileNames FileType\n   RenameDirectory RenameFile SetFileDate ToFileName\nScoping:\n   Block Module W\
ith*\nAttributes:\n   Attributes* Clear Evaluate Head Hold Literal Protect ReleaseHold\n   SetAttributes* Unevaluated Unprotect\nG\
UI Widget:\n   Window* PanedWindow* Frame* LabelFrame* Canvas* TextLabel* TextMessage*\n   Button* CheckButton* RadioButton* Menu*\
 OptionMenu* MenuButton*\n   Entry* SpinBox* ListBox* ScrollBar* Scale* TextEditor*\nGraphics:\n   BeamPlot* ColumnPlot* HistoPlot\
* ListContourPlot ListDensityPlot \n   ListPlot Plot Show FitPlot* GeometryPlot* OpticsPlot* TkPhotoPutBlock*\nSystem Interface:\n\
   Directory Environment GetEnv* GetGID* GetPID* GetUID* ProcessStatus* \n   SetDirectory SetEnv* System* TemporaryName* MkSecureT\
emp* RealPath*\nMultiprocessing:\n   BiPipe* Fork* OpenShared* Shared* Wait*\nUtilities:\n   Date DateString* Definition* FromDate\
* ToDate ToDateString* Pause\n   MemoryCheck* Message Off On Sleep TimeUsed Timing TracePrint\n\nFunctions listed above work basic\
ally in the same way as Mathematica's \nexcept those marked by *.\n\nFFS-dedicated-functions:\n   BeamMatrix CalculateOptics Dynam\
icApertureSurvey Element Emittance FFS\n   FitValue FitWeight GeoBase LINE OptimizeOptics OrbitGeo RadiationField\n   RadiationSpe\
ctrum SymplecticJ SetElement TrackParticles Twiss VariableRange\n   SynchroBetaEmittance TouschekLifetime WakeFunction\nBeam-line-\
functions:\n   BeamLine BeamLineName ExtractBeamLine PrintBeamLine WriteBeamLine"[1,Max[p0$2209,0]]//"<img  class=\"eqs\" SRC=\""//
   equ$2209//"\" />"//
Help2HTML`oy$["FFS functions:\n\nConstants:\n   Degree GoldenRatio I INF* Infinity NaN* Pi SpeedOfLight\nElementary-functions:\n  \
 ArcCos ArcCosh ArcSin ArcSinh ArcTan ArcTanh Cos Cosh Exp Log Sin Sinh\n   Sqrt Tan Tanh\nSpecial-functions:\n   BesselI BesselJ \
BesselK BesselY BesselJZero Erf Erfc Factorial \n   Gamma LogGamma LogGamma1 GammaRegularized GammaRegularizedQ*\n   GammaRegulari\
zedP* GaussianCoulomb* GaussianCoulombU*\n   GaussianCoulombFitted* LegendreP*\nNumerical-functions:\n   Abs Ceiling Floor Max Min\
 MinMax* Mod Negative NonNegative Positive\n   Round Sign FractionalPart\nMatrix-operations:\n   Det Eigensystem IdentityMatrix In\
ner LinearSolve Outer SingularValues*\n   Transpose\nRandom-number:\n   GaussRandom* Random* SeedRandom\nComplex:\n   Arg Complex \
ComplexQ Conjugate Im Re\nRational:\n   Rational FromRational ContinuedFraction FromContinuedFraction SmallPrime\n   Numerator Den\
ominator\nFourier-Transformation:\n   Fourier InverseFourier\nData-Manipulation:\n   FindRoot Fit* NIntegrate* PolynomialFit* Spli\
ne*\nCalculus:\n   D NIntegrate\nMinimization:\n   DownhillSimplex*\nList-manipulations:\n   Append Complement Delete Depth Differ\
ence* Dimensions Drop Extract Flatten\n   FlattenAt HeldPart Insert Intersection Join Length Part Partition Prepend\n   Product Ra\
nge ReplacePart Rest Reverse RotateLeft RotateRight Select \n   Sort Sum Take Table Union\nCharacter-strings:\n   FromCharacterCod\
e CharacterPosition Characters DigitQ LetterQ StringDrop\n   StringFill* StringInsert StringLength StringPosition StringTrim*\n   \
Symbol SymbolName ToCharacterCode ToLowerCase ToUpperCase ToExpression\nFunctional-Operations:\n   Apply Cases Count DeleteCases I\
dentity FixedPoint* FixedPointList*\n   Fold Function Level Map MapAll MapAt MapIndexed MapThread Nest Position\n   Replace Scan S\
canThread* SelectCases* SwitchCases* Thread\nObject-oriented programing and context:\n   Begin BeginPackage Class* End EndPackage\\
nFlow-Control:\n   Break Catch Check Continue Do For Goto If Label Return Switch Throw Which\n   While\nTests:\n   AtomQ ComplexQ \
DirectoryQ* EvenQ FileQ* MatchQ MatrixQ MemberQ NearlySameQ* \n   Negative NonNegative NumberQ OddQ Order Positive RealQ StringQ* \
VectorQ\n   BoundQ* FBoundQ*\nInput/Output:\n   Close Flush* Get OpenRead OpenWrite OpenAppend Print Put Read ReadString SeekFile*\
\n   Short* StringToStream Write WriteString\nFile System:\n   CopyDirectory CopyFile CreateDirectory DeleteDirectory DeleteFile\n\
   DirectoryName FileByteCount FileDate FileNames FileType\n   RenameDirectory RenameFile SetFileDate ToFileName\nScoping:\n   Blo\
ck Module With*\nAttributes:\n   Attributes* Clear Evaluate Head Hold Literal Protect ReleaseHold\n   SetAttributes* Unevaluated U\
nprotect\nGUI Widget:\n   Window* PanedWindow* Frame* LabelFrame* Canvas* TextLabel* TextMessage*\n   Button* CheckButton* RadioBu\
tton* Menu* OptionMenu* MenuButton*\n   Entry* SpinBox* ListBox* ScrollBar* Scale* TextEditor*\nGraphics:\n   BeamPlot* ColumnPlot\
* HistoPlot* ListContourPlot ListDensityPlot \n   ListPlot Plot Show FitPlot* GeometryPlot* OpticsPlot* TkPhotoPutBlock*\nSystem I\
nterface:\n   Directory Environment GetEnv* GetGID* GetPID* GetUID* ProcessStatus* \n   SetDirectory SetEnv* System* TemporaryName\
* MkSecureTemp* RealPath*\nMultiprocessing:\n   BiPipe* Fork* OpenShared* Shared* Wait*\nUtilities:\n   Date DateString* Definitio\
n* FromDate* ToDate ToDateString* Pause\n   MemoryCheck* Message Off On Sleep TimeUsed Timing TracePrint\n\nFunctions listed above\
 work basically in the same way as Mathematica's \nexcept those marked by *.\n\nFFS-dedicated-functions:\n   BeamMatrix CalculateO\
ptics DynamicApertureSurvey Element Emittance FFS\n   FitValue FitWeight GeoBase LINE OptimizeOptics OrbitGeo RadiationField\n   R\
adiationSpectrum SymplecticJ SetElement TrackParticles Twiss VariableRange\n   SynchroBetaEmittance TouschekLifetime WakeFunction\\
nBeam-line-functions:\n   BeamLine BeamLineName ExtractBeamLine PrintBeamLine WriteBeamLine"[p2$2209,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L246>expression</A> <A HREF=#L31>constants</A> <A HREF=#L483>physical-constants</A> <A HREF=#L6>beam-line-functions</A></PRE>
<UL>
<LI>
<H3><A NAME=L359>
Data-Manipulation</A></H3>
<PRE>
</PRE>
<UL>
<LI>
<H3><A NAME=L360>
Fit</A></H3>
<PRE>If[{},
Help2HTML`oA$["Usage: Fit[data, expr, var, \n         {par1, ini1, [{min1, max1}] }, .. ,{parn, inin, [{minn, maxn}]},\n         [\
options..] ]\n\nperforms a nonlinear fitting of data with an expression expr.\n\ndata: list of {xi,yi}, {xi,yi,dyi}, or {xi,yi,dxi\
,dyi}, where dxi and dyi\n      are the standard deviation of the i-th point.\nexpr: an expression containing var as the x-variabl\
e, and \n      parameters par1,..,parn explicitly. Use Evaluate[fun] if an implicit\n      expression is necessary.\nvar:  a symbo\
l to express the x-axis variable.\npar:  parameter symbol to be varied in the fitting.\nini:  initial value of the parameter. It m\
ust be specified.\n(min, max}: optional range of parameter.\n\nFit returns the result as a list:\n\n{par1 -> v1, .., parn->vn, Chi\
Square -> chisq, GoodnessOfFit -> good,\nConfidenceInterval -> {c1, .., cn}, ConvarianceMatrix -> cov},\n\nwhere v1,..,vn are the \
values of the parameters which minimizes chi-square, chisq is the resulting minimum value of the total chi-square (when no error i\
s given for yi, variance is returned), good is a number given by GammaRegularized[(ndata-npara)/2,chisq/2] to represent the goodne\
ss of the fit, c1, .., cn are the estimated errors in parameters, and cov is the covariance matrix. A typical criterion of the goo\
dness is (good > 0.1).\n\n   Options are\n\nMaxIterations        Maximum number of iterations.\nD                    If True (defa\
ult), tries to use analytical derivative.\nCutoff               If nonzero, set the saturation point for each data as:\n\nchi-suar\
e = Sum_i ( Min[Cutoff, Max[-Cutoff, (d_i - f_ i) / sigma_i]]^2 ) ,\n\n                     which is a sort of robust M-Estimates.\
 By Cutoff, the fit\n                     tends to ignore tail data which are beyond Cutoff.\n                     If Cutoff is ze\
ro (default), it is ignored."],
p$2213=1+p$2213[[1,2]];p1$2213=StringPosition["Usage: Fit[data, expr, var, \n         {par1, ini1, [{min1, max1}] }, .. ,{parn, in\
in, [{minn, maxn}]},\n         [options..] ]\n\nperforms a nonlinear fitting of data with an expression expr.\n\ndata: list of {xi\
,yi}, {xi,yi,dyi}, or {xi,yi,dxi,dyi}, where dxi and dyi\n      are the standard deviation of the i-th point.\nexpr: an expression\
 containing var as the x-variable, and \n      parameters par1,..,parn explicitly. Use Evaluate[fun] if an implicit\n      express\
ion is necessary.\nvar:  a symbol to express the x-axis variable.\npar:  parameter symbol to be varied in the fitting.\nini:  init\
ial value of the parameter. It must be specified.\n(min, max}: optional range of parameter.\n\nFit returns the result as a list:\n\
\n{par1 -> v1, .., parn->vn, ChiSquare -> chisq, GoodnessOfFit -> good,\nConfidenceInterval -> {c1, .., cn}, ConvarianceMatrix -> \
cov},\n\nwhere v1,..,vn are the values of the parameters which minimizes chi-square, chisq is the resulting minimum value of the t\
otal chi-square (when no error is given for yi, variance is returned), good is a number given by GammaRegularized[(ndata-npara)/2,\
chisq/2] to represent the goodness of the fit, c1, .., cn are the estimated errors in parameters, and cov is the covariance matrix\
. A typical criterion of the goodness is (good > 0.1).\n\n   Options are\n\nMaxIterations        Maximum number of iterations.\nD \
                   If True (default), tries to use analytical derivative.\nCutoff               If nonzero, set the saturation poi\
nt for each data as:\n\nchi-suare = Sum_i ( Min[Cutoff, Max[-Cutoff, (d_i - f_ i) / sigma_i]]^2 ) ,\n\n                     which \
is a sort of robust M-Estimates. By Cutoff, the fit\n                     tends to ignore tail data which are beyond Cutoff.\n    \
                 If Cutoff is zero (default), it is ignored."[p$2213,-1],">::",1];
   p1$2213=If[p1$2213==={},1800,-2+p$2213+p1$2213[[1,1]]];
neq=Which["Usage: Fit[data, expr, var, \n         {par1, ini1, [{min1, max1}] }, .. ,{parn, inin, [{minn, maxn}]},\n         [opti\
ons..] ]\n\nperforms a nonlinear fitting of data with an expression expr.\n\ndata: list of {xi,yi}, {xi,yi,dyi}, or {xi,yi,dxi,dyi\
}, where dxi and dyi\n      are the standard deviation of the i-th point.\nexpr: an expression containing var as the x-variable, a\
nd \n      parameters par1,..,parn explicitly. Use Evaluate[fun] if an implicit\n      expression is necessary.\nvar:  a symbol to\
 express the x-axis variable.\npar:  parameter symbol to be varied in the fitting.\nini:  initial value of the parameter. It must \
be specified.\n(min, max}: optional range of parameter.\n\nFit returns the result as a list:\n\n{par1 -> v1, .., parn->vn, ChiSqua\
re -> chisq, GoodnessOfFit -> good,\nConfidenceInterval -> {c1, .., cn}, ConvarianceMatrix -> cov},\n\nwhere v1,..,vn are the valu\
es of the parameters which minimizes chi-square, chisq is the resulting minimum value of the total chi-square (when no error is gi\
ven for yi, variance is returned), good is a number given by GammaRegularized[(ndata-npara)/2,chisq/2] to represent the goodness o\
f the fit, c1, .., cn are the estimated errors in parameters, and cov is the covariance matrix. A typical criterion of the goodnes\
s is (good > 0.1).\n\n   Options are\n\nMaxIterations        Maximum number of iterations.\nD                    If True (default)\
, tries to use analytical derivative.\nCutoff               If nonzero, set the saturation point for each data as:\n\nchi-suare = \
Sum_i ( Min[Cutoff, Max[-Cutoff, (d_i - f_ i) / sigma_i]]^2 ) ,\n\n                     which is a sort of robust M-Estimates. By \
Cutoff, the fit\n                     tends to ignore tail data which are beyond Cutoff.\n                     If Cutoff is zero (\
default), it is ignored."[p$2213,4+p$2213]==="Text[",
    lx$2213:=Help2HTML`oa$;p$2213=5+p$2213;p1$2213-=1;p2$2213=5+p1$2213;p0$2213=-9+p$2213;
If[(pe$2213=StringPosition["Usage: Fit[data, expr, var, \n         {par1, ini1, [{min1, max1}] }, .. ,{parn, inin, [{minn, maxn}]}\
,\n         [options..] ]\n\nperforms a nonlinear fitting of data with an expression expr.\n\ndata: list of {xi,yi}, {xi,yi,dyi}, \
or {xi,yi,dxi,dyi}, where dxi and dyi\n      are the standard deviation of the i-th point.\nexpr: an expression containing var as \
the x-variable, and \n      parameters par1,..,parn explicitly. Use Evaluate[fun] if an implicit\n      expression is necessary.\n\
var:  a symbol to express the x-axis variable.\npar:  parameter symbol to be varied in the fitting.\nini:  initial value of the pa\
rameter. It must be specified.\n(min, max}: optional range of parameter.\n\nFit returns the result as a list:\n\n{par1 -> v1, .., \
parn->vn, ChiSquare -> chisq, GoodnessOfFit -> good,\nConfidenceInterval -> {c1, .., cn}, ConvarianceMatrix -> cov},\n\nwhere v1,.\
.,vn are the values of the parameters which minimizes chi-square, chisq is the resulting minimum value of the total chi-square (wh\
en no error is given for yi, variance is returned), good is a number given by GammaRegularized[(ndata-npara)/2,chisq/2] to represe\
nt the goodness of the fit, c1, .., cn are the estimated errors in parameters, and cov is the covariance matrix. A typical criteri\
on of the goodness is (good > 0.1).\n\n   Options are\n\nMaxIterations        Maximum number of iterations.\nD                    \
If True (default), tries to use analytical derivative.\nCutoff               If nonzero, set the saturation point for each data as\
:\n\nchi-suare = Sum_i ( Min[Cutoff, Max[-Cutoff, (d_i - f_ i) / sigma_i]]^2 ) ,\n\n                     which is a sort of robust\
 M-Estimates. By Cutoff, the fit\n                     tends to ignore tail data which are beyond Cutoff.\n                     If\
 Cutoff is zero (default), it is ignored."[p$2213,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Usage: Fit[data, expr, var, \n         {par1, ini1, [{min1, max1}] }, .. ,{parn, inin, [{minn, maxn}]},\n        \
 [options..] ]\n\nperforms a nonlinear fitting of data with an expression expr.\n\ndata: list of {xi,yi}, {xi,yi,dyi}, or {xi,yi,d\
xi,dyi}, where dxi and dyi\n      are the standard deviation of the i-th point.\nexpr: an expression containing var as the x-varia\
ble, and \n      parameters par1,..,parn explicitly. Use Evaluate[fun] if an implicit\n      expression is necessary.\nvar:  a sym\
bol to express the x-axis variable.\npar:  parameter symbol to be varied in the fitting.\nini:  initial value of the parameter. It\
 must be specified.\n(min, max}: optional range of parameter.\n\nFit returns the result as a list:\n\n{par1 -> v1, .., parn->vn, C\
hiSquare -> chisq, GoodnessOfFit -> good,\nConfidenceInterval -> {c1, .., cn}, ConvarianceMatrix -> cov},\n\nwhere v1,..,vn are th\
e values of the parameters which minimizes chi-square, chisq is the resulting minimum value of the total chi-square (when no error\
 is given for yi, variance is returned), good is a number given by GammaRegularized[(ndata-npara)/2,chisq/2] to represent the good\
ness of the fit, c1, .., cn are the estimated errors in parameters, and cov is the covariance matrix. A typical criterion of the g\
oodness is (good > 0.1).\n\n   Options are\n\nMaxIterations        Maximum number of iterations.\nD                    If True (de\
fault), tries to use analytical derivative.\nCutoff               If nonzero, set the saturation point for each data as:\n\nchi-su\
are = Sum_i ( Min[Cutoff, Max[-Cutoff, (d_i - f_ i) / sigma_i]]^2 ) ,\n\n                     which is a sort of robust M-Estimate\
s. By Cutoff, the fit\n                     tends to ignore tail data which are beyond Cutoff.\n                     If Cutoff is \
zero (default), it is ignored."[p$2213+pe$2213[[1,2]],p1$2213]]],
        p1$2213=-2+p$2213+pe$2213[[1,1]]}[[
       1]],
      0],
    1,lx$2213:=Help2HTML`o9$;p2$2213=4+p1$2213;p0$2213=-4+p$2213;0];
  If[(equ$2213=
Help2HTML`o8$["Usage: Fit[data, expr, var, \n         {par1, ini1, [{min1, max1}] }, .. ,{parn, inin, [{minn, maxn}]},\n         [\
options..] ]\n\nperforms a nonlinear fitting of data with an expression expr.\n\ndata: list of {xi,yi}, {xi,yi,dyi}, or {xi,yi,dxi\
,dyi}, where dxi and dyi\n      are the standard deviation of the i-th point.\nexpr: an expression containing var as the x-variabl\
e, and \n      parameters par1,..,parn explicitly. Use Evaluate[fun] if an implicit\n      expression is necessary.\nvar:  a symbo\
l to express the x-axis variable.\npar:  parameter symbol to be varied in the fitting.\nini:  initial value of the parameter. It m\
ust be specified.\n(min, max}: optional range of parameter.\n\nFit returns the result as a list:\n\n{par1 -> v1, .., parn->vn, Chi\
Square -> chisq, GoodnessOfFit -> good,\nConfidenceInterval -> {c1, .., cn}, ConvarianceMatrix -> cov},\n\nwhere v1,..,vn are the \
values of the parameters which minimizes chi-square, chisq is the resulting minimum value of the total chi-square (when no error i\
s given for yi, variance is returned), good is a number given by GammaRegularized[(ndata-npara)/2,chisq/2] to represent the goodne\
ss of the fit, c1, .., cn are the estimated errors in parameters, and cov is the covariance matrix. A typical criterion of the goo\
dness is (good > 0.1).\n\n   Options are\n\nMaxIterations        Maximum number of iterations.\nD                    If True (defa\
ult), tries to use analytical derivative.\nCutoff               If nonzero, set the saturation point for each data as:\n\nchi-suar\
e = Sum_i ( Min[Cutoff, Max[-Cutoff, (d_i - f_ i) / sigma_i]]^2 ) ,\n\n                     which is a sort of robust M-Estimates.\
 By Cutoff, the fit\n                     tends to ignore tail data which are beyond Cutoff.\n                     If Cutoff is ze\
ro (default), it is ignored."[p$2213,p1$2213]])===
    Undefined,
equ$2213="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Usage: Fit[data, expr, var, \n         {par1\
, ini1, [{min1, max1}] }, .. ,{parn, inin, [{minn, maxn}]},\n         [options..] ]\n\nperforms a nonlinear fitting of data with a\
n expression expr.\n\ndata: list of {xi,yi}, {xi,yi,dyi}, or {xi,yi,dxi,dyi}, where dxi and dyi\n      are the standard deviation \
of the i-th point.\nexpr: an expression containing var as the x-variable, and \n      parameters par1,..,parn explicitly. Use Eval\
uate[fun] if an implicit\n      expression is necessary.\nvar:  a symbol to express the x-axis variable.\npar:  parameter symbol t\
o be varied in the fitting.\nini:  initial value of the parameter. It must be specified.\n(min, max}: optional range of parameter.\
\n\nFit returns the result as a list:\n\n{par1 -> v1, .., parn->vn, ChiSquare -> chisq, GoodnessOfFit -> good,\nConfidenceInterval\
 -> {c1, .., cn}, ConvarianceMatrix -> cov},\n\nwhere v1,..,vn are the values of the parameters which minimizes chi-square, chisq \
is the resulting minimum value of the total chi-square (when no error is given for yi, variance is returned), good is a number giv\
en by GammaRegularized[(ndata-npara)/2,chisq/2] to represent the goodness of the fit, c1, .., cn are the estimated errors in param\
eters, and cov is the covariance matrix. A typical criterion of the goodness is (good > 0.1).\n\n   Options are\n\nMaxIterations  \
      Maximum number of iterations.\nD                    If True (default), tries to use analytical derivative.\nCutoff          \
     If nonzero, set the saturation point for each data as:\n\nchi-suare = Sum_i ( Min[Cutoff, Max[-Cutoff, (d_i - f_ i) / sigma_i\
]]^2 ) ,\n\n                     which is a sort of robust M-Estimates. By Cutoff, the fit\n                     tends to ignore t\
ail data which are beyond Cutoff.\n                     If Cutoff is zero (default), it is ignored."[p$2213,p1$2213]]=
       equ$2213;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2213},out$2213=lx$2213@Typeset["Usage: Fit[data, expr, var, \n         {par1, ini1, [{min1, max1}] }, .. ,{parn, inin, [{\
minn, maxn}]},\n         [options..] ]\n\nperforms a nonlinear fitting of data with an expression expr.\n\ndata: list of {xi,yi}, \
{xi,yi,dyi}, or {xi,yi,dxi,dyi}, where dxi and dyi\n      are the standard deviation of the i-th point.\nexpr: an expression conta\
ining var as the x-variable, and \n      parameters par1,..,parn explicitly. Use Evaluate[fun] if an implicit\n      expression is\
 necessary.\nvar:  a symbol to express the x-axis variable.\npar:  parameter symbol to be varied in the fitting.\nini:  initial va\
lue of the parameter. It must be specified.\n(min, max}: optional range of parameter.\n\nFit returns the result as a list:\n\n{par\
1 -> v1, .., parn->vn, ChiSquare -> chisq, GoodnessOfFit -> good,\nConfidenceInterval -> {c1, .., cn}, ConvarianceMatrix -> cov},\\
n\nwhere v1,..,vn are the values of the parameters which minimizes chi-square, chisq is the resulting minimum value of the total c\
hi-square (when no error is given for yi, variance is returned), good is a number given by GammaRegularized[(ndata-npara)/2,chisq/\
2] to represent the goodness of the fit, c1, .., cn are the estimated errors in parameters, and cov is the covariance matrix. A ty\
pical criterion of the goodness is (good > 0.1).\n\n   Options are\n\nMaxIterations        Maximum number of iterations.\nD       \
             If True (default), tries to use analytical derivative.\nCutoff               If nonzero, set the saturation point for\
 each data as:\n\nchi-suare = Sum_i ( Min[Cutoff, Max[-Cutoff, (d_i - f_ i) / sigma_i]]^2 ) ,\n\n                     which is a s\
ort of robust M-Estimates. By Cutoff, the fit\n                     tends to ignore tail data which are beyond Cutoff.\n          \
           If Cutoff is zero (default), it is ignored."[p$2213,p1$2213],Format->Help2HTML`oB$];
        System["mv -f "//out$2213//" "//equ$2213]];
      Exit[]]];
   "Usage: Fit[data, expr, var, \n         {par1, ini1, [{min1, max1}] }, .. ,{parn, inin, [{minn, maxn}]},\n         [options..] \
]\n\nperforms a nonlinear fitting of data with an expression expr.\n\ndata: list of {xi,yi}, {xi,yi,dyi}, or {xi,yi,dxi,dyi}, wher\
e dxi and dyi\n      are the standard deviation of the i-th point.\nexpr: an expression containing var as the x-variable, and \n  \
    parameters par1,..,parn explicitly. Use Evaluate[fun] if an implicit\n      expression is necessary.\nvar:  a symbol to expres\
s the x-axis variable.\npar:  parameter symbol to be varied in the fitting.\nini:  initial value of the parameter. It must be spec\
ified.\n(min, max}: optional range of parameter.\n\nFit returns the result as a list:\n\n{par1 -> v1, .., parn->vn, ChiSquare -> c\
hisq, GoodnessOfFit -> good,\nConfidenceInterval -> {c1, .., cn}, ConvarianceMatrix -> cov},\n\nwhere v1,..,vn are the values of t\
he parameters which minimizes chi-square, chisq is the resulting minimum value of the total chi-square (when no error is given for\
 yi, variance is returned), good is a number given by GammaRegularized[(ndata-npara)/2,chisq/2] to represent the goodness of the f\
it, c1, .., cn are the estimated errors in parameters, and cov is the covariance matrix. A typical criterion of the goodness is (g\
ood > 0.1).\n\n   Options are\n\nMaxIterations        Maximum number of iterations.\nD                    If True (default), tries\
 to use analytical derivative.\nCutoff               If nonzero, set the saturation point for each data as:\n\nchi-suare = Sum_i (\
 Min[Cutoff, Max[-Cutoff, (d_i - f_ i) / sigma_i]]^2 ) ,\n\n                     which is a sort of robust M-Estimates. By Cutoff,\
 the fit\n                     tends to ignore tail data which are beyond Cutoff.\n                     If Cutoff is zero (default\
), it is ignored."[1,Max[p0$2213,0]]//"<img  class=\"eqs\" SRC=\""//equ$2213//"\" />"//
Help2HTML`oy$["Usage: Fit[data, expr, var, \n         {par1, ini1, [{min1, max1}] }, .. ,{parn, inin, [{minn, maxn}]},\n         [\
options..] ]\n\nperforms a nonlinear fitting of data with an expression expr.\n\ndata: list of {xi,yi}, {xi,yi,dyi}, or {xi,yi,dxi\
,dyi}, where dxi and dyi\n      are the standard deviation of the i-th point.\nexpr: an expression containing var as the x-variabl\
e, and \n      parameters par1,..,parn explicitly. Use Evaluate[fun] if an implicit\n      expression is necessary.\nvar:  a symbo\
l to express the x-axis variable.\npar:  parameter symbol to be varied in the fitting.\nini:  initial value of the parameter. It m\
ust be specified.\n(min, max}: optional range of parameter.\n\nFit returns the result as a list:\n\n{par1 -> v1, .., parn->vn, Chi\
Square -> chisq, GoodnessOfFit -> good,\nConfidenceInterval -> {c1, .., cn}, ConvarianceMatrix -> cov},\n\nwhere v1,..,vn are the \
values of the parameters which minimizes chi-square, chisq is the resulting minimum value of the total chi-square (when no error i\
s given for yi, variance is returned), good is a number given by GammaRegularized[(ndata-npara)/2,chisq/2] to represent the goodne\
ss of the fit, c1, .., cn are the estimated errors in parameters, and cov is the covariance matrix. A typical criterion of the goo\
dness is (good > 0.1).\n\n   Options are\n\nMaxIterations        Maximum number of iterations.\nD                    If True (defa\
ult), tries to use analytical derivative.\nCutoff               If nonzero, set the saturation point for each data as:\n\nchi-suar\
e = Sum_i ( Min[Cutoff, Max[-Cutoff, (d_i - f_ i) / sigma_i]]^2 ) ,\n\n                     which is a sort of robust M-Estimates.\
 By Cutoff, the fit\n                     tends to ignore tail data which are beyond Cutoff.\n                     If Cutoff is ze\
ro (default), it is ignored."[p2$2213,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L417>FitPlot</A></PRE>
<LI>
<H3><A NAME=L361>
FitEmit</A></H3>
<PRE>If[{},
Help2HTML`oA$["Obtain the emittance, beta, alpha, etc. from data of particles x and px using FitGaussian.\n\n  FitEmit[x, px] ,\n\\
nwhere x and px are the lists of data of the particles in the phase space, returns a list\n\n  {{xmean, pxmean, alpha, beta, emitt\
ance},\n   {xmean, pxmean, alpha, beta, emittance}_conf},\n\nwhere the second component is the confidence intervals of the results\
."],
p$2216=1+p$2216[[1,2]];p1$2216=StringPosition["Obtain the emittance, beta, alpha, etc. from data of particles x and px using FitGa\
ussian.\n\n  FitEmit[x, px] ,\n\nwhere x and px are the lists of data of the particles in the phase space, returns a list\n\n  {{x\
mean, pxmean, alpha, beta, emittance},\n   {xmean, pxmean, alpha, beta, emittance}_conf},\n\nwhere the second component is the con\
fidence intervals of the results."[p$2216,-1],">::",1];
   p1$2216=If[p1$2216==={},367,-2+p$2216+p1$2216[[1,1]]];
neq=Which["Obtain the emittance, beta, alpha, etc. from data of particles x and px using FitGaussian.\n\n  FitEmit[x, px] ,\n\nwhe\
re x and px are the lists of data of the particles in the phase space, returns a list\n\n  {{xmean, pxmean, alpha, beta, emittance\
},\n   {xmean, pxmean, alpha, beta, emittance}_conf},\n\nwhere the second component is the confidence intervals of the results."[
      p$2216,4+p$2216]===
     "Text[",
lx$2216:=Help2HTML`oa$;p$2216=5+p$2216;p1$2216-=1;p2$2216=5+p1$2216;p0$2216=-9+p$2216;If[(pe$2216=StringPosition["Obtain the emitt\
ance, beta, alpha, etc. from data of particles x and px using FitGaussian.\n\n  FitEmit[x, px] ,\n\nwhere x and px are the lists o\
f data of the particles in the phase space, returns a list\n\n  {{xmean, pxmean, alpha, beta, emittance},\n   {xmean, pxmean, alph\
a, beta, emittance}_conf},\n\nwhere the second component is the confidence intervals of the results."[p$2216,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Obtain the emittance, beta, alpha, etc. from data of particles x and px using FitGaussian.\n\n  FitEmit[x, px] ,\\
n\nwhere x and px are the lists of data of the particles in the phase space, returns a list\n\n  {{xmean, pxmean, alpha, beta, emi\
ttance},\n   {xmean, pxmean, alpha, beta, emittance}_conf},\n\nwhere the second component is the confidence intervals of the resul\
ts."[p$2216+pe$2216[[1,2]],p1$2216]]],
        p1$2216=-2+p$2216+pe$2216[[1,1]]}[[
       1]],
      0],
    1,lx$2216:=Help2HTML`o9$;p2$2216=4+p1$2216;p0$2216=-4+p$2216;0];
  If[(equ$2216=
Help2HTML`o8$["Obtain the emittance, beta, alpha, etc. from data of particles x and px using FitGaussian.\n\n  FitEmit[x, px] ,\n\\
nwhere x and px are the lists of data of the particles in the phase space, returns a list\n\n  {{xmean, pxmean, alpha, beta, emitt\
ance},\n   {xmean, pxmean, alpha, beta, emittance}_conf},\n\nwhere the second component is the confidence intervals of the results\
."[p$2216,p1$2216]])===
    Undefined,
equ$2216="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Obtain the emittance, beta, alpha, etc. from\
 data of particles x and px using FitGaussian.\n\n  FitEmit[x, px] ,\n\nwhere x and px are the lists of data of the particles in t\
he phase space, returns a list\n\n  {{xmean, pxmean, alpha, beta, emittance},\n   {xmean, pxmean, alpha, beta, emittance}_conf},\n\
\nwhere the second component is the confidence intervals of the results."[p$2216,p1$2216]]=
       equ$2216;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2216},out$2216=lx$2216@Typeset["Obtain the emittance, beta, alpha, etc. from data of particles x and px using FitGaussian\
.\n\n  FitEmit[x, px] ,\n\nwhere x and px are the lists of data of the particles in the phase space, returns a list\n\n  {{xmean, \
pxmean, alpha, beta, emittance},\n   {xmean, pxmean, alpha, beta, emittance}_conf},\n\nwhere the second component is the confidenc\
e intervals of the results."[p$2216,p1$2216],Format->Help2HTML`oB$];
        System["mv -f "//out$2216//" "//equ$2216]];
      Exit[]]];
   "Obtain the emittance, beta, alpha, etc. from data of particles x and px using FitGaussian.\n\n  FitEmit[x, px] ,\n\nwhere x an\
d px are the lists of data of the particles in the phase space, returns a list\n\n  {{xmean, pxmean, alpha, beta, emittance},\n   \
{xmean, pxmean, alpha, beta, emittance}_conf},\n\nwhere the second component is the confidence intervals of the results."[1,
    Max[p0$2216,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2216//"\" />"//
Help2HTML`oy$["Obtain the emittance, beta, alpha, etc. from data of particles x and px using FitGaussian.\n\n  FitEmit[x, px] ,\n\\
nwhere x and px are the lists of data of the particles in the phase space, returns a list\n\n  {{xmean, pxmean, alpha, beta, emitt\
ance},\n   {xmean, pxmean, alpha, beta, emittance}_conf},\n\nwhere the second component is the confidence intervals of the results\
."[p2$2216,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L362>FitGaussian</A></PRE>
<LI>
<H3><A NAME=L362>
FitGaussian</A></H3>
<PRE>If[{},
Help2HTML`oA$["Performs Gaussian fit of 1D list data:\n\n  FitGaussian[data, [opt, ...]]\n\nreturns a list\n\n  {sigma, mean, {sig\
ma_conf, mean_conf}, chisq} ,\n\nwhere sigma_conf and mean_conf are the confidence interval of the results sigma and mean, respect\
ively. The arguments opt... are options for Fit. If Plot -> True is specified as the option, a plot of the fitting will be made."],
 p$2219=1+p$2219[[1,2]];
p1$2219=StringPosition["Performs Gaussian fit of 1D list data:\n\n  FitGaussian[data, [opt, ...]]\n\nreturns a list\n\n  {sigma, m\
ean, {sigma_conf, mean_conf}, chisq} ,\n\nwhere sigma_conf and mean_conf are the confidence interval of the results sigma and mean\
, respectively. The arguments opt... are options for Fit. If Plot -> True is specified as the option, a plot of the fitting will b\
e made."[p$2219,-1],">::",1];
   p1$2219=If[p1$2219==={},365,-2+p$2219+p1$2219[[1,1]]];
neq=Which["Performs Gaussian fit of 1D list data:\n\n  FitGaussian[data, [opt, ...]]\n\nreturns a list\n\n  {sigma, mean, {sigma_c\
onf, mean_conf}, chisq} ,\n\nwhere sigma_conf and mean_conf are the confidence interval of the results sigma and mean, respectivel\
y. The arguments opt... are options for Fit. If Plot -> True is specified as the option, a plot of the fitting will be made."[p
      $2219,4+p$2219]===
     "Text[",
lx$2219:=Help2HTML`oa$;p$2219=5+p$2219;p1$2219-=1;p2$2219=5+p1$2219;p0$2219=-9+p$2219;If[(pe$2219=StringPosition["Performs Gaussia\
n fit of 1D list data:\n\n  FitGaussian[data, [opt, ...]]\n\nreturns a list\n\n  {sigma, mean, {sigma_conf, mean_conf}, chisq} ,\n\
\nwhere sigma_conf and mean_conf are the confidence interval of the results sigma and mean, respectively. The arguments opt... are\
 options for Fit. If Plot -> True is specified as the option, a plot of the fitting will be made."[p$2219,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Performs Gaussian fit of 1D list data:\n\n  FitGaussian[data, [opt, ...]]\n\nreturns a list\n\n  {sigma, mean, {s\
igma_conf, mean_conf}, chisq} ,\n\nwhere sigma_conf and mean_conf are the confidence interval of the results sigma and mean, respe\
ctively. The arguments opt... are options for Fit. If Plot -> True is specified as the option, a plot of the fitting will be made."
          [p$2219+pe$2219[[1,2]],p1$2219]]],
        p1$2219=-2+p$2219+pe$2219[[1,1]]}[[
       1]],
      0],
    1,lx$2219:=Help2HTML`o9$;p2$2219=4+p1$2219;p0$2219=-4+p$2219;0];
  If[(equ$2219=
Help2HTML`o8$["Performs Gaussian fit of 1D list data:\n\n  FitGaussian[data, [opt, ...]]\n\nreturns a list\n\n  {sigma, mean, {sig\
ma_conf, mean_conf}, chisq} ,\n\nwhere sigma_conf and mean_conf are the confidence interval of the results sigma and mean, respect\
ively. The arguments opt... are options for Fit. If Plot -> True is specified as the option, a plot of the fitting will be made."[
       p$2219,p1$2219]])===
    Undefined,
equ$2219="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Performs Gaussian fit of 1D list data:\n\n  \
FitGaussian[data, [opt, ...]]\n\nreturns a list\n\n  {sigma, mean, {sigma_conf, mean_conf}, chisq} ,\n\nwhere sigma_conf and mean_\
conf are the confidence interval of the results sigma and mean, respectively. The arguments opt... are options for Fit. If Plot ->\
 True is specified as the option, a plot of the fitting will be made."[p$2219,p1$2219]]=
       equ$2219;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2219},out$2219=lx$2219@Typeset["Performs Gaussian fit of 1D list data:\n\n  FitGaussian[data, [opt, ...]]\n\nreturns a li\
st\n\n  {sigma, mean, {sigma_conf, mean_conf}, chisq} ,\n\nwhere sigma_conf and mean_conf are the confidence interval of the resul\
ts sigma and mean, respectively. The arguments opt... are options for Fit. If Plot -> True is specified as the option, a plot of t\
he fitting will be made."[p$2219,p1$2219],Format->Help2HTML`oB$];
        System["mv -f "//out$2219//" "//equ$2219]];
      Exit[]]];
   "Performs Gaussian fit of 1D list data:\n\n  FitGaussian[data, [opt, ...]]\n\nreturns a list\n\n  {sigma, mean, {sigma_conf, me\
an_conf}, chisq} ,\n\nwhere sigma_conf and mean_conf are the confidence interval of the results sigma and mean, respectively. The \
arguments opt... are options for Fit. If Plot -> True is specified as the option, a plot of the fitting will be made."[1,
    Max[p0$2219,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2219//"\" />"//
Help2HTML`oy$["Performs Gaussian fit of 1D list data:\n\n  FitGaussian[data, [opt, ...]]\n\nreturns a list\n\n  {sigma, mean, {sig\
ma_conf, mean_conf}, chisq} ,\n\nwhere sigma_conf and mean_conf are the confidence interval of the results sigma and mean, respect\
ively. The arguments opt... are options for Fit. If Plot -> True is specified as the option, a plot of the fitting will be made."[
     p2$2219,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L360>Fit</A> <A HREF=#L361>FitEmit</A></PRE>
<LI>
<H3><A NAME=L363>
NIntegrate</A></H3>
<PRE>If[{},
Help2HTML`oA$["NIntegrate returns numerical integration of a Real or Complex\nfunction\n\nUsage:   NIntegrate[f, {x, x0, x1}, opti\
ons]\n\nwhere f is a function containing Symbol x as the independent variable. The integral range is from x0 and x1. The function \
f must contain the symbol x explicitly.\n\nOptions           Default      Description\n-------------------------------------------\
------------------\nAccuracyGoal      1e-13        Relative accuracy\nInitialPoints     20           Number of initial points wher\
e\n                               the function is evaluated."],
p$2222=1+p$2222[[1,2]];p1$2222=StringPosition["NIntegrate returns numerical integration of a Real or Complex\nfunction\n\nUsage:  \
 NIntegrate[f, {x, x0, x1}, options]\n\nwhere f is a function containing Symbol x as the independent variable. The integral range \
is from x0 and x1. The function f must contain the symbol x explicitly.\n\nOptions           Default      Description\n-----------\
--------------------------------------------------\nAccuracyGoal      1e-13        Relative accuracy\nInitialPoints     20        \
   Number of initial points where\n                               the function is evaluated."[p$2222,-1],">::",1];
   p1$2222=If[p1$2222==={},554,-2+p$2222+p1$2222[[1,1]]];
neq=Which["NIntegrate returns numerical integration of a Real or Complex\nfunction\n\nUsage:   NIntegrate[f, {x, x0, x1}, options]\
\n\nwhere f is a function containing Symbol x as the independent variable. The integral range is from x0 and x1. The function f mu\
st contain the symbol x explicitly.\n\nOptions           Default      Description\n-----------------------------------------------\
--------------\nAccuracyGoal      1e-13        Relative accuracy\nInitialPoints     20           Number of initial points where\n \
                              the function is evaluated."[p$2222,4+p$2222]==="Text[",
    lx$2222:=Help2HTML`oa$;p$2222=5+p$2222;p1$2222-=1;p2$2222=5+p1$2222;p0$2222=-9+p$2222;
If[(pe$2222=StringPosition["NIntegrate returns numerical integration of a Real or Complex\nfunction\n\nUsage:   NIntegrate[f, {x, \
x0, x1}, options]\n\nwhere f is a function containing Symbol x as the independent variable. The integral range is from x0 and x1. \
The function f must contain the symbol x explicitly.\n\nOptions           Default      Description\n------------------------------\
-------------------------------\nAccuracyGoal      1e-13        Relative accuracy\nInitialPoints     20           Number of initia\
l points where\n                               the function is evaluated."[p$2222,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["NIntegrate returns numerical integration of a Real or Complex\nfunction\n\nUsage:   NIntegrate[f, {x, x0, x1}, op\
tions]\n\nwhere f is a function containing Symbol x as the independent variable. The integral range is from x0 and x1. The functio\
n f must contain the symbol x explicitly.\n\nOptions           Default      Description\n-----------------------------------------\
--------------------\nAccuracyGoal      1e-13        Relative accuracy\nInitialPoints     20           Number of initial points wh\
ere\n                               the function is evaluated."[p$2222+pe$2222[[1,2]],p1$2222]]],
        p1$2222=-2+p$2222+pe$2222[[1,1]]}[[
       1]],
      0],
    1,lx$2222:=Help2HTML`o9$;p2$2222=4+p1$2222;p0$2222=-4+p$2222;0];
  If[(equ$2222=
Help2HTML`o8$["NIntegrate returns numerical integration of a Real or Complex\nfunction\n\nUsage:   NIntegrate[f, {x, x0, x1}, opti\
ons]\n\nwhere f is a function containing Symbol x as the independent variable. The integral range is from x0 and x1. The function \
f must contain the symbol x explicitly.\n\nOptions           Default      Description\n-------------------------------------------\
------------------\nAccuracyGoal      1e-13        Relative accuracy\nInitialPoints     20           Number of initial points wher\
e\n                               the function is evaluated."[p$2222,p1$2222]])===
    Undefined,
equ$2222="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["NIntegrate returns numerical integration of \
a Real or Complex\nfunction\n\nUsage:   NIntegrate[f, {x, x0, x1}, options]\n\nwhere f is a function containing Symbol x as the in\
dependent variable. The integral range is from x0 and x1. The function f must contain the symbol x explicitly.\n\nOptions         \
  Default      Description\n-------------------------------------------------------------\nAccuracyGoal      1e-13        Relative\
 accuracy\nInitialPoints     20           Number of initial points where\n                               the function is evaluated\
."[p$2222,p1$2222]]=
       equ$2222;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2222},out$2222=lx$2222@Typeset["NIntegrate returns numerical integration of a Real or Complex\nfunction\n\nUsage:   NInte\
grate[f, {x, x0, x1}, options]\n\nwhere f is a function containing Symbol x as the independent variable. The integral range is fro\
m x0 and x1. The function f must contain the symbol x explicitly.\n\nOptions           Default      Description\n-----------------\
--------------------------------------------\nAccuracyGoal      1e-13        Relative accuracy\nInitialPoints     20           Num\
ber of initial points where\n                               the function is evaluated."[p$2222,p1$2222],Format->Help2HTML`oB$];
        System["mv -f "//out$2222//" "//equ$2222]];
      Exit[]]];
   "NIntegrate returns numerical integration of a Real or Complex\nfunction\n\nUsage:   NIntegrate[f, {x, x0, x1}, options]\n\nwhe\
re f is a function containing Symbol x as the independent variable. The integral range is from x0 and x1. The function f must cont\
ain the symbol x explicitly.\n\nOptions           Default      Description\n------------------------------------------------------\
-------\nAccuracyGoal      1e-13        Relative accuracy\nInitialPoints     20           Number of initial points where\n        \
                       the function is evaluated."[1,Max[p0$2222,0]]//"<img  class=\"eqs\" SRC=\""//equ$2222//"\" />"//
   Help2HTML`oy$["NIntegrate returns numerical integration of a Real or Complex\nfunction\n\nUsage:   NIntegrate[f, {x, x0, x1}, o\
ptions]\n\nwhere f is a function containing Symbol x as the independent variable. The integral range is from x0 and x1. The functi\
on f must contain the symbol x explicitly.\n\nOptions           Default      Description\n----------------------------------------\
---------------------\nAccuracyGoal      1e-13        Relative accuracy\nInitialPoints     20           Number of initial points w\
here\n                               the function is evaluated."[p2$2222,-1]]
]</PRE>
<LI>
<H3><A NAME=L364>
PolynomialFit</A></H3>
<PRE>If[{},
Help2HTML`oA$["Usage: PolynomialFit[data, n]\n\nperforms a 1D linear regression of data.\n\ndata: list of {xi,yi}\nn: the order of\
 the polynomial\n\nFit returns the result as a list:\n\n{{c0, .., cn}, {Residual -> res}} ,\n\nwhere c0 .. cn are the coefficients\
 of the fitted polynomial, y = c0 + c1 x + .. + cn x^n . Res is the rms residual of the fit."],
 p$2224=1+p$2224[[1,2]];p1$2224=StringPosition["Usage: PolynomialFit[data, n]\n\nperforms a 1D linear regression of data.\n\ndata:\
 list of {xi,yi}\nn: the order of the polynomial\n\nFit returns the result as a list:\n\n{{c0, .., cn}, {Residual -> res}} ,\n\nwh\
ere c0 .. cn are the coefficients of the fitted polynomial, y = c0 + c1 x + .. + cn x^n . Res is the rms residual of the fit."[p
     $2224,-1],
    ">::",1];
   p1$2224=If[p1$2224==={},326,-2+p$2224+p1$2224[[1,1]]];
neq=Which["Usage: PolynomialFit[data, n]\n\nperforms a 1D linear regression of data.\n\ndata: list of {xi,yi}\nn: the order of the\
 polynomial\n\nFit returns the result as a list:\n\n{{c0, .., cn}, {Residual -> res}} ,\n\nwhere c0 .. cn are the coefficients of \
the fitted polynomial, y = c0 + c1 x + .. + cn x^n . Res is the rms residual of the fit."[p$2224,4+p$2224]==="Text[",
    lx$2224:=Help2HTML`oa$;p$2224=5+p$2224;p1$2224-=1;p2$2224=5+p1$2224;p0$2224=-9+p$2224;
If[(pe$2224=StringPosition["Usage: PolynomialFit[data, n]\n\nperforms a 1D linear regression of data.\n\ndata: list of {xi,yi}\nn:\
 the order of the polynomial\n\nFit returns the result as a list:\n\n{{c0, .., cn}, {Residual -> res}} ,\n\nwhere c0 .. cn are the\
 coefficients of the fitted polynomial, y = c0 + c1 x + .. + cn x^n . Res is the rms residual of the fit."[p$2224,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Usage: PolynomialFit[data, n]\n\nperforms a 1D linear regression of data.\n\ndata: list of {xi,yi}\nn: the order \
of the polynomial\n\nFit returns the result as a list:\n\n{{c0, .., cn}, {Residual -> res}} ,\n\nwhere c0 .. cn are the coefficien\
ts of the fitted polynomial, y = c0 + c1 x + .. + cn x^n . Res is the rms residual of the fit."[p$2224+pe$2224[[1,2]],p1$2224]]],
        p1$2224=-2+p$2224+pe$2224[[1,1]]}[[
       1]],
      0],
    1,lx$2224:=Help2HTML`o9$;p2$2224=4+p1$2224;p0$2224=-4+p$2224;0];
  If[(equ$2224=
Help2HTML`o8$["Usage: PolynomialFit[data, n]\n\nperforms a 1D linear regression of data.\n\ndata: list of {xi,yi}\nn: the order of\
 the polynomial\n\nFit returns the result as a list:\n\n{{c0, .., cn}, {Residual -> res}} ,\n\nwhere c0 .. cn are the coefficients\
 of the fitted polynomial, y = c0 + c1 x + .. + cn x^n . Res is the rms residual of the fit."[p$2224,p1$2224]])===
    Undefined,
equ$2224="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Usage: PolynomialFit[data, n]\n\nperforms a \
1D linear regression of data.\n\ndata: list of {xi,yi}\nn: the order of the polynomial\n\nFit returns the result as a list:\n\n{{c\
0, .., cn}, {Residual -> res}} ,\n\nwhere c0 .. cn are the coefficients of the fitted polynomial, y = c0 + c1 x + .. + cn x^n . Re\
s is the rms residual of the fit."[p$2224,p1$2224]]=
       equ$2224;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2224},out$2224=lx$2224@Typeset["Usage: PolynomialFit[data, n]\n\nperforms a 1D linear regression of data.\n\ndata: list o\
f {xi,yi}\nn: the order of the polynomial\n\nFit returns the result as a list:\n\n{{c0, .., cn}, {Residual -> res}} ,\n\nwhere c0 \
.. cn are the coefficients of the fitted polynomial, y = c0 + c1 x + .. + cn x^n . Res is the rms residual of the fit."[p$2224,
           p1$2224],Format->Help2HTML`oB$];
        System["mv -f "//out$2224//" "//equ$2224]];
      Exit[]]];
   "Usage: PolynomialFit[data, n]\n\nperforms a 1D linear regression of data.\n\ndata: list of {xi,yi}\nn: the order of the polyno\
mial\n\nFit returns the result as a list:\n\n{{c0, .., cn}, {Residual -> res}} ,\n\nwhere c0 .. cn are the coefficients of the fit\
ted polynomial, y = c0 + c1 x + .. + cn x^n . Res is the rms residual of the fit."[1,Max[p0$2224,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2224//"\" />"//
Help2HTML`oy$["Usage: PolynomialFit[data, n]\n\nperforms a 1D linear regression of data.\n\ndata: list of {xi,yi}\nn: the order of\
 the polynomial\n\nFit returns the result as a list:\n\n{{c0, .., cn}, {Residual -> res}} ,\n\nwhere c0 .. cn are the coefficients\
 of the fitted polynomial, y = c0 + c1 x + .. + cn x^n . Res is the rms residual of the fit."[p2$2224,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L417>FitPlot</A></PRE>
<LI>
<H3><A NAME=L365>
Spline</A></H3>
<PRE>If[{},
Help2HTML`oA$["Spline returns data for cubic-spline interpolation.\n\nUsage:   sp = Spline[list, [Derivative->{dy1,dy2}] ]\n\nwher\
e list contains data in the form as {{x1,y1}, ..} or {{x1,{y11, y12, ..}}, ..}.\n Complex number can be allowed for y, but not for\
 x.\n\n This spline assumes y''=0 at the boundary, unless Derivative->{dy1,dy2} is specified to constrain the derivative at each e\
nd to dy1 or dy2. They can be Null to unspecify the constraint at one of the boundary. The resulting data of the spline is assigne\
d sp as a SplineData object. Then one can calculate the interpolated data by\n\n    sp[x]                     value of y at x.\n  \
  Derivative[1][sp][x]      value of y' at x.\n    Derivative[2][sp][x]      value of y'' at x.\n    Integrate[sp[x],{x, x0, x1}] \
  integral of sp[x] from x0 to x1.\n\nExample:\n   sp=Spline[{{1,2},{3,5},{4,2},{5,7}}];\n   Plot[{sp[x],Derivative[1][sp][x],Deri\
vative[2][sp][x],Integrate[sp[y],{y,1,#}]&[x]}, {x,1,5}, FrameLabel->{\"x\"}, Thickness->2, Legend->{\"sp[x]\",\"sp'[x]\",\"sp''[x\
]\",\"Int sp[x]\"}];\n   Update[];\n\n<Spline.png"],
p$2227=1+p$2227[[1,2]];p1$2227=StringPosition["Spline returns data for cubic-spline interpolation.\n\nUsage:   sp = Spline[list, [\
Derivative->{dy1,dy2}] ]\n\nwhere list contains data in the form as {{x1,y1}, ..} or {{x1,{y11, y12, ..}}, ..}.\n Complex number c\
an be allowed for y, but not for x.\n\n This spline assumes y''=0 at the boundary, unless Derivative->{dy1,dy2} is specified to co\
nstrain the derivative at each end to dy1 or dy2. They can be Null to unspecify the constraint at one of the boundary. The resulti\
ng data of the spline is assigned sp as a SplineData object. Then one can calculate the interpolated data by\n\n    sp[x]         \
            value of y at x.\n    Derivative[1][sp][x]      value of y' at x.\n    Derivative[2][sp][x]      value of y'' at x.\n \
   Integrate[sp[x],{x, x0, x1}]   integral of sp[x] from x0 to x1.\n\nExample:\n   sp=Spline[{{1,2},{3,5},{4,2},{5,7}}];\n   Plot[\
{sp[x],Derivative[1][sp][x],Derivative[2][sp][x],Integrate[sp[y],{y,1,#}]&[x]}, {x,1,5}, FrameLabel->{\"x\"}, Thickness->2, Legend\
->{\"sp[x]\",\"sp'[x]\",\"sp''[x]\",\"Int sp[x]\"}];\n   Update[];\n\n<Spline.png"[p$2227,-1],">::",1];
   p1$2227=If[p1$2227==={},1045,-2+p$2227+p1$2227[[1,1]]];
neq=Which["Spline returns data for cubic-spline interpolation.\n\nUsage:   sp = Spline[list, [Derivative->{dy1,dy2}] ]\n\nwhere li\
st contains data in the form as {{x1,y1}, ..} or {{x1,{y11, y12, ..}}, ..}.\n Complex number can be allowed for y, but not for x.\\
n\n This spline assumes y''=0 at the boundary, unless Derivative->{dy1,dy2} is specified to constrain the derivative at each end t\
o dy1 or dy2. They can be Null to unspecify the constraint at one of the boundary. The resulting data of the spline is assigned sp\
 as a SplineData object. Then one can calculate the interpolated data by\n\n    sp[x]                     value of y at x.\n    De\
rivative[1][sp][x]      value of y' at x.\n    Derivative[2][sp][x]      value of y'' at x.\n    Integrate[sp[x],{x, x0, x1}]   in\
tegral of sp[x] from x0 to x1.\n\nExample:\n   sp=Spline[{{1,2},{3,5},{4,2},{5,7}}];\n   Plot[{sp[x],Derivative[1][sp][x],Derivati\
ve[2][sp][x],Integrate[sp[y],{y,1,#}]&[x]}, {x,1,5}, FrameLabel->{\"x\"}, Thickness->2, Legend->{\"sp[x]\",\"sp'[x]\",\"sp''[x]\",\
\"Int sp[x]\"}];\n   Update[];\n\n<Spline.png"[p$2227,4+p$2227]==="Text[",
    lx$2227:=Help2HTML`oa$;p$2227=5+p$2227;p1$2227-=1;p2$2227=5+p1$2227;p0$2227=-9+p$2227;
If[(pe$2227=StringPosition["Spline returns data for cubic-spline interpolation.\n\nUsage:   sp = Spline[list, [Derivative->{dy1,dy\
2}] ]\n\nwhere list contains data in the form as {{x1,y1}, ..} or {{x1,{y11, y12, ..}}, ..}.\n Complex number can be allowed for y\
, but not for x.\n\n This spline assumes y''=0 at the boundary, unless Derivative->{dy1,dy2} is specified to constrain the derivat\
ive at each end to dy1 or dy2. They can be Null to unspecify the constraint at one of the boundary. The resulting data of the spli\
ne is assigned sp as a SplineData object. Then one can calculate the interpolated data by\n\n    sp[x]                     value o\
f y at x.\n    Derivative[1][sp][x]      value of y' at x.\n    Derivative[2][sp][x]      value of y'' at x.\n    Integrate[sp[x],\
{x, x0, x1}]   integral of sp[x] from x0 to x1.\n\nExample:\n   sp=Spline[{{1,2},{3,5},{4,2},{5,7}}];\n   Plot[{sp[x],Derivative[1\
][sp][x],Derivative[2][sp][x],Integrate[sp[y],{y,1,#}]&[x]}, {x,1,5}, FrameLabel->{\"x\"}, Thickness->2, Legend->{\"sp[x]\",\"sp'[\
x]\",\"sp''[x]\",\"Int sp[x]\"}];\n   Update[];\n\n<Spline.png"[p$2227,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Spline returns data for cubic-spline interpolation.\n\nUsage:   sp = Spline[list, [Derivative->{dy1,dy2}] ]\n\nwh\
ere list contains data in the form as {{x1,y1}, ..} or {{x1,{y11, y12, ..}}, ..}.\n Complex number can be allowed for y, but not f\
or x.\n\n This spline assumes y''=0 at the boundary, unless Derivative->{dy1,dy2} is specified to constrain the derivative at each\
 end to dy1 or dy2. They can be Null to unspecify the constraint at one of the boundary. The resulting data of the spline is assig\
ned sp as a SplineData object. Then one can calculate the interpolated data by\n\n    sp[x]                     value of y at x.\n\
    Derivative[1][sp][x]      value of y' at x.\n    Derivative[2][sp][x]      value of y'' at x.\n    Integrate[sp[x],{x, x0, x1}\
]   integral of sp[x] from x0 to x1.\n\nExample:\n   sp=Spline[{{1,2},{3,5},{4,2},{5,7}}];\n   Plot[{sp[x],Derivative[1][sp][x],De\
rivative[2][sp][x],Integrate[sp[y],{y,1,#}]&[x]}, {x,1,5}, FrameLabel->{\"x\"}, Thickness->2, Legend->{\"sp[x]\",\"sp'[x]\",\"sp''\
[x]\",\"Int sp[x]\"}];\n   Update[];\n\n<Spline.png"[p$2227+pe$2227[[1,2]],p1$2227]]],
        p1$2227=-2+p$2227+pe$2227[[1,1]]}[[
       1]],
      0],
    1,lx$2227:=Help2HTML`o9$;p2$2227=4+p1$2227;p0$2227=-4+p$2227;0];
  If[(equ$2227=
Help2HTML`o8$["Spline returns data for cubic-spline interpolation.\n\nUsage:   sp = Spline[list, [Derivative->{dy1,dy2}] ]\n\nwher\
e list contains data in the form as {{x1,y1}, ..} or {{x1,{y11, y12, ..}}, ..}.\n Complex number can be allowed for y, but not for\
 x.\n\n This spline assumes y''=0 at the boundary, unless Derivative->{dy1,dy2} is specified to constrain the derivative at each e\
nd to dy1 or dy2. They can be Null to unspecify the constraint at one of the boundary. The resulting data of the spline is assigne\
d sp as a SplineData object. Then one can calculate the interpolated data by\n\n    sp[x]                     value of y at x.\n  \
  Derivative[1][sp][x]      value of y' at x.\n    Derivative[2][sp][x]      value of y'' at x.\n    Integrate[sp[x],{x, x0, x1}] \
  integral of sp[x] from x0 to x1.\n\nExample:\n   sp=Spline[{{1,2},{3,5},{4,2},{5,7}}];\n   Plot[{sp[x],Derivative[1][sp][x],Deri\
vative[2][sp][x],Integrate[sp[y],{y,1,#}]&[x]}, {x,1,5}, FrameLabel->{\"x\"}, Thickness->2, Legend->{\"sp[x]\",\"sp'[x]\",\"sp''[x\
]\",\"Int sp[x]\"}];\n   Update[];\n\n<Spline.png"[p$2227,p1$2227]])===
    Undefined,
equ$2227="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Spline returns data for cubic-spline interpo\
lation.\n\nUsage:   sp = Spline[list, [Derivative->{dy1,dy2}] ]\n\nwhere list contains data in the form as {{x1,y1}, ..} or {{x1,{\
y11, y12, ..}}, ..}.\n Complex number can be allowed for y, but not for x.\n\n This spline assumes y''=0 at the boundary, unless D\
erivative->{dy1,dy2} is specified to constrain the derivative at each end to dy1 or dy2. They can be Null to unspecify the constra\
int at one of the boundary. The resulting data of the spline is assigned sp as a SplineData object. Then one can calculate the int\
erpolated data by\n\n    sp[x]                     value of y at x.\n    Derivative[1][sp][x]      value of y' at x.\n    Derivati\
ve[2][sp][x]      value of y'' at x.\n    Integrate[sp[x],{x, x0, x1}]   integral of sp[x] from x0 to x1.\n\nExample:\n   sp=Splin\
e[{{1,2},{3,5},{4,2},{5,7}}];\n   Plot[{sp[x],Derivative[1][sp][x],Derivative[2][sp][x],Integrate[sp[y],{y,1,#}]&[x]}, {x,1,5}, Fr\
ameLabel->{\"x\"}, Thickness->2, Legend->{\"sp[x]\",\"sp'[x]\",\"sp''[x]\",\"Int sp[x]\"}];\n   Update[];\n\n<Spline.png"[p$2227,
         p1$2227]]=
       equ$2227;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2227},out$2227=lx$2227@Typeset["Spline returns data for cubic-spline interpolation.\n\nUsage:   sp = Spline[list, [Deriva\
tive->{dy1,dy2}] ]\n\nwhere list contains data in the form as {{x1,y1}, ..} or {{x1,{y11, y12, ..}}, ..}.\n Complex number can be \
allowed for y, but not for x.\n\n This spline assumes y''=0 at the boundary, unless Derivative->{dy1,dy2} is specified to constrai\
n the derivative at each end to dy1 or dy2. They can be Null to unspecify the constraint at one of the boundary. The resulting dat\
a of the spline is assigned sp as a SplineData object. Then one can calculate the interpolated data by\n\n    sp[x]               \
      value of y at x.\n    Derivative[1][sp][x]      value of y' at x.\n    Derivative[2][sp][x]      value of y'' at x.\n    Int\
egrate[sp[x],{x, x0, x1}]   integral of sp[x] from x0 to x1.\n\nExample:\n   sp=Spline[{{1,2},{3,5},{4,2},{5,7}}];\n   Plot[{sp[x]\
,Derivative[1][sp][x],Derivative[2][sp][x],Integrate[sp[y],{y,1,#}]&[x]}, {x,1,5}, FrameLabel->{\"x\"}, Thickness->2, Legend->{\"s\
p[x]\",\"sp'[x]\",\"sp''[x]\",\"Int sp[x]\"}];\n   Update[];\n\n<Spline.png"[p$2227,p1$2227],Format->Help2HTML`oB$];
        System["mv -f "//out$2227//" "//equ$2227]];
      Exit[]]];
   "Spline returns data for cubic-spline interpolation.\n\nUsage:   sp = Spline[list, [Derivative->{dy1,dy2}] ]\n\nwhere list cont\
ains data in the form as {{x1,y1}, ..} or {{x1,{y11, y12, ..}}, ..}.\n Complex number can be allowed for y, but not for x.\n\n Thi\
s spline assumes y''=0 at the boundary, unless Derivative->{dy1,dy2} is specified to constrain the derivative at each end to dy1 o\
r dy2. They can be Null to unspecify the constraint at one of the boundary. The resulting data of the spline is assigned sp as a S\
plineData object. Then one can calculate the interpolated data by\n\n    sp[x]                     value of y at x.\n    Derivativ\
e[1][sp][x]      value of y' at x.\n    Derivative[2][sp][x]      value of y'' at x.\n    Integrate[sp[x],{x, x0, x1}]   integral \
of sp[x] from x0 to x1.\n\nExample:\n   sp=Spline[{{1,2},{3,5},{4,2},{5,7}}];\n   Plot[{sp[x],Derivative[1][sp][x],Derivative[2][s\
p][x],Integrate[sp[y],{y,1,#}]&[x]}, {x,1,5}, FrameLabel->{\"x\"}, Thickness->2, Legend->{\"sp[x]\",\"sp'[x]\",\"sp''[x]\",\"Int s\
p[x]\"}];\n   Update[];\n\n<Spline.png"[1,Max[p0$2227,0]]//"<img  class=\"eqs\" SRC=\""//equ$2227//"\" />"//
Help2HTML`oy$["Spline returns data for cubic-spline interpolation.\n\nUsage:   sp = Spline[list, [Derivative->{dy1,dy2}] ]\n\nwher\
e list contains data in the form as {{x1,y1}, ..} or {{x1,{y11, y12, ..}}, ..}.\n Complex number can be allowed for y, but not for\
 x.\n\n This spline assumes y''=0 at the boundary, unless Derivative->{dy1,dy2} is specified to constrain the derivative at each e\
nd to dy1 or dy2. They can be Null to unspecify the constraint at one of the boundary. The resulting data of the spline is assigne\
d sp as a SplineData object. Then one can calculate the interpolated data by\n\n    sp[x]                     value of y at x.\n  \
  Derivative[1][sp][x]      value of y' at x.\n    Derivative[2][sp][x]      value of y'' at x.\n    Integrate[sp[x],{x, x0, x1}] \
  integral of sp[x] from x0 to x1.\n\nExample:\n   sp=Spline[{{1,2},{3,5},{4,2},{5,7}}];\n   Plot[{sp[x],Derivative[1][sp][x],Deri\
vative[2][sp][x],Integrate[sp[y],{y,1,#}]&[x]}, {x,1,5}, FrameLabel->{\"x\"}, Thickness->2, Legend->{\"sp[x]\",\"sp'[x]\",\"sp''[x\
]\",\"Int sp[x]\"}];\n   Update[];\n\n<Spline.png"[p2$2227,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L42>defining-functions</A> <A HREF=#L424>Plot</A> <A HREF=#L363>NIntegrate</A></PRE>
</UL>
<LI>
<H3><A NAME=L366>
DownhillSimplex</A></H3>
<PRE>If[{},
Help2HTML`oA$["Usage: DownhillSimplex[initial, f, options]\n\nminimizes a function f by the downhill simplex method, starting from\
 an initial simplex initial.  Suppose f is a function of n variables.   Then  initial is a list of n+1 elements, each of which is \
a list of the form\n\n   {f[vi], vi} ,\n\nwhere vi is a list of n values corresponding to each variable. The initial must be sorte\
d in ascending order of f, i.e.,\n\n   initial=Sort[Map[{f[#],#}&,vlist]]\n\ngenerates initial from a list of variables vlist.\n  \
 DownhillSimplex returns the final simplex in the same form as initial.\n\nOptions:\n   VariableRange -> {{min1 .. minn}, {max1 ..\
 maxn}} gives the range of n\n      variables.   The default is -Infinity to Infinity for all variables.\n   MaxIteration -> maxi \
gives the limit of number of iterations.   The\n      default is Max[100, 10*(n+1)].\n   Output -> lfn sets the output file number\
 for the intermediate results.\n      the default is 6 (stdout).\n   Tolerance -> tol sets the tolerance to judge the local minimu\
m.\n      If (fmax-fmin)/(abs(fmax)+abs(fmin)) becomes less than tol, the \n      iteration loop terminates.   The default is 10^-\
6.\n\nExamples:\n  f:=Apply[Function[{x,y},((x^2+y^2)-1)*(x^2+y^2)-(x-.5)/3.],#]&;\n  v={{1.,1.},{0.,-1.},{0.,1.}};\n  limit={{-0.\
5,-1.5},{0.65,1.5}};\n  p=Sort[Map[{f[#],#}&,v]]\n  DownhillSimplex[p,f,MaxIteration->100,\n     Tolerance->1e-4,VariableRange->li\
mit]"],
p$2230=1+p$2230[[1,2]];p1$2230=StringPosition["Usage: DownhillSimplex[initial, f, options]\n\nminimizes a function f by the downhi\
ll simplex method, starting from an initial simplex initial.  Suppose f is a function of n variables.   Then  initial is a list of\
 n+1 elements, each of which is a list of the form\n\n   {f[vi], vi} ,\n\nwhere vi is a list of n values corresponding to each var\
iable. The initial must be sorted in ascending order of f, i.e.,\n\n   initial=Sort[Map[{f[#],#}&,vlist]]\n\ngenerates initial fro\
m a list of variables vlist.\n   DownhillSimplex returns the final simplex in the same form as initial.\n\nOptions:\n   VariableRa\
nge -> {{min1 .. minn}, {max1 .. maxn}} gives the range of n\n      variables.   The default is -Infinity to Infinity for all vari\
ables.\n   MaxIteration -> maxi gives the limit of number of iterations.   The\n      default is Max[100, 10*(n+1)].\n   Output ->\
 lfn sets the output file number for the intermediate results.\n      the default is 6 (stdout).\n   Tolerance -> tol sets the tol\
erance to judge the local minimum.\n      If (fmax-fmin)/(abs(fmax)+abs(fmin)) becomes less than tol, the \n      iteration loop t\
erminates.   The default is 10^-6.\n\nExamples:\n  f:=Apply[Function[{x,y},((x^2+y^2)-1)*(x^2+y^2)-(x-.5)/3.],#]&;\n  v={{1.,1.},{\
0.,-1.},{0.,1.}};\n  limit={{-0.5,-1.5},{0.65,1.5}};\n  p=Sort[Map[{f[#],#}&,v]]\n  DownhillSimplex[p,f,MaxIteration->100,\n     T\
olerance->1e-4,VariableRange->limit]"[p$2230,-1],">::",1];
   p1$2230=If[p1$2230==={},1389,-2+p$2230+p1$2230[[1,1]]];
neq=Which["Usage: DownhillSimplex[initial, f, options]\n\nminimizes a function f by the downhill simplex method, starting from an \
initial simplex initial.  Suppose f is a function of n variables.   Then  initial is a list of n+1 elements, each of which is a li\
st of the form\n\n   {f[vi], vi} ,\n\nwhere vi is a list of n values corresponding to each variable. The initial must be sorted in\
 ascending order of f, i.e.,\n\n   initial=Sort[Map[{f[#],#}&,vlist]]\n\ngenerates initial from a list of variables vlist.\n   Dow\
nhillSimplex returns the final simplex in the same form as initial.\n\nOptions:\n   VariableRange -> {{min1 .. minn}, {max1 .. max\
n}} gives the range of n\n      variables.   The default is -Infinity to Infinity for all variables.\n   MaxIteration -> maxi give\
s the limit of number of iterations.   The\n      default is Max[100, 10*(n+1)].\n   Output -> lfn sets the output file number for\
 the intermediate results.\n      the default is 6 (stdout).\n   Tolerance -> tol sets the tolerance to judge the local minimum.\n\
      If (fmax-fmin)/(abs(fmax)+abs(fmin)) becomes less than tol, the \n      iteration loop terminates.   The default is 10^-6.\n\
\nExamples:\n  f:=Apply[Function[{x,y},((x^2+y^2)-1)*(x^2+y^2)-(x-.5)/3.],#]&;\n  v={{1.,1.},{0.,-1.},{0.,1.}};\n  limit={{-0.5,-1\
.5},{0.65,1.5}};\n  p=Sort[Map[{f[#],#}&,v]]\n  DownhillSimplex[p,f,MaxIteration->100,\n     Tolerance->1e-4,VariableRange->limit]"
     [p$2230,4+p$2230]==="Text[",
    lx$2230:=Help2HTML`oa$;p$2230=5+p$2230;p1$2230-=1;p2$2230=5+p1$2230;p0$2230=-9+p$2230;If[(pe$2230=StringPosition["Usage: Downh\
illSimplex[initial, f, options]\n\nminimizes a function f by the downhill simplex method, starting from an initial simplex initial\
.  Suppose f is a function of n variables.   Then  initial is a list of n+1 elements, each of which is a list of the form\n\n   {f\
[vi], vi} ,\n\nwhere vi is a list of n values corresponding to each variable. The initial must be sorted in ascending order of f, \
i.e.,\n\n   initial=Sort[Map[{f[#],#}&,vlist]]\n\ngenerates initial from a list of variables vlist.\n   DownhillSimplex returns th\
e final simplex in the same form as initial.\n\nOptions:\n   VariableRange -> {{min1 .. minn}, {max1 .. maxn}} gives the range of \
n\n      variables.   The default is -Infinity to Infinity for all variables.\n   MaxIteration -> maxi gives the limit of number o\
f iterations.   The\n      default is Max[100, 10*(n+1)].\n   Output -> lfn sets the output file number for the intermediate resul\
ts.\n      the default is 6 (stdout).\n   Tolerance -> tol sets the tolerance to judge the local minimum.\n      If (fmax-fmin)/(a\
bs(fmax)+abs(fmin)) becomes less than tol, the \n      iteration loop terminates.   The default is 10^-6.\n\nExamples:\n  f:=Apply\
[Function[{x,y},((x^2+y^2)-1)*(x^2+y^2)-(x-.5)/3.],#]&;\n  v={{1.,1.},{0.,-1.},{0.,1.}};\n  limit={{-0.5,-1.5},{0.65,1.5}};\n  p=S\
ort[Map[{f[#],#}&,v]]\n  DownhillSimplex[p,f,MaxIteration->100,\n     Tolerance->1e-4,VariableRange->limit]"[p$2230,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Usage: DownhillSimplex[initial, f, options]\n\nminimizes a function f by the downhill simplex method, starting fr\
om an initial simplex initial.  Suppose f is a function of n variables.   Then  initial is a list of n+1 elements, each of which i\
s a list of the form\n\n   {f[vi], vi} ,\n\nwhere vi is a list of n values corresponding to each variable. The initial must be sor\
ted in ascending order of f, i.e.,\n\n   initial=Sort[Map[{f[#],#}&,vlist]]\n\ngenerates initial from a list of variables vlist.\n\
   DownhillSimplex returns the final simplex in the same form as initial.\n\nOptions:\n   VariableRange -> {{min1 .. minn}, {max1 \
.. maxn}} gives the range of n\n      variables.   The default is -Infinity to Infinity for all variables.\n   MaxIteration -> max\
i gives the limit of number of iterations.   The\n      default is Max[100, 10*(n+1)].\n   Output -> lfn sets the output file numb\
er for the intermediate results.\n      the default is 6 (stdout).\n   Tolerance -> tol sets the tolerance to judge the local mini\
mum.\n      If (fmax-fmin)/(abs(fmax)+abs(fmin)) becomes less than tol, the \n      iteration loop terminates.   The default is 10\
^-6.\n\nExamples:\n  f:=Apply[Function[{x,y},((x^2+y^2)-1)*(x^2+y^2)-(x-.5)/3.],#]&;\n  v={{1.,1.},{0.,-1.},{0.,1.}};\n  limit={{-\
0.5,-1.5},{0.65,1.5}};\n  p=Sort[Map[{f[#],#}&,v]]\n  DownhillSimplex[p,f,MaxIteration->100,\n     Tolerance->1e-4,VariableRange->\
limit]"[p$2230+pe$2230[[1,2]],p1$2230]]],
        p1$2230=-2+p$2230+pe$2230[[1,1]]}[[
       1]],
      0],
    1,lx$2230:=Help2HTML`o9$;p2$2230=4+p1$2230;p0$2230=-4+p$2230;0];
  If[(equ$2230=
Help2HTML`o8$["Usage: DownhillSimplex[initial, f, options]\n\nminimizes a function f by the downhill simplex method, starting from\
 an initial simplex initial.  Suppose f is a function of n variables.   Then  initial is a list of n+1 elements, each of which is \
a list of the form\n\n   {f[vi], vi} ,\n\nwhere vi is a list of n values corresponding to each variable. The initial must be sorte\
d in ascending order of f, i.e.,\n\n   initial=Sort[Map[{f[#],#}&,vlist]]\n\ngenerates initial from a list of variables vlist.\n  \
 DownhillSimplex returns the final simplex in the same form as initial.\n\nOptions:\n   VariableRange -> {{min1 .. minn}, {max1 ..\
 maxn}} gives the range of n\n      variables.   The default is -Infinity to Infinity for all variables.\n   MaxIteration -> maxi \
gives the limit of number of iterations.   The\n      default is Max[100, 10*(n+1)].\n   Output -> lfn sets the output file number\
 for the intermediate results.\n      the default is 6 (stdout).\n   Tolerance -> tol sets the tolerance to judge the local minimu\
m.\n      If (fmax-fmin)/(abs(fmax)+abs(fmin)) becomes less than tol, the \n      iteration loop terminates.   The default is 10^-\
6.\n\nExamples:\n  f:=Apply[Function[{x,y},((x^2+y^2)-1)*(x^2+y^2)-(x-.5)/3.],#]&;\n  v={{1.,1.},{0.,-1.},{0.,1.}};\n  limit={{-0.\
5,-1.5},{0.65,1.5}};\n  p=Sort[Map[{f[#],#}&,v]]\n  DownhillSimplex[p,f,MaxIteration->100,\n     Tolerance->1e-4,VariableRange->li\
mit]"[p$2230,p1$2230]])===
    Undefined,
equ$2230="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Usage: DownhillSimplex[initial, f, options]\\
n\nminimizes a function f by the downhill simplex method, starting from an initial simplex initial.  Suppose f is a function of n \
variables.   Then  initial is a list of n+1 elements, each of which is a list of the form\n\n   {f[vi], vi} ,\n\nwhere vi is a lis\
t of n values corresponding to each variable. The initial must be sorted in ascending order of f, i.e.,\n\n   initial=Sort[Map[{f[\
#],#}&,vlist]]\n\ngenerates initial from a list of variables vlist.\n   DownhillSimplex returns the final simplex in the same form\
 as initial.\n\nOptions:\n   VariableRange -> {{min1 .. minn}, {max1 .. maxn}} gives the range of n\n      variables.   The defaul\
t is -Infinity to Infinity for all variables.\n   MaxIteration -> maxi gives the limit of number of iterations.   The\n      defau\
lt is Max[100, 10*(n+1)].\n   Output -> lfn sets the output file number for the intermediate results.\n      the default is 6 (std\
out).\n   Tolerance -> tol sets the tolerance to judge the local minimum.\n      If (fmax-fmin)/(abs(fmax)+abs(fmin)) becomes less\
 than tol, the \n      iteration loop terminates.   The default is 10^-6.\n\nExamples:\n  f:=Apply[Function[{x,y},((x^2+y^2)-1)*(x\
^2+y^2)-(x-.5)/3.],#]&;\n  v={{1.,1.},{0.,-1.},{0.,1.}};\n  limit={{-0.5,-1.5},{0.65,1.5}};\n  p=Sort[Map[{f[#],#}&,v]]\n  Downhil\
lSimplex[p,f,MaxIteration->100,\n     Tolerance->1e-4,VariableRange->limit]"[p$2230,p1$2230]]=
       equ$2230;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2230},out$2230=lx$2230@Typeset["Usage: DownhillSimplex[initial, f, options]\n\nminimizes a function f by the downhill sim\
plex method, starting from an initial simplex initial.  Suppose f is a function of n variables.   Then  initial is a list of n+1 e\
lements, each of which is a list of the form\n\n   {f[vi], vi} ,\n\nwhere vi is a list of n values corresponding to each variable.\
 The initial must be sorted in ascending order of f, i.e.,\n\n   initial=Sort[Map[{f[#],#}&,vlist]]\n\ngenerates initial from a li\
st of variables vlist.\n   DownhillSimplex returns the final simplex in the same form as initial.\n\nOptions:\n   VariableRange ->\
 {{min1 .. minn}, {max1 .. maxn}} gives the range of n\n      variables.   The default is -Infinity to Infinity for all variables.\
\n   MaxIteration -> maxi gives the limit of number of iterations.   The\n      default is Max[100, 10*(n+1)].\n   Output -> lfn s\
ets the output file number for the intermediate results.\n      the default is 6 (stdout).\n   Tolerance -> tol sets the tolerance\
 to judge the local minimum.\n      If (fmax-fmin)/(abs(fmax)+abs(fmin)) becomes less than tol, the \n      iteration loop termina\
tes.   The default is 10^-6.\n\nExamples:\n  f:=Apply[Function[{x,y},((x^2+y^2)-1)*(x^2+y^2)-(x-.5)/3.],#]&;\n  v={{1.,1.},{0.,-1.\
},{0.,1.}};\n  limit={{-0.5,-1.5},{0.65,1.5}};\n  p=Sort[Map[{f[#],#}&,v]]\n  DownhillSimplex[p,f,MaxIteration->100,\n     Toleran\
ce->1e-4,VariableRange->limit]"[p$2230,p1$2230],Format->Help2HTML`oB$];
        System["mv -f "//out$2230//" "//equ$2230]];
      Exit[]]];
   "Usage: DownhillSimplex[initial, f, options]\n\nminimizes a function f by the downhill simplex method, starting from an initial\
 simplex initial.  Suppose f is a function of n variables.   Then  initial is a list of n+1 elements, each of which is a list of t\
he form\n\n   {f[vi], vi} ,\n\nwhere vi is a list of n values corresponding to each variable. The initial must be sorted in ascend\
ing order of f, i.e.,\n\n   initial=Sort[Map[{f[#],#}&,vlist]]\n\ngenerates initial from a list of variables vlist.\n   DownhillSi\
mplex returns the final simplex in the same form as initial.\n\nOptions:\n   VariableRange -> {{min1 .. minn}, {max1 .. maxn}} giv\
es the range of n\n      variables.   The default is -Infinity to Infinity for all variables.\n   MaxIteration -> maxi gives the l\
imit of number of iterations.   The\n      default is Max[100, 10*(n+1)].\n   Output -> lfn sets the output file number for the in\
termediate results.\n      the default is 6 (stdout).\n   Tolerance -> tol sets the tolerance to judge the local minimum.\n      I\
f (fmax-fmin)/(abs(fmax)+abs(fmin)) becomes less than tol, the \n      iteration loop terminates.   The default is 10^-6.\n\nExamp\
les:\n  f:=Apply[Function[{x,y},((x^2+y^2)-1)*(x^2+y^2)-(x-.5)/3.],#]&;\n  v={{1.,1.},{0.,-1.},{0.,1.}};\n  limit={{-0.5,-1.5},{0.\
65,1.5}};\n  p=Sort[Map[{f[#],#}&,v]]\n  DownhillSimplex[p,f,MaxIteration->100,\n     Tolerance->1e-4,VariableRange->limit]"[1,
    Max[p0$2230,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2230//"\" />"//
Help2HTML`oy$["Usage: DownhillSimplex[initial, f, options]\n\nminimizes a function f by the downhill simplex method, starting from\
 an initial simplex initial.  Suppose f is a function of n variables.   Then  initial is a list of n+1 elements, each of which is \
a list of the form\n\n   {f[vi], vi} ,\n\nwhere vi is a list of n values corresponding to each variable. The initial must be sorte\
d in ascending order of f, i.e.,\n\n   initial=Sort[Map[{f[#],#}&,vlist]]\n\ngenerates initial from a list of variables vlist.\n  \
 DownhillSimplex returns the final simplex in the same form as initial.\n\nOptions:\n   VariableRange -> {{min1 .. minn}, {max1 ..\
 maxn}} gives the range of n\n      variables.   The default is -Infinity to Infinity for all variables.\n   MaxIteration -> maxi \
gives the limit of number of iterations.   The\n      default is Max[100, 10*(n+1)].\n   Output -> lfn sets the output file number\
 for the intermediate results.\n      the default is 6 (stdout).\n   Tolerance -> tol sets the tolerance to judge the local minimu\
m.\n      If (fmax-fmin)/(abs(fmax)+abs(fmin)) becomes less than tol, the \n      iteration loop terminates.   The default is 10^-\
6.\n\nExamples:\n  f:=Apply[Function[{x,y},((x^2+y^2)-1)*(x^2+y^2)-(x-.5)/3.],#]&;\n  v={{1.,1.},{0.,-1.},{0.,1.}};\n  limit={{-0.\
5,-1.5},{0.65,1.5}};\n  p=Sort[Map[{f[#],#}&,v]]\n  DownhillSimplex[p,f,MaxIteration->100,\n     Tolerance->1e-4,VariableRange->li\
mit]"[p2$2230,-1]]
]</PRE>
<PRE>See also:
 FFS-dedicated-functions:OptimizeOptics</PRE>
<LI>
<H3><A NAME=L367>
functional-operations</A></H3>
<PRE>
</PRE>
<UL>
<LI>
<H3><A NAME=L368>
Apply</A></H3>
<PRE>If[{},
Help2HTML`oA$["   Apply[f, x [, level]] or f@@x [f@@[x, level]] \n\ntakes the bod of a list x as the argument sequence of f, and r\
eturns the result:\n\nf@@{a, b, c} ===> f[a, b, c]\n\nAn optional argument specifies the level-spec."],
 p$2234=1+p$2234[[1,2]];p1$2234=
StringPosition["   Apply[f, x [, level]] or f@@x [f@@[x, level]] \n\ntakes the bod of a list x as the argument sequence of f, and \
returns the result:\n\nf@@{a, b, c} ===> f[a, b, c]\n\nAn optional argument specifies the level-spec."[p$2234,-1],">::",1];
   p1$2234=If[p1$2234==={},209,-2+p$2234+p1$2234[[1,1]]];
neq=Which["   Apply[f, x [, level]] or f@@x [f@@[x, level]] \n\ntakes the bod of a list x as the argument sequence of f, and retur\
ns the result:\n\nf@@{a, b, c} ===> f[a, b, c]\n\nAn optional argument specifies the level-spec."[p$2234,4+p$2234]==="Text[",
    lx$2234:=Help2HTML`oa$;p$2234=5+p$2234;p1$2234-=1;p2$2234=5+p1$2234;p0$2234=-9+p$2234;
If[(pe$2234=StringPosition["   Apply[f, x [, level]] or f@@x [f@@[x, level]] \n\ntakes the bod of a list x as the argument sequenc\
e of f, and returns the result:\n\nf@@{a, b, c} ===> f[a, b, c]\n\nAn optional argument specifies the level-spec."[p$2234,-2],";;;"
         ])<=>
       {},
      {Max[0,
-1+ToExpression["   Apply[f, x [, level]] or f@@x [f@@[x, level]] \n\ntakes the bod of a list x as the argument sequence of f, and\
 returns the result:\n\nf@@{a, b, c} ===> f[a, b, c]\n\nAn optional argument specifies the level-spec."[p$2234+pe$2234[[1,2]],
           p1$2234]]],
        p1$2234=-2+p$2234+pe$2234[[1,1]]}[[
       1]],
      0],
    1,lx$2234:=Help2HTML`o9$;p2$2234=4+p1$2234;p0$2234=-4+p$2234;0];
  If[(equ$2234=
Help2HTML`o8$["   Apply[f, x [, level]] or f@@x [f@@[x, level]] \n\ntakes the bod of a list x as the argument sequence of f, and r\
eturns the result:\n\nf@@{a, b, c} ===> f[a, b, c]\n\nAn optional argument specifies the level-spec."[p$2234,p1$2234]])===
    Undefined,
equ$2234="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["   Apply[f, x [, level]] or f@@x [f@@[x, lev\
el]] \n\ntakes the bod of a list x as the argument sequence of f, and returns the result:\n\nf@@{a, b, c} ===> f[a, b, c]\n\nAn op\
tional argument specifies the level-spec."[p$2234,p1$2234]]=
       equ$2234;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2234},out$2234=lx$2234@Typeset["   Apply[f, x [, level]] or f@@x [f@@[x, level]] \n\ntakes the bod of a list x as the arg\
ument sequence of f, and returns the result:\n\nf@@{a, b, c} ===> f[a, b, c]\n\nAn optional argument specifies the level-spec."[p
           $2234,p1$2234],Format->Help2HTML`oB$];
        System["mv -f "//out$2234//" "//equ$2234]];
      Exit[]]];
   "   Apply[f, x [, level]] or f@@x [f@@[x, level]] \n\ntakes the bod of a list x as the argument sequence of f, and returns the \
result:\n\nf@@{a, b, c} ===> f[a, b, c]\n\nAn optional argument specifies the level-spec."[1,Max[p0$2234,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2234//"\" />"//
Help2HTML`oy$["   Apply[f, x [, level]] or f@@x [f@@[x, level]] \n\ntakes the bod of a list x as the argument sequence of f, and r\
eturns the result:\n\nf@@{a, b, c} ===> f[a, b, c]\n\nAn optional argument specifies the level-spec."[p2$2234,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L252>Apply (@@)</A> <A HREF=#L375>Map</A> <A HREF=#L378>Scan</A> <A HREF=#L376>MapThread</A> <A HREF=#L374>level-spec</A></PRE>
<LI>
<H3><A NAME=L369>
Cases</A></H3>
<PRE>If[{},
Help2HTML`oA$["   Cases[l, pat [, level [,n]]]\n\nreturns a list of parts of l, which match a pattern pat. Optional level-spec l a\
nd the maximum number of results n can be specified."],
p$2237=1+p$2237[[1,2]];p1$2237=StringPosition["   Cases[l, pat [, level [,n]]]\n\nreturns a list of parts of l, which match a patt\
ern pat. Optional level-spec l and the maximum number of results n can be specified."[p$2237,-1],">::",1];
   p1$2237=If[p1$2237==={},165,-2+p$2237+p1$2237[[1,1]]];
neq=Which["   Cases[l, pat [, level [,n]]]\n\nreturns a list of parts of l, which match a pattern pat. Optional level-spec l and t\
he maximum number of results n can be specified."[p$2237,4+p$2237]==="Text[",
    lx$2237:=Help2HTML`oa$;p$2237=5+p$2237;p1$2237-=1;p2$2237=5+p1$2237;p0$2237=-9+p$2237;
If[(pe$2237=StringPosition["   Cases[l, pat [, level [,n]]]\n\nreturns a list of parts of l, which match a pattern pat. Optional l\
evel-spec l and the maximum number of results n can be specified."[p$2237,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["   Cases[l, pat [, level [,n]]]\n\nreturns a list of parts of l, which match a pattern pat. Optional level-spec l\
 and the maximum number of results n can be specified."[p$2237+pe$2237[[1,2]],p1$2237]]],
        p1$2237=-2+p$2237+pe$2237[[1,1]]}[[
       1]],
      0],
    1,lx$2237:=Help2HTML`o9$;p2$2237=4+p1$2237;p0$2237=-4+p$2237;0];
  If[(equ$2237=
Help2HTML`o8$["   Cases[l, pat [, level [,n]]]\n\nreturns a list of parts of l, which match a pattern pat. Optional level-spec l a\
nd the maximum number of results n can be specified."[p$2237,p1$2237]])===
    Undefined,
equ$2237="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["   Cases[l, pat [, level [,n]]]\n\nreturns a\
 list of parts of l, which match a pattern pat. Optional level-spec l and the maximum number of results n can be specified."[p$2237
         ,p1$2237]]=
       equ$2237;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2237},out$2237=lx$2237@Typeset["   Cases[l, pat [, level [,n]]]\n\nreturns a list of parts of l, which match a pattern pa\
t. Optional level-spec l and the maximum number of results n can be specified."[p$2237,p1$2237],Format->Help2HTML`oB$];
        System["mv -f "//out$2237//" "//equ$2237]];
      Exit[]]];
   "   Cases[l, pat [, level [,n]]]\n\nreturns a list of parts of l, which match a pattern pat. Optional level-spec l and the maxi\
mum number of results n can be specified."[1,Max[p0$2237,0]]//"<img  class=\"eqs\" SRC=\""//equ$2237//"\" />"//
Help2HTML`oy$["   Cases[l, pat [, level [,n]]]\n\nreturns a list of parts of l, which match a pattern pat. Optional level-spec l a\
nd the maximum number of results n can be specified."[p2$2237,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L374>level-spec</A> <A HREF=#L481>pattern</A> <A HREF=#L377>Position</A> Deletecases</PRE>
<LI>
<H3><A NAME=L370>
DeleteCases</A></H3>
<PRE>If[{},
Help2HTML`oA$["   DeleteCases[l, pat [, level [,n]]]\n\nreturns a list of parts of l, which do not match a pattern pat. Optional l\
evel-spec l and the maximum number of results n can be specified."],
p$2240=1+p$2240[[1,2]];p1$2240=StringPosition["   DeleteCases[l, pat [, level [,n]]]\n\nreturns a list of parts of l, which do not\
 match a pattern pat. Optional level-spec l and the maximum number of results n can be specified."[p$2240,-1],">::",1];
   p1$2240=If[p1$2240==={},178,-2+p$2240+p1$2240[[1,1]]];
neq=Which["   DeleteCases[l, pat [, level [,n]]]\n\nreturns a list of parts of l, which do not match a pattern pat. Optional level\
-spec l and the maximum number of results n can be specified."[p$2240,4+p$2240]==="Text[",
    lx$2240:=Help2HTML`oa$;p$2240=5+p$2240;p1$2240-=1;p2$2240=5+p1$2240;p0$2240=-9+p$2240;
If[(pe$2240=StringPosition["   DeleteCases[l, pat [, level [,n]]]\n\nreturns a list of parts of l, which do not match a pattern pa\
t. Optional level-spec l and the maximum number of results n can be specified."[p$2240,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["   DeleteCases[l, pat [, level [,n]]]\n\nreturns a list of parts of l, which do not match a pattern pat. Optional\
 level-spec l and the maximum number of results n can be specified."[p$2240+pe$2240[[1,2]],p1$2240]]],
        p1$2240=-2+p$2240+pe$2240[[1,1]]}[[
       1]],
      0],
    1,lx$2240:=Help2HTML`o9$;p2$2240=4+p1$2240;p0$2240=-4+p$2240;0];
  If[(equ$2240=
Help2HTML`o8$["   DeleteCases[l, pat [, level [,n]]]\n\nreturns a list of parts of l, which do not match a pattern pat. Optional l\
evel-spec l and the maximum number of results n can be specified."[p$2240,p1$2240]])===
    Undefined,
equ$2240="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["   DeleteCases[l, pat [, level [,n]]]\n\nret\
urns a list of parts of l, which do not match a pattern pat. Optional level-spec l and the maximum number of results n can be spec\
ified."[p$2240,p1$2240]]=
       equ$2240;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2240},out$2240=lx$2240@Typeset["   DeleteCases[l, pat [, level [,n]]]\n\nreturns a list of parts of l, which do not match\
 a pattern pat. Optional level-spec l and the maximum number of results n can be specified."[p$2240,p1$2240],
          Format->Help2HTML`oB$];
        System["mv -f "//out$2240//" "//equ$2240]];
      Exit[]]];
   "   DeleteCases[l, pat [, level [,n]]]\n\nreturns a list of parts of l, which do not match a pattern pat. Optional level-spec l\
 and the maximum number of results n can be specified."[1,Max[p0$2240,0]]//"<img  class=\"eqs\" SRC=\""//equ$2240//"\" />"//
   Help2HTML`oy$["   DeleteCases[l, pat [, level [,n]]]\n\nreturns a list of parts of l, which do not match a pattern pat. Optiona\
l level-spec l and the maximum number of results n can be specified."[p2$2240,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L374>level-spec</A> <A HREF=#L481>pattern</A> <A HREF=#L369>Cases</A> <A HREF=#L377>Position</A></PRE>
<LI>
<H3><A NAME=L371>
Difference</A></H3>
<PRE>If[{},Help2HTML`oA$["Difference[list] returns Rest[list] - Drop[list, -1] ."],
 p$2243=1+p$2243[[1,2]];p1$2243=StringPosition["Difference[list] returns Rest[list] - Drop[list, -1] ."[p$2243,-1],">::",1];
  p1$2243=If[p1$2243==={},54,-2+p$2243+p1$2243[[1,1]]];
  neq=Which["Difference[list] returns Rest[list] - Drop[list, -1] ."[p$2243,4+p$2243]==="Text[",
    lx$2243:=Help2HTML`oa$;p$2243=5+p$2243;p1$2243-=1;p2$2243=5+p1$2243;p0$2243=-9+p$2243;
     If[(pe$2243=StringPosition["Difference[list] returns Rest[list] - Drop[list, -1] ."[p$2243,-2],";;;"])<=>{},
      {Max[0,-1+ToExpression["Difference[list] returns Rest[list] - Drop[list, -1] ."[p$2243+pe$2243[[1,2]],p1$2243]]],
       p1$2243=-2+p$2243+pe$2243[[1,1]]}[[1]],
      0],
    1,lx$2243:=Help2HTML`o9$;p2$2243=4+p1$2243;p0$2243=-4+p$2243;0];
  If[(equ$2243=Help2HTML`o8$["Difference[list] returns Rest[list] - Drop[list, -1] ."[p$2243,p1$2243]])===Undefined,
   equ$2243="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["Difference[list] returns Rest[list] - Drop[list, -1] ."[p$2243,p1$2243]]=equ$2243;LaTeX`ob$+=neq,
     --LaTeX`ob$;
      With[{lx$2243},out$2243=lx$2243@Typeset["Difference[list] returns Rest[list] - Drop[list, -1] ."[p$2243,p1$2243],Format->
           Help2HTML`oB$];
        System["mv -f "//out$2243//" "//equ$2243]];
      Exit[]]];
   "Difference[list] returns Rest[list] - Drop[list, -1] ."[1,Max[p0$2243,0]]//"<img  class=\"eqs\" SRC=\""//equ$2243//"\" />"//
   Help2HTML`oy$["Difference[list] returns Rest[list] - Drop[list, -1] ."[p2$2243,-1]]
]</PRE>
<LI>
<H3><A NAME=L372>
FixedPoint</A></H3>
<PRE>If[{},
Help2HTML`oA$["FixedPoint[f, e] starts from f[e] then applies f repeatedly until the result no longer changes. FixedPoint[f, e, n]\
 specifies the maximum number of iterations by n. An option SameTest->s specifies the test function. Threshold->re, and AbsoluteTh\
reshold->ae set the relative and absolute accuracy, respectively, when SameTest->NearlySameQ (default)."],
 p$2245=1+p$2245[[1,2]];p1$2245=
StringPosition["FixedPoint[f, e] starts from f[e] then applies f repeatedly until the result no longer changes. FixedPoint[f, e, n\
] specifies the maximum number of iterations by n. An option SameTest->s specifies the test function. Threshold->re, and AbsoluteT\
hreshold->ae set the relative and absolute accuracy, respectively, when SameTest->NearlySameQ (default)."[p$2245,-1],">::",1];
   p1$2245=If[p1$2245==={},348,-2+p$2245+p1$2245[[1,1]]];
neq=Which["FixedPoint[f, e] starts from f[e] then applies f repeatedly until the result no longer changes. FixedPoint[f, e, n] spe\
cifies the maximum number of iterations by n. An option SameTest->s specifies the test function. Threshold->re, and AbsoluteThresh\
old->ae set the relative and absolute accuracy, respectively, when SameTest->NearlySameQ (default)."[p$2245,4+p$2245]==="Text[",
    lx$2245:=Help2HTML`oa$;p$2245=5+p$2245;p1$2245-=1;p2$2245=5+p1$2245;p0$2245=-9+p$2245;
If[(pe$2245=StringPosition["FixedPoint[f, e] starts from f[e] then applies f repeatedly until the result no longer changes. FixedP\
oint[f, e, n] specifies the maximum number of iterations by n. An option SameTest->s specifies the test function. Threshold->re, a\
nd AbsoluteThreshold->ae set the relative and absolute accuracy, respectively, when SameTest->NearlySameQ (default)."[p$2245,-2],
         ";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["FixedPoint[f, e] starts from f[e] then applies f repeatedly until the result no longer changes. FixedPoint[f, e, \
n] specifies the maximum number of iterations by n. An option SameTest->s specifies the test function. Threshold->re, and Absolute\
Threshold->ae set the relative and absolute accuracy, respectively, when SameTest->NearlySameQ (default)."[p$2245+pe$2245[[1,2]],
           p1$2245]]],
        p1$2245=-2+p$2245+pe$2245[[1,1]]}[[
       1]],
      0],
    1,lx$2245:=Help2HTML`o9$;p2$2245=4+p1$2245;p0$2245=-4+p$2245;0];
  If[(equ$2245=
Help2HTML`o8$["FixedPoint[f, e] starts from f[e] then applies f repeatedly until the result no longer changes. FixedPoint[f, e, n]\
 specifies the maximum number of iterations by n. An option SameTest->s specifies the test function. Threshold->re, and AbsoluteTh\
reshold->ae set the relative and absolute accuracy, respectively, when SameTest->NearlySameQ (default)."[p$2245,p1$2245]])===
    Undefined,
equ$2245="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["FixedPoint[f, e] starts from f[e] then appli\
es f repeatedly until the result no longer changes. FixedPoint[f, e, n] specifies the maximum number of iterations by n. An option\
 SameTest->s specifies the test function. Threshold->re, and AbsoluteThreshold->ae set the relative and absolute accuracy, respect\
ively, when SameTest->NearlySameQ (default)."[p$2245,p1$2245]]=
       equ$2245;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2245},out$2245=lx$2245@Typeset["FixedPoint[f, e] starts from f[e] then applies f repeatedly until the result no longer ch\
anges. FixedPoint[f, e, n] specifies the maximum number of iterations by n. An option SameTest->s specifies the test function. Thr\
eshold->re, and AbsoluteThreshold->ae set the relative and absolute accuracy, respectively, when SameTest->NearlySameQ (default)."[
           p$2245,p1$2245],Format->Help2HTML`oB$];
        System["mv -f "//out$2245//" "//equ$2245]];
      Exit[]]];
   "FixedPoint[f, e] starts from f[e] then applies f repeatedly until the result no longer changes. FixedPoint[f, e, n] specifies \
the maximum number of iterations by n. An option SameTest->s specifies the test function. Threshold->re, and AbsoluteThreshold->ae\
 set the relative and absolute accuracy, respectively, when SameTest->NearlySameQ (default)."[1,Max[p0$2245,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2245//"\" />"//
Help2HTML`oy$["FixedPoint[f, e] starts from f[e] then applies f repeatedly until the result no longer changes. FixedPoint[f, e, n]\
 specifies the maximum number of iterations by n. An option SameTest->s specifies the test function. Threshold->re, and AbsoluteTh\
reshold->ae set the relative and absolute accuracy, respectively, when SameTest->NearlySameQ (default)."[p2$2245,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L373>FixedPointList</A></PRE>
<LI>
<H3><A NAME=L373>
FixedPointList</A></H3>
<PRE>If[{},
Help2HTML`oA$["FixedPointList[f, e] returns the intermediate values of FixedPoint[f, e] as a list. FixedPointList[f, e, n] and opt\
ions for FixedPoint are valid."],
p$2248=1+p$2248[[1,2]];p1$2248=StringPosition["FixedPointList[f, e] returns the intermediate values of FixedPoint[f, e] as a list.\
 FixedPointList[f, e, n] and options for FixedPoint are valid."[p$2248,-1],">::",1];
   p1$2248=If[p1$2248==={},145,-2+p$2248+p1$2248[[1,1]]];
neq=Which["FixedPointList[f, e] returns the intermediate values of FixedPoint[f, e] as a list. FixedPointList[f, e, n] and options\
 for FixedPoint are valid."[p$2248,4+p$2248]==="Text[",
    lx$2248:=Help2HTML`oa$;p$2248=5+p$2248;p1$2248-=1;p2$2248=5+p1$2248;p0$2248=-9+p$2248;
If[(pe$2248=StringPosition["FixedPointList[f, e] returns the intermediate values of FixedPoint[f, e] as a list. FixedPointList[f, \
e, n] and options for FixedPoint are valid."[p$2248,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["FixedPointList[f, e] returns the intermediate values of FixedPoint[f, e] as a list. FixedPointList[f, e, n] and o\
ptions for FixedPoint are valid."[p$2248+pe$2248[[1,2]],p1$2248]]],
        p1$2248=-2+p$2248+pe$2248[[1,1]]}[[
       1]],
      0],
    1,lx$2248:=Help2HTML`o9$;p2$2248=4+p1$2248;p0$2248=-4+p$2248;0];
  If[(equ$2248=
Help2HTML`o8$["FixedPointList[f, e] returns the intermediate values of FixedPoint[f, e] as a list. FixedPointList[f, e, n] and opt\
ions for FixedPoint are valid."[p$2248,p1$2248]])===
    Undefined,
equ$2248="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["FixedPointList[f, e] returns the intermediat\
e values of FixedPoint[f, e] as a list. FixedPointList[f, e, n] and options for FixedPoint are valid."[p$2248,p1$2248]]=
       equ$2248;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2248},out$2248=lx$2248@Typeset["FixedPointList[f, e] returns the intermediate values of FixedPoint[f, e] as a list. Fixed\
PointList[f, e, n] and options for FixedPoint are valid."[p$2248,p1$2248],Format->Help2HTML`oB$];
        System["mv -f "//out$2248//" "//equ$2248]];
      Exit[]]];
   "FixedPointList[f, e] returns the intermediate values of FixedPoint[f, e] as a list. FixedPointList[f, e, n] and options for Fi\
xedPoint are valid."[1,Max[p0$2248,0]]//"<img  class=\"eqs\" SRC=\""//equ$2248//"\" />"//
Help2HTML`oy$["FixedPointList[f, e] returns the intermediate values of FixedPoint[f, e] as a list. FixedPointList[f, e, n] and opt\
ions for FixedPoint are valid."[p2$2248,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L372>FixedPoint</A></PRE>
<LI>
<H3><A NAME=L374>
level-spec</A></H3>
<PRE>If[{},
Help2HTML`oA$["Functions Map, Apply, Scan, Cases, Position, Count, Level, DeleteCases takes an optional argument level to specify \
which level to operate:\n\nvalue               operates\nn_Real              from level 1 through level n\n{n_Real}            onl\
y on level n\n{n1_Real, n2_Real}  from leveln1 through level n2\n\nIf n is negative, it counts from the deepest level of each elem\
ent.\n\nExamples: f@@[{{a, b}, {c, d}}, {1}] ===> {f[a, b], f[c, d]}"],
p$2251=1+p$2251[[1,2]];p1$2251=StringPosition["Functions Map, Apply, Scan, Cases, Position, Count, Level, DeleteCases takes an opt\
ional argument level to specify which level to operate:\n\nvalue               operates\nn_Real              from level 1 through \
level n\n{n_Real}            only on level n\n{n1_Real, n2_Real}  from leveln1 through level n2\n\nIf n is negative, it counts fro\
m the deepest level of each element.\n\nExamples: f@@[{{a, b}, {c, d}}, {1}] ===> {f[a, b], f[c, d]}"[p$2251,-1],">::",1];
   p1$2251=If[p1$2251==={},434,-2+p$2251+p1$2251[[1,1]]];
neq=Which["Functions Map, Apply, Scan, Cases, Position, Count, Level, DeleteCases takes an optional argument level to specify whic\
h level to operate:\n\nvalue               operates\nn_Real              from level 1 through level n\n{n_Real}            only on\
 level n\n{n1_Real, n2_Real}  from leveln1 through level n2\n\nIf n is negative, it counts from the deepest level of each element.\
\n\nExamples: f@@[{{a, b}, {c, d}}, {1}] ===> {f[a, b], f[c, d]}"[p$2251,4+p$2251]==="Text[",
    lx$2251:=Help2HTML`oa$;p$2251=5+p$2251;p1$2251-=1;p2$2251=5+p1$2251;p0$2251=-9+p$2251;
If[(pe$2251=StringPosition["Functions Map, Apply, Scan, Cases, Position, Count, Level, DeleteCases takes an optional argument leve\
l to specify which level to operate:\n\nvalue               operates\nn_Real              from level 1 through level n\n{n_Real}  \
          only on level n\n{n1_Real, n2_Real}  from leveln1 through level n2\n\nIf n is negative, it counts from the deepest level\
 of each element.\n\nExamples: f@@[{{a, b}, {c, d}}, {1}] ===> {f[a, b], f[c, d]}"[p$2251,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Functions Map, Apply, Scan, Cases, Position, Count, Level, DeleteCases takes an optional argument level to specif\
y which level to operate:\n\nvalue               operates\nn_Real              from level 1 through level n\n{n_Real}            o\
nly on level n\n{n1_Real, n2_Real}  from leveln1 through level n2\n\nIf n is negative, it counts from the deepest level of each el\
ement.\n\nExamples: f@@[{{a, b}, {c, d}}, {1}] ===> {f[a, b], f[c, d]}"[p$2251+pe$2251[[1,2]],p1$2251]]],
        p1$2251=-2+p$2251+pe$2251[[1,1]]}[[
       1]],
      0],
    1,lx$2251:=Help2HTML`o9$;p2$2251=4+p1$2251;p0$2251=-4+p$2251;0];
  If[(equ$2251=
Help2HTML`o8$["Functions Map, Apply, Scan, Cases, Position, Count, Level, DeleteCases takes an optional argument level to specify \
which level to operate:\n\nvalue               operates\nn_Real              from level 1 through level n\n{n_Real}            onl\
y on level n\n{n1_Real, n2_Real}  from leveln1 through level n2\n\nIf n is negative, it counts from the deepest level of each elem\
ent.\n\nExamples: f@@[{{a, b}, {c, d}}, {1}] ===> {f[a, b], f[c, d]}"[p$2251,p1$2251]])===
    Undefined,
equ$2251="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Functions Map, Apply, Scan, Cases, Position,\
 Count, Level, DeleteCases takes an optional argument level to specify which level to operate:\n\nvalue               operates\nn_\
Real              from level 1 through level n\n{n_Real}            only on level n\n{n1_Real, n2_Real}  from leveln1 through leve\
l n2\n\nIf n is negative, it counts from the deepest level of each element.\n\nExamples: f@@[{{a, b}, {c, d}}, {1}] ===> {f[a, b],\
 f[c, d]}"[p$2251,p1$2251]]=
       equ$2251;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2251},out$2251=lx$2251@Typeset["Functions Map, Apply, Scan, Cases, Position, Count, Level, DeleteCases takes an optional \
argument level to specify which level to operate:\n\nvalue               operates\nn_Real              from level 1 through level \
n\n{n_Real}            only on level n\n{n1_Real, n2_Real}  from leveln1 through level n2\n\nIf n is negative, it counts from the \
deepest level of each element.\n\nExamples: f@@[{{a, b}, {c, d}}, {1}] ===> {f[a, b], f[c, d]}"[p$2251,p1$2251],
          Format->Help2HTML`oB$];
        System["mv -f "//out$2251//" "//equ$2251]];
      Exit[]]];
   "Functions Map, Apply, Scan, Cases, Position, Count, Level, DeleteCases takes an optional argument level to specify which level\
 to operate:\n\nvalue               operates\nn_Real              from level 1 through level n\n{n_Real}            only on level \
n\n{n1_Real, n2_Real}  from leveln1 through level n2\n\nIf n is negative, it counts from the deepest level of each element.\n\nExa\
mples: f@@[{{a, b}, {c, d}}, {1}] ===> {f[a, b], f[c, d]}"[1,Max[p0$2251,0]]//"<img  class=\"eqs\" SRC=\""//equ$2251//"\" />"//
   Help2HTML`oy$["Functions Map, Apply, Scan, Cases, Position, Count, Level, DeleteCases takes an optional argument level to speci\
fy which level to operate:\n\nvalue               operates\nn_Real              from level 1 through level n\n{n_Real}            \
only on level n\n{n1_Real, n2_Real}  from leveln1 through level n2\n\nIf n is negative, it counts from the deepest level of each e\
lement.\n\nExamples: f@@[{{a, b}, {c, d}}, {1}] ===> {f[a, b], f[c, d]}"[p2$2251,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L375>Map</A> <A HREF=#L368>Apply</A> <A HREF=#L378>Scan</A> <A HREF=#L369>Cases</A> <A HREF=#L377>Position</A> Count Level <A HREF=#L370>DeleteCases</A></PRE>
<LI>
<H3><A NAME=L375>
Map</A></H3>
<PRE>If[{},
Help2HTML`oA$["   Map[f, x [, level]] or f/@x [f/@[x, level]] \n\noperates f over each element of a list x and returns the result \
as a list:\n\nf/@{a, b, c} ===> {f[a], f[b], f[c]}\n\nAn optional argument specifies the level-spec."],
 p$2254=1+p$2254[[1,2]];p1$2254=
StringPosition["   Map[f, x [, level]] or f/@x [f/@[x, level]] \n\noperates f over each element of a list x and returns the result\
 as a list:\n\nf/@{a, b, c} ===> {f[a], f[b], f[c]}\n\nAn optional argument specifies the level-spec."[p$2254,-1],">::",1];
   p1$2254=If[p1$2254==={},209,-2+p$2254+p1$2254[[1,1]]];
neq=Which["   Map[f, x [, level]] or f/@x [f/@[x, level]] \n\noperates f over each element of a list x and returns the result as a\
 list:\n\nf/@{a, b, c} ===> {f[a], f[b], f[c]}\n\nAn optional argument specifies the level-spec."[p$2254,4+p$2254]==="Text[",
    lx$2254:=Help2HTML`oa$;p$2254=5+p$2254;p1$2254-=1;p2$2254=5+p1$2254;p0$2254=-9+p$2254;
If[(pe$2254=StringPosition["   Map[f, x [, level]] or f/@x [f/@[x, level]] \n\noperates f over each element of a list x and return\
s the result as a list:\n\nf/@{a, b, c} ===> {f[a], f[b], f[c]}\n\nAn optional argument specifies the level-spec."[p$2254,-2],";;;"
         ])<=>
       {},
      {Max[0,
-1+ToExpression["   Map[f, x [, level]] or f/@x [f/@[x, level]] \n\noperates f over each element of a list x and returns the resul\
t as a list:\n\nf/@{a, b, c} ===> {f[a], f[b], f[c]}\n\nAn optional argument specifies the level-spec."[p$2254+pe$2254[[1,2]],
           p1$2254]]],
        p1$2254=-2+p$2254+pe$2254[[1,1]]}[[
       1]],
      0],
    1,lx$2254:=Help2HTML`o9$;p2$2254=4+p1$2254;p0$2254=-4+p$2254;0];
  If[(equ$2254=
Help2HTML`o8$["   Map[f, x [, level]] or f/@x [f/@[x, level]] \n\noperates f over each element of a list x and returns the result \
as a list:\n\nf/@{a, b, c} ===> {f[a], f[b], f[c]}\n\nAn optional argument specifies the level-spec."[p$2254,p1$2254]])===
    Undefined,
equ$2254="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["   Map[f, x [, level]] or f/@x [f/@[x, level\
]] \n\noperates f over each element of a list x and returns the result as a list:\n\nf/@{a, b, c} ===> {f[a], f[b], f[c]}\n\nAn op\
tional argument specifies the level-spec."[p$2254,p1$2254]]=
       equ$2254;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2254},out$2254=lx$2254@Typeset["   Map[f, x [, level]] or f/@x [f/@[x, level]] \n\noperates f over each element of a list\
 x and returns the result as a list:\n\nf/@{a, b, c} ===> {f[a], f[b], f[c]}\n\nAn optional argument specifies the level-spec."[p
           $2254,p1$2254],Format->Help2HTML`oB$];
        System["mv -f "//out$2254//" "//equ$2254]];
      Exit[]]];
   "   Map[f, x [, level]] or f/@x [f/@[x, level]] \n\noperates f over each element of a list x and returns the result as a list:\\
n\nf/@{a, b, c} ===> {f[a], f[b], f[c]}\n\nAn optional argument specifies the level-spec."[1,Max[p0$2254,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2254//"\" />"//
Help2HTML`oy$["   Map[f, x [, level]] or f/@x [f/@[x, level]] \n\noperates f over each element of a list x and returns the result \
as a list:\n\nf/@{a, b, c} ===> {f[a], f[b], f[c]}\n\nAn optional argument specifies the level-spec."[p2$2254,-1]]
]</PRE>
<PRE>See also:
 @/ <A HREF=#L378>Scan</A> <A HREF=#L368>Apply</A> <A HREF=#L376>MapThread</A> <A HREF=#L374>level-spec</A></PRE>
<LI>
<H3><A NAME=L376>
MapThread</A></H3>
<PRE>If[{},
 Help2HTML`oA$["   MapThread[f, l] ===> f@@[Thread[l], {1}]\n\nExample: MapThread[f, {{1, 2}, {3, 4}}] ===> {f[1, 3], f[1, 4]}"],
 p$2257=1+p$2257[[1,2]];
  p1$2257=StringPosition[
    "   MapThread[f, l] ===> f@@[Thread[l], {1}]\n\nExample: MapThread[f, {{1, 2}, {3, 4}}] ===> {f[1, 3], f[1, 4]}"[p$2257,-1],
    ">::",1];
   p1$2257=If[p1$2257==={},108,-2+p$2257+p1$2257[[1,1]]];
  neq=Which["   MapThread[f, l] ===> f@@[Thread[l], {1}]\n\nExample: MapThread[f, {{1, 2}, {3, 4}}] ===> {f[1, 3], f[1, 4]}"[p$2257
      ,4+p$2257]===
     "Text[",
    lx$2257:=Help2HTML`oa$;p$2257=5+p$2257;p1$2257-=1;p2$2257=5+p1$2257;p0$2257=-9+p$2257;If[(pe$2257=StringPosition[
         "   MapThread[f, l] ===> f@@[Thread[l], {1}]\n\nExample: MapThread[f, {{1, 2}, {3, 4}}] ===> {f[1, 3], f[1, 4]}"[p$2257,-2
          ],
         ";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression[
          "   MapThread[f, l] ===> f@@[Thread[l], {1}]\n\nExample: MapThread[f, {{1, 2}, {3, 4}}] ===> {f[1, 3], f[1, 4]}"[p$2257+
            pe$2257[[1,2]],
           p1$2257]]],
        p1$2257=-2+p$2257+pe$2257[[1,1]]}[[
       1]],
      0],
    1,lx$2257:=Help2HTML`o9$;p2$2257=4+p1$2257;p0$2257=-4+p$2257;0];
  If[(equ$2257=
     Help2HTML`o8$["   MapThread[f, l] ===> f@@[Thread[l], {1}]\n\nExample: MapThread[f, {{1, 2}, {3, 4}}] ===> {f[1, 3], f[1, 4]}"
      [p$2257,p1$2257]])===
    Undefined,
   equ$2257="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "   MapThread[f, l] ===> f@@[Thread[l], {1}]\n\nExample: MapThread[f, {{1, 2}, {3, 4}}] ===> {f[1, 3], f[1, 4]}"[p$2257,
         p1$2257]]=
       equ$2257;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$2257},out$2257=lx$2257@Typeset[
          "   MapThread[f, l] ===> f@@[Thread[l], {1}]\n\nExample: MapThread[f, {{1, 2}, {3, 4}}] ===> {f[1, 3], f[1, 4]}"[p$2257,
           p1$2257],Format->Help2HTML`oB$];
        System["mv -f "//out$2257//" "//equ$2257]];
      Exit[]]];
   "   MapThread[f, l] ===> f@@[Thread[l], {1}]\n\nExample: MapThread[f, {{1, 2}, {3, 4}}] ===> {f[1, 3], f[1, 4]}"[1,
    Max[p0$2257,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2257//"\" />"//
   Help2HTML`oy$["   MapThread[f, l] ===> f@@[Thread[l], {1}]\n\nExample: MapThread[f, {{1, 2}, {3, 4}}] ===> {f[1, 3], f[1, 4]}"[
     p2$2257,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L379>ScanThread</A> <A HREF=#L382>Thread</A> <A HREF=#L375>Map</A> <A HREF=#L368>Apply</A></PRE>
<LI>
<H3><A NAME=L377>
Position</A></H3>
<PRE>If[{},
Help2HTML`oA$["   Position[l, pat [, level [,n]]]\n\nreturns a list of indices of parts of l, which match a pattern pat. Optional \
level-spec l and the maximum number of results n can be specified."],
p$2260=1+p$2260[[1,2]];p1$2260=StringPosition["   Position[l, pat [, level [,n]]]\n\nreturns a list of indices of parts of l, whic\
h match a pattern pat. Optional level-spec l and the maximum number of results n can be specified."[p$2260,-1],">::",1];
   p1$2260=If[p1$2260==={},179,-2+p$2260+p1$2260[[1,1]]];
neq=Which["   Position[l, pat [, level [,n]]]\n\nreturns a list of indices of parts of l, which match a pattern pat. Optional leve\
l-spec l and the maximum number of results n can be specified."[p$2260,4+p$2260]==="Text[",
    lx$2260:=Help2HTML`oa$;p$2260=5+p$2260;p1$2260-=1;p2$2260=5+p1$2260;p0$2260=-9+p$2260;
If[(pe$2260=StringPosition["   Position[l, pat [, level [,n]]]\n\nreturns a list of indices of parts of l, which match a pattern p\
at. Optional level-spec l and the maximum number of results n can be specified."[p$2260,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["   Position[l, pat [, level [,n]]]\n\nreturns a list of indices of parts of l, which match a pattern pat. Optiona\
l level-spec l and the maximum number of results n can be specified."[p$2260+pe$2260[[1,2]],p1$2260]]],
        p1$2260=-2+p$2260+pe$2260[[1,1]]}[[
       1]],
      0],
    1,lx$2260:=Help2HTML`o9$;p2$2260=4+p1$2260;p0$2260=-4+p$2260;0];
  If[(equ$2260=
Help2HTML`o8$["   Position[l, pat [, level [,n]]]\n\nreturns a list of indices of parts of l, which match a pattern pat. Optional \
level-spec l and the maximum number of results n can be specified."[p$2260,p1$2260]])===
    Undefined,
equ$2260="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["   Position[l, pat [, level [,n]]]\n\nreturn\
s a list of indices of parts of l, which match a pattern pat. Optional level-spec l and the maximum number of results n can be spe\
cified."[p$2260,p1$2260]]=
       equ$2260;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2260},out$2260=lx$2260@Typeset["   Position[l, pat [, level [,n]]]\n\nreturns a list of indices of parts of l, which matc\
h a pattern pat. Optional level-spec l and the maximum number of results n can be specified."[p$2260,p1$2260],
          Format->Help2HTML`oB$];
        System["mv -f "//out$2260//" "//equ$2260]];
      Exit[]]];
   "   Position[l, pat [, level [,n]]]\n\nreturns a list of indices of parts of l, which match a pattern pat. Optional level-spec \
l and the maximum number of results n can be specified."[1,Max[p0$2260,0]]//"<img  class=\"eqs\" SRC=\""//equ$2260//"\" />"//
   Help2HTML`oy$["   Position[l, pat [, level [,n]]]\n\nreturns a list of indices of parts of l, which match a pattern pat. Option\
al level-spec l and the maximum number of results n can be specified."[p2$2260,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L374>level-spec</A> <A HREF=#L481>pattern</A> <A HREF=#L369>Cases</A> <A HREF=#L370>DeleteCases</A></PRE>
<LI>
<H3><A NAME=L378>
Scan</A></H3>
<PRE>If[{},
Help2HTML`oA$["   Scan[f, x [, level]]\n\noperates f over each element of a list without returning the result:\n\nScan[f, {a, b, c\
}] ===> {f[a], f[b], f[c]};Null \n\nAn optional argument specifies the level-spec."],
 p$2263=1+p$2263[[1,2]];p1$2263=StringPosition["   Scan[f, x [, level]]\n\noperates f over each element of a list without returnin\
g the result:\n\nScan[f, {a, b, c}] ===> {f[a], f[b], f[c]};Null \n\nAn optional argument specifies the level-spec."[p$2263,-1],
    ">::",1];
   p1$2263=If[p1$2263==={},191,-2+p$2263+p1$2263[[1,1]]];
neq=Which["   Scan[f, x [, level]]\n\noperates f over each element of a list without returning the result:\n\nScan[f, {a, b, c}] =\
==> {f[a], f[b], f[c]};Null \n\nAn optional argument specifies the level-spec."[p$2263,4+p$2263]==="Text[",
    lx$2263:=Help2HTML`oa$;p$2263=5+p$2263;p1$2263-=1;p2$2263=5+p1$2263;p0$2263=-9+p$2263;
If[(pe$2263=StringPosition["   Scan[f, x [, level]]\n\noperates f over each element of a list without returning the result:\n\nSca\
n[f, {a, b, c}] ===> {f[a], f[b], f[c]};Null \n\nAn optional argument specifies the level-spec."[p$2263,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["   Scan[f, x [, level]]\n\noperates f over each element of a list without returning the result:\n\nScan[f, {a, b,\
 c}] ===> {f[a], f[b], f[c]};Null \n\nAn optional argument specifies the level-spec."[p$2263+pe$2263[[1,2]],p1$2263]]],
        p1$2263=-2+p$2263+pe$2263[[1,1]]}[[
       1]],
      0],
    1,lx$2263:=Help2HTML`o9$;p2$2263=4+p1$2263;p0$2263=-4+p$2263;0];
  If[(equ$2263=
Help2HTML`o8$["   Scan[f, x [, level]]\n\noperates f over each element of a list without returning the result:\n\nScan[f, {a, b, c\
}] ===> {f[a], f[b], f[c]};Null \n\nAn optional argument specifies the level-spec."[p$2263,p1$2263]])===
    Undefined,
equ$2263="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["   Scan[f, x [, level]]\n\noperates f over e\
ach element of a list without returning the result:\n\nScan[f, {a, b, c}] ===> {f[a], f[b], f[c]};Null \n\nAn optional argument sp\
ecifies the level-spec."[p$2263,p1$2263]]=
       equ$2263;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2263},out$2263=lx$2263@Typeset["   Scan[f, x [, level]]\n\noperates f over each element of a list without returning the r\
esult:\n\nScan[f, {a, b, c}] ===> {f[a], f[b], f[c]};Null \n\nAn optional argument specifies the level-spec."[p$2263,p1$2263],
          Format->Help2HTML`oB$];
        System["mv -f "//out$2263//" "//equ$2263]];
      Exit[]]];
   "   Scan[f, x [, level]]\n\noperates f over each element of a list without returning the result:\n\nScan[f, {a, b, c}] ===> {f[\
a], f[b], f[c]};Null \n\nAn optional argument specifies the level-spec."[1,Max[p0$2263,0]]//"<img  class=\"eqs\" SRC=\""//
   equ$2263//"\" />"//
Help2HTML`oy$["   Scan[f, x [, level]]\n\noperates f over each element of a list without returning the result:\n\nScan[f, {a, b, c\
}] ===> {f[a], f[b], f[c]};Null \n\nAn optional argument specifies the level-spec."[p2$2263,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L375>Map</A> <A HREF=#L368>Apply</A> <A HREF=#L376>MapThread</A> <A HREF=#L374>level-spec</A></PRE>
<LI>
<H3><A NAME=L379>
ScanThread</A></H3>
<PRE>If[{},
 Help2HTML`oA$[
  "   ScanThread[f, l] ===> (f@@[Thread[l], {1}];Null) ,\n\nwhich is equivalent to MapThread without returning the results."],
 p$2266=1+p$2266[[1,2]];
  p1$2266=StringPosition[
    "   ScanThread[f, l] ===> (f@@[Thread[l], {1}];Null) ,\n\nwhich is equivalent to MapThread without returning the results."[p
     $2266,-1],
    ">::",1];
   p1$2266=If[p1$2266==={},118,-2+p$2266+p1$2266[[1,1]]];
  neq=Which[
     "   ScanThread[f, l] ===> (f@@[Thread[l], {1}];Null) ,\n\nwhich is equivalent to MapThread without returning the results."[p
      $2266,4+p$2266]===
     "Text[",
    lx$2266:=Help2HTML`oa$;p$2266=5+p$2266;p1$2266-=1;p2$2266=5+p1$2266;p0$2266=-9+p$2266;If[(pe$2266=StringPosition[
         "   ScanThread[f, l] ===> (f@@[Thread[l], {1}];Null) ,\n\nwhich is equivalent to MapThread without returning the results."
         [p$2266,-2],";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression[
          "   ScanThread[f, l] ===> (f@@[Thread[l], {1}];Null) ,\n\nwhich is equivalent to MapThread without returning the results\
."[p$2266+pe$2266[[1,2]],p1$2266]]],
        p1$2266=-2+p$2266+pe$2266[[1,1]]}[[
       1]],
      0],
    1,lx$2266:=Help2HTML`o9$;p2$2266=4+p1$2266;p0$2266=-4+p$2266;0];
  If[(equ$2266=
     Help2HTML`o8$[
      "   ScanThread[f, l] ===> (f@@[Thread[l], {1}];Null) ,\n\nwhich is equivalent to MapThread without returning the results."[
       p$2266,p1$2266]])===
    Undefined,
   equ$2266="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "   ScanThread[f, l] ===> (f@@[Thread[l], {1}];Null) ,\n\nwhich is equivalent to MapThread without returning the results."[
         p$2266,p1$2266]]=
       equ$2266;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$2266},out$2266=lx$2266@Typeset[
          "   ScanThread[f, l] ===> (f@@[Thread[l], {1}];Null) ,\n\nwhich is equivalent to MapThread without returning the results\
."[p$2266,p1$2266],Format->Help2HTML`oB$];
        System["mv -f "//out$2266//" "//equ$2266]];
      Exit[]]];
  "   ScanThread[f, l] ===> (f@@[Thread[l], {1}];Null) ,\n\nwhich is equivalent to MapThread without returning the results."[1,
    Max[p0$2266,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2266//"\" />"//
   Help2HTML`oy$[
    "   ScanThread[f, l] ===> (f@@[Thread[l], {1}];Null) ,\n\nwhich is equivalent to MapThread without returning the results."[p2
     $2266,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L376>MapThread</A> <A HREF=#L382>Thread</A> <A HREF=#L375>Map</A> <A HREF=#L368>Apply</A></PRE>
<LI>
<H3><A NAME=L380>
SelectCases</A></H3>
<PRE>If[{},
Help2HTML`oA$["Usage: SelectCases[list, {test1,..}]\n\nreturns a list {list1, .. }, where list1 is a list of subexpressions which \
makes test1 True, etc. If the second argument is like {c1, .. , True&},  the last of the returned list contains subexpressions whi\
ch make none of c1, ... True."],
p$2269=1+p$2269[[1,2]];p1$2269=StringPosition["Usage: SelectCases[list, {test1,..}]\n\nreturns a list {list1, .. }, where list1 is\
 a list of subexpressions which makes test1 True, etc. If the second argument is like {c1, .. , True&},  the last of the returned \
list contains subexpressions which make none of c1, ... True."[p$2269,-1],">::",1];
   p1$2269=If[p1$2269==={},272,-2+p$2269+p1$2269[[1,1]]];
neq=Which["Usage: SelectCases[list, {test1,..}]\n\nreturns a list {list1, .. }, where list1 is a list of subexpressions which make\
s test1 True, etc. If the second argument is like {c1, .. , True&},  the last of the returned list contains subexpressions which m\
ake none of c1, ... True."[p$2269,4+p$2269]==="Text[",
    lx$2269:=Help2HTML`oa$;p$2269=5+p$2269;p1$2269-=1;p2$2269=5+p1$2269;p0$2269=-9+p$2269;
If[(pe$2269=StringPosition["Usage: SelectCases[list, {test1,..}]\n\nreturns a list {list1, .. }, where list1 is a list of subexpre\
ssions which makes test1 True, etc. If the second argument is like {c1, .. , True&},  the last of the returned list contains subex\
pressions which make none of c1, ... True."[p$2269,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Usage: SelectCases[list, {test1,..}]\n\nreturns a list {list1, .. }, where list1 is a list of subexpressions whic\
h makes test1 True, etc. If the second argument is like {c1, .. , True&},  the last of the returned list contains subexpressions w\
hich make none of c1, ... True."[p$2269+pe$2269[[1,2]],p1$2269]]],
        p1$2269=-2+p$2269+pe$2269[[1,1]]}[[
       1]],
      0],
    1,lx$2269:=Help2HTML`o9$;p2$2269=4+p1$2269;p0$2269=-4+p$2269;0];
  If[(equ$2269=
Help2HTML`o8$["Usage: SelectCases[list, {test1,..}]\n\nreturns a list {list1, .. }, where list1 is a list of subexpressions which \
makes test1 True, etc. If the second argument is like {c1, .. , True&},  the last of the returned list contains subexpressions whi\
ch make none of c1, ... True."[p$2269,p1$2269]])===
    Undefined,
equ$2269="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Usage: SelectCases[list, {test1,..}]\n\nretu\
rns a list {list1, .. }, where list1 is a list of subexpressions which makes test1 True, etc. If the second argument is like {c1, \
.. , True&},  the last of the returned list contains subexpressions which make none of c1, ... True."[p$2269,p1$2269]]=
       equ$2269;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2269},out$2269=lx$2269@Typeset["Usage: SelectCases[list, {test1,..}]\n\nreturns a list {list1, .. }, where list1 is a lis\
t of subexpressions which makes test1 True, etc. If the second argument is like {c1, .. , True&},  the last of the returned list c\
ontains subexpressions which make none of c1, ... True."[p$2269,p1$2269],Format->Help2HTML`oB$];
        System["mv -f "//out$2269//" "//equ$2269]];
      Exit[]]];
   "Usage: SelectCases[list, {test1,..}]\n\nreturns a list {list1, .. }, where list1 is a list of subexpressions which makes test1\
 True, etc. If the second argument is like {c1, .. , True&},  the last of the returned list contains subexpressions which make non\
e of c1, ... True."[1,Max[p0$2269,0]]//"<img  class=\"eqs\" SRC=\""//equ$2269//"\" />"//
Help2HTML`oy$["Usage: SelectCases[list, {test1,..}]\n\nreturns a list {list1, .. }, where list1 is a list of subexpressions which \
makes test1 True, etc. If the second argument is like {c1, .. , True&},  the last of the returned list contains subexpressions whi\
ch make none of c1, ... True."[p2$2269,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L381>SwitchCases</A></PRE>
<LI>
<H3><A NAME=L381>
SwitchCases</A></H3>
<PRE>If[{},
Help2HTML`oA$["Usage: SwitchCases[list, {case1,..}]\n\nreturns a list {list1, .. }, where list1 is a list of subexpressions which \
match case1, etc. SwitchCases does what are done by Cases and DeleteCases simultaneously. If the second argument is like {c1, .. ,\
 _}, the last of the returned list contains subexpressions which match none of c1, ..."],
 p$2272=1+p$2272[[1,2]];p1$2272=StringPosition["Usage: SwitchCases[list, {case1,..}]\n\nreturns a list {list1, .. }, where list1 i\
s a list of subexpressions which match case1, etc. SwitchCases does what are done by Cases and DeleteCases simultaneously. If the \
second argument is like {c1, .. , _}, the last of the returned list contains subexpressions which match none of c1, ..."[p$2272,-1
     ],
    ">::",1];
   p1$2272=If[p1$2272==={},329,-2+p$2272+p1$2272[[1,1]]];
neq=Which["Usage: SwitchCases[list, {case1,..}]\n\nreturns a list {list1, .. }, where list1 is a list of subexpressions which matc\
h case1, etc. SwitchCases does what are done by Cases and DeleteCases simultaneously. If the second argument is like {c1, .. , _},\
 the last of the returned list contains subexpressions which match none of c1, ..."[p$2272,4+p$2272]==="Text[",
    lx$2272:=Help2HTML`oa$;p$2272=5+p$2272;p1$2272-=1;p2$2272=5+p1$2272;p0$2272=-9+p$2272;
If[(pe$2272=StringPosition["Usage: SwitchCases[list, {case1,..}]\n\nreturns a list {list1, .. }, where list1 is a list of subexpre\
ssions which match case1, etc. SwitchCases does what are done by Cases and DeleteCases simultaneously. If the second argument is l\
ike {c1, .. , _}, the last of the returned list contains subexpressions which match none of c1, ..."[p$2272,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Usage: SwitchCases[list, {case1,..}]\n\nreturns a list {list1, .. }, where list1 is a list of subexpressions whic\
h match case1, etc. SwitchCases does what are done by Cases and DeleteCases simultaneously. If the second argument is like {c1, ..\
 , _}, the last of the returned list contains subexpressions which match none of c1, ..."[p$2272+pe$2272[[1,2]],p1$2272]]],
        p1$2272=-2+p$2272+pe$2272[[1,1]]}[[
       1]],
      0],
    1,lx$2272:=Help2HTML`o9$;p2$2272=4+p1$2272;p0$2272=-4+p$2272;0];
  If[(equ$2272=
Help2HTML`o8$["Usage: SwitchCases[list, {case1,..}]\n\nreturns a list {list1, .. }, where list1 is a list of subexpressions which \
match case1, etc. SwitchCases does what are done by Cases and DeleteCases simultaneously. If the second argument is like {c1, .. ,\
 _}, the last of the returned list contains subexpressions which match none of c1, ..."[p$2272,p1$2272]])===
    Undefined,
equ$2272="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Usage: SwitchCases[list, {case1,..}]\n\nretu\
rns a list {list1, .. }, where list1 is a list of subexpressions which match case1, etc. SwitchCases does what are done by Cases a\
nd DeleteCases simultaneously. If the second argument is like {c1, .. , _}, the last of the returned list contains subexpressions \
which match none of c1, ..."[p$2272,p1$2272]]=
       equ$2272;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2272},out$2272=lx$2272@Typeset["Usage: SwitchCases[list, {case1,..}]\n\nreturns a list {list1, .. }, where list1 is a lis\
t of subexpressions which match case1, etc. SwitchCases does what are done by Cases and DeleteCases simultaneously. If the second \
argument is like {c1, .. , _}, the last of the returned list contains subexpressions which match none of c1, ..."[p$2272,p1$2272],
          Format->Help2HTML`oB$];
        System["mv -f "//out$2272//" "//equ$2272]];
      Exit[]]];
   "Usage: SwitchCases[list, {case1,..}]\n\nreturns a list {list1, .. }, where list1 is a list of subexpressions which match case1\
, etc. SwitchCases does what are done by Cases and DeleteCases simultaneously. If the second argument is like {c1, .. , _}, the la\
st of the returned list contains subexpressions which match none of c1, ..."[1,Max[p0$2272,0]]//"<img  class=\"eqs\" SRC=\""//
   equ$2272//"\" />"//
Help2HTML`oy$["Usage: SwitchCases[list, {case1,..}]\n\nreturns a list {list1, .. }, where list1 is a list of subexpressions which \
match case1, etc. SwitchCases does what are done by Cases and DeleteCases simultaneously. If the second argument is like {c1, .. ,\
 _}, the last of the returned list contains subexpressions which match none of c1, ..."[p2$2272,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L380>SelectCases</A></PRE>
<LI>
<H3><A NAME=L382>
Thread</A></H3>
<PRE>If[{},
Help2HTML`oA$[" Thread[l] returns a threaded list of l:\n\n   Thread[{{1, 2}, {3, 4}}] ===> {{1, 3}, {2, 4}}\n   Thread[{{1, 2}, {\
3, 4}, 5}] ===> {{1, 3, 5}, {2, 4, 5}}\n\n If an optional second argument h is given, Thread operates only over on a structure who\
se head is h:\n\n   Thread[{{1, 2}, {3, 4}} , f] ===> {{1, 2}, {3, 4}}\n   Thread[{f[1, 2], f[3, 4]} , f] ===> f[{1, 3}, {2, 4}]\n\
   Thread[f[f[1, 2], f[3, 4]] , f] ===> f[f[1, 3], f[2, 4]]\n\n Thread is equivalent to Transpose if l is a matrix."],
 p$2275=1+p$2275[[1,2]];
p1$2275=StringPosition[" Thread[l] returns a threaded list of l:\n\n   Thread[{{1, 2}, {3, 4}}] ===> {{1, 3}, {2, 4}}\n   Thread[{\
{1, 2}, {3, 4}, 5}] ===> {{1, 3, 5}, {2, 4, 5}}\n\n If an optional second argument h is given, Thread operates only over on a stru\
cture whose head is h:\n\n   Thread[{{1, 2}, {3, 4}} , f] ===> {{1, 2}, {3, 4}}\n   Thread[{f[1, 2], f[3, 4]} , f] ===> f[{1, 3}, \
{2, 4}]\n   Thread[f[f[1, 2], f[3, 4]] , f] ===> f[f[1, 3], f[2, 4]]\n\n Thread is equivalent to Transpose if l is a matrix."[p
     $2275,-1],
    ">::",1];
   p1$2275=If[p1$2275==={},479,-2+p$2275+p1$2275[[1,1]]];
neq=Which[" Thread[l] returns a threaded list of l:\n\n   Thread[{{1, 2}, {3, 4}}] ===> {{1, 3}, {2, 4}}\n   Thread[{{1, 2}, {3, 4\
}, 5}] ===> {{1, 3, 5}, {2, 4, 5}}\n\n If an optional second argument h is given, Thread operates only over on a structure whose h\
ead is h:\n\n   Thread[{{1, 2}, {3, 4}} , f] ===> {{1, 2}, {3, 4}}\n   Thread[{f[1, 2], f[3, 4]} , f] ===> f[{1, 3}, {2, 4}]\n   T\
hread[f[f[1, 2], f[3, 4]] , f] ===> f[f[1, 3], f[2, 4]]\n\n Thread is equivalent to Transpose if l is a matrix."[p$2275,4+p$2275
      ]===
     "Text[",
lx$2275:=Help2HTML`oa$;p$2275=5+p$2275;p1$2275-=1;p2$2275=5+p1$2275;p0$2275=-9+p$2275;If[(pe$2275=StringPosition[" Thread[l] retur\
ns a threaded list of l:\n\n   Thread[{{1, 2}, {3, 4}}] ===> {{1, 3}, {2, 4}}\n   Thread[{{1, 2}, {3, 4}, 5}] ===> {{1, 3, 5}, {2,\
 4, 5}}\n\n If an optional second argument h is given, Thread operates only over on a structure whose head is h:\n\n   Thread[{{1,\
 2}, {3, 4}} , f] ===> {{1, 2}, {3, 4}}\n   Thread[{f[1, 2], f[3, 4]} , f] ===> f[{1, 3}, {2, 4}]\n   Thread[f[f[1, 2], f[3, 4]] ,\
 f] ===> f[f[1, 3], f[2, 4]]\n\n Thread is equivalent to Transpose if l is a matrix."[p$2275,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression[" Thread[l] returns a threaded list of l:\n\n   Thread[{{1, 2}, {3, 4}}] ===> {{1, 3}, {2, 4}}\n   Thread[{{1, 2},\
 {3, 4}, 5}] ===> {{1, 3, 5}, {2, 4, 5}}\n\n If an optional second argument h is given, Thread operates only over on a structure w\
hose head is h:\n\n   Thread[{{1, 2}, {3, 4}} , f] ===> {{1, 2}, {3, 4}}\n   Thread[{f[1, 2], f[3, 4]} , f] ===> f[{1, 3}, {2, 4}]\
\n   Thread[f[f[1, 2], f[3, 4]] , f] ===> f[f[1, 3], f[2, 4]]\n\n Thread is equivalent to Transpose if l is a matrix."[p$2275+
            pe$2275[[1,2]],
           p1$2275]]],
        p1$2275=-2+p$2275+pe$2275[[1,1]]}[[
       1]],
      0],
    1,lx$2275:=Help2HTML`o9$;p2$2275=4+p1$2275;p0$2275=-4+p$2275;0];
  If[(equ$2275=
Help2HTML`o8$[" Thread[l] returns a threaded list of l:\n\n   Thread[{{1, 2}, {3, 4}}] ===> {{1, 3}, {2, 4}}\n   Thread[{{1, 2}, {\
3, 4}, 5}] ===> {{1, 3, 5}, {2, 4, 5}}\n\n If an optional second argument h is given, Thread operates only over on a structure who\
se head is h:\n\n   Thread[{{1, 2}, {3, 4}} , f] ===> {{1, 2}, {3, 4}}\n   Thread[{f[1, 2], f[3, 4]} , f] ===> f[{1, 3}, {2, 4}]\n\
   Thread[f[f[1, 2], f[3, 4]] , f] ===> f[f[1, 3], f[2, 4]]\n\n Thread is equivalent to Transpose if l is a matrix."[p$2275,p1$2275
       ]])===
    Undefined,
equ$2275="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[" Thread[l] returns a threaded list of l:\n\n\
   Thread[{{1, 2}, {3, 4}}] ===> {{1, 3}, {2, 4}}\n   Thread[{{1, 2}, {3, 4}, 5}] ===> {{1, 3, 5}, {2, 4, 5}}\n\n If an optional s\
econd argument h is given, Thread operates only over on a structure whose head is h:\n\n   Thread[{{1, 2}, {3, 4}} , f] ===> {{1, \
2}, {3, 4}}\n   Thread[{f[1, 2], f[3, 4]} , f] ===> f[{1, 3}, {2, 4}]\n   Thread[f[f[1, 2], f[3, 4]] , f] ===> f[f[1, 3], f[2, 4]]\
\n\n Thread is equivalent to Transpose if l is a matrix."[p$2275,p1$2275]]=
       equ$2275;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2275},out$2275=lx$2275@Typeset[" Thread[l] returns a threaded list of l:\n\n   Thread[{{1, 2}, {3, 4}}] ===> {{1, 3}, {2,\
 4}}\n   Thread[{{1, 2}, {3, 4}, 5}] ===> {{1, 3, 5}, {2, 4, 5}}\n\n If an optional second argument h is given, Thread operates on\
ly over on a structure whose head is h:\n\n   Thread[{{1, 2}, {3, 4}} , f] ===> {{1, 2}, {3, 4}}\n   Thread[{f[1, 2], f[3, 4]} , f\
] ===> f[{1, 3}, {2, 4}]\n   Thread[f[f[1, 2], f[3, 4]] , f] ===> f[f[1, 3], f[2, 4]]\n\n Thread is equivalent to Transpose if l i\
s a matrix."[p$2275,p1$2275],Format->Help2HTML`oB$];
        System["mv -f "//out$2275//" "//equ$2275]];
      Exit[]]];
   " Thread[l] returns a threaded list of l:\n\n   Thread[{{1, 2}, {3, 4}}] ===> {{1, 3}, {2, 4}}\n   Thread[{{1, 2}, {3, 4}, 5}] \
===> {{1, 3, 5}, {2, 4, 5}}\n\n If an optional second argument h is given, Thread operates only over on a structure whose head is \
h:\n\n   Thread[{{1, 2}, {3, 4}} , f] ===> {{1, 2}, {3, 4}}\n   Thread[{f[1, 2], f[3, 4]} , f] ===> f[{1, 3}, {2, 4}]\n   Thread[f\
[f[1, 2], f[3, 4]] , f] ===> f[f[1, 3], f[2, 4]]\n\n Thread is equivalent to Transpose if l is a matrix."[1,Max[p0$2275,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2275//"\" />"//
Help2HTML`oy$[" Thread[l] returns a threaded list of l:\n\n   Thread[{{1, 2}, {3, 4}}] ===> {{1, 3}, {2, 4}}\n   Thread[{{1, 2}, {\
3, 4}, 5}] ===> {{1, 3, 5}, {2, 4, 5}}\n\n If an optional second argument h is given, Thread operates only over on a structure who\
se head is h:\n\n   Thread[{{1, 2}, {3, 4}} , f] ===> {{1, 2}, {3, 4}}\n   Thread[{f[1, 2], f[3, 4]} , f] ===> f[{1, 3}, {2, 4}]\n\
   Thread[f[f[1, 2], f[3, 4]] , f] ===> f[f[1, 3], f[2, 4]]\n\n Thread is equivalent to Transpose if l is a matrix."[p2$2275,-1]]
 ]
</PRE>
<PRE>See also:
 <A HREF=#L376>MapThread</A> Transpose</PRE>
</UL>
<LI>
<H3><A NAME=L383>
FFS-dedicated-functions</A></H3>
<PRE>If[{},Help2HTML`oA$["Functions dedicated to the optics calculations and simulations in FFS."],
 p$2278=1+p$2278[[1,2]];p1$2278=StringPosition["Functions dedicated to the optics calculations and simulations in FFS."[p$2278,-1],
    ">::",1];
   p1$2278=If[p1$2278==={},70,-2+p$2278+p1$2278[[1,1]]];
  neq=Which["Functions dedicated to the optics calculations and simulations in FFS."[p$2278,4+p$2278]==="Text[",
    lx$2278:=Help2HTML`oa$;p$2278=5+p$2278;p1$2278-=1;p2$2278=5+p1$2278;p0$2278=-9+p$2278;
     If[(pe$2278=StringPosition["Functions dedicated to the optics calculations and simulations in FFS."[p$2278,-2],";;;"])<=>{},
      {Max[0,
        -1+ToExpression["Functions dedicated to the optics calculations and simulations in FFS."[p$2278+pe$2278[[1,2]],p1$2278]]],
       p1$2278=-2+p$2278+pe$2278[[1,1]]}[[1]],
      0],
    1,lx$2278:=Help2HTML`o9$;p2$2278=4+p1$2278;p0$2278=-4+p$2278;0];
  If[(equ$2278=Help2HTML`o8$["Functions dedicated to the optics calculations and simulations in FFS."[p$2278,p1$2278]])===
    Undefined,
   equ$2278="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "Functions dedicated to the optics calculations and simulations in FFS."[p$2278,p1$2278]]=
       equ$2278;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$2278},out$2278=lx$2278@Typeset["Functions dedicated to the optics calculations and simulations in FFS."[p$2278,
           p1$2278],Format->Help2HTML`oB$];
        System["mv -f "//out$2278//" "//equ$2278]];
      Exit[]]];
   "Functions dedicated to the optics calculations and simulations in FFS."[1,Max[p0$2278,0]]//"<img  class=\"eqs\" SRC=\""//
   equ$2278//"\" />"//Help2HTML`oy$["Functions dedicated to the optics calculations and simulations in FFS."[p2$2278,-1]]
]</PRE>
<UL>
<LI>
<H3><A NAME=L384>
AccelerateParticles</A></H3>
<PRE>If[{},
Help2HTML`oA$["AccelerateParticles does TrackParticles with acceleration in a ring for a given number of turns. The adiabatic damp\
ing is automatically taken cared.\n\nUsage:    AccelerateParticles[beam_,mom_,{n_Symbol,nturn_},opt___]\n\nwhere beam is a list of\
 beam coordinates in the same format for TrackParticles. mom is an expression to determine MOMENTUM in each turn as a function of \
turn number n. nturn is the total number of turns. An option Synchronize specifies a routine to be executed at every turn of the t\
racking (e.g. changing voltages and magnet settings, or storing the results.)\n\nExample:\n  AccelerateParticles[\n    beam,\n    \
Which[\n      n < 100,  1e9,\n      n <= 200, 1e9 + (n - 100) * 1e7,\n      True, 2e9],\n    {n, 300},\n    Synchronize :> ((\n   \
   d = {d, MOMENTUM/1e9 * (1 + #2[[2,6,1]])})&)];"],
p$2280=1+p$2280[[1,2]];p1$2280=StringPosition["AccelerateParticles does TrackParticles with acceleration in a ring for a given num\
ber of turns. The adiabatic damping is automatically taken cared.\n\nUsage:    AccelerateParticles[beam_,mom_,{n_Symbol,nturn_},op\
t___]\n\nwhere beam is a list of beam coordinates in the same format for TrackParticles. mom is an expression to determine MOMENTU\
M in each turn as a function of turn number n. nturn is the total number of turns. An option Synchronize specifies a routine to be\
 executed at every turn of the tracking (e.g. changing voltages and magnet settings, or storing the results.)\n\nExample:\n  Accel\
erateParticles[\n    beam,\n    Which[\n      n < 100,  1e9,\n      n <= 200, 1e9 + (n - 100) * 1e7,\n      True, 2e9],\n    {n, 3\
00},\n    Synchronize :> ((\n      d = {d, MOMENTUM/1e9 * (1 + #2[[2,6,1]])})&)];"[p$2280,-1],">::",1];
   p1$2280=If[p1$2280==={},799,-2+p$2280+p1$2280[[1,1]]];
neq=Which["AccelerateParticles does TrackParticles with acceleration in a ring for a given number of turns. The adiabatic damping \
is automatically taken cared.\n\nUsage:    AccelerateParticles[beam_,mom_,{n_Symbol,nturn_},opt___]\n\nwhere beam is a list of bea\
m coordinates in the same format for TrackParticles. mom is an expression to determine MOMENTUM in each turn as a function of turn\
 number n. nturn is the total number of turns. An option Synchronize specifies a routine to be executed at every turn of the track\
ing (e.g. changing voltages and magnet settings, or storing the results.)\n\nExample:\n  AccelerateParticles[\n    beam,\n    Whic\
h[\n      n < 100,  1e9,\n      n <= 200, 1e9 + (n - 100) * 1e7,\n      True, 2e9],\n    {n, 300},\n    Synchronize :> ((\n      d\
 = {d, MOMENTUM/1e9 * (1 + #2[[2,6,1]])})&)];"[p$2280,4+p$2280]==="Text[",
    lx$2280:=Help2HTML`oa$;p$2280=5+p$2280;p1$2280-=1;p2$2280=5+p1$2280;p0$2280=-9+p$2280;
If[(pe$2280=StringPosition["AccelerateParticles does TrackParticles with acceleration in a ring for a given number of turns. The a\
diabatic damping is automatically taken cared.\n\nUsage:    AccelerateParticles[beam_,mom_,{n_Symbol,nturn_},opt___]\n\nwhere beam\
 is a list of beam coordinates in the same format for TrackParticles. mom is an expression to determine MOMENTUM in each turn as a\
 function of turn number n. nturn is the total number of turns. An option Synchronize specifies a routine to be executed at every \
turn of the tracking (e.g. changing voltages and magnet settings, or storing the results.)\n\nExample:\n  AccelerateParticles[\n  \
  beam,\n    Which[\n      n < 100,  1e9,\n      n <= 200, 1e9 + (n - 100) * 1e7,\n      True, 2e9],\n    {n, 300},\n    Synchroni\
ze :> ((\n      d = {d, MOMENTUM/1e9 * (1 + #2[[2,6,1]])})&)];"[p$2280,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["AccelerateParticles does TrackParticles with acceleration in a ring for a given number of turns. The adiabatic da\
mping is automatically taken cared.\n\nUsage:    AccelerateParticles[beam_,mom_,{n_Symbol,nturn_},opt___]\n\nwhere beam is a list \
of beam coordinates in the same format for TrackParticles. mom is an expression to determine MOMENTUM in each turn as a function o\
f turn number n. nturn is the total number of turns. An option Synchronize specifies a routine to be executed at every turn of the\
 tracking (e.g. changing voltages and magnet settings, or storing the results.)\n\nExample:\n  AccelerateParticles[\n    beam,\n  \
  Which[\n      n < 100,  1e9,\n      n <= 200, 1e9 + (n - 100) * 1e7,\n      True, 2e9],\n    {n, 300},\n    Synchronize :> ((\n \
     d = {d, MOMENTUM/1e9 * (1 + #2[[2,6,1]])})&)];"[p$2280+pe$2280[[1,2]],p1$2280]]],
        p1$2280=-2+p$2280+pe$2280[[1,1]]}[[
       1]],
      0],
    1,lx$2280:=Help2HTML`o9$;p2$2280=4+p1$2280;p0$2280=-4+p$2280;0];
  If[(equ$2280=
Help2HTML`o8$["AccelerateParticles does TrackParticles with acceleration in a ring for a given number of turns. The adiabatic damp\
ing is automatically taken cared.\n\nUsage:    AccelerateParticles[beam_,mom_,{n_Symbol,nturn_},opt___]\n\nwhere beam is a list of\
 beam coordinates in the same format for TrackParticles. mom is an expression to determine MOMENTUM in each turn as a function of \
turn number n. nturn is the total number of turns. An option Synchronize specifies a routine to be executed at every turn of the t\
racking (e.g. changing voltages and magnet settings, or storing the results.)\n\nExample:\n  AccelerateParticles[\n    beam,\n    \
Which[\n      n < 100,  1e9,\n      n <= 200, 1e9 + (n - 100) * 1e7,\n      True, 2e9],\n    {n, 300},\n    Synchronize :> ((\n   \
   d = {d, MOMENTUM/1e9 * (1 + #2[[2,6,1]])})&)];"[p$2280,p1$2280]])===
    Undefined,
equ$2280="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["AccelerateParticles does TrackParticles with\
 acceleration in a ring for a given number of turns. The adiabatic damping is automatically taken cared.\n\nUsage:    AcceleratePa\
rticles[beam_,mom_,{n_Symbol,nturn_},opt___]\n\nwhere beam is a list of beam coordinates in the same format for TrackParticles. mo\
m is an expression to determine MOMENTUM in each turn as a function of turn number n. nturn is the total number of turns. An optio\
n Synchronize specifies a routine to be executed at every turn of the tracking (e.g. changing voltages and magnet settings, or sto\
ring the results.)\n\nExample:\n  AccelerateParticles[\n    beam,\n    Which[\n      n < 100,  1e9,\n      n <= 200, 1e9 + (n - 10\
0) * 1e7,\n      True, 2e9],\n    {n, 300},\n    Synchronize :> ((\n      d = {d, MOMENTUM/1e9 * (1 + #2[[2,6,1]])})&)];"[p$2280,
         p1$2280]]=
       equ$2280;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2280},out$2280=lx$2280@Typeset["AccelerateParticles does TrackParticles with acceleration in a ring for a given number of\
 turns. The adiabatic damping is automatically taken cared.\n\nUsage:    AccelerateParticles[beam_,mom_,{n_Symbol,nturn_},opt___]\\
n\nwhere beam is a list of beam coordinates in the same format for TrackParticles. mom is an expression to determine MOMENTUM in e\
ach turn as a function of turn number n. nturn is the total number of turns. An option Synchronize specifies a routine to be execu\
ted at every turn of the tracking (e.g. changing voltages and magnet settings, or storing the results.)\n\nExample:\n  AccelerateP\
articles[\n    beam,\n    Which[\n      n < 100,  1e9,\n      n <= 200, 1e9 + (n - 100) * 1e7,\n      True, 2e9],\n    {n, 300},\n\
    Synchronize :> ((\n      d = {d, MOMENTUM/1e9 * (1 + #2[[2,6,1]])})&)];"[p$2280,p1$2280],Format->Help2HTML`oB$];
        System["mv -f "//out$2280//" "//equ$2280]];
      Exit[]]];
   "AccelerateParticles does TrackParticles with acceleration in a ring for a given number of turns. The adiabatic damping is auto\
matically taken cared.\n\nUsage:    AccelerateParticles[beam_,mom_,{n_Symbol,nturn_},opt___]\n\nwhere beam is a list of beam coord\
inates in the same format for TrackParticles. mom is an expression to determine MOMENTUM in each turn as a function of turn number\
 n. nturn is the total number of turns. An option Synchronize specifies a routine to be executed at every turn of the tracking (e.\
g. changing voltages and magnet settings, or storing the results.)\n\nExample:\n  AccelerateParticles[\n    beam,\n    Which[\n   \
   n < 100,  1e9,\n      n <= 200, 1e9 + (n - 100) * 1e7,\n      True, 2e9],\n    {n, 300},\n    Synchronize :> ((\n      d = {d, \
MOMENTUM/1e9 * (1 + #2[[2,6,1]])})&)];"[1,Max[p0$2280,0]]//"<img  class=\"eqs\" SRC=\""//equ$2280//"\" />"//
Help2HTML`oy$["AccelerateParticles does TrackParticles with acceleration in a ring for a given number of turns. The adiabatic damp\
ing is automatically taken cared.\n\nUsage:    AccelerateParticles[beam_,mom_,{n_Symbol,nturn_},opt___]\n\nwhere beam is a list of\
 beam coordinates in the same format for TrackParticles. mom is an expression to determine MOMENTUM in each turn as a function of \
turn number n. nturn is the total number of turns. An option Synchronize specifies a routine to be executed at every turn of the t\
racking (e.g. changing voltages and magnet settings, or storing the results.)\n\nExample:\n  AccelerateParticles[\n    beam,\n    \
Which[\n      n < 100,  1e9,\n      n <= 200, 1e9 + (n - 100) * 1e7,\n      True, 2e9],\n    {n, 300},\n    Synchronize :> ((\n   \
   d = {d, MOMENTUM/1e9 * (1 + #2[[2,6,1]])})&)];"[p2$2280,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L409>TrackParticles</A></PRE>
<LI>
<H3><A NAME=L385>
BeamMatrix</A></H3>
<PRE>If[{},
Help2HTML`oA$["BeamMatrix[i] returns a 6 by 6 beam-matrix (i.e., <x_k x_l>) at location i. The index i can have a fraction to spec\
ify intermediate numbers (see LINE or Twiss). The calculation is based on linear 4 by 5 calculation in the present version, so the\
 z-direction is meaningless. Flag GAUSS affects the result."],
p$2283=1+p$2283[[1,2]];p1$2283=StringPosition["BeamMatrix[i] returns a 6 by 6 beam-matrix (i.e., <x_k x_l>) at location i. The ind\
ex i can have a fraction to specify intermediate numbers (see LINE or Twiss). The calculation is based on linear 4 by 5 calculatio\
n in the present version, so the z-direction is meaningless. Flag GAUSS affects the result."[p$2283,-1],">::",1];
   p1$2283=If[p1$2283==={},304,-2+p$2283+p1$2283[[1,1]]];
neq=Which["BeamMatrix[i] returns a 6 by 6 beam-matrix (i.e., <x_k x_l>) at location i. The index i can have a fraction to specify \
intermediate numbers (see LINE or Twiss). The calculation is based on linear 4 by 5 calculation in the present version, so the z-d\
irection is meaningless. Flag GAUSS affects the result."[p$2283,4+p$2283]==="Text[",
    lx$2283:=Help2HTML`oa$;p$2283=5+p$2283;p1$2283-=1;p2$2283=5+p1$2283;p0$2283=-9+p$2283;
If[(pe$2283=StringPosition["BeamMatrix[i] returns a 6 by 6 beam-matrix (i.e., <x_k x_l>) at location i. The index i can have a fra\
ction to specify intermediate numbers (see LINE or Twiss). The calculation is based on linear 4 by 5 calculation in the present ve\
rsion, so the z-direction is meaningless. Flag GAUSS affects the result."[p$2283,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["BeamMatrix[i] returns a 6 by 6 beam-matrix (i.e., <x_k x_l>) at location i. The index i can have a fraction to sp\
ecify intermediate numbers (see LINE or Twiss). The calculation is based on linear 4 by 5 calculation in the present version, so t\
he z-direction is meaningless. Flag GAUSS affects the result."[p$2283+pe$2283[[1,2]],p1$2283]]],
        p1$2283=-2+p$2283+pe$2283[[1,1]]}[[
       1]],
      0],
    1,lx$2283:=Help2HTML`o9$;p2$2283=4+p1$2283;p0$2283=-4+p$2283;0];
  If[(equ$2283=
Help2HTML`o8$["BeamMatrix[i] returns a 6 by 6 beam-matrix (i.e., <x_k x_l>) at location i. The index i can have a fraction to spec\
ify intermediate numbers (see LINE or Twiss). The calculation is based on linear 4 by 5 calculation in the present version, so the\
 z-direction is meaningless. Flag GAUSS affects the result."[p$2283,p1$2283]])===
    Undefined,
equ$2283="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["BeamMatrix[i] returns a 6 by 6 beam-matrix (\
i.e., <x_k x_l>) at location i. The index i can have a fraction to specify intermediate numbers (see LINE or Twiss). The calculati\
on is based on linear 4 by 5 calculation in the present version, so the z-direction is meaningless. Flag GAUSS affects the result."
        [p$2283,p1$2283]]=
       equ$2283;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2283},out$2283=lx$2283@Typeset["BeamMatrix[i] returns a 6 by 6 beam-matrix (i.e., <x_k x_l>) at location i. The index i c\
an have a fraction to specify intermediate numbers (see LINE or Twiss). The calculation is based on linear 4 by 5 calculation in t\
he present version, so the z-direction is meaningless. Flag GAUSS affects the result."[p$2283,p1$2283],Format->Help2HTML`oB$];
        System["mv -f "//out$2283//" "//equ$2283]];
      Exit[]]];
   "BeamMatrix[i] returns a 6 by 6 beam-matrix (i.e., <x_k x_l>) at location i. The index i can have a fraction to specify interme\
diate numbers (see LINE or Twiss). The calculation is based on linear 4 by 5 calculation in the present version, so the z-directio\
n is meaningless. Flag GAUSS affects the result."[1,Max[p0$2283,0]]//"<img  class=\"eqs\" SRC=\""//equ$2283//"\" />"//
   Help2HTML`oy$["BeamMatrix[i] returns a 6 by 6 beam-matrix (i.e., <x_k x_l>) at location i. The index i can have a fraction to s\
pecify intermediate numbers (see LINE or Twiss). The calculation is based on linear 4 by 5 calculation in the present version, so \
the z-direction is meaningless. Flag GAUSS affects the result."[p2$2283,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L398>LINE</A> <A HREF=#L410>Twiss</A> <A HREF=#L319>GAUSS</A></PRE>
<LI>
<H3><A NAME=L386>
DynamicApertureSurvey</A></H3>
<PRE>If[{},
Help2HTML`oA$["Usage: DynamicApertureSurvey[range,nturn,options]\n\nwhere\n\nrange: a list of {xrange,yrange,zrange}, with\n      \
 xrange: {xmin, xmax},\n       yrange: {ymin, ymax},\n       zrange: {zmin, zmax},\n       and for the horizontal plane, specified\
 by the Axes option, \n       the corresponding range must be given as {v1, ..., vn}.\n       These values are the initial amplitu\
de divided by the equilibrium \n       values, i.e., Sqrt[2Jx,y/(EMITX+EMITY)], Sqrt[2Jz/EMITZ].\n       See EMITTANCE(EMIT) comma\
nd or Emittance function.\nnturn: number of turns to track.\noptions: Output->lfn : output to the unit lfn (see OpenWrite).\n     \
    Axes->axes : one of \"XY\", \"XZ\", \"YX\", \"YZ\", \"ZX\", \"ZY\",\n          where the first character specifies the horizon\
tal axis, and\n          the second the vertical, respectively. The default is \"ZX\".\n         ReferenceOrbit->{x0, px0, y0, py0\
, z0, dp0} : Survey is done around\n          this orbit.\n         PhaseX->phix : The initial amplitude is rotated in (X, PX) pha\
se space\n          by phix. Default is zero.\n         PhaseY->phiy : The initial amplitude is rotated in (Y, PY) phase space\n  \
        by phiy. Default is zero.\n         PhaseZ->phiz : The initial amplitude is rotated in (Z, PZ) phase space\n          by p\
hiz. Default is -Pi/2.\n         ExpandElementValues->True(default) : set the values of the components\n          according to the\
 values of elements. Machine errors may be reset.\n          See machine-error-commands, CALCULATE(CALC).\n\n   DynamicApertureSur\
vey returns the result as a list:\n\n   {score,{{{xmin, xmax},{ymin, ymax},{z1, z2, .., zn}},\n           {{z1,score1,{turn1_1,..,\
turn1_50}},..,\n            {zn,scoren,{turnn_1,..,turnn_50}}}}} ,\n\nwhere score = Sum[scorei,{i,n}], scorei is the \"score\" of \
i-th momentum, and turni_j is the lost turn of the particle with i-th momentum and j-th initial amplitude.\n   DynamicApertureSurv\
ey tracks number of particles with different initial conditions in the range given by range. It outputs a z-x diagram of the dynam\
ic aperture of the ring. Fifty one initial conditions are chosen in the range x-range for each point of z-range. The initial y-amp\
litude is linearly dependent on the x-amplitude. It tracks from xmax to downward for each z-amplitude zn, until the particles turn\
s nturn with successive DAPWIDTH x-amplitudes. The default DAPWIDTH is 7.\n  DynamicApertureSurvey does parallel processing up to \
NPARA processes."],
p$2286=1+p$2286[[1,2]];p1$2286=StringPosition["Usage: DynamicApertureSurvey[range,nturn,options]\n\nwhere\n\nrange: a list of {xra\
nge,yrange,zrange}, with\n       xrange: {xmin, xmax},\n       yrange: {ymin, ymax},\n       zrange: {zmin, zmax},\n       and for\
 the horizontal plane, specified by the Axes option, \n       the corresponding range must be given as {v1, ..., vn}.\n       Thes\
e values are the initial amplitude divided by the equilibrium \n       values, i.e., Sqrt[2Jx,y/(EMITX+EMITY)], Sqrt[2Jz/EMITZ].\n\
       See EMITTANCE(EMIT) command or Emittance function.\nnturn: number of turns to track.\noptions: Output->lfn : output to the \
unit lfn (see OpenWrite).\n         Axes->axes : one of \"XY\", \"XZ\", \"YX\", \"YZ\", \"ZX\", \"ZY\",\n          where the first\
 character specifies the horizontal axis, and\n          the second the vertical, respectively. The default is \"ZX\".\n         R\
eferenceOrbit->{x0, px0, y0, py0, z0, dp0} : Survey is done around\n          this orbit.\n         PhaseX->phix : The initial amp\
litude is rotated in (X, PX) phase space\n          by phix. Default is zero.\n         PhaseY->phiy : The initial amplitude is ro\
tated in (Y, PY) phase space\n          by phiy. Default is zero.\n         PhaseZ->phiz : The initial amplitude is rotated in (Z,\
 PZ) phase space\n          by phiz. Default is -Pi/2.\n         ExpandElementValues->True(default) : set the values of the compon\
ents\n          according to the values of elements. Machine errors may be reset.\n          See machine-error-commands, CALCULATE\
(CALC).\n\n   DynamicApertureSurvey returns the result as a list:\n\n   {score,{{{xmin, xmax},{ymin, ymax},{z1, z2, .., zn}},\n   \
        {{z1,score1,{turn1_1,..,turn1_50}},..,\n            {zn,scoren,{turnn_1,..,turnn_50}}}}} ,\n\nwhere score = Sum[scorei,{i,\
n}], scorei is the \"score\" of i-th momentum, and turni_j is the lost turn of the particle with i-th momentum and j-th initial am\
plitude.\n   DynamicApertureSurvey tracks number of particles with different initial conditions in the range given by range. It ou\
tputs a z-x diagram of the dynamic aperture of the ring. Fifty one initial conditions are chosen in the range x-range for each poi\
nt of z-range. The initial y-amplitude is linearly dependent on the x-amplitude. It tracks from xmax to downward for each z-amplit\
ude zn, until the particles turns nturn with successive DAPWIDTH x-amplitudes. The default DAPWIDTH is 7.\n  DynamicApertureSurvey\
 does parallel processing up to NPARA processes."[p$2286,-1],">::",1];
   p1$2286=If[p1$2286==={},2417,-2+p$2286+p1$2286[[1,1]]];
neq=Which["Usage: DynamicApertureSurvey[range,nturn,options]\n\nwhere\n\nrange: a list of {xrange,yrange,zrange}, with\n       xra\
nge: {xmin, xmax},\n       yrange: {ymin, ymax},\n       zrange: {zmin, zmax},\n       and for the horizontal plane, specified by \
the Axes option, \n       the corresponding range must be given as {v1, ..., vn}.\n       These values are the initial amplitude d\
ivided by the equilibrium \n       values, i.e., Sqrt[2Jx,y/(EMITX+EMITY)], Sqrt[2Jz/EMITZ].\n       See EMITTANCE(EMIT) command o\
r Emittance function.\nnturn: number of turns to track.\noptions: Output->lfn : output to the unit lfn (see OpenWrite).\n         \
Axes->axes : one of \"XY\", \"XZ\", \"YX\", \"YZ\", \"ZX\", \"ZY\",\n          where the first character specifies the horizontal \
axis, and\n          the second the vertical, respectively. The default is \"ZX\".\n         ReferenceOrbit->{x0, px0, y0, py0, z0\
, dp0} : Survey is done around\n          this orbit.\n         PhaseX->phix : The initial amplitude is rotated in (X, PX) phase s\
pace\n          by phix. Default is zero.\n         PhaseY->phiy : The initial amplitude is rotated in (Y, PY) phase space\n      \
    by phiy. Default is zero.\n         PhaseZ->phiz : The initial amplitude is rotated in (Z, PZ) phase space\n          by phiz.\
 Default is -Pi/2.\n         ExpandElementValues->True(default) : set the values of the components\n          according to the val\
ues of elements. Machine errors may be reset.\n          See machine-error-commands, CALCULATE(CALC).\n\n   DynamicApertureSurvey \
returns the result as a list:\n\n   {score,{{{xmin, xmax},{ymin, ymax},{z1, z2, .., zn}},\n           {{z1,score1,{turn1_1,..,turn\
1_50}},..,\n            {zn,scoren,{turnn_1,..,turnn_50}}}}} ,\n\nwhere score = Sum[scorei,{i,n}], scorei is the \"score\" of i-th\
 momentum, and turni_j is the lost turn of the particle with i-th momentum and j-th initial amplitude.\n   DynamicApertureSurvey t\
racks number of particles with different initial conditions in the range given by range. It outputs a z-x diagram of the dynamic a\
perture of the ring. Fifty one initial conditions are chosen in the range x-range for each point of z-range. The initial y-amplitu\
de is linearly dependent on the x-amplitude. It tracks from xmax to downward for each z-amplitude zn, until the particles turns nt\
urn with successive DAPWIDTH x-amplitudes. The default DAPWIDTH is 7.\n  DynamicApertureSurvey does parallel processing up to NPAR\
A processes."[p$2286,4+p$2286]==="Text[",
    lx$2286:=Help2HTML`oa$;p$2286=5+p$2286;p1$2286-=1;p2$2286=5+p1$2286;p0$2286=-9+p$2286;If[(pe$2286=
StringPosition["Usage: DynamicApertureSurvey[range,nturn,options]\n\nwhere\n\nrange: a list of {xrange,yrange,zrange}, with\n     \
  xrange: {xmin, xmax},\n       yrange: {ymin, ymax},\n       zrange: {zmin, zmax},\n       and for the horizontal plane, specifie\
d by the Axes option, \n       the corresponding range must be given as {v1, ..., vn}.\n       These values are the initial amplit\
ude divided by the equilibrium \n       values, i.e., Sqrt[2Jx,y/(EMITX+EMITY)], Sqrt[2Jz/EMITZ].\n       See EMITTANCE(EMIT) comm\
and or Emittance function.\nnturn: number of turns to track.\noptions: Output->lfn : output to the unit lfn (see OpenWrite).\n    \
     Axes->axes : one of \"XY\", \"XZ\", \"YX\", \"YZ\", \"ZX\", \"ZY\",\n          where the first character specifies the horizo\
ntal axis, and\n          the second the vertical, respectively. The default is \"ZX\".\n         ReferenceOrbit->{x0, px0, y0, py\
0, z0, dp0} : Survey is done around\n          this orbit.\n         PhaseX->phix : The initial amplitude is rotated in (X, PX) ph\
ase space\n          by phix. Default is zero.\n         PhaseY->phiy : The initial amplitude is rotated in (Y, PY) phase space\n \
         by phiy. Default is zero.\n         PhaseZ->phiz : The initial amplitude is rotated in (Z, PZ) phase space\n          by \
phiz. Default is -Pi/2.\n         ExpandElementValues->True(default) : set the values of the components\n          according to th\
e values of elements. Machine errors may be reset.\n          See machine-error-commands, CALCULATE(CALC).\n\n   DynamicApertureSu\
rvey returns the result as a list:\n\n   {score,{{{xmin, xmax},{ymin, ymax},{z1, z2, .., zn}},\n           {{z1,score1,{turn1_1,..\
,turn1_50}},..,\n            {zn,scoren,{turnn_1,..,turnn_50}}}}} ,\n\nwhere score = Sum[scorei,{i,n}], scorei is the \"score\" of\
 i-th momentum, and turni_j is the lost turn of the particle with i-th momentum and j-th initial amplitude.\n   DynamicApertureSur\
vey tracks number of particles with different initial conditions in the range given by range. It outputs a z-x diagram of the dyna\
mic aperture of the ring. Fifty one initial conditions are chosen in the range x-range for each point of z-range. The initial y-am\
plitude is linearly dependent on the x-amplitude. It tracks from xmax to downward for each z-amplitude zn, until the particles tur\
ns nturn with successive DAPWIDTH x-amplitudes. The default DAPWIDTH is 7.\n  DynamicApertureSurvey does parallel processing up to\
 NPARA processes."[p$2286,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Usage: DynamicApertureSurvey[range,nturn,options]\n\nwhere\n\nrange: a list of {xrange,yrange,zrange}, with\n    \
   xrange: {xmin, xmax},\n       yrange: {ymin, ymax},\n       zrange: {zmin, zmax},\n       and for the horizontal plane, specifi\
ed by the Axes option, \n       the corresponding range must be given as {v1, ..., vn}.\n       These values are the initial ampli\
tude divided by the equilibrium \n       values, i.e., Sqrt[2Jx,y/(EMITX+EMITY)], Sqrt[2Jz/EMITZ].\n       See EMITTANCE(EMIT) com\
mand or Emittance function.\nnturn: number of turns to track.\noptions: Output->lfn : output to the unit lfn (see OpenWrite).\n   \
      Axes->axes : one of \"XY\", \"XZ\", \"YX\", \"YZ\", \"ZX\", \"ZY\",\n          where the first character specifies the horiz\
ontal axis, and\n          the second the vertical, respectively. The default is \"ZX\".\n         ReferenceOrbit->{x0, px0, y0, p\
y0, z0, dp0} : Survey is done around\n          this orbit.\n         PhaseX->phix : The initial amplitude is rotated in (X, PX) p\
hase space\n          by phix. Default is zero.\n         PhaseY->phiy : The initial amplitude is rotated in (Y, PY) phase space\n\
          by phiy. Default is zero.\n         PhaseZ->phiz : The initial amplitude is rotated in (Z, PZ) phase space\n          by\
 phiz. Default is -Pi/2.\n         ExpandElementValues->True(default) : set the values of the components\n          according to t\
he values of elements. Machine errors may be reset.\n          See machine-error-commands, CALCULATE(CALC).\n\n   DynamicApertureS\
urvey returns the result as a list:\n\n   {score,{{{xmin, xmax},{ymin, ymax},{z1, z2, .., zn}},\n           {{z1,score1,{turn1_1,.\
.,turn1_50}},..,\n            {zn,scoren,{turnn_1,..,turnn_50}}}}} ,\n\nwhere score = Sum[scorei,{i,n}], scorei is the \"score\" o\
f i-th momentum, and turni_j is the lost turn of the particle with i-th momentum and j-th initial amplitude.\n   DynamicApertureSu\
rvey tracks number of particles with different initial conditions in the range given by range. It outputs a z-x diagram of the dyn\
amic aperture of the ring. Fifty one initial conditions are chosen in the range x-range for each point of z-range. The initial y-a\
mplitude is linearly dependent on the x-amplitude. It tracks from xmax to downward for each z-amplitude zn, until the particles tu\
rns nturn with successive DAPWIDTH x-amplitudes. The default DAPWIDTH is 7.\n  DynamicApertureSurvey does parallel processing up t\
o NPARA processes."[p$2286+pe$2286[[1,2]],p1$2286]]],
        p1$2286=-2+p$2286+pe$2286[[1,1]]}[[
       1]],
      0],
    1,lx$2286:=Help2HTML`o9$;p2$2286=4+p1$2286;p0$2286=-4+p$2286;0];
  If[(equ$2286=
Help2HTML`o8$["Usage: DynamicApertureSurvey[range,nturn,options]\n\nwhere\n\nrange: a list of {xrange,yrange,zrange}, with\n      \
 xrange: {xmin, xmax},\n       yrange: {ymin, ymax},\n       zrange: {zmin, zmax},\n       and for the horizontal plane, specified\
 by the Axes option, \n       the corresponding range must be given as {v1, ..., vn}.\n       These values are the initial amplitu\
de divided by the equilibrium \n       values, i.e., Sqrt[2Jx,y/(EMITX+EMITY)], Sqrt[2Jz/EMITZ].\n       See EMITTANCE(EMIT) comma\
nd or Emittance function.\nnturn: number of turns to track.\noptions: Output->lfn : output to the unit lfn (see OpenWrite).\n     \
    Axes->axes : one of \"XY\", \"XZ\", \"YX\", \"YZ\", \"ZX\", \"ZY\",\n          where the first character specifies the horizon\
tal axis, and\n          the second the vertical, respectively. The default is \"ZX\".\n         ReferenceOrbit->{x0, px0, y0, py0\
, z0, dp0} : Survey is done around\n          this orbit.\n         PhaseX->phix : The initial amplitude is rotated in (X, PX) pha\
se space\n          by phix. Default is zero.\n         PhaseY->phiy : The initial amplitude is rotated in (Y, PY) phase space\n  \
        by phiy. Default is zero.\n         PhaseZ->phiz : The initial amplitude is rotated in (Z, PZ) phase space\n          by p\
hiz. Default is -Pi/2.\n         ExpandElementValues->True(default) : set the values of the components\n          according to the\
 values of elements. Machine errors may be reset.\n          See machine-error-commands, CALCULATE(CALC).\n\n   DynamicApertureSur\
vey returns the result as a list:\n\n   {score,{{{xmin, xmax},{ymin, ymax},{z1, z2, .., zn}},\n           {{z1,score1,{turn1_1,..,\
turn1_50}},..,\n            {zn,scoren,{turnn_1,..,turnn_50}}}}} ,\n\nwhere score = Sum[scorei,{i,n}], scorei is the \"score\" of \
i-th momentum, and turni_j is the lost turn of the particle with i-th momentum and j-th initial amplitude.\n   DynamicApertureSurv\
ey tracks number of particles with different initial conditions in the range given by range. It outputs a z-x diagram of the dynam\
ic aperture of the ring. Fifty one initial conditions are chosen in the range x-range for each point of z-range. The initial y-amp\
litude is linearly dependent on the x-amplitude. It tracks from xmax to downward for each z-amplitude zn, until the particles turn\
s nturn with successive DAPWIDTH x-amplitudes. The default DAPWIDTH is 7.\n  DynamicApertureSurvey does parallel processing up to \
NPARA processes."[p$2286,p1$2286]])===
    Undefined,
equ$2286="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Usage: DynamicApertureSurvey[range,nturn,opt\
ions]\n\nwhere\n\nrange: a list of {xrange,yrange,zrange}, with\n       xrange: {xmin, xmax},\n       yrange: {ymin, ymax},\n     \
  zrange: {zmin, zmax},\n       and for the horizontal plane, specified by the Axes option, \n       the corresponding range must \
be given as {v1, ..., vn}.\n       These values are the initial amplitude divided by the equilibrium \n       values, i.e., Sqrt[2\
Jx,y/(EMITX+EMITY)], Sqrt[2Jz/EMITZ].\n       See EMITTANCE(EMIT) command or Emittance function.\nnturn: number of turns to track.\
\noptions: Output->lfn : output to the unit lfn (see OpenWrite).\n         Axes->axes : one of \"XY\", \"XZ\", \"YX\", \"YZ\", \"Z\
X\", \"ZY\",\n          where the first character specifies the horizontal axis, and\n          the second the vertical, respectiv\
ely. The default is \"ZX\".\n         ReferenceOrbit->{x0, px0, y0, py0, z0, dp0} : Survey is done around\n          this orbit.\n\
         PhaseX->phix : The initial amplitude is rotated in (X, PX) phase space\n          by phix. Default is zero.\n         Pha\
seY->phiy : The initial amplitude is rotated in (Y, PY) phase space\n          by phiy. Default is zero.\n         PhaseZ->phiz : \
The initial amplitude is rotated in (Z, PZ) phase space\n          by phiz. Default is -Pi/2.\n         ExpandElementValues->True(\
default) : set the values of the components\n          according to the values of elements. Machine errors may be reset.\n        \
  See machine-error-commands, CALCULATE(CALC).\n\n   DynamicApertureSurvey returns the result as a list:\n\n   {score,{{{xmin, xma\
x},{ymin, ymax},{z1, z2, .., zn}},\n           {{z1,score1,{turn1_1,..,turn1_50}},..,\n            {zn,scoren,{turnn_1,..,turnn_50\
}}}}} ,\n\nwhere score = Sum[scorei,{i,n}], scorei is the \"score\" of i-th momentum, and turni_j is the lost turn of the particle\
 with i-th momentum and j-th initial amplitude.\n   DynamicApertureSurvey tracks number of particles with different initial condit\
ions in the range given by range. It outputs a z-x diagram of the dynamic aperture of the ring. Fifty one initial conditions are c\
hosen in the range x-range for each point of z-range. The initial y-amplitude is linearly dependent on the x-amplitude. It tracks \
from xmax to downward for each z-amplitude zn, until the particles turns nturn with successive DAPWIDTH x-amplitudes. The default \
DAPWIDTH is 7.\n  DynamicApertureSurvey does parallel processing up to NPARA processes."[p$2286,p1$2286]]=
       equ$2286;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2286},out$2286=lx$2286@Typeset["Usage: DynamicApertureSurvey[range,nturn,options]\n\nwhere\n\nrange: a list of {xrange,yr\
ange,zrange}, with\n       xrange: {xmin, xmax},\n       yrange: {ymin, ymax},\n       zrange: {zmin, zmax},\n       and for the h\
orizontal plane, specified by the Axes option, \n       the corresponding range must be given as {v1, ..., vn}.\n       These valu\
es are the initial amplitude divided by the equilibrium \n       values, i.e., Sqrt[2Jx,y/(EMITX+EMITY)], Sqrt[2Jz/EMITZ].\n      \
 See EMITTANCE(EMIT) command or Emittance function.\nnturn: number of turns to track.\noptions: Output->lfn : output to the unit l\
fn (see OpenWrite).\n         Axes->axes : one of \"XY\", \"XZ\", \"YX\", \"YZ\", \"ZX\", \"ZY\",\n          where the first chara\
cter specifies the horizontal axis, and\n          the second the vertical, respectively. The default is \"ZX\".\n         Referen\
ceOrbit->{x0, px0, y0, py0, z0, dp0} : Survey is done around\n          this orbit.\n         PhaseX->phix : The initial amplitude\
 is rotated in (X, PX) phase space\n          by phix. Default is zero.\n         PhaseY->phiy : The initial amplitude is rotated \
in (Y, PY) phase space\n          by phiy. Default is zero.\n         PhaseZ->phiz : The initial amplitude is rotated in (Z, PZ) p\
hase space\n          by phiz. Default is -Pi/2.\n         ExpandElementValues->True(default) : set the values of the components\n\
          according to the values of elements. Machine errors may be reset.\n          See machine-error-commands, CALCULATE(CALC)\
.\n\n   DynamicApertureSurvey returns the result as a list:\n\n   {score,{{{xmin, xmax},{ymin, ymax},{z1, z2, .., zn}},\n         \
  {{z1,score1,{turn1_1,..,turn1_50}},..,\n            {zn,scoren,{turnn_1,..,turnn_50}}}}} ,\n\nwhere score = Sum[scorei,{i,n}], s\
corei is the \"score\" of i-th momentum, and turni_j is the lost turn of the particle with i-th momentum and j-th initial amplitud\
e.\n   DynamicApertureSurvey tracks number of particles with different initial conditions in the range given by range. It outputs \
a z-x diagram of the dynamic aperture of the ring. Fifty one initial conditions are chosen in the range x-range for each point of \
z-range. The initial y-amplitude is linearly dependent on the x-amplitude. It tracks from xmax to downward for each z-amplitude zn\
, until the particles turns nturn with successive DAPWIDTH x-amplitudes. The default DAPWIDTH is 7.\n  DynamicApertureSurvey does \
parallel processing up to NPARA processes."[p$2286,p1$2286],Format->Help2HTML`oB$];
        System["mv -f "//out$2286//" "//equ$2286]];
      Exit[]]];
   "Usage: DynamicApertureSurvey[range,nturn,options]\n\nwhere\n\nrange: a list of {xrange,yrange,zrange}, with\n       xrange: {x\
min, xmax},\n       yrange: {ymin, ymax},\n       zrange: {zmin, zmax},\n       and for the horizontal plane, specified by the Axe\
s option, \n       the corresponding range must be given as {v1, ..., vn}.\n       These values are the initial amplitude divided \
by the equilibrium \n       values, i.e., Sqrt[2Jx,y/(EMITX+EMITY)], Sqrt[2Jz/EMITZ].\n       See EMITTANCE(EMIT) command or Emitt\
ance function.\nnturn: number of turns to track.\noptions: Output->lfn : output to the unit lfn (see OpenWrite).\n         Axes->a\
xes : one of \"XY\", \"XZ\", \"YX\", \"YZ\", \"ZX\", \"ZY\",\n          where the first character specifies the horizontal axis, a\
nd\n          the second the vertical, respectively. The default is \"ZX\".\n         ReferenceOrbit->{x0, px0, y0, py0, z0, dp0} \
: Survey is done around\n          this orbit.\n         PhaseX->phix : The initial amplitude is rotated in (X, PX) phase space\n \
         by phix. Default is zero.\n         PhaseY->phiy : The initial amplitude is rotated in (Y, PY) phase space\n          by \
phiy. Default is zero.\n         PhaseZ->phiz : The initial amplitude is rotated in (Z, PZ) phase space\n          by phiz. Defaul\
t is -Pi/2.\n         ExpandElementValues->True(default) : set the values of the components\n          according to the values of \
elements. Machine errors may be reset.\n          See machine-error-commands, CALCULATE(CALC).\n\n   DynamicApertureSurvey returns\
 the result as a list:\n\n   {score,{{{xmin, xmax},{ymin, ymax},{z1, z2, .., zn}},\n           {{z1,score1,{turn1_1,..,turn1_50}},\
..,\n            {zn,scoren,{turnn_1,..,turnn_50}}}}} ,\n\nwhere score = Sum[scorei,{i,n}], scorei is the \"score\" of i-th moment\
um, and turni_j is the lost turn of the particle with i-th momentum and j-th initial amplitude.\n   DynamicApertureSurvey tracks n\
umber of particles with different initial conditions in the range given by range. It outputs a z-x diagram of the dynamic aperture\
 of the ring. Fifty one initial conditions are chosen in the range x-range for each point of z-range. The initial y-amplitude is l\
inearly dependent on the x-amplitude. It tracks from xmax to downward for each z-amplitude zn, until the particles turns nturn wit\
h successive DAPWIDTH x-amplitudes. The default DAPWIDTH is 7.\n  DynamicApertureSurvey does parallel processing up to NPARA proce\
sses."[1,Max[p0$2286,0]]//"<img  class=\"eqs\" SRC=\""//equ$2286//"\" />"//
Help2HTML`oy$["Usage: DynamicApertureSurvey[range,nturn,options]\n\nwhere\n\nrange: a list of {xrange,yrange,zrange}, with\n      \
 xrange: {xmin, xmax},\n       yrange: {ymin, ymax},\n       zrange: {zmin, zmax},\n       and for the horizontal plane, specified\
 by the Axes option, \n       the corresponding range must be given as {v1, ..., vn}.\n       These values are the initial amplitu\
de divided by the equilibrium \n       values, i.e., Sqrt[2Jx,y/(EMITX+EMITY)], Sqrt[2Jz/EMITZ].\n       See EMITTANCE(EMIT) comma\
nd or Emittance function.\nnturn: number of turns to track.\noptions: Output->lfn : output to the unit lfn (see OpenWrite).\n     \
    Axes->axes : one of \"XY\", \"XZ\", \"YX\", \"YZ\", \"ZX\", \"ZY\",\n          where the first character specifies the horizon\
tal axis, and\n          the second the vertical, respectively. The default is \"ZX\".\n         ReferenceOrbit->{x0, px0, y0, py0\
, z0, dp0} : Survey is done around\n          this orbit.\n         PhaseX->phix : The initial amplitude is rotated in (X, PX) pha\
se space\n          by phix. Default is zero.\n         PhaseY->phiy : The initial amplitude is rotated in (Y, PY) phase space\n  \
        by phiy. Default is zero.\n         PhaseZ->phiz : The initial amplitude is rotated in (Z, PZ) phase space\n          by p\
hiz. Default is -Pi/2.\n         ExpandElementValues->True(default) : set the values of the components\n          according to the\
 values of elements. Machine errors may be reset.\n          See machine-error-commands, CALCULATE(CALC).\n\n   DynamicApertureSur\
vey returns the result as a list:\n\n   {score,{{{xmin, xmax},{ymin, ymax},{z1, z2, .., zn}},\n           {{z1,score1,{turn1_1,..,\
turn1_50}},..,\n            {zn,scoren,{turnn_1,..,turnn_50}}}}} ,\n\nwhere score = Sum[scorei,{i,n}], scorei is the \"score\" of \
i-th momentum, and turni_j is the lost turn of the particle with i-th momentum and j-th initial amplitude.\n   DynamicApertureSurv\
ey tracks number of particles with different initial conditions in the range given by range. It outputs a z-x diagram of the dynam\
ic aperture of the ring. Fifty one initial conditions are chosen in the range x-range for each point of z-range. The initial y-amp\
litude is linearly dependent on the x-amplitude. It tracks from xmax to downward for each z-amplitude zn, until the particles turn\
s nturn with successive DAPWIDTH x-amplitudes. The default DAPWIDTH is 7.\n  DynamicApertureSurvey does parallel processing up to \
NPARA processes."[p2$2286,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L535>NPARA</A> <A HREF=#L505>DAPWIDTH</A> <A HREF=#L295>EMITTANCE(EMIT)</A> <A HREF=#L389>Emittance</A></PRE>
<LI>
<H3><A NAME=L387>
Element</A></H3>
<PRE>If[{},
Help2HTML`oA$["Element[key-string, {element-pattern-string | element-position}] returns values for key-string of elements which ma\
tch element-pattern-string or located at element-position. It returns a list if more than one elements match. The key-string and e\
lement-pattern-string can be symbols, unless values are not assigned to them.\n   If the second argument is omitted, it means all \
elements.\n   The element-position can be known by Element[\"POSITION\"].\n   Key-strings \"VALUE\" and element-keywords allows to\
 be set (i.e., Element[a,b] = v) when element-pattern-string chooses only one element. If a value is set to Element, it is automat\
ically distributed to all components those belong to the element. If the keyword is the default variable, the error given by machi\
ne-error-command DK is applied.\n   The arguments of Element can be lists. It automatically maps as\n\n   Element[{a,b,c..},y]  me\
ans {Element[a,y],Element[b,y],Element[c,y]..}\n   Element[x,{a,b,c..}]  means {Element[x,a],Element[x,b],Element[x,c]..},\n\nwher\
e both x and y can be also a list.\n\n   If an option Saved->True is given, Element refers the save-buffer which can be transferre\
d to other beam lines. Otherwise values set by Element are not saved when FFS is stopped, unless they are the default-keyword or k\
eywords once used in matching."],
p$2289=1+p$2289[[1,2]];p1$2289=StringPosition["Element[key-string, {element-pattern-string | element-position}] returns values for\
 key-string of elements which match element-pattern-string or located at element-position. It returns a list if more than one elem\
ents match. The key-string and element-pattern-string can be symbols, unless values are not assigned to them.\n   If the second ar\
gument is omitted, it means all elements.\n   The element-position can be known by Element[\"POSITION\"].\n   Key-strings \"VALUE\\
" and element-keywords allows to be set (i.e., Element[a,b] = v) when element-pattern-string chooses only one element. If a value \
is set to Element, it is automatically distributed to all components those belong to the element. If the keyword is the default va\
riable, the error given by machine-error-command DK is applied.\n   The arguments of Element can be lists. It automatically maps a\
s\n\n   Element[{a,b,c..},y]  means {Element[a,y],Element[b,y],Element[c,y]..}\n   Element[x,{a,b,c..}]  means {Element[x,a],Eleme\
nt[x,b],Element[x,c]..},\n\nwhere both x and y can be also a list.\n\n   If an option Saved->True is given, Element refers the sav\
e-buffer which can be transferred to other beam lines. Otherwise values set by Element are not saved when FFS is stopped, unless t\
hey are the default-keyword or keywords once used in matching."[p$2289,-1],">::",1];
   p1$2289=If[p1$2289==={},1300,-2+p$2289+p1$2289[[1,1]]];
neq=Which["Element[key-string, {element-pattern-string | element-position}] returns values for key-string of elements which match \
element-pattern-string or located at element-position. It returns a list if more than one elements match. The key-string and eleme\
nt-pattern-string can be symbols, unless values are not assigned to them.\n   If the second argument is omitted, it means all elem\
ents.\n   The element-position can be known by Element[\"POSITION\"].\n   Key-strings \"VALUE\" and element-keywords allows to be \
set (i.e., Element[a,b] = v) when element-pattern-string chooses only one element. If a value is set to Element, it is automatical\
ly distributed to all components those belong to the element. If the keyword is the default variable, the error given by machine-e\
rror-command DK is applied.\n   The arguments of Element can be lists. It automatically maps as\n\n   Element[{a,b,c..},y]  means \
{Element[a,y],Element[b,y],Element[c,y]..}\n   Element[x,{a,b,c..}]  means {Element[x,a],Element[x,b],Element[x,c]..},\n\nwhere bo\
th x and y can be also a list.\n\n   If an option Saved->True is given, Element refers the save-buffer which can be transferred to\
 other beam lines. Otherwise values set by Element are not saved when FFS is stopped, unless they are the default-keyword or keywo\
rds once used in matching."[p$2289,4+p$2289]==="Text[",
    lx$2289:=Help2HTML`oa$;p$2289=5+p$2289;p1$2289-=1;p2$2289=5+p1$2289;p0$2289=-9+p$2289;
If[(pe$2289=StringPosition["Element[key-string, {element-pattern-string | element-position}] returns values for key-string of elem\
ents which match element-pattern-string or located at element-position. It returns a list if more than one elements match. The key\
-string and element-pattern-string can be symbols, unless values are not assigned to them.\n   If the second argument is omitted, \
it means all elements.\n   The element-position can be known by Element[\"POSITION\"].\n   Key-strings \"VALUE\" and element-keywo\
rds allows to be set (i.e., Element[a,b] = v) when element-pattern-string chooses only one element. If a value is set to Element, \
it is automatically distributed to all components those belong to the element. If the keyword is the default variable, the error g\
iven by machine-error-command DK is applied.\n   The arguments of Element can be lists. It automatically maps as\n\n   Element[{a,\
b,c..},y]  means {Element[a,y],Element[b,y],Element[c,y]..}\n   Element[x,{a,b,c..}]  means {Element[x,a],Element[x,b],Element[x,c\
]..},\n\nwhere both x and y can be also a list.\n\n   If an option Saved->True is given, Element refers the save-buffer which can \
be transferred to other beam lines. Otherwise values set by Element are not saved when FFS is stopped, unless they are the default\
-keyword or keywords once used in matching."[p$2289,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Element[key-string, {element-pattern-string | element-position}] returns values for key-string of elements which \
match element-pattern-string or located at element-position. It returns a list if more than one elements match. The key-string and\
 element-pattern-string can be symbols, unless values are not assigned to them.\n   If the second argument is omitted, it means al\
l elements.\n   The element-position can be known by Element[\"POSITION\"].\n   Key-strings \"VALUE\" and element-keywords allows \
to be set (i.e., Element[a,b] = v) when element-pattern-string chooses only one element. If a value is set to Element, it is autom\
atically distributed to all components those belong to the element. If the keyword is the default variable, the error given by mac\
hine-error-command DK is applied.\n   The arguments of Element can be lists. It automatically maps as\n\n   Element[{a,b,c..},y]  \
means {Element[a,y],Element[b,y],Element[c,y]..}\n   Element[x,{a,b,c..}]  means {Element[x,a],Element[x,b],Element[x,c]..},\n\nwh\
ere both x and y can be also a list.\n\n   If an option Saved->True is given, Element refers the save-buffer which can be transfer\
red to other beam lines. Otherwise values set by Element are not saved when FFS is stopped, unless they are the default-keyword or\
 keywords once used in matching."[p$2289+pe$2289[[1,2]],p1$2289]]],
        p1$2289=-2+p$2289+pe$2289[[1,1]]}[[
       1]],
      0],
    1,lx$2289:=Help2HTML`o9$;p2$2289=4+p1$2289;p0$2289=-4+p$2289;0];
  If[(equ$2289=
Help2HTML`o8$["Element[key-string, {element-pattern-string | element-position}] returns values for key-string of elements which ma\
tch element-pattern-string or located at element-position. It returns a list if more than one elements match. The key-string and e\
lement-pattern-string can be symbols, unless values are not assigned to them.\n   If the second argument is omitted, it means all \
elements.\n   The element-position can be known by Element[\"POSITION\"].\n   Key-strings \"VALUE\" and element-keywords allows to\
 be set (i.e., Element[a,b] = v) when element-pattern-string chooses only one element. If a value is set to Element, it is automat\
ically distributed to all components those belong to the element. If the keyword is the default variable, the error given by machi\
ne-error-command DK is applied.\n   The arguments of Element can be lists. It automatically maps as\n\n   Element[{a,b,c..},y]  me\
ans {Element[a,y],Element[b,y],Element[c,y]..}\n   Element[x,{a,b,c..}]  means {Element[x,a],Element[x,b],Element[x,c]..},\n\nwher\
e both x and y can be also a list.\n\n   If an option Saved->True is given, Element refers the save-buffer which can be transferre\
d to other beam lines. Otherwise values set by Element are not saved when FFS is stopped, unless they are the default-keyword or k\
eywords once used in matching."[p$2289,p1$2289]])===
    Undefined,
equ$2289="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Element[key-string, {element-pattern-string \
| element-position}] returns values for key-string of elements which match element-pattern-string or located at element-position. \
It returns a list if more than one elements match. The key-string and element-pattern-string can be symbols, unless values are not\
 assigned to them.\n   If the second argument is omitted, it means all elements.\n   The element-position can be known by Element[\
\"POSITION\"].\n   Key-strings \"VALUE\" and element-keywords allows to be set (i.e., Element[a,b] = v) when element-pattern-strin\
g chooses only one element. If a value is set to Element, it is automatically distributed to all components those belong to the el\
ement. If the keyword is the default variable, the error given by machine-error-command DK is applied.\n   The arguments of Elemen\
t can be lists. It automatically maps as\n\n   Element[{a,b,c..},y]  means {Element[a,y],Element[b,y],Element[c,y]..}\n   Element[\
x,{a,b,c..}]  means {Element[x,a],Element[x,b],Element[x,c]..},\n\nwhere both x and y can be also a list.\n\n   If an option Saved\
->True is given, Element refers the save-buffer which can be transferred to other beam lines. Otherwise values set by Element are \
not saved when FFS is stopped, unless they are the default-keyword or keywords once used in matching."[p$2289,p1$2289]]=
       equ$2289;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2289},out$2289=lx$2289@Typeset["Element[key-string, {element-pattern-string | element-position}] returns values for key-s\
tring of elements which match element-pattern-string or located at element-position. It returns a list if more than one elements m\
atch. The key-string and element-pattern-string can be symbols, unless values are not assigned to them.\n   If the second argument\
 is omitted, it means all elements.\n   The element-position can be known by Element[\"POSITION\"].\n   Key-strings \"VALUE\" and \
element-keywords allows to be set (i.e., Element[a,b] = v) when element-pattern-string chooses only one element. If a value is set\
 to Element, it is automatically distributed to all components those belong to the element. If the keyword is the default variable\
, the error given by machine-error-command DK is applied.\n   The arguments of Element can be lists. It automatically maps as\n\n \
  Element[{a,b,c..},y]  means {Element[a,y],Element[b,y],Element[c,y]..}\n   Element[x,{a,b,c..}]  means {Element[x,a],Element[x,b\
],Element[x,c]..},\n\nwhere both x and y can be also a list.\n\n   If an option Saved->True is given, Element refers the save-buff\
er which can be transferred to other beam lines. Otherwise values set by Element are not saved when FFS is stopped, unless they ar\
e the default-keyword or keywords once used in matching."[p$2289,p1$2289],Format->Help2HTML`oB$];
        System["mv -f "//out$2289//" "//equ$2289]];
      Exit[]]];
   "Element[key-string, {element-pattern-string | element-position}] returns values for key-string of elements which match element\
-pattern-string or located at element-position. It returns a list if more than one elements match. The key-string and element-patt\
ern-string can be symbols, unless values are not assigned to them.\n   If the second argument is omitted, it means all elements.\n\
   The element-position can be known by Element[\"POSITION\"].\n   Key-strings \"VALUE\" and element-keywords allows to be set (i.\
e., Element[a,b] = v) when element-pattern-string chooses only one element. If a value is set to Element, it is automatically dist\
ributed to all components those belong to the element. If the keyword is the default variable, the error given by machine-error-co\
mmand DK is applied.\n   The arguments of Element can be lists. It automatically maps as\n\n   Element[{a,b,c..},y]  means {Elemen\
t[a,y],Element[b,y],Element[c,y]..}\n   Element[x,{a,b,c..}]  means {Element[x,a],Element[x,b],Element[x,c]..},\n\nwhere both x an\
d y can be also a list.\n\n   If an option Saved->True is given, Element refers the save-buffer which can be transferred to other \
beam lines. Otherwise values set by Element are not saved when FFS is stopped, unless they are the default-keyword or keywords onc\
e used in matching."[1,Max[p0$2289,0]]//"<img  class=\"eqs\" SRC=\""//equ$2289//"\" />"//
Help2HTML`oy$["Element[key-string, {element-pattern-string | element-position}] returns values for key-string of elements which ma\
tch element-pattern-string or located at element-position. It returns a list if more than one elements match. The key-string and e\
lement-pattern-string can be symbols, unless values are not assigned to them.\n   If the second argument is omitted, it means all \
elements.\n   The element-position can be known by Element[\"POSITION\"].\n   Key-strings \"VALUE\" and element-keywords allows to\
 be set (i.e., Element[a,b] = v) when element-pattern-string chooses only one element. If a value is set to Element, it is automat\
ically distributed to all components those belong to the element. If the keyword is the default variable, the error given by machi\
ne-error-command DK is applied.\n   The arguments of Element can be lists. It automatically maps as\n\n   Element[{a,b,c..},y]  me\
ans {Element[a,y],Element[b,y],Element[c,y]..}\n   Element[x,{a,b,c..}]  means {Element[x,a],Element[x,b],Element[x,c]..},\n\nwher\
e both x and y can be also a list.\n\n   If an option Saved->True is given, Element refers the save-buffer which can be transferre\
d to other beam lines. Otherwise values set by Element are not saved when FFS is stopped, unless they are the default-keyword or k\
eywords once used in matching."[p2$2289,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L75>elements</A> <A HREF=#L562>wildcards</A> <A HREF=#L30>components</A> <A HREF=#L398>LINE</A> <A HREF=#L404>SetElement</A></PRE>
<UL>
<LI>
<H3><A NAME=L388>
key-strings:Element</A></H3>
<PRE>If[{},
Help2HTML`oA$["The key-string is not case-sensitive. Available key-strings are:\t\n\n\"LENGTH\"       Number of elements in the be\
am line. No second argument.\n\"POSITION\"     Position of the element in the element-list.\n\"NAME\"         Name of the element.\
\n\"VALUE\"        Current value of the default keyword of the element.\n\"KEYWORDS\"     List of available keywords of the elemen\
t.\n\"DEFAULT\"      The default keyword of the element\n\"TYPE\"         The internal code-number of the type of the element.\n\"\
TYPENAME\"     The name of the type of the element.\nkeyword        If keyword is the default keyword, it means the current value.\
 If not, it means the saved value. Changing the non-default keyword by Element does not affects the current setting of the compone\
nts.\n\"EXPAND\"       Distribute the value of the default-keywords and the keywords used in the matching to all components in the\
 beam line. No second argument.\t\n\nSetting by Element[\"VALUE\",..] or Element[keyword,..] to the DEFAULT  keyword or a matching\
-variable keyword changes the current value, and  distributed to the components in the succeeding calculation."],
 p$2292=1+p$2292[[1,2]];
p1$2292=StringPosition["The key-string is not case-sensitive. Available key-strings are:\t\n\n\"LENGTH\"       Number of elements \
in the beam line. No second argument.\n\"POSITION\"     Position of the element in the element-list.\n\"NAME\"         Name of the\
 element.\n\"VALUE\"        Current value of the default keyword of the element.\n\"KEYWORDS\"     List of available keywords of t\
he element.\n\"DEFAULT\"      The default keyword of the element\n\"TYPE\"         The internal code-number of the type of the ele\
ment.\n\"TYPENAME\"     The name of the type of the element.\nkeyword        If keyword is the default keyword, it means the curre\
nt value. If not, it means the saved value. Changing the non-default keyword by Element does not affects the current setting of th\
e components.\n\"EXPAND\"       Distribute the value of the default-keywords and the keywords used in the matching to all componen\
ts in the beam line. No second argument.\t\n\nSetting by Element[\"VALUE\",..] or Element[keyword,..] to the DEFAULT  keyword or a\
 matching-variable keyword changes the current value, and  distributed to the components in the succeeding calculation."[p$2292,-1
     ],
    ">::",1];
   p1$2292=If[p1$2292==={},1100,-2+p$2292+p1$2292[[1,1]]];
neq=Which["The key-string is not case-sensitive. Available key-strings are:\t\n\n\"LENGTH\"       Number of elements in the beam l\
ine. No second argument.\n\"POSITION\"     Position of the element in the element-list.\n\"NAME\"         Name of the element.\n\"\
VALUE\"        Current value of the default keyword of the element.\n\"KEYWORDS\"     List of available keywords of the element.\n\
\"DEFAULT\"      The default keyword of the element\n\"TYPE\"         The internal code-number of the type of the element.\n\"TYPE\
NAME\"     The name of the type of the element.\nkeyword        If keyword is the default keyword, it means the current value. If \
not, it means the saved value. Changing the non-default keyword by Element does not affects the current setting of the components.\
\n\"EXPAND\"       Distribute the value of the default-keywords and the keywords used in the matching to all components in the bea\
m line. No second argument.\t\n\nSetting by Element[\"VALUE\",..] or Element[keyword,..] to the DEFAULT  keyword or a matching-var\
iable keyword changes the current value, and  distributed to the components in the succeeding calculation."[p$2292,4+p$2292]===
     "Text[",
lx$2292:=Help2HTML`oa$;p$2292=5+p$2292;p1$2292-=1;p2$2292=5+p1$2292;p0$2292=-9+p$2292;If[(pe$2292=StringPosition["The key-string i\
s not case-sensitive. Available key-strings are:\t\n\n\"LENGTH\"       Number of elements in the beam line. No second argument.\n\\
"POSITION\"     Position of the element in the element-list.\n\"NAME\"         Name of the element.\n\"VALUE\"        Current valu\
e of the default keyword of the element.\n\"KEYWORDS\"     List of available keywords of the element.\n\"DEFAULT\"      The defaul\
t keyword of the element\n\"TYPE\"         The internal code-number of the type of the element.\n\"TYPENAME\"     The name of the \
type of the element.\nkeyword        If keyword is the default keyword, it means the current value. If not, it means the saved val\
ue. Changing the non-default keyword by Element does not affects the current setting of the components.\n\"EXPAND\"       Distribu\
te the value of the default-keywords and the keywords used in the matching to all components in the beam line. No second argument.\
\t\n\nSetting by Element[\"VALUE\",..] or Element[keyword,..] to the DEFAULT  keyword or a matching-variable keyword changes the c\
urrent value, and  distributed to the components in the succeeding calculation."[p$2292,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["The key-string is not case-sensitive. Available key-strings are:\t\n\n\"LENGTH\"       Number of elements in the \
beam line. No second argument.\n\"POSITION\"     Position of the element in the element-list.\n\"NAME\"         Name of the elemen\
t.\n\"VALUE\"        Current value of the default keyword of the element.\n\"KEYWORDS\"     List of available keywords of the elem\
ent.\n\"DEFAULT\"      The default keyword of the element\n\"TYPE\"         The internal code-number of the type of the element.\n\
\"TYPENAME\"     The name of the type of the element.\nkeyword        If keyword is the default keyword, it means the current valu\
e. If not, it means the saved value. Changing the non-default keyword by Element does not affects the current setting of the compo\
nents.\n\"EXPAND\"       Distribute the value of the default-keywords and the keywords used in the matching to all components in t\
he beam line. No second argument.\t\n\nSetting by Element[\"VALUE\",..] or Element[keyword,..] to the DEFAULT  keyword or a matchi\
ng-variable keyword changes the current value, and  distributed to the components in the succeeding calculation."[p$2292+
            pe$2292[[1,2]],
           p1$2292]]],
        p1$2292=-2+p$2292+pe$2292[[1,1]]}[[
       1]],
      0],
    1,lx$2292:=Help2HTML`o9$;p2$2292=4+p1$2292;p0$2292=-4+p$2292;0];
  If[(equ$2292=
Help2HTML`o8$["The key-string is not case-sensitive. Available key-strings are:\t\n\n\"LENGTH\"       Number of elements in the be\
am line. No second argument.\n\"POSITION\"     Position of the element in the element-list.\n\"NAME\"         Name of the element.\
\n\"VALUE\"        Current value of the default keyword of the element.\n\"KEYWORDS\"     List of available keywords of the elemen\
t.\n\"DEFAULT\"      The default keyword of the element\n\"TYPE\"         The internal code-number of the type of the element.\n\"\
TYPENAME\"     The name of the type of the element.\nkeyword        If keyword is the default keyword, it means the current value.\
 If not, it means the saved value. Changing the non-default keyword by Element does not affects the current setting of the compone\
nts.\n\"EXPAND\"       Distribute the value of the default-keywords and the keywords used in the matching to all components in the\
 beam line. No second argument.\t\n\nSetting by Element[\"VALUE\",..] or Element[keyword,..] to the DEFAULT  keyword or a matching\
-variable keyword changes the current value, and  distributed to the components in the succeeding calculation."[p$2292,p1$2292]]
     )===
    Undefined,
equ$2292="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["The key-string is not case-sensitive. Availa\
ble key-strings are:\t\n\n\"LENGTH\"       Number of elements in the beam line. No second argument.\n\"POSITION\"     Position of \
the element in the element-list.\n\"NAME\"         Name of the element.\n\"VALUE\"        Current value of the default keyword of \
the element.\n\"KEYWORDS\"     List of available keywords of the element.\n\"DEFAULT\"      The default keyword of the element\n\"\
TYPE\"         The internal code-number of the type of the element.\n\"TYPENAME\"     The name of the type of the element.\nkeywor\
d        If keyword is the default keyword, it means the current value. If not, it means the saved value. Changing the non-default\
 keyword by Element does not affects the current setting of the components.\n\"EXPAND\"       Distribute the value of the default-\
keywords and the keywords used in the matching to all components in the beam line. No second argument.\t\n\nSetting by Element[\"V\
ALUE\",..] or Element[keyword,..] to the DEFAULT  keyword or a matching-variable keyword changes the current value, and  distribut\
ed to the components in the succeeding calculation."[p$2292,p1$2292]]=
       equ$2292;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2292},out$2292=lx$2292@Typeset["The key-string is not case-sensitive. Available key-strings are:\t\n\n\"LENGTH\"       Nu\
mber of elements in the beam line. No second argument.\n\"POSITION\"     Position of the element in the element-list.\n\"NAME\"   \
      Name of the element.\n\"VALUE\"        Current value of the default keyword of the element.\n\"KEYWORDS\"     List of availa\
ble keywords of the element.\n\"DEFAULT\"      The default keyword of the element\n\"TYPE\"         The internal code-number of th\
e type of the element.\n\"TYPENAME\"     The name of the type of the element.\nkeyword        If keyword is the default keyword, i\
t means the current value. If not, it means the saved value. Changing the non-default keyword by Element does not affects the curr\
ent setting of the components.\n\"EXPAND\"       Distribute the value of the default-keywords and the keywords used in the matchin\
g to all components in the beam line. No second argument.\t\n\nSetting by Element[\"VALUE\",..] or Element[keyword,..] to the DEFA\
ULT  keyword or a matching-variable keyword changes the current value, and  distributed to the components in the succeeding calcul\
ation."[p$2292,p1$2292],Format->Help2HTML`oB$];
        System["mv -f "//out$2292//" "//equ$2292]];
      Exit[]]];
   "The key-string is not case-sensitive. Available key-strings are:\t\n\n\"LENGTH\"       Number of elements in the beam line. No\
 second argument.\n\"POSITION\"     Position of the element in the element-list.\n\"NAME\"         Name of the element.\n\"VALUE\"\
        Current value of the default keyword of the element.\n\"KEYWORDS\"     List of available keywords of the element.\n\"DEFAU\
LT\"      The default keyword of the element\n\"TYPE\"         The internal code-number of the type of the element.\n\"TYPENAME\" \
    The name of the type of the element.\nkeyword        If keyword is the default keyword, it means the current value. If not, it\
 means the saved value. Changing the non-default keyword by Element does not affects the current setting of the components.\n\"EXP\
AND\"       Distribute the value of the default-keywords and the keywords used in the matching to all components in the beam line.\
 No second argument.\t\n\nSetting by Element[\"VALUE\",..] or Element[keyword,..] to the DEFAULT  keyword or a matching-variable k\
eyword changes the current value, and  distributed to the components in the succeeding calculation."[1,Max[p0$2292,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2292//"\" />"//
Help2HTML`oy$["The key-string is not case-sensitive. Available key-strings are:\t\n\n\"LENGTH\"       Number of elements in the be\
am line. No second argument.\n\"POSITION\"     Position of the element in the element-list.\n\"NAME\"         Name of the element.\
\n\"VALUE\"        Current value of the default keyword of the element.\n\"KEYWORDS\"     List of available keywords of the elemen\
t.\n\"DEFAULT\"      The default keyword of the element\n\"TYPE\"         The internal code-number of the type of the element.\n\"\
TYPENAME\"     The name of the type of the element.\nkeyword        If keyword is the default keyword, it means the current value.\
 If not, it means the saved value. Changing the non-default keyword by Element does not affects the current setting of the compone\
nts.\n\"EXPAND\"       Distribute the value of the default-keywords and the keywords used in the matching to all components in the\
 beam line. No second argument.\t\n\nSetting by Element[\"VALUE\",..] or Element[keyword,..] to the DEFAULT  keyword or a matching\
-variable keyword changes the current value, and  distributed to the components in the succeeding calculation."[p2$2292,-1]]
 ]
</PRE>
<PRE>See also:
 <A HREF=#L497>set-value-of-element</A> <A HREF=#L75>elements</A> <A HREF=#L136>keywords</A> <A HREF=#L113>default-keyword</A> <A HREF=#L30>components</A></PRE>
</UL>
<LI>
<H3><A NAME=L389>
Emittance</A></H3>
<PRE>If[{},
Help2HTML`oA$["Emittance[option] returns a set of rules as \n\n   {keyword1->value1, keyword2->value2, ..} .\n\nIts options and de\
fault values are Matrix(False), Orbit(False), OneTurnInformation(False), Emittance(True), ExpandElementValues(True), SaveEMIT(Fals\
e), InitialOrbit(Null), InitialBeamMatrix(Null), Region({1,-1}), and Output(0).\n\nIf Emittance->False is specified, the resulting\
 keywords are:\t\n\nStable                  True if all modes are stable and the closed orbit is found.\nRegion                  T\
he region {begin, end} to calculate.\nTunes                   {nux, nuy, nuz} .\nEnergyLossU0            One turn energy loss in e\
V.\nRfVoltageVc             The effective RF voltage (V).\nEquilibriumPosition     dz in meter.\nMomentumCompaction      -dz/dp\nO\
rbitDilation           ds in meter.\nBucketHeight            dV/E0\nHarmonicNumber          The effective harmonic number\nOrbitAt\
Exit             physical c.o.d. at the end of line.\t\n\nIf None of the options is given, the following keywords are added:\t\n\n\
DampingRate             {T0/taux, T0/tauy, T0/tauz}\nEmittances              {emitx, emity, emitz} *1)\nMomentumSpread          si\
gma p/p0\nBunchLength             sigma_z\nPolarization            equilibrium polarization, if POL is on\nPolarization2          \
 equilibrium polarization by up to 2nd order calculation\nPolarization4           equilibrium polarization by up to 4th order calc\
ulation\nPolarization6           equilibrium polarization by up to 6th order calculation\nPolarizationVector      direction of pol\
arization AppendTo the entrance of the beam line\nSpinTune                spin tune on the closed orbit\nNominalSpinTune         s\
pin tune calculated by MOMENTUM and electron g-2\nTuneShiftByRadiation    {dnux, dnuy, dnuz}\t\n\nIf OneTurnInformation->True, or \
Orbit->True, or Matrix->True, the followings are added.\t\n\nOrbitAtEntrance         physical c.o.d. at the entrance of the ring.\\
nOneTurnTransferMatrix   symplectic part of the one-turn transfer matrix.\nOneTurnDampingMatrix    deviation of transfer matrix du\
e to radiation.\nNormalCoordinates       conversion matrix from physical to normal coords.\nOneTurnExcitation       excitation mat\
rix by radiation and intrabeam scattering (with INTRA).\nEquilibriumBeamMatrix   equilibrium beam matrix.\nExtendedTwissParameters\
 list of rules giving the extended Twiss parameters at the entrance of the ring.\t\n\nIf Orbit->True or Matrix->True, the followin\
g is added:\t\n\nClosedOrbit             List of physical closed orbit at every element in the ring.\t\n\nIf Matrix->True, the fol\
lowings are added:\t\n\nTransferMatrices        List of physical transfer matrix from the beginning of the beam line to all elemen\
ts.\nIntrabeamExcitation     List of the change of the 6 x 6 beam matrix due to the intrabeam scattering (only when INTRA), conver\
ted to the beginning of the beam line.\t\n\n   If the flag TRPT or NORING is set, the calculation assumes a transport line so that\
 several quantities such as damping rate, eigen modes, equilibrium beam matrix, etc. are meaningless. Use RING or NOTRPT for such \
calculation. In the case of TRPT or NORING, the incoming beam envelope must be given by the option InitialBeamMatrix with a 6 x 6 \
symmetric matrix. TRPT is useful for calculation of space charge and intrabeam in a transport line.\n   Please do not forget to pu\
t semicolon at the end of Emittance[] function, otherwise the output will be huge especially when Orbit or Matrix is True.\n If Ex\
pandElementValues->False, calculation is made using the present values of each component (i.e., including machine errors).\n\nIf S\
aveEMIT->True, the calculated values of emittances are stored in variables EMITX, EMITY, EMITZ, SIGE, SIGZ. The default is SaveEMI\
T->False. These are the values calculated by the lattice, and not affected by MINCOUP.\n\nInitialOrbit->{x0,px0,y0,py0,z0,dp0/p0} \
specifies the incoming orbit which is valid when NOCOD is set. The option Output->filenum enables the print out of EMITTANCE(EMIT)\
 to filnum.\n\nIf Region is not the entire ring, parameters such as Emittances and DampingRate, etc., are not calculated, and retu\
rn NaNs.\n\n*1) The values of Emittances with INTRA and MINCOUP correspond to the equilibrium with intrabeam scattering weakened b\
y MINCOUP."],
p$2295=1+p$2295[[1,2]];p1$2295=StringPosition["Emittance[option] returns a set of rules as \n\n   {keyword1->value1, keyword2->val\
ue2, ..} .\n\nIts options and default values are Matrix(False), Orbit(False), OneTurnInformation(False), Emittance(True), ExpandEl\
ementValues(True), SaveEMIT(False), InitialOrbit(Null), InitialBeamMatrix(Null), Region({1,-1}), and Output(0).\n\nIf Emittance->F\
alse is specified, the resulting keywords are:\t\n\nStable                  True if all modes are stable and the closed orbit is f\
ound.\nRegion                  The region {begin, end} to calculate.\nTunes                   {nux, nuy, nuz} .\nEnergyLossU0     \
       One turn energy loss in eV.\nRfVoltageVc             The effective RF voltage (V).\nEquilibriumPosition     dz in meter.\nM\
omentumCompaction      -dz/dp\nOrbitDilation           ds in meter.\nBucketHeight            dV/E0\nHarmonicNumber          The ef\
fective harmonic number\nOrbitAtExit             physical c.o.d. at the end of line.\t\n\nIf None of the options is given, the fol\
lowing keywords are added:\t\n\nDampingRate             {T0/taux, T0/tauy, T0/tauz}\nEmittances              {emitx, emity, emitz}\
 *1)\nMomentumSpread          sigma p/p0\nBunchLength             sigma_z\nPolarization            equilibrium polarization, if PO\
L is on\nPolarization2           equilibrium polarization by up to 2nd order calculation\nPolarization4           equilibrium pola\
rization by up to 4th order calculation\nPolarization6           equilibrium polarization by up to 6th order calculation\nPolariza\
tionVector      direction of polarization AppendTo the entrance of the beam line\nSpinTune                spin tune on the closed \
orbit\nNominalSpinTune         spin tune calculated by MOMENTUM and electron g-2\nTuneShiftByRadiation    {dnux, dnuy, dnuz}\t\n\n\
If OneTurnInformation->True, or Orbit->True, or Matrix->True, the followings are added.\t\n\nOrbitAtEntrance         physical c.o.\
d. at the entrance of the ring.\nOneTurnTransferMatrix   symplectic part of the one-turn transfer matrix.\nOneTurnDampingMatrix   \
 deviation of transfer matrix due to radiation.\nNormalCoordinates       conversion matrix from physical to normal coords.\nOneTur\
nExcitation       excitation matrix by radiation and intrabeam scattering (with INTRA).\nEquilibriumBeamMatrix   equilibrium beam \
matrix.\nExtendedTwissParameters list of rules giving the extended Twiss parameters at the entrance of the ring.\t\n\nIf Orbit->Tr\
ue or Matrix->True, the following is added:\t\n\nClosedOrbit             List of physical closed orbit at every element in the rin\
g.\t\n\nIf Matrix->True, the followings are added:\t\n\nTransferMatrices        List of physical transfer matrix from the beginnin\
g of the beam line to all elements.\nIntrabeamExcitation     List of the change of the 6 x 6 beam matrix due to the intrabeam scat\
tering (only when INTRA), converted to the beginning of the beam line.\t\n\n   If the flag TRPT or NORING is set, the calculation \
assumes a transport line so that several quantities such as damping rate, eigen modes, equilibrium beam matrix, etc. are meaningle\
ss. Use RING or NOTRPT for such calculation. In the case of TRPT or NORING, the incoming beam envelope must be given by the option\
 InitialBeamMatrix with a 6 x 6 symmetric matrix. TRPT is useful for calculation of space charge and intrabeam in a transport line\
.\n   Please do not forget to put semicolon at the end of Emittance[] function, otherwise the output will be huge especially when \
Orbit or Matrix is True.\n If ExpandElementValues->False, calculation is made using the present values of each component (i.e., in\
cluding machine errors).\n\nIf SaveEMIT->True, the calculated values of emittances are stored in variables EMITX, EMITY, EMITZ, SI\
GE, SIGZ. The default is SaveEMIT->False. These are the values calculated by the lattice, and not affected by MINCOUP.\n\nInitialO\
rbit->{x0,px0,y0,py0,z0,dp0/p0} specifies the incoming orbit which is valid when NOCOD is set. The option Output->filenum enables \
the print out of EMITTANCE(EMIT) to filnum.\n\nIf Region is not the entire ring, parameters such as Emittances and DampingRate, et\
c., are not calculated, and return NaNs.\n\n*1) The values of Emittances with INTRA and MINCOUP correspond to the equilibrium with\
 intrabeam scattering weakened by MINCOUP."[p$2295,-1],">::",1];
   p1$2295=If[p1$2295==={},4211,-2+p$2295+p1$2295[[1,1]]];
neq=Which["Emittance[option] returns a set of rules as \n\n   {keyword1->value1, keyword2->value2, ..} .\n\nIts options and defaul\
t values are Matrix(False), Orbit(False), OneTurnInformation(False), Emittance(True), ExpandElementValues(True), SaveEMIT(False), \
InitialOrbit(Null), InitialBeamMatrix(Null), Region({1,-1}), and Output(0).\n\nIf Emittance->False is specified, the resulting key\
words are:\t\n\nStable                  True if all modes are stable and the closed orbit is found.\nRegion                  The r\
egion {begin, end} to calculate.\nTunes                   {nux, nuy, nuz} .\nEnergyLossU0            One turn energy loss in eV.\n\
RfVoltageVc             The effective RF voltage (V).\nEquilibriumPosition     dz in meter.\nMomentumCompaction      -dz/dp\nOrbit\
Dilation           ds in meter.\nBucketHeight            dV/E0\nHarmonicNumber          The effective harmonic number\nOrbitAtExit\
             physical c.o.d. at the end of line.\t\n\nIf None of the options is given, the following keywords are added:\t\n\nDamp\
ingRate             {T0/taux, T0/tauy, T0/tauz}\nEmittances              {emitx, emity, emitz} *1)\nMomentumSpread          sigma \
p/p0\nBunchLength             sigma_z\nPolarization            equilibrium polarization, if POL is on\nPolarization2           equ\
ilibrium polarization by up to 2nd order calculation\nPolarization4           equilibrium polarization by up to 4th order calculat\
ion\nPolarization6           equilibrium polarization by up to 6th order calculation\nPolarizationVector      direction of polariz\
ation AppendTo the entrance of the beam line\nSpinTune                spin tune on the closed orbit\nNominalSpinTune         spin \
tune calculated by MOMENTUM and electron g-2\nTuneShiftByRadiation    {dnux, dnuy, dnuz}\t\n\nIf OneTurnInformation->True, or Orbi\
t->True, or Matrix->True, the followings are added.\t\n\nOrbitAtEntrance         physical c.o.d. at the entrance of the ring.\nOne\
TurnTransferMatrix   symplectic part of the one-turn transfer matrix.\nOneTurnDampingMatrix    deviation of transfer matrix due to\
 radiation.\nNormalCoordinates       conversion matrix from physical to normal coords.\nOneTurnExcitation       excitation matrix \
by radiation and intrabeam scattering (with INTRA).\nEquilibriumBeamMatrix   equilibrium beam matrix.\nExtendedTwissParameters lis\
t of rules giving the extended Twiss parameters at the entrance of the ring.\t\n\nIf Orbit->True or Matrix->True, the following is\
 added:\t\n\nClosedOrbit             List of physical closed orbit at every element in the ring.\t\n\nIf Matrix->True, the followi\
ngs are added:\t\n\nTransferMatrices        List of physical transfer matrix from the beginning of the beam line to all elements.\\
nIntrabeamExcitation     List of the change of the 6 x 6 beam matrix due to the intrabeam scattering (only when INTRA), converted \
to the beginning of the beam line.\t\n\n   If the flag TRPT or NORING is set, the calculation assumes a transport line so that sev\
eral quantities such as damping rate, eigen modes, equilibrium beam matrix, etc. are meaningless. Use RING or NOTRPT for such calc\
ulation. In the case of TRPT or NORING, the incoming beam envelope must be given by the option InitialBeamMatrix with a 6 x 6 symm\
etric matrix. TRPT is useful for calculation of space charge and intrabeam in a transport line.\n   Please do not forget to put se\
micolon at the end of Emittance[] function, otherwise the output will be huge especially when Orbit or Matrix is True.\n If Expand\
ElementValues->False, calculation is made using the present values of each component (i.e., including machine errors).\n\nIf SaveE\
MIT->True, the calculated values of emittances are stored in variables EMITX, EMITY, EMITZ, SIGE, SIGZ. The default is SaveEMIT->F\
alse. These are the values calculated by the lattice, and not affected by MINCOUP.\n\nInitialOrbit->{x0,px0,y0,py0,z0,dp0/p0} spec\
ifies the incoming orbit which is valid when NOCOD is set. The option Output->filenum enables the print out of EMITTANCE(EMIT) to \
filnum.\n\nIf Region is not the entire ring, parameters such as Emittances and DampingRate, etc., are not calculated, and return N\
aNs.\n\n*1) The values of Emittances with INTRA and MINCOUP correspond to the equilibrium with intrabeam scattering weakened by MI\
NCOUP."[p$2295,4+p$2295]==="Text[",
    lx$2295:=Help2HTML`oa$;p$2295=5+p$2295;p1$2295-=1;p2$2295=5+p1$2295;p0$2295=-9+p$2295;If[(pe$2295=
StringPosition["Emittance[option] returns a set of rules as \n\n   {keyword1->value1, keyword2->value2, ..} .\n\nIts options and d\
efault values are Matrix(False), Orbit(False), OneTurnInformation(False), Emittance(True), ExpandElementValues(True), SaveEMIT(Fal\
se), InitialOrbit(Null), InitialBeamMatrix(Null), Region({1,-1}), and Output(0).\n\nIf Emittance->False is specified, the resultin\
g keywords are:\t\n\nStable                  True if all modes are stable and the closed orbit is found.\nRegion                  \
The region {begin, end} to calculate.\nTunes                   {nux, nuy, nuz} .\nEnergyLossU0            One turn energy loss in \
eV.\nRfVoltageVc             The effective RF voltage (V).\nEquilibriumPosition     dz in meter.\nMomentumCompaction      -dz/dp\n\
OrbitDilation           ds in meter.\nBucketHeight            dV/E0\nHarmonicNumber          The effective harmonic number\nOrbitA\
tExit             physical c.o.d. at the end of line.\t\n\nIf None of the options is given, the following keywords are added:\t\n\\
nDampingRate             {T0/taux, T0/tauy, T0/tauz}\nEmittances              {emitx, emity, emitz} *1)\nMomentumSpread          s\
igma p/p0\nBunchLength             sigma_z\nPolarization            equilibrium polarization, if POL is on\nPolarization2         \
  equilibrium polarization by up to 2nd order calculation\nPolarization4           equilibrium polarization by up to 4th order cal\
culation\nPolarization6           equilibrium polarization by up to 6th order calculation\nPolarizationVector      direction of po\
larization AppendTo the entrance of the beam line\nSpinTune                spin tune on the closed orbit\nNominalSpinTune         \
spin tune calculated by MOMENTUM and electron g-2\nTuneShiftByRadiation    {dnux, dnuy, dnuz}\t\n\nIf OneTurnInformation->True, or\
 Orbit->True, or Matrix->True, the followings are added.\t\n\nOrbitAtEntrance         physical c.o.d. at the entrance of the ring.\
\nOneTurnTransferMatrix   symplectic part of the one-turn transfer matrix.\nOneTurnDampingMatrix    deviation of transfer matrix d\
ue to radiation.\nNormalCoordinates       conversion matrix from physical to normal coords.\nOneTurnExcitation       excitation ma\
trix by radiation and intrabeam scattering (with INTRA).\nEquilibriumBeamMatrix   equilibrium beam matrix.\nExtendedTwissParameter\
s list of rules giving the extended Twiss parameters at the entrance of the ring.\t\n\nIf Orbit->True or Matrix->True, the followi\
ng is added:\t\n\nClosedOrbit             List of physical closed orbit at every element in the ring.\t\n\nIf Matrix->True, the fo\
llowings are added:\t\n\nTransferMatrices        List of physical transfer matrix from the beginning of the beam line to all eleme\
nts.\nIntrabeamExcitation     List of the change of the 6 x 6 beam matrix due to the intrabeam scattering (only when INTRA), conve\
rted to the beginning of the beam line.\t\n\n   If the flag TRPT or NORING is set, the calculation assumes a transport line so tha\
t several quantities such as damping rate, eigen modes, equilibrium beam matrix, etc. are meaningless. Use RING or NOTRPT for such\
 calculation. In the case of TRPT or NORING, the incoming beam envelope must be given by the option InitialBeamMatrix with a 6 x 6\
 symmetric matrix. TRPT is useful for calculation of space charge and intrabeam in a transport line.\n   Please do not forget to p\
ut semicolon at the end of Emittance[] function, otherwise the output will be huge especially when Orbit or Matrix is True.\n If E\
xpandElementValues->False, calculation is made using the present values of each component (i.e., including machine errors).\n\nIf \
SaveEMIT->True, the calculated values of emittances are stored in variables EMITX, EMITY, EMITZ, SIGE, SIGZ. The default is SaveEM\
IT->False. These are the values calculated by the lattice, and not affected by MINCOUP.\n\nInitialOrbit->{x0,px0,y0,py0,z0,dp0/p0}\
 specifies the incoming orbit which is valid when NOCOD is set. The option Output->filenum enables the print out of EMITTANCE(EMIT\
) to filnum.\n\nIf Region is not the entire ring, parameters such as Emittances and DampingRate, etc., are not calculated, and ret\
urn NaNs.\n\n*1) The values of Emittances with INTRA and MINCOUP correspond to the equilibrium with intrabeam scattering weakened \
by MINCOUP."[p$2295,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Emittance[option] returns a set of rules as \n\n   {keyword1->value1, keyword2->value2, ..} .\n\nIts options and \
default values are Matrix(False), Orbit(False), OneTurnInformation(False), Emittance(True), ExpandElementValues(True), SaveEMIT(Fa\
lse), InitialOrbit(Null), InitialBeamMatrix(Null), Region({1,-1}), and Output(0).\n\nIf Emittance->False is specified, the resulti\
ng keywords are:\t\n\nStable                  True if all modes are stable and the closed orbit is found.\nRegion                 \
 The region {begin, end} to calculate.\nTunes                   {nux, nuy, nuz} .\nEnergyLossU0            One turn energy loss in\
 eV.\nRfVoltageVc             The effective RF voltage (V).\nEquilibriumPosition     dz in meter.\nMomentumCompaction      -dz/dp\\
nOrbitDilation           ds in meter.\nBucketHeight            dV/E0\nHarmonicNumber          The effective harmonic number\nOrbit\
AtExit             physical c.o.d. at the end of line.\t\n\nIf None of the options is given, the following keywords are added:\t\n\
\nDampingRate             {T0/taux, T0/tauy, T0/tauz}\nEmittances              {emitx, emity, emitz} *1)\nMomentumSpread          \
sigma p/p0\nBunchLength             sigma_z\nPolarization            equilibrium polarization, if POL is on\nPolarization2        \
   equilibrium polarization by up to 2nd order calculation\nPolarization4           equilibrium polarization by up to 4th order ca\
lculation\nPolarization6           equilibrium polarization by up to 6th order calculation\nPolarizationVector      direction of p\
olarization AppendTo the entrance of the beam line\nSpinTune                spin tune on the closed orbit\nNominalSpinTune        \
 spin tune calculated by MOMENTUM and electron g-2\nTuneShiftByRadiation    {dnux, dnuy, dnuz}\t\n\nIf OneTurnInformation->True, o\
r Orbit->True, or Matrix->True, the followings are added.\t\n\nOrbitAtEntrance         physical c.o.d. at the entrance of the ring\
.\nOneTurnTransferMatrix   symplectic part of the one-turn transfer matrix.\nOneTurnDampingMatrix    deviation of transfer matrix \
due to radiation.\nNormalCoordinates       conversion matrix from physical to normal coords.\nOneTurnExcitation       excitation m\
atrix by radiation and intrabeam scattering (with INTRA).\nEquilibriumBeamMatrix   equilibrium beam matrix.\nExtendedTwissParamete\
rs list of rules giving the extended Twiss parameters at the entrance of the ring.\t\n\nIf Orbit->True or Matrix->True, the follow\
ing is added:\t\n\nClosedOrbit             List of physical closed orbit at every element in the ring.\t\n\nIf Matrix->True, the f\
ollowings are added:\t\n\nTransferMatrices        List of physical transfer matrix from the beginning of the beam line to all elem\
ents.\nIntrabeamExcitation     List of the change of the 6 x 6 beam matrix due to the intrabeam scattering (only when INTRA), conv\
erted to the beginning of the beam line.\t\n\n   If the flag TRPT or NORING is set, the calculation assumes a transport line so th\
at several quantities such as damping rate, eigen modes, equilibrium beam matrix, etc. are meaningless. Use RING or NOTRPT for suc\
h calculation. In the case of TRPT or NORING, the incoming beam envelope must be given by the option InitialBeamMatrix with a 6 x \
6 symmetric matrix. TRPT is useful for calculation of space charge and intrabeam in a transport line.\n   Please do not forget to \
put semicolon at the end of Emittance[] function, otherwise the output will be huge especially when Orbit or Matrix is True.\n If \
ExpandElementValues->False, calculation is made using the present values of each component (i.e., including machine errors).\n\nIf\
 SaveEMIT->True, the calculated values of emittances are stored in variables EMITX, EMITY, EMITZ, SIGE, SIGZ. The default is SaveE\
MIT->False. These are the values calculated by the lattice, and not affected by MINCOUP.\n\nInitialOrbit->{x0,px0,y0,py0,z0,dp0/p0\
} specifies the incoming orbit which is valid when NOCOD is set. The option Output->filenum enables the print out of EMITTANCE(EMI\
T) to filnum.\n\nIf Region is not the entire ring, parameters such as Emittances and DampingRate, etc., are not calculated, and re\
turn NaNs.\n\n*1) The values of Emittances with INTRA and MINCOUP correspond to the equilibrium with intrabeam scattering weakened\
 by MINCOUP."[p$2295+pe$2295[[1,2]],p1$2295]]],
        p1$2295=-2+p$2295+pe$2295[[1,1]]}[[
       1]],
      0],
    1,lx$2295:=Help2HTML`o9$;p2$2295=4+p1$2295;p0$2295=-4+p$2295;0];
  If[(equ$2295=
Help2HTML`o8$["Emittance[option] returns a set of rules as \n\n   {keyword1->value1, keyword2->value2, ..} .\n\nIts options and de\
fault values are Matrix(False), Orbit(False), OneTurnInformation(False), Emittance(True), ExpandElementValues(True), SaveEMIT(Fals\
e), InitialOrbit(Null), InitialBeamMatrix(Null), Region({1,-1}), and Output(0).\n\nIf Emittance->False is specified, the resulting\
 keywords are:\t\n\nStable                  True if all modes are stable and the closed orbit is found.\nRegion                  T\
he region {begin, end} to calculate.\nTunes                   {nux, nuy, nuz} .\nEnergyLossU0            One turn energy loss in e\
V.\nRfVoltageVc             The effective RF voltage (V).\nEquilibriumPosition     dz in meter.\nMomentumCompaction      -dz/dp\nO\
rbitDilation           ds in meter.\nBucketHeight            dV/E0\nHarmonicNumber          The effective harmonic number\nOrbitAt\
Exit             physical c.o.d. at the end of line.\t\n\nIf None of the options is given, the following keywords are added:\t\n\n\
DampingRate             {T0/taux, T0/tauy, T0/tauz}\nEmittances              {emitx, emity, emitz} *1)\nMomentumSpread          si\
gma p/p0\nBunchLength             sigma_z\nPolarization            equilibrium polarization, if POL is on\nPolarization2          \
 equilibrium polarization by up to 2nd order calculation\nPolarization4           equilibrium polarization by up to 4th order calc\
ulation\nPolarization6           equilibrium polarization by up to 6th order calculation\nPolarizationVector      direction of pol\
arization AppendTo the entrance of the beam line\nSpinTune                spin tune on the closed orbit\nNominalSpinTune         s\
pin tune calculated by MOMENTUM and electron g-2\nTuneShiftByRadiation    {dnux, dnuy, dnuz}\t\n\nIf OneTurnInformation->True, or \
Orbit->True, or Matrix->True, the followings are added.\t\n\nOrbitAtEntrance         physical c.o.d. at the entrance of the ring.\\
nOneTurnTransferMatrix   symplectic part of the one-turn transfer matrix.\nOneTurnDampingMatrix    deviation of transfer matrix du\
e to radiation.\nNormalCoordinates       conversion matrix from physical to normal coords.\nOneTurnExcitation       excitation mat\
rix by radiation and intrabeam scattering (with INTRA).\nEquilibriumBeamMatrix   equilibrium beam matrix.\nExtendedTwissParameters\
 list of rules giving the extended Twiss parameters at the entrance of the ring.\t\n\nIf Orbit->True or Matrix->True, the followin\
g is added:\t\n\nClosedOrbit             List of physical closed orbit at every element in the ring.\t\n\nIf Matrix->True, the fol\
lowings are added:\t\n\nTransferMatrices        List of physical transfer matrix from the beginning of the beam line to all elemen\
ts.\nIntrabeamExcitation     List of the change of the 6 x 6 beam matrix due to the intrabeam scattering (only when INTRA), conver\
ted to the beginning of the beam line.\t\n\n   If the flag TRPT or NORING is set, the calculation assumes a transport line so that\
 several quantities such as damping rate, eigen modes, equilibrium beam matrix, etc. are meaningless. Use RING or NOTRPT for such \
calculation. In the case of TRPT or NORING, the incoming beam envelope must be given by the option InitialBeamMatrix with a 6 x 6 \
symmetric matrix. TRPT is useful for calculation of space charge and intrabeam in a transport line.\n   Please do not forget to pu\
t semicolon at the end of Emittance[] function, otherwise the output will be huge especially when Orbit or Matrix is True.\n If Ex\
pandElementValues->False, calculation is made using the present values of each component (i.e., including machine errors).\n\nIf S\
aveEMIT->True, the calculated values of emittances are stored in variables EMITX, EMITY, EMITZ, SIGE, SIGZ. The default is SaveEMI\
T->False. These are the values calculated by the lattice, and not affected by MINCOUP.\n\nInitialOrbit->{x0,px0,y0,py0,z0,dp0/p0} \
specifies the incoming orbit which is valid when NOCOD is set. The option Output->filenum enables the print out of EMITTANCE(EMIT)\
 to filnum.\n\nIf Region is not the entire ring, parameters such as Emittances and DampingRate, etc., are not calculated, and retu\
rn NaNs.\n\n*1) The values of Emittances with INTRA and MINCOUP correspond to the equilibrium with intrabeam scattering weakened b\
y MINCOUP."[p$2295,p1$2295]])===
    Undefined,
equ$2295="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Emittance[option] returns a set of rules as \
\n\n   {keyword1->value1, keyword2->value2, ..} .\n\nIts options and default values are Matrix(False), Orbit(False), OneTurnInform\
ation(False), Emittance(True), ExpandElementValues(True), SaveEMIT(False), InitialOrbit(Null), InitialBeamMatrix(Null), Region({1,\
-1}), and Output(0).\n\nIf Emittance->False is specified, the resulting keywords are:\t\n\nStable                  True if all mod\
es are stable and the closed orbit is found.\nRegion                  The region {begin, end} to calculate.\nTunes                \
   {nux, nuy, nuz} .\nEnergyLossU0            One turn energy loss in eV.\nRfVoltageVc             The effective RF voltage (V).\n\
EquilibriumPosition     dz in meter.\nMomentumCompaction      -dz/dp\nOrbitDilation           ds in meter.\nBucketHeight          \
  dV/E0\nHarmonicNumber          The effective harmonic number\nOrbitAtExit             physical c.o.d. at the end of line.\t\n\nI\
f None of the options is given, the following keywords are added:\t\n\nDampingRate             {T0/taux, T0/tauy, T0/tauz}\nEmitta\
nces              {emitx, emity, emitz} *1)\nMomentumSpread          sigma p/p0\nBunchLength             sigma_z\nPolarization    \
        equilibrium polarization, if POL is on\nPolarization2           equilibrium polarization by up to 2nd order calculation\nP\
olarization4           equilibrium polarization by up to 4th order calculation\nPolarization6           equilibrium polarization b\
y up to 6th order calculation\nPolarizationVector      direction of polarization AppendTo the entrance of the beam line\nSpinTune \
               spin tune on the closed orbit\nNominalSpinTune         spin tune calculated by MOMENTUM and electron g-2\nTuneShift\
ByRadiation    {dnux, dnuy, dnuz}\t\n\nIf OneTurnInformation->True, or Orbit->True, or Matrix->True, the followings are added.\t\n\
\nOrbitAtEntrance         physical c.o.d. at the entrance of the ring.\nOneTurnTransferMatrix   symplectic part of the one-turn tr\
ansfer matrix.\nOneTurnDampingMatrix    deviation of transfer matrix due to radiation.\nNormalCoordinates       conversion matrix \
from physical to normal coords.\nOneTurnExcitation       excitation matrix by radiation and intrabeam scattering (with INTRA).\nEq\
uilibriumBeamMatrix   equilibrium beam matrix.\nExtendedTwissParameters list of rules giving the extended Twiss parameters at the \
entrance of the ring.\t\n\nIf Orbit->True or Matrix->True, the following is added:\t\n\nClosedOrbit             List of physical c\
losed orbit at every element in the ring.\t\n\nIf Matrix->True, the followings are added:\t\n\nTransferMatrices        List of phy\
sical transfer matrix from the beginning of the beam line to all elements.\nIntrabeamExcitation     List of the change of the 6 x \
6 beam matrix due to the intrabeam scattering (only when INTRA), converted to the beginning of the beam line.\t\n\n   If the flag \
TRPT or NORING is set, the calculation assumes a transport line so that several quantities such as damping rate, eigen modes, equi\
librium beam matrix, etc. are meaningless. Use RING or NOTRPT for such calculation. In the case of TRPT or NORING, the incoming be\
am envelope must be given by the option InitialBeamMatrix with a 6 x 6 symmetric matrix. TRPT is useful for calculation of space c\
harge and intrabeam in a transport line.\n   Please do not forget to put semicolon at the end of Emittance[] function, otherwise t\
he output will be huge especially when Orbit or Matrix is True.\n If ExpandElementValues->False, calculation is made using the pre\
sent values of each component (i.e., including machine errors).\n\nIf SaveEMIT->True, the calculated values of emittances are stor\
ed in variables EMITX, EMITY, EMITZ, SIGE, SIGZ. The default is SaveEMIT->False. These are the values calculated by the lattice, a\
nd not affected by MINCOUP.\n\nInitialOrbit->{x0,px0,y0,py0,z0,dp0/p0} specifies the incoming orbit which is valid when NOCOD is s\
et. The option Output->filenum enables the print out of EMITTANCE(EMIT) to filnum.\n\nIf Region is not the entire ring, parameters\
 such as Emittances and DampingRate, etc., are not calculated, and return NaNs.\n\n*1) The values of Emittances with INTRA and MIN\
COUP correspond to the equilibrium with intrabeam scattering weakened by MINCOUP."[p$2295,p1$2295]]=
       equ$2295;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2295},out$2295=lx$2295@Typeset["Emittance[option] returns a set of rules as \n\n   {keyword1->value1, keyword2->value2, .\
.} .\n\nIts options and default values are Matrix(False), Orbit(False), OneTurnInformation(False), Emittance(True), ExpandElementV\
alues(True), SaveEMIT(False), InitialOrbit(Null), InitialBeamMatrix(Null), Region({1,-1}), and Output(0).\n\nIf Emittance->False i\
s specified, the resulting keywords are:\t\n\nStable                  True if all modes are stable and the closed orbit is found.\\
nRegion                  The region {begin, end} to calculate.\nTunes                   {nux, nuy, nuz} .\nEnergyLossU0           \
 One turn energy loss in eV.\nRfVoltageVc             The effective RF voltage (V).\nEquilibriumPosition     dz in meter.\nMomentu\
mCompaction      -dz/dp\nOrbitDilation           ds in meter.\nBucketHeight            dV/E0\nHarmonicNumber          The effectiv\
e harmonic number\nOrbitAtExit             physical c.o.d. at the end of line.\t\n\nIf None of the options is given, the following\
 keywords are added:\t\n\nDampingRate             {T0/taux, T0/tauy, T0/tauz}\nEmittances              {emitx, emity, emitz} *1)\n\
MomentumSpread          sigma p/p0\nBunchLength             sigma_z\nPolarization            equilibrium polarization, if POL is o\
n\nPolarization2           equilibrium polarization by up to 2nd order calculation\nPolarization4           equilibrium polarizati\
on by up to 4th order calculation\nPolarization6           equilibrium polarization by up to 6th order calculation\nPolarizationVe\
ctor      direction of polarization AppendTo the entrance of the beam line\nSpinTune                spin tune on the closed orbit\\
nNominalSpinTune         spin tune calculated by MOMENTUM and electron g-2\nTuneShiftByRadiation    {dnux, dnuy, dnuz}\t\n\nIf One\
TurnInformation->True, or Orbit->True, or Matrix->True, the followings are added.\t\n\nOrbitAtEntrance         physical c.o.d. at \
the entrance of the ring.\nOneTurnTransferMatrix   symplectic part of the one-turn transfer matrix.\nOneTurnDampingMatrix    devia\
tion of transfer matrix due to radiation.\nNormalCoordinates       conversion matrix from physical to normal coords.\nOneTurnExcit\
ation       excitation matrix by radiation and intrabeam scattering (with INTRA).\nEquilibriumBeamMatrix   equilibrium beam matrix\
.\nExtendedTwissParameters list of rules giving the extended Twiss parameters at the entrance of the ring.\t\n\nIf Orbit->True or \
Matrix->True, the following is added:\t\n\nClosedOrbit             List of physical closed orbit at every element in the ring.\t\n\
\nIf Matrix->True, the followings are added:\t\n\nTransferMatrices        List of physical transfer matrix from the beginning of t\
he beam line to all elements.\nIntrabeamExcitation     List of the change of the 6 x 6 beam matrix due to the intrabeam scattering\
 (only when INTRA), converted to the beginning of the beam line.\t\n\n   If the flag TRPT or NORING is set, the calculation assume\
s a transport line so that several quantities such as damping rate, eigen modes, equilibrium beam matrix, etc. are meaningless. Us\
e RING or NOTRPT for such calculation. In the case of TRPT or NORING, the incoming beam envelope must be given by the option Initi\
alBeamMatrix with a 6 x 6 symmetric matrix. TRPT is useful for calculation of space charge and intrabeam in a transport line.\n   \
Please do not forget to put semicolon at the end of Emittance[] function, otherwise the output will be huge especially when Orbit \
or Matrix is True.\n If ExpandElementValues->False, calculation is made using the present values of each component (i.e., includin\
g machine errors).\n\nIf SaveEMIT->True, the calculated values of emittances are stored in variables EMITX, EMITY, EMITZ, SIGE, SI\
GZ. The default is SaveEMIT->False. These are the values calculated by the lattice, and not affected by MINCOUP.\n\nInitialOrbit->\
{x0,px0,y0,py0,z0,dp0/p0} specifies the incoming orbit which is valid when NOCOD is set. The option Output->filenum enables the pr\
int out of EMITTANCE(EMIT) to filnum.\n\nIf Region is not the entire ring, parameters such as Emittances and DampingRate, etc., ar\
e not calculated, and return NaNs.\n\n*1) The values of Emittances with INTRA and MINCOUP correspond to the equilibrium with intra\
beam scattering weakened by MINCOUP."[p$2295,p1$2295],Format->Help2HTML`oB$];
        System["mv -f "//out$2295//" "//equ$2295]];
      Exit[]]];
   "Emittance[option] returns a set of rules as \n\n   {keyword1->value1, keyword2->value2, ..} .\n\nIts options and default value\
s are Matrix(False), Orbit(False), OneTurnInformation(False), Emittance(True), ExpandElementValues(True), SaveEMIT(False), Initial\
Orbit(Null), InitialBeamMatrix(Null), Region({1,-1}), and Output(0).\n\nIf Emittance->False is specified, the resulting keywords a\
re:\t\n\nStable                  True if all modes are stable and the closed orbit is found.\nRegion                  The region {\
begin, end} to calculate.\nTunes                   {nux, nuy, nuz} .\nEnergyLossU0            One turn energy loss in eV.\nRfVolta\
geVc             The effective RF voltage (V).\nEquilibriumPosition     dz in meter.\nMomentumCompaction      -dz/dp\nOrbitDilatio\
n           ds in meter.\nBucketHeight            dV/E0\nHarmonicNumber          The effective harmonic number\nOrbitAtExit       \
      physical c.o.d. at the end of line.\t\n\nIf None of the options is given, the following keywords are added:\t\n\nDampingRate\
             {T0/taux, T0/tauy, T0/tauz}\nEmittances              {emitx, emity, emitz} *1)\nMomentumSpread          sigma p/p0\nB\
unchLength             sigma_z\nPolarization            equilibrium polarization, if POL is on\nPolarization2           equilibriu\
m polarization by up to 2nd order calculation\nPolarization4           equilibrium polarization by up to 4th order calculation\nPo\
larization6           equilibrium polarization by up to 6th order calculation\nPolarizationVector      direction of polarization A\
ppendTo the entrance of the beam line\nSpinTune                spin tune on the closed orbit\nNominalSpinTune         spin tune ca\
lculated by MOMENTUM and electron g-2\nTuneShiftByRadiation    {dnux, dnuy, dnuz}\t\n\nIf OneTurnInformation->True, or Orbit->True\
, or Matrix->True, the followings are added.\t\n\nOrbitAtEntrance         physical c.o.d. at the entrance of the ring.\nOneTurnTra\
nsferMatrix   symplectic part of the one-turn transfer matrix.\nOneTurnDampingMatrix    deviation of transfer matrix due to radiat\
ion.\nNormalCoordinates       conversion matrix from physical to normal coords.\nOneTurnExcitation       excitation matrix by radi\
ation and intrabeam scattering (with INTRA).\nEquilibriumBeamMatrix   equilibrium beam matrix.\nExtendedTwissParameters list of ru\
les giving the extended Twiss parameters at the entrance of the ring.\t\n\nIf Orbit->True or Matrix->True, the following is added:\
\t\n\nClosedOrbit             List of physical closed orbit at every element in the ring.\t\n\nIf Matrix->True, the followings are\
 added:\t\n\nTransferMatrices        List of physical transfer matrix from the beginning of the beam line to all elements.\nIntrab\
eamExcitation     List of the change of the 6 x 6 beam matrix due to the intrabeam scattering (only when INTRA), converted to the \
beginning of the beam line.\t\n\n   If the flag TRPT or NORING is set, the calculation assumes a transport line so that several qu\
antities such as damping rate, eigen modes, equilibrium beam matrix, etc. are meaningless. Use RING or NOTRPT for such calculation\
. In the case of TRPT or NORING, the incoming beam envelope must be given by the option InitialBeamMatrix with a 6 x 6 symmetric m\
atrix. TRPT is useful for calculation of space charge and intrabeam in a transport line.\n   Please do not forget to put semicolon\
 at the end of Emittance[] function, otherwise the output will be huge especially when Orbit or Matrix is True.\n If ExpandElement\
Values->False, calculation is made using the present values of each component (i.e., including machine errors).\n\nIf SaveEMIT->Tr\
ue, the calculated values of emittances are stored in variables EMITX, EMITY, EMITZ, SIGE, SIGZ. The default is SaveEMIT->False. T\
hese are the values calculated by the lattice, and not affected by MINCOUP.\n\nInitialOrbit->{x0,px0,y0,py0,z0,dp0/p0} specifies t\
he incoming orbit which is valid when NOCOD is set. The option Output->filenum enables the print out of EMITTANCE(EMIT) to filnum.\
\n\nIf Region is not the entire ring, parameters such as Emittances and DampingRate, etc., are not calculated, and return NaNs.\n\\
n*1) The values of Emittances with INTRA and MINCOUP correspond to the equilibrium with intrabeam scattering weakened by MINCOUP."[
    1,Max[p0$2295,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2295//"\" />"//
Help2HTML`oy$["Emittance[option] returns a set of rules as \n\n   {keyword1->value1, keyword2->value2, ..} .\n\nIts options and de\
fault values are Matrix(False), Orbit(False), OneTurnInformation(False), Emittance(True), ExpandElementValues(True), SaveEMIT(Fals\
e), InitialOrbit(Null), InitialBeamMatrix(Null), Region({1,-1}), and Output(0).\n\nIf Emittance->False is specified, the resulting\
 keywords are:\t\n\nStable                  True if all modes are stable and the closed orbit is found.\nRegion                  T\
he region {begin, end} to calculate.\nTunes                   {nux, nuy, nuz} .\nEnergyLossU0            One turn energy loss in e\
V.\nRfVoltageVc             The effective RF voltage (V).\nEquilibriumPosition     dz in meter.\nMomentumCompaction      -dz/dp\nO\
rbitDilation           ds in meter.\nBucketHeight            dV/E0\nHarmonicNumber          The effective harmonic number\nOrbitAt\
Exit             physical c.o.d. at the end of line.\t\n\nIf None of the options is given, the following keywords are added:\t\n\n\
DampingRate             {T0/taux, T0/tauy, T0/tauz}\nEmittances              {emitx, emity, emitz} *1)\nMomentumSpread          si\
gma p/p0\nBunchLength             sigma_z\nPolarization            equilibrium polarization, if POL is on\nPolarization2          \
 equilibrium polarization by up to 2nd order calculation\nPolarization4           equilibrium polarization by up to 4th order calc\
ulation\nPolarization6           equilibrium polarization by up to 6th order calculation\nPolarizationVector      direction of pol\
arization AppendTo the entrance of the beam line\nSpinTune                spin tune on the closed orbit\nNominalSpinTune         s\
pin tune calculated by MOMENTUM and electron g-2\nTuneShiftByRadiation    {dnux, dnuy, dnuz}\t\n\nIf OneTurnInformation->True, or \
Orbit->True, or Matrix->True, the followings are added.\t\n\nOrbitAtEntrance         physical c.o.d. at the entrance of the ring.\\
nOneTurnTransferMatrix   symplectic part of the one-turn transfer matrix.\nOneTurnDampingMatrix    deviation of transfer matrix du\
e to radiation.\nNormalCoordinates       conversion matrix from physical to normal coords.\nOneTurnExcitation       excitation mat\
rix by radiation and intrabeam scattering (with INTRA).\nEquilibriumBeamMatrix   equilibrium beam matrix.\nExtendedTwissParameters\
 list of rules giving the extended Twiss parameters at the entrance of the ring.\t\n\nIf Orbit->True or Matrix->True, the followin\
g is added:\t\n\nClosedOrbit             List of physical closed orbit at every element in the ring.\t\n\nIf Matrix->True, the fol\
lowings are added:\t\n\nTransferMatrices        List of physical transfer matrix from the beginning of the beam line to all elemen\
ts.\nIntrabeamExcitation     List of the change of the 6 x 6 beam matrix due to the intrabeam scattering (only when INTRA), conver\
ted to the beginning of the beam line.\t\n\n   If the flag TRPT or NORING is set, the calculation assumes a transport line so that\
 several quantities such as damping rate, eigen modes, equilibrium beam matrix, etc. are meaningless. Use RING or NOTRPT for such \
calculation. In the case of TRPT or NORING, the incoming beam envelope must be given by the option InitialBeamMatrix with a 6 x 6 \
symmetric matrix. TRPT is useful for calculation of space charge and intrabeam in a transport line.\n   Please do not forget to pu\
t semicolon at the end of Emittance[] function, otherwise the output will be huge especially when Orbit or Matrix is True.\n If Ex\
pandElementValues->False, calculation is made using the present values of each component (i.e., including machine errors).\n\nIf S\
aveEMIT->True, the calculated values of emittances are stored in variables EMITX, EMITY, EMITZ, SIGE, SIGZ. The default is SaveEMI\
T->False. These are the values calculated by the lattice, and not affected by MINCOUP.\n\nInitialOrbit->{x0,px0,y0,py0,z0,dp0/p0} \
specifies the incoming orbit which is valid when NOCOD is set. The option Output->filenum enables the print out of EMITTANCE(EMIT)\
 to filnum.\n\nIf Region is not the entire ring, parameters such as Emittances and DampingRate, etc., are not calculated, and retu\
rn NaNs.\n\n*1) The values of Emittances with INTRA and MINCOUP correspond to the equilibrium with intrabeam scattering weakened b\
y MINCOUP."[p2$2295,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L295>EMITTANCE(EMIT)</A> <A HREF=#L406>SymplecticJ</A> <A HREF=#L307>COD</A> <A HREF=#L513>EMITX</A> <A HREF=#L515>EMITY</A> <A HREF=#L517>EMITZ</A> <A HREF=#L544>SIGZ</A> <A HREF=#L543>SIGE</A> <A HREF=#L333>POL</A> <A HREF=#L530>MINCOUP</A> <A HREF=#L55>equilibrium-beam-envelope</A>
</PRE>
<LI>
<H3><A NAME=L390>
ExternalMap</A></H3>
<PRE>If[{},
Help2HTML`oA$["With MAP elements, ExternalMap defines a user-defined map of particles. It also allows a user to do anything (doing\
 statistics, etc.) at any point of a beam line during a tracking. \n\nUsage: First define a MAP element at MAIN level:\n\n     MAP\
    name=(L=leng);\n\nCurrently L is the only keyword. Insert it at the location(s) where you want to use it.\n\n1) Tracking\nIn F\
FS, define the function ExternalMap as\n\n    ExternalMap[\"TRACK\",n,nt_,x_]:=body;\n\nThe second argument n is the position of M\
AP counting from the beginning, which can be obtained using LINE[\"POSITION\",\"name.m\"]. The third argument nt_ is used to recei\
ve the number of turns which is incremented by the tracking. The last argument x_ is used to receive the coordinates of particles.\
 It is a (7 or 9, np) list of real numbers. The elements  (1..8, i) are (x, px ,y ,py ,z ,dp/p0, sy, sarg) of the i-th particle. T\
he (-1, i)  element is True(==1) if the i-th particle has been survived, and False(==0) if it has been lost. The spin coordinates \
sy and sarg are only valid with the POL flag.\n\n You can define ExternalMap to change the coordinates of each particle as you lik\
e by returning a new x in the same format as above. If you do not return it or you return in a different format, the tracking rout\
ine does not change the particle coordinates. You can neither rebirth a lost particle nor kill a surviving particle.\n\nAfter defi\
ned ExternalMap, tracking calls it in every turn.\n\nExample:\n\n   MAP P1=();\n   ....\n   LINE A=(... P1 ... P1 ...);\n   ....\n\
   FFS USE=A;\n     ExternalMap[\"TRACK\",LINE[\"POSITION\",\"P1.2\"],nt_,x_]:=\n\t(Print[x];x*2);\n   ....\n\n   TRACK USE=A ....\
;\n\nThis example defines ExternalMap to print out the coordinates of all particles at the second P1 in the line A. It also makes \
all coordinates of all particles twice in every turn.\n\nOptionally a compiled module CompiledMap can be used for ExternalMap[\"TR\
ACK\"] (see below).\n\n2) Emittance\nIn FFS, define the function ExternalMap as\n\n    ExternalMap[\"EMIT\",n,cod_]:=body;\n\nThe \
second argument n is the position of MAP counting from the beginning, which can be obtained using LINE[\"POSITION\",\"name.m\"]. T\
he last argument cod_ is used to receive the orbit at the entrance of the element, as a list of 6 real numbers. ExternalMap must r\
eturn a list, either {cod1, trans} or  {cod1, trans, dtrans, dbeam}, where cod1 is the orbit at the exit, trans is the 6 by 6 tran\
sfer matrix of this element, dtrans is the radiation damping part of the transfer matrix (6 by 6), and dbeam is the radiation exci\
tation of the beam matrix (6 by 6). Only j >= i parts of dbeam[[i, j]] are taken into account.\n\nExample:\n\n    ExternalMap[\"EM\
IT\",LINE[\"POSITION\",\"P1\"],cod_]:=(\n      Print[cod];\n      {cod+{0,0.001,0,0,0,0},IdentityMatrix[6]});\n\n3) Optics\nIn FFS\
, define the function ExternalMap as\n\n    ExternalMap[\"OPTICS\",n,cod_]:=body;\n\nThe second argument n is the position of MAP \
counting from the beginning, which can be obtained using LINE[\"POSITION\",\"name.m\"]. The last argument cod_ is used to receive \
the orbit at the entrance of the element, as a list of 6 real numbers. ExternalMap must return a list {cod1, trans}, where cod1 is\
 the orbit at the exit and trans is the 6 by 6 transfer matrix of this element. In the case of CACL4D (== ~CALC6D), only the 4 by \
5 transfer matrix is effective.\n\nExample:\n\n    ExternalMap[\"OPTICS\",LINE[\"POSITION\",\"P1\"],cod_]:=(\n      Print[cod];\n \
     {cod+{0,0.001,0,0,0,0},IdentityMatrix[6]});\n\n4) Geometry\nIn FFS, define the function ExternalMap as\n\n    ExternalMap[\"G\
EO\",n,geo_,pos_]:=body;\n\nThe second argument n is the position of MAP counting from the beginning, which can be obtained using \
LINE[\"POSITION\",\"name.m\"]. The argument geo_ receives the geometry of the beam line at the MAP element, in the same format as \
LINE[\"GEO\",n], i.e., {{GX,GY,GZ},{CHI1,CHI2,CHI3}}. The last argument pos_ receives the orbit length S at the element. ExternalM\
ap must return an updated list {geo1, pos1}, as { {{GX,GY,GZ},{CHI1,CHI2,CHI3}}, S} as the values at the exit of the element.\nExa\
mple:\n\n    ExternalMap[\"GEO\",LINE[\"POSITION\",\"P1\"],geo_,pos_]:=(\n      Print[cod];\n      { {geo[[1]]+{1,0,0}, geo[[2]]},\
 pos+0.1})"],
p$2298=1+p$2298[[1,2]];p1$2298=StringPosition["With MAP elements, ExternalMap defines a user-defined map of particles. It also all\
ows a user to do anything (doing statistics, etc.) at any point of a beam line during a tracking. \n\nUsage: First define a MAP el\
ement at MAIN level:\n\n     MAP    name=(L=leng);\n\nCurrently L is the only keyword. Insert it at the location(s) where you want\
 to use it.\n\n1) Tracking\nIn FFS, define the function ExternalMap as\n\n    ExternalMap[\"TRACK\",n,nt_,x_]:=body;\n\nThe second\
 argument n is the position of MAP counting from the beginning, which can be obtained using LINE[\"POSITION\",\"name.m\"]. The thi\
rd argument nt_ is used to receive the number of turns which is incremented by the tracking. The last argument x_ is used to recei\
ve the coordinates of particles. It is a (7 or 9, np) list of real numbers. The elements  (1..8, i) are (x, px ,y ,py ,z ,dp/p0, s\
y, sarg) of the i-th particle. The (-1, i)  element is True(==1) if the i-th particle has been survived, and False(==0) if it has \
been lost. The spin coordinates sy and sarg are only valid with the POL flag.\n\n You can define ExternalMap to change the coordin\
ates of each particle as you like by returning a new x in the same format as above. If you do not return it or you return in a dif\
ferent format, the tracking routine does not change the particle coordinates. You can neither rebirth a lost particle nor kill a s\
urviving particle.\n\nAfter defined ExternalMap, tracking calls it in every turn.\n\nExample:\n\n   MAP P1=();\n   ....\n   LINE A\
=(... P1 ... P1 ...);\n   ....\n   FFS USE=A;\n     ExternalMap[\"TRACK\",LINE[\"POSITION\",\"P1.2\"],nt_,x_]:=\n\t(Print[x];x*2);\
\n   ....\n\n   TRACK USE=A ....;\n\nThis example defines ExternalMap to print out the coordinates of all particles at the second \
P1 in the line A. It also makes all coordinates of all particles twice in every turn.\n\nOptionally a compiled module CompiledMap \
can be used for ExternalMap[\"TRACK\"] (see below).\n\n2) Emittance\nIn FFS, define the function ExternalMap as\n\n    ExternalMap\
[\"EMIT\",n,cod_]:=body;\n\nThe second argument n is the position of MAP counting from the beginning, which can be obtained using \
LINE[\"POSITION\",\"name.m\"]. The last argument cod_ is used to receive the orbit at the entrance of the element, as a list of 6 \
real numbers. ExternalMap must return a list, either {cod1, trans} or  {cod1, trans, dtrans, dbeam}, where cod1 is the orbit at th\
e exit, trans is the 6 by 6 transfer matrix of this element, dtrans is the radiation damping part of the transfer matrix (6 by 6),\
 and dbeam is the radiation excitation of the beam matrix (6 by 6). Only j >= i parts of dbeam[[i, j]] are taken into account.\n\n\
Example:\n\n    ExternalMap[\"EMIT\",LINE[\"POSITION\",\"P1\"],cod_]:=(\n      Print[cod];\n      {cod+{0,0.001,0,0,0,0},IdentityM\
atrix[6]});\n\n3) Optics\nIn FFS, define the function ExternalMap as\n\n    ExternalMap[\"OPTICS\",n,cod_]:=body;\n\nThe second ar\
gument n is the position of MAP counting from the beginning, which can be obtained using LINE[\"POSITION\",\"name.m\"]. The last a\
rgument cod_ is used to receive the orbit at the entrance of the element, as a list of 6 real numbers. ExternalMap must return a l\
ist {cod1, trans}, where cod1 is the orbit at the exit and trans is the 6 by 6 transfer matrix of this element. In the case of CAC\
L4D (== ~CALC6D), only the 4 by 5 transfer matrix is effective.\n\nExample:\n\n    ExternalMap[\"OPTICS\",LINE[\"POSITION\",\"P1\"\
],cod_]:=(\n      Print[cod];\n      {cod+{0,0.001,0,0,0,0},IdentityMatrix[6]});\n\n4) Geometry\nIn FFS, define the function Exter\
nalMap as\n\n    ExternalMap[\"GEO\",n,geo_,pos_]:=body;\n\nThe second argument n is the position of MAP counting from the beginni\
ng, which can be obtained using LINE[\"POSITION\",\"name.m\"]. The argument geo_ receives the geometry of the beam line at the MAP\
 element, in the same format as LINE[\"GEO\",n], i.e., {{GX,GY,GZ},{CHI1,CHI2,CHI3}}. The last argument pos_ receives the orbit le\
ngth S at the element. ExternalMap must return an updated list {geo1, pos1}, as { {{GX,GY,GZ},{CHI1,CHI2,CHI3}}, S} as the values \
at the exit of the element.\nExample:\n\n    ExternalMap[\"GEO\",LINE[\"POSITION\",\"P1\"],geo_,pos_]:=(\n      Print[cod];\n     \
 { {geo[[1]]+{1,0,0}, geo[[2]]}, pos+0.1})"[p$2298,-1],">::",1];
   p1$2298=If[p1$2298==={},4160,-2+p$2298+p1$2298[[1,1]]];
neq=Which["With MAP elements, ExternalMap defines a user-defined map of particles. It also allows a user to do anything (doing sta\
tistics, etc.) at any point of a beam line during a tracking. \n\nUsage: First define a MAP element at MAIN level:\n\n     MAP    \
name=(L=leng);\n\nCurrently L is the only keyword. Insert it at the location(s) where you want to use it.\n\n1) Tracking\nIn FFS, \
define the function ExternalMap as\n\n    ExternalMap[\"TRACK\",n,nt_,x_]:=body;\n\nThe second argument n is the position of MAP c\
ounting from the beginning, which can be obtained using LINE[\"POSITION\",\"name.m\"]. The third argument nt_ is used to receive t\
he number of turns which is incremented by the tracking. The last argument x_ is used to receive the coordinates of particles. It \
is a (7 or 9, np) list of real numbers. The elements  (1..8, i) are (x, px ,y ,py ,z ,dp/p0, sy, sarg) of the i-th particle. The (\
-1, i)  element is True(==1) if the i-th particle has been survived, and False(==0) if it has been lost. The spin coordinates sy a\
nd sarg are only valid with the POL flag.\n\n You can define ExternalMap to change the coordinates of each particle as you like by\
 returning a new x in the same format as above. If you do not return it or you return in a different format, the tracking routine \
does not change the particle coordinates. You can neither rebirth a lost particle nor kill a surviving particle.\n\nAfter defined \
ExternalMap, tracking calls it in every turn.\n\nExample:\n\n   MAP P1=();\n   ....\n   LINE A=(... P1 ... P1 ...);\n   ....\n   F\
FS USE=A;\n     ExternalMap[\"TRACK\",LINE[\"POSITION\",\"P1.2\"],nt_,x_]:=\n\t(Print[x];x*2);\n   ....\n\n   TRACK USE=A ....;\n\\
nThis example defines ExternalMap to print out the coordinates of all particles at the second P1 in the line A. It also makes all \
coordinates of all particles twice in every turn.\n\nOptionally a compiled module CompiledMap can be used for ExternalMap[\"TRACK\\
"] (see below).\n\n2) Emittance\nIn FFS, define the function ExternalMap as\n\n    ExternalMap[\"EMIT\",n,cod_]:=body;\n\nThe seco\
nd argument n is the position of MAP counting from the beginning, which can be obtained using LINE[\"POSITION\",\"name.m\"]. The l\
ast argument cod_ is used to receive the orbit at the entrance of the element, as a list of 6 real numbers. ExternalMap must retur\
n a list, either {cod1, trans} or  {cod1, trans, dtrans, dbeam}, where cod1 is the orbit at the exit, trans is the 6 by 6 transfer\
 matrix of this element, dtrans is the radiation damping part of the transfer matrix (6 by 6), and dbeam is the radiation excitati\
on of the beam matrix (6 by 6). Only j >= i parts of dbeam[[i, j]] are taken into account.\n\nExample:\n\n    ExternalMap[\"EMIT\"\
,LINE[\"POSITION\",\"P1\"],cod_]:=(\n      Print[cod];\n      {cod+{0,0.001,0,0,0,0},IdentityMatrix[6]});\n\n3) Optics\nIn FFS, de\
fine the function ExternalMap as\n\n    ExternalMap[\"OPTICS\",n,cod_]:=body;\n\nThe second argument n is the position of MAP coun\
ting from the beginning, which can be obtained using LINE[\"POSITION\",\"name.m\"]. The last argument cod_ is used to receive the \
orbit at the entrance of the element, as a list of 6 real numbers. ExternalMap must return a list {cod1, trans}, where cod1 is the\
 orbit at the exit and trans is the 6 by 6 transfer matrix of this element. In the case of CACL4D (== ~CALC6D), only the 4 by 5 tr\
ansfer matrix is effective.\n\nExample:\n\n    ExternalMap[\"OPTICS\",LINE[\"POSITION\",\"P1\"],cod_]:=(\n      Print[cod];\n     \
 {cod+{0,0.001,0,0,0,0},IdentityMatrix[6]});\n\n4) Geometry\nIn FFS, define the function ExternalMap as\n\n    ExternalMap[\"GEO\"\
,n,geo_,pos_]:=body;\n\nThe second argument n is the position of MAP counting from the beginning, which can be obtained using LINE\
[\"POSITION\",\"name.m\"]. The argument geo_ receives the geometry of the beam line at the MAP element, in the same format as LINE\
[\"GEO\",n], i.e., {{GX,GY,GZ},{CHI1,CHI2,CHI3}}. The last argument pos_ receives the orbit length S at the element. ExternalMap m\
ust return an updated list {geo1, pos1}, as { {{GX,GY,GZ},{CHI1,CHI2,CHI3}}, S} as the values at the exit of the element.\nExample\
:\n\n    ExternalMap[\"GEO\",LINE[\"POSITION\",\"P1\"],geo_,pos_]:=(\n      Print[cod];\n      { {geo[[1]]+{1,0,0}, geo[[2]]}, pos\
+0.1})"[p$2298,4+p$2298]==="Text[",
    lx$2298:=Help2HTML`oa$;p$2298=5+p$2298;p1$2298-=1;p2$2298=5+p1$2298;p0$2298=-9+p$2298;If[(pe$2298=
StringPosition["With MAP elements, ExternalMap defines a user-defined map of particles. It also allows a user to do anything (doin\
g statistics, etc.) at any point of a beam line during a tracking. \n\nUsage: First define a MAP element at MAIN level:\n\n     MA\
P    name=(L=leng);\n\nCurrently L is the only keyword. Insert it at the location(s) where you want to use it.\n\n1) Tracking\nIn \
FFS, define the function ExternalMap as\n\n    ExternalMap[\"TRACK\",n,nt_,x_]:=body;\n\nThe second argument n is the position of \
MAP counting from the beginning, which can be obtained using LINE[\"POSITION\",\"name.m\"]. The third argument nt_ is used to rece\
ive the number of turns which is incremented by the tracking. The last argument x_ is used to receive the coordinates of particles\
. It is a (7 or 9, np) list of real numbers. The elements  (1..8, i) are (x, px ,y ,py ,z ,dp/p0, sy, sarg) of the i-th particle. \
The (-1, i)  element is True(==1) if the i-th particle has been survived, and False(==0) if it has been lost. The spin coordinates\
 sy and sarg are only valid with the POL flag.\n\n You can define ExternalMap to change the coordinates of each particle as you li\
ke by returning a new x in the same format as above. If you do not return it or you return in a different format, the tracking rou\
tine does not change the particle coordinates. You can neither rebirth a lost particle nor kill a surviving particle.\n\nAfter def\
ined ExternalMap, tracking calls it in every turn.\n\nExample:\n\n   MAP P1=();\n   ....\n   LINE A=(... P1 ... P1 ...);\n   ....\\
n   FFS USE=A;\n     ExternalMap[\"TRACK\",LINE[\"POSITION\",\"P1.2\"],nt_,x_]:=\n\t(Print[x];x*2);\n   ....\n\n   TRACK USE=A ...\
.;\n\nThis example defines ExternalMap to print out the coordinates of all particles at the second P1 in the line A. It also makes\
 all coordinates of all particles twice in every turn.\n\nOptionally a compiled module CompiledMap can be used for ExternalMap[\"T\
RACK\"] (see below).\n\n2) Emittance\nIn FFS, define the function ExternalMap as\n\n    ExternalMap[\"EMIT\",n,cod_]:=body;\n\nThe\
 second argument n is the position of MAP counting from the beginning, which can be obtained using LINE[\"POSITION\",\"name.m\"]. \
The last argument cod_ is used to receive the orbit at the entrance of the element, as a list of 6 real numbers. ExternalMap must \
return a list, either {cod1, trans} or  {cod1, trans, dtrans, dbeam}, where cod1 is the orbit at the exit, trans is the 6 by 6 tra\
nsfer matrix of this element, dtrans is the radiation damping part of the transfer matrix (6 by 6), and dbeam is the radiation exc\
itation of the beam matrix (6 by 6). Only j >= i parts of dbeam[[i, j]] are taken into account.\n\nExample:\n\n    ExternalMap[\"E\
MIT\",LINE[\"POSITION\",\"P1\"],cod_]:=(\n      Print[cod];\n      {cod+{0,0.001,0,0,0,0},IdentityMatrix[6]});\n\n3) Optics\nIn FF\
S, define the function ExternalMap as\n\n    ExternalMap[\"OPTICS\",n,cod_]:=body;\n\nThe second argument n is the position of MAP\
 counting from the beginning, which can be obtained using LINE[\"POSITION\",\"name.m\"]. The last argument cod_ is used to receive\
 the orbit at the entrance of the element, as a list of 6 real numbers. ExternalMap must return a list {cod1, trans}, where cod1 i\
s the orbit at the exit and trans is the 6 by 6 transfer matrix of this element. In the case of CACL4D (== ~CALC6D), only the 4 by\
 5 transfer matrix is effective.\n\nExample:\n\n    ExternalMap[\"OPTICS\",LINE[\"POSITION\",\"P1\"],cod_]:=(\n      Print[cod];\n\
      {cod+{0,0.001,0,0,0,0},IdentityMatrix[6]});\n\n4) Geometry\nIn FFS, define the function ExternalMap as\n\n    ExternalMap[\"\
GEO\",n,geo_,pos_]:=body;\n\nThe second argument n is the position of MAP counting from the beginning, which can be obtained using\
 LINE[\"POSITION\",\"name.m\"]. The argument geo_ receives the geometry of the beam line at the MAP element, in the same format as\
 LINE[\"GEO\",n], i.e., {{GX,GY,GZ},{CHI1,CHI2,CHI3}}. The last argument pos_ receives the orbit length S at the element. External\
Map must return an updated list {geo1, pos1}, as { {{GX,GY,GZ},{CHI1,CHI2,CHI3}}, S} as the values at the exit of the element.\nEx\
ample:\n\n    ExternalMap[\"GEO\",LINE[\"POSITION\",\"P1\"],geo_,pos_]:=(\n      Print[cod];\n      { {geo[[1]]+{1,0,0}, geo[[2]]}\
, pos+0.1})"[p$2298,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["With MAP elements, ExternalMap defines a user-defined map of particles. It also allows a user to do anything (doi\
ng statistics, etc.) at any point of a beam line during a tracking. \n\nUsage: First define a MAP element at MAIN level:\n\n     M\
AP    name=(L=leng);\n\nCurrently L is the only keyword. Insert it at the location(s) where you want to use it.\n\n1) Tracking\nIn\
 FFS, define the function ExternalMap as\n\n    ExternalMap[\"TRACK\",n,nt_,x_]:=body;\n\nThe second argument n is the position of\
 MAP counting from the beginning, which can be obtained using LINE[\"POSITION\",\"name.m\"]. The third argument nt_ is used to rec\
eive the number of turns which is incremented by the tracking. The last argument x_ is used to receive the coordinates of particle\
s. It is a (7 or 9, np) list of real numbers. The elements  (1..8, i) are (x, px ,y ,py ,z ,dp/p0, sy, sarg) of the i-th particle.\
 The (-1, i)  element is True(==1) if the i-th particle has been survived, and False(==0) if it has been lost. The spin coordinate\
s sy and sarg are only valid with the POL flag.\n\n You can define ExternalMap to change the coordinates of each particle as you l\
ike by returning a new x in the same format as above. If you do not return it or you return in a different format, the tracking ro\
utine does not change the particle coordinates. You can neither rebirth a lost particle nor kill a surviving particle.\n\nAfter de\
fined ExternalMap, tracking calls it in every turn.\n\nExample:\n\n   MAP P1=();\n   ....\n   LINE A=(... P1 ... P1 ...);\n   ....\
\n   FFS USE=A;\n     ExternalMap[\"TRACK\",LINE[\"POSITION\",\"P1.2\"],nt_,x_]:=\n\t(Print[x];x*2);\n   ....\n\n   TRACK USE=A ..\
..;\n\nThis example defines ExternalMap to print out the coordinates of all particles at the second P1 in the line A. It also make\
s all coordinates of all particles twice in every turn.\n\nOptionally a compiled module CompiledMap can be used for ExternalMap[\"\
TRACK\"] (see below).\n\n2) Emittance\nIn FFS, define the function ExternalMap as\n\n    ExternalMap[\"EMIT\",n,cod_]:=body;\n\nTh\
e second argument n is the position of MAP counting from the beginning, which can be obtained using LINE[\"POSITION\",\"name.m\"].\
 The last argument cod_ is used to receive the orbit at the entrance of the element, as a list of 6 real numbers. ExternalMap must\
 return a list, either {cod1, trans} or  {cod1, trans, dtrans, dbeam}, where cod1 is the orbit at the exit, trans is the 6 by 6 tr\
ansfer matrix of this element, dtrans is the radiation damping part of the transfer matrix (6 by 6), and dbeam is the radiation ex\
citation of the beam matrix (6 by 6). Only j >= i parts of dbeam[[i, j]] are taken into account.\n\nExample:\n\n    ExternalMap[\"\
EMIT\",LINE[\"POSITION\",\"P1\"],cod_]:=(\n      Print[cod];\n      {cod+{0,0.001,0,0,0,0},IdentityMatrix[6]});\n\n3) Optics\nIn F\
FS, define the function ExternalMap as\n\n    ExternalMap[\"OPTICS\",n,cod_]:=body;\n\nThe second argument n is the position of MA\
P counting from the beginning, which can be obtained using LINE[\"POSITION\",\"name.m\"]. The last argument cod_ is used to receiv\
e the orbit at the entrance of the element, as a list of 6 real numbers. ExternalMap must return a list {cod1, trans}, where cod1 \
is the orbit at the exit and trans is the 6 by 6 transfer matrix of this element. In the case of CACL4D (== ~CALC6D), only the 4 b\
y 5 transfer matrix is effective.\n\nExample:\n\n    ExternalMap[\"OPTICS\",LINE[\"POSITION\",\"P1\"],cod_]:=(\n      Print[cod];\\
n      {cod+{0,0.001,0,0,0,0},IdentityMatrix[6]});\n\n4) Geometry\nIn FFS, define the function ExternalMap as\n\n    ExternalMap[\\
"GEO\",n,geo_,pos_]:=body;\n\nThe second argument n is the position of MAP counting from the beginning, which can be obtained usin\
g LINE[\"POSITION\",\"name.m\"]. The argument geo_ receives the geometry of the beam line at the MAP element, in the same format a\
s LINE[\"GEO\",n], i.e., {{GX,GY,GZ},{CHI1,CHI2,CHI3}}. The last argument pos_ receives the orbit length S at the element. Externa\
lMap must return an updated list {geo1, pos1}, as { {{GX,GY,GZ},{CHI1,CHI2,CHI3}}, S} as the values at the exit of the element.\nE\
xample:\n\n    ExternalMap[\"GEO\",LINE[\"POSITION\",\"P1\"],geo_,pos_]:=(\n      Print[cod];\n      { {geo[[1]]+{1,0,0}, geo[[2]]\
}, pos+0.1})"[p$2298+pe$2298[[1,2]],p1$2298]]],
        p1$2298=-2+p$2298+pe$2298[[1,1]]}[[
       1]],
      0],
    1,lx$2298:=Help2HTML`o9$;p2$2298=4+p1$2298;p0$2298=-4+p$2298;0];
  If[(equ$2298=
Help2HTML`o8$["With MAP elements, ExternalMap defines a user-defined map of particles. It also allows a user to do anything (doing\
 statistics, etc.) at any point of a beam line during a tracking. \n\nUsage: First define a MAP element at MAIN level:\n\n     MAP\
    name=(L=leng);\n\nCurrently L is the only keyword. Insert it at the location(s) where you want to use it.\n\n1) Tracking\nIn F\
FS, define the function ExternalMap as\n\n    ExternalMap[\"TRACK\",n,nt_,x_]:=body;\n\nThe second argument n is the position of M\
AP counting from the beginning, which can be obtained using LINE[\"POSITION\",\"name.m\"]. The third argument nt_ is used to recei\
ve the number of turns which is incremented by the tracking. The last argument x_ is used to receive the coordinates of particles.\
 It is a (7 or 9, np) list of real numbers. The elements  (1..8, i) are (x, px ,y ,py ,z ,dp/p0, sy, sarg) of the i-th particle. T\
he (-1, i)  element is True(==1) if the i-th particle has been survived, and False(==0) if it has been lost. The spin coordinates \
sy and sarg are only valid with the POL flag.\n\n You can define ExternalMap to change the coordinates of each particle as you lik\
e by returning a new x in the same format as above. If you do not return it or you return in a different format, the tracking rout\
ine does not change the particle coordinates. You can neither rebirth a lost particle nor kill a surviving particle.\n\nAfter defi\
ned ExternalMap, tracking calls it in every turn.\n\nExample:\n\n   MAP P1=();\n   ....\n   LINE A=(... P1 ... P1 ...);\n   ....\n\
   FFS USE=A;\n     ExternalMap[\"TRACK\",LINE[\"POSITION\",\"P1.2\"],nt_,x_]:=\n\t(Print[x];x*2);\n   ....\n\n   TRACK USE=A ....\
;\n\nThis example defines ExternalMap to print out the coordinates of all particles at the second P1 in the line A. It also makes \
all coordinates of all particles twice in every turn.\n\nOptionally a compiled module CompiledMap can be used for ExternalMap[\"TR\
ACK\"] (see below).\n\n2) Emittance\nIn FFS, define the function ExternalMap as\n\n    ExternalMap[\"EMIT\",n,cod_]:=body;\n\nThe \
second argument n is the position of MAP counting from the beginning, which can be obtained using LINE[\"POSITION\",\"name.m\"]. T\
he last argument cod_ is used to receive the orbit at the entrance of the element, as a list of 6 real numbers. ExternalMap must r\
eturn a list, either {cod1, trans} or  {cod1, trans, dtrans, dbeam}, where cod1 is the orbit at the exit, trans is the 6 by 6 tran\
sfer matrix of this element, dtrans is the radiation damping part of the transfer matrix (6 by 6), and dbeam is the radiation exci\
tation of the beam matrix (6 by 6). Only j >= i parts of dbeam[[i, j]] are taken into account.\n\nExample:\n\n    ExternalMap[\"EM\
IT\",LINE[\"POSITION\",\"P1\"],cod_]:=(\n      Print[cod];\n      {cod+{0,0.001,0,0,0,0},IdentityMatrix[6]});\n\n3) Optics\nIn FFS\
, define the function ExternalMap as\n\n    ExternalMap[\"OPTICS\",n,cod_]:=body;\n\nThe second argument n is the position of MAP \
counting from the beginning, which can be obtained using LINE[\"POSITION\",\"name.m\"]. The last argument cod_ is used to receive \
the orbit at the entrance of the element, as a list of 6 real numbers. ExternalMap must return a list {cod1, trans}, where cod1 is\
 the orbit at the exit and trans is the 6 by 6 transfer matrix of this element. In the case of CACL4D (== ~CALC6D), only the 4 by \
5 transfer matrix is effective.\n\nExample:\n\n    ExternalMap[\"OPTICS\",LINE[\"POSITION\",\"P1\"],cod_]:=(\n      Print[cod];\n \
     {cod+{0,0.001,0,0,0,0},IdentityMatrix[6]});\n\n4) Geometry\nIn FFS, define the function ExternalMap as\n\n    ExternalMap[\"G\
EO\",n,geo_,pos_]:=body;\n\nThe second argument n is the position of MAP counting from the beginning, which can be obtained using \
LINE[\"POSITION\",\"name.m\"]. The argument geo_ receives the geometry of the beam line at the MAP element, in the same format as \
LINE[\"GEO\",n], i.e., {{GX,GY,GZ},{CHI1,CHI2,CHI3}}. The last argument pos_ receives the orbit length S at the element. ExternalM\
ap must return an updated list {geo1, pos1}, as { {{GX,GY,GZ},{CHI1,CHI2,CHI3}}, S} as the values at the exit of the element.\nExa\
mple:\n\n    ExternalMap[\"GEO\",LINE[\"POSITION\",\"P1\"],geo_,pos_]:=(\n      Print[cod];\n      { {geo[[1]]+{1,0,0}, geo[[2]]},\
 pos+0.1})"[p$2298,p1$2298]])===
    Undefined,
equ$2298="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["With MAP elements, ExternalMap defines a use\
r-defined map of particles. It also allows a user to do anything (doing statistics, etc.) at any point of a beam line during a tra\
cking. \n\nUsage: First define a MAP element at MAIN level:\n\n     MAP    name=(L=leng);\n\nCurrently L is the only keyword. Inse\
rt it at the location(s) where you want to use it.\n\n1) Tracking\nIn FFS, define the function ExternalMap as\n\n    ExternalMap[\\
"TRACK\",n,nt_,x_]:=body;\n\nThe second argument n is the position of MAP counting from the beginning, which can be obtained using\
 LINE[\"POSITION\",\"name.m\"]. The third argument nt_ is used to receive the number of turns which is incremented by the tracking\
. The last argument x_ is used to receive the coordinates of particles. It is a (7 or 9, np) list of real numbers. The elements  (\
1..8, i) are (x, px ,y ,py ,z ,dp/p0, sy, sarg) of the i-th particle. The (-1, i)  element is True(==1) if the i-th particle has b\
een survived, and False(==0) if it has been lost. The spin coordinates sy and sarg are only valid with the POL flag.\n\n You can d\
efine ExternalMap to change the coordinates of each particle as you like by returning a new x in the same format as above. If you \
do not return it or you return in a different format, the tracking routine does not change the particle coordinates. You can neith\
er rebirth a lost particle nor kill a surviving particle.\n\nAfter defined ExternalMap, tracking calls it in every turn.\n\nExampl\
e:\n\n   MAP P1=();\n   ....\n   LINE A=(... P1 ... P1 ...);\n   ....\n   FFS USE=A;\n     ExternalMap[\"TRACK\",LINE[\"POSITION\"\
,\"P1.2\"],nt_,x_]:=\n\t(Print[x];x*2);\n   ....\n\n   TRACK USE=A ....;\n\nThis example defines ExternalMap to print out the coor\
dinates of all particles at the second P1 in the line A. It also makes all coordinates of all particles twice in every turn.\n\nOp\
tionally a compiled module CompiledMap can be used for ExternalMap[\"TRACK\"] (see below).\n\n2) Emittance\nIn FFS, define the fun\
ction ExternalMap as\n\n    ExternalMap[\"EMIT\",n,cod_]:=body;\n\nThe second argument n is the position of MAP counting from the \
beginning, which can be obtained using LINE[\"POSITION\",\"name.m\"]. The last argument cod_ is used to receive the orbit at the e\
ntrance of the element, as a list of 6 real numbers. ExternalMap must return a list, either {cod1, trans} or  {cod1, trans, dtrans\
, dbeam}, where cod1 is the orbit at the exit, trans is the 6 by 6 transfer matrix of this element, dtrans is the radiation dampin\
g part of the transfer matrix (6 by 6), and dbeam is the radiation excitation of the beam matrix (6 by 6). Only j >= i parts of db\
eam[[i, j]] are taken into account.\n\nExample:\n\n    ExternalMap[\"EMIT\",LINE[\"POSITION\",\"P1\"],cod_]:=(\n      Print[cod];\\
n      {cod+{0,0.001,0,0,0,0},IdentityMatrix[6]});\n\n3) Optics\nIn FFS, define the function ExternalMap as\n\n    ExternalMap[\"O\
PTICS\",n,cod_]:=body;\n\nThe second argument n is the position of MAP counting from the beginning, which can be obtained using LI\
NE[\"POSITION\",\"name.m\"]. The last argument cod_ is used to receive the orbit at the entrance of the element, as a list of 6 re\
al numbers. ExternalMap must return a list {cod1, trans}, where cod1 is the orbit at the exit and trans is the 6 by 6 transfer mat\
rix of this element. In the case of CACL4D (== ~CALC6D), only the 4 by 5 transfer matrix is effective.\n\nExample:\n\n    External\
Map[\"OPTICS\",LINE[\"POSITION\",\"P1\"],cod_]:=(\n      Print[cod];\n      {cod+{0,0.001,0,0,0,0},IdentityMatrix[6]});\n\n4) Geom\
etry\nIn FFS, define the function ExternalMap as\n\n    ExternalMap[\"GEO\",n,geo_,pos_]:=body;\n\nThe second argument n is the po\
sition of MAP counting from the beginning, which can be obtained using LINE[\"POSITION\",\"name.m\"]. The argument geo_ receives t\
he geometry of the beam line at the MAP element, in the same format as LINE[\"GEO\",n], i.e., {{GX,GY,GZ},{CHI1,CHI2,CHI3}}. The l\
ast argument pos_ receives the orbit length S at the element. ExternalMap must return an updated list {geo1, pos1}, as { {{GX,GY,G\
Z},{CHI1,CHI2,CHI3}}, S} as the values at the exit of the element.\nExample:\n\n    ExternalMap[\"GEO\",LINE[\"POSITION\",\"P1\"],\
geo_,pos_]:=(\n      Print[cod];\n      { {geo[[1]]+{1,0,0}, geo[[2]]}, pos+0.1})"[p$2298,p1$2298]]=
       equ$2298;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2298},out$2298=lx$2298@Typeset["With MAP elements, ExternalMap defines a user-defined map of particles. It also allows a \
user to do anything (doing statistics, etc.) at any point of a beam line during a tracking. \n\nUsage: First define a MAP element \
at MAIN level:\n\n     MAP    name=(L=leng);\n\nCurrently L is the only keyword. Insert it at the location(s) where you want to us\
e it.\n\n1) Tracking\nIn FFS, define the function ExternalMap as\n\n    ExternalMap[\"TRACK\",n,nt_,x_]:=body;\n\nThe second argum\
ent n is the position of MAP counting from the beginning, which can be obtained using LINE[\"POSITION\",\"name.m\"]. The third arg\
ument nt_ is used to receive the number of turns which is incremented by the tracking. The last argument x_ is used to receive the\
 coordinates of particles. It is a (7 or 9, np) list of real numbers. The elements  (1..8, i) are (x, px ,y ,py ,z ,dp/p0, sy, sar\
g) of the i-th particle. The (-1, i)  element is True(==1) if the i-th particle has been survived, and False(==0) if it has been l\
ost. The spin coordinates sy and sarg are only valid with the POL flag.\n\n You can define ExternalMap to change the coordinates o\
f each particle as you like by returning a new x in the same format as above. If you do not return it or you return in a different\
 format, the tracking routine does not change the particle coordinates. You can neither rebirth a lost particle nor kill a survivi\
ng particle.\n\nAfter defined ExternalMap, tracking calls it in every turn.\n\nExample:\n\n   MAP P1=();\n   ....\n   LINE A=(... \
P1 ... P1 ...);\n   ....\n   FFS USE=A;\n     ExternalMap[\"TRACK\",LINE[\"POSITION\",\"P1.2\"],nt_,x_]:=\n\t(Print[x];x*2);\n   .\
...\n\n   TRACK USE=A ....;\n\nThis example defines ExternalMap to print out the coordinates of all particles at the second P1 in \
the line A. It also makes all coordinates of all particles twice in every turn.\n\nOptionally a compiled module CompiledMap can be\
 used for ExternalMap[\"TRACK\"] (see below).\n\n2) Emittance\nIn FFS, define the function ExternalMap as\n\n    ExternalMap[\"EMI\
T\",n,cod_]:=body;\n\nThe second argument n is the position of MAP counting from the beginning, which can be obtained using LINE[\\
"POSITION\",\"name.m\"]. The last argument cod_ is used to receive the orbit at the entrance of the element, as a list of 6 real n\
umbers. ExternalMap must return a list, either {cod1, trans} or  {cod1, trans, dtrans, dbeam}, where cod1 is the orbit at the exit\
, trans is the 6 by 6 transfer matrix of this element, dtrans is the radiation damping part of the transfer matrix (6 by 6), and d\
beam is the radiation excitation of the beam matrix (6 by 6). Only j >= i parts of dbeam[[i, j]] are taken into account.\n\nExampl\
e:\n\n    ExternalMap[\"EMIT\",LINE[\"POSITION\",\"P1\"],cod_]:=(\n      Print[cod];\n      {cod+{0,0.001,0,0,0,0},IdentityMatrix[\
6]});\n\n3) Optics\nIn FFS, define the function ExternalMap as\n\n    ExternalMap[\"OPTICS\",n,cod_]:=body;\n\nThe second argument\
 n is the position of MAP counting from the beginning, which can be obtained using LINE[\"POSITION\",\"name.m\"]. The last argumen\
t cod_ is used to receive the orbit at the entrance of the element, as a list of 6 real numbers. ExternalMap must return a list {c\
od1, trans}, where cod1 is the orbit at the exit and trans is the 6 by 6 transfer matrix of this element. In the case of CACL4D (=\
= ~CALC6D), only the 4 by 5 transfer matrix is effective.\n\nExample:\n\n    ExternalMap[\"OPTICS\",LINE[\"POSITION\",\"P1\"],cod_\
]:=(\n      Print[cod];\n      {cod+{0,0.001,0,0,0,0},IdentityMatrix[6]});\n\n4) Geometry\nIn FFS, define the function ExternalMap\
 as\n\n    ExternalMap[\"GEO\",n,geo_,pos_]:=body;\n\nThe second argument n is the position of MAP counting from the beginning, wh\
ich can be obtained using LINE[\"POSITION\",\"name.m\"]. The argument geo_ receives the geometry of the beam line at the MAP eleme\
nt, in the same format as LINE[\"GEO\",n], i.e., {{GX,GY,GZ},{CHI1,CHI2,CHI3}}. The last argument pos_ receives the orbit length S\
 at the element. ExternalMap must return an updated list {geo1, pos1}, as { {{GX,GY,GZ},{CHI1,CHI2,CHI3}}, S} as the values at the\
 exit of the element.\nExample:\n\n    ExternalMap[\"GEO\",LINE[\"POSITION\",\"P1\"],geo_,pos_]:=(\n      Print[cod];\n      { {ge\
o[[1]]+{1,0,0}, geo[[2]]}, pos+0.1})"[p$2298,p1$2298],Format->Help2HTML`oB$];
        System["mv -f "//out$2298//" "//equ$2298]];
      Exit[]]];
   "With MAP elements, ExternalMap defines a user-defined map of particles. It also allows a user to do anything (doing statistics\
, etc.) at any point of a beam line during a tracking. \n\nUsage: First define a MAP element at MAIN level:\n\n     MAP    name=(L\
=leng);\n\nCurrently L is the only keyword. Insert it at the location(s) where you want to use it.\n\n1) Tracking\nIn FFS, define \
the function ExternalMap as\n\n    ExternalMap[\"TRACK\",n,nt_,x_]:=body;\n\nThe second argument n is the position of MAP counting\
 from the beginning, which can be obtained using LINE[\"POSITION\",\"name.m\"]. The third argument nt_ is used to receive the numb\
er of turns which is incremented by the tracking. The last argument x_ is used to receive the coordinates of particles. It is a (7\
 or 9, np) list of real numbers. The elements  (1..8, i) are (x, px ,y ,py ,z ,dp/p0, sy, sarg) of the i-th particle. The (-1, i) \
 element is True(==1) if the i-th particle has been survived, and False(==0) if it has been lost. The spin coordinates sy and sarg\
 are only valid with the POL flag.\n\n You can define ExternalMap to change the coordinates of each particle as you like by return\
ing a new x in the same format as above. If you do not return it or you return in a different format, the tracking routine does no\
t change the particle coordinates. You can neither rebirth a lost particle nor kill a surviving particle.\n\nAfter defined Externa\
lMap, tracking calls it in every turn.\n\nExample:\n\n   MAP P1=();\n   ....\n   LINE A=(... P1 ... P1 ...);\n   ....\n   FFS USE=\
A;\n     ExternalMap[\"TRACK\",LINE[\"POSITION\",\"P1.2\"],nt_,x_]:=\n\t(Print[x];x*2);\n   ....\n\n   TRACK USE=A ....;\n\nThis e\
xample defines ExternalMap to print out the coordinates of all particles at the second P1 in the line A. It also makes all coordin\
ates of all particles twice in every turn.\n\nOptionally a compiled module CompiledMap can be used for ExternalMap[\"TRACK\"] (see\
 below).\n\n2) Emittance\nIn FFS, define the function ExternalMap as\n\n    ExternalMap[\"EMIT\",n,cod_]:=body;\n\nThe second argu\
ment n is the position of MAP counting from the beginning, which can be obtained using LINE[\"POSITION\",\"name.m\"]. The last arg\
ument cod_ is used to receive the orbit at the entrance of the element, as a list of 6 real numbers. ExternalMap must return a lis\
t, either {cod1, trans} or  {cod1, trans, dtrans, dbeam}, where cod1 is the orbit at the exit, trans is the 6 by 6 transfer matrix\
 of this element, dtrans is the radiation damping part of the transfer matrix (6 by 6), and dbeam is the radiation excitation of t\
he beam matrix (6 by 6). Only j >= i parts of dbeam[[i, j]] are taken into account.\n\nExample:\n\n    ExternalMap[\"EMIT\",LINE[\\
"POSITION\",\"P1\"],cod_]:=(\n      Print[cod];\n      {cod+{0,0.001,0,0,0,0},IdentityMatrix[6]});\n\n3) Optics\nIn FFS, define th\
e function ExternalMap as\n\n    ExternalMap[\"OPTICS\",n,cod_]:=body;\n\nThe second argument n is the position of MAP counting fr\
om the beginning, which can be obtained using LINE[\"POSITION\",\"name.m\"]. The last argument cod_ is used to receive the orbit a\
t the entrance of the element, as a list of 6 real numbers. ExternalMap must return a list {cod1, trans}, where cod1 is the orbit \
at the exit and trans is the 6 by 6 transfer matrix of this element. In the case of CACL4D (== ~CALC6D), only the 4 by 5 transfer \
matrix is effective.\n\nExample:\n\n    ExternalMap[\"OPTICS\",LINE[\"POSITION\",\"P1\"],cod_]:=(\n      Print[cod];\n      {cod+{\
0,0.001,0,0,0,0},IdentityMatrix[6]});\n\n4) Geometry\nIn FFS, define the function ExternalMap as\n\n    ExternalMap[\"GEO\",n,geo_\
,pos_]:=body;\n\nThe second argument n is the position of MAP counting from the beginning, which can be obtained using LINE[\"POSI\
TION\",\"name.m\"]. The argument geo_ receives the geometry of the beam line at the MAP element, in the same format as LINE[\"GEO\\
",n], i.e., {{GX,GY,GZ},{CHI1,CHI2,CHI3}}. The last argument pos_ receives the orbit length S at the element. ExternalMap must ret\
urn an updated list {geo1, pos1}, as { {{GX,GY,GZ},{CHI1,CHI2,CHI3}}, S} as the values at the exit of the element.\nExample:\n\n  \
  ExternalMap[\"GEO\",LINE[\"POSITION\",\"P1\"],geo_,pos_]:=(\n      Print[cod];\n      { {geo[[1]]+{1,0,0}, geo[[2]]}, pos+0.1})"[
    1,Max[p0$2298,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2298//"\" />"//
Help2HTML`oy$["With MAP elements, ExternalMap defines a user-defined map of particles. It also allows a user to do anything (doing\
 statistics, etc.) at any point of a beam line during a tracking. \n\nUsage: First define a MAP element at MAIN level:\n\n     MAP\
    name=(L=leng);\n\nCurrently L is the only keyword. Insert it at the location(s) where you want to use it.\n\n1) Tracking\nIn F\
FS, define the function ExternalMap as\n\n    ExternalMap[\"TRACK\",n,nt_,x_]:=body;\n\nThe second argument n is the position of M\
AP counting from the beginning, which can be obtained using LINE[\"POSITION\",\"name.m\"]. The third argument nt_ is used to recei\
ve the number of turns which is incremented by the tracking. The last argument x_ is used to receive the coordinates of particles.\
 It is a (7 or 9, np) list of real numbers. The elements  (1..8, i) are (x, px ,y ,py ,z ,dp/p0, sy, sarg) of the i-th particle. T\
he (-1, i)  element is True(==1) if the i-th particle has been survived, and False(==0) if it has been lost. The spin coordinates \
sy and sarg are only valid with the POL flag.\n\n You can define ExternalMap to change the coordinates of each particle as you lik\
e by returning a new x in the same format as above. If you do not return it or you return in a different format, the tracking rout\
ine does not change the particle coordinates. You can neither rebirth a lost particle nor kill a surviving particle.\n\nAfter defi\
ned ExternalMap, tracking calls it in every turn.\n\nExample:\n\n   MAP P1=();\n   ....\n   LINE A=(... P1 ... P1 ...);\n   ....\n\
   FFS USE=A;\n     ExternalMap[\"TRACK\",LINE[\"POSITION\",\"P1.2\"],nt_,x_]:=\n\t(Print[x];x*2);\n   ....\n\n   TRACK USE=A ....\
;\n\nThis example defines ExternalMap to print out the coordinates of all particles at the second P1 in the line A. It also makes \
all coordinates of all particles twice in every turn.\n\nOptionally a compiled module CompiledMap can be used for ExternalMap[\"TR\
ACK\"] (see below).\n\n2) Emittance\nIn FFS, define the function ExternalMap as\n\n    ExternalMap[\"EMIT\",n,cod_]:=body;\n\nThe \
second argument n is the position of MAP counting from the beginning, which can be obtained using LINE[\"POSITION\",\"name.m\"]. T\
he last argument cod_ is used to receive the orbit at the entrance of the element, as a list of 6 real numbers. ExternalMap must r\
eturn a list, either {cod1, trans} or  {cod1, trans, dtrans, dbeam}, where cod1 is the orbit at the exit, trans is the 6 by 6 tran\
sfer matrix of this element, dtrans is the radiation damping part of the transfer matrix (6 by 6), and dbeam is the radiation exci\
tation of the beam matrix (6 by 6). Only j >= i parts of dbeam[[i, j]] are taken into account.\n\nExample:\n\n    ExternalMap[\"EM\
IT\",LINE[\"POSITION\",\"P1\"],cod_]:=(\n      Print[cod];\n      {cod+{0,0.001,0,0,0,0},IdentityMatrix[6]});\n\n3) Optics\nIn FFS\
, define the function ExternalMap as\n\n    ExternalMap[\"OPTICS\",n,cod_]:=body;\n\nThe second argument n is the position of MAP \
counting from the beginning, which can be obtained using LINE[\"POSITION\",\"name.m\"]. The last argument cod_ is used to receive \
the orbit at the entrance of the element, as a list of 6 real numbers. ExternalMap must return a list {cod1, trans}, where cod1 is\
 the orbit at the exit and trans is the 6 by 6 transfer matrix of this element. In the case of CACL4D (== ~CALC6D), only the 4 by \
5 transfer matrix is effective.\n\nExample:\n\n    ExternalMap[\"OPTICS\",LINE[\"POSITION\",\"P1\"],cod_]:=(\n      Print[cod];\n \
     {cod+{0,0.001,0,0,0,0},IdentityMatrix[6]});\n\n4) Geometry\nIn FFS, define the function ExternalMap as\n\n    ExternalMap[\"G\
EO\",n,geo_,pos_]:=body;\n\nThe second argument n is the position of MAP counting from the beginning, which can be obtained using \
LINE[\"POSITION\",\"name.m\"]. The argument geo_ receives the geometry of the beam line at the MAP element, in the same format as \
LINE[\"GEO\",n], i.e., {{GX,GY,GZ},{CHI1,CHI2,CHI3}}. The last argument pos_ receives the orbit length S at the element. ExternalM\
ap must return an updated list {geo1, pos1}, as { {{GX,GY,GZ},{CHI1,CHI2,CHI3}}, S} as the values at the exit of the element.\nExa\
mple:\n\n    ExternalMap[\"GEO\",LINE[\"POSITION\",\"P1\"],geo_,pos_]:=(\n      Print[cod];\n      { {geo[[1]]+{1,0,0}, geo[[2]]},\
 pos+0.1})"[p2$2298,-1]]
]</PRE>
<PRE>See also:
 MAP <A HREF=#L303>CALC4D</A> <A HREF=#L333>POL</A> <A HREF=#L391>CompiledMap</A></PRE>
<UL>
<LI>
<H3><A NAME=L391>
CompiledMap</A></H3>
<PRE>If[{},
Help2HTML`oA$["Usage:\n\nExternapMa[\"TRACK\", n, nt_, x_]:=CompiledMap[nt, x, src, prm, opt___];\n\nwhere n is the location numbe\
r, nt the number of turns, x the particle coordinates with the alive flag, as described for ExternalMap. It takes options of Rules\
 as shown below. A charachter string src is the source code for the map, which completes a subroutine having a header:\n\nimplicit\
 none;\ninteger,intent(in):: np,nprm,nt,n;\nreal(kind=8),intent(inout):: x(np),px(np),y(np),py(np),z(np),dp(np),&\n               \
              sy(np),sarg(np),flag(np),prm(nprm);\n\nwhere np is the number of particles, and prm is a list of reals of any length\
. The spin coordinates sy and sarg are meaningless without the flag POL. The src must ends with \"return;end\" to complete the sub\
routine, and more routines can be inserted if needed. Currently gfortran in free format is available for the compiler, and gcc wil\
l be supported in future.\n\nExample:\n\nsrc = \"flag = flag * merge(1.d0, 0.d0, x&ltprm(1) .or. x&gtprm(2) .or. (y&gtprm(3) .and.\
 y&ltprm(4)));return;end\";\nprm = {-0.001, 0.001, -3e-4, 3e-4};\nExternalMap[\"TRACK\", LINE[\"POSITION\",\"M1.2\"], nt_, x_]:=Co\
mpiledMap[nt, x, src, prm];\n\nworks as a special colimation at a MAP element M1.2, resulting:\n\n<Collimate.png\n\n(Actually the \
example above can be performed also by SADScript:\n\nExternalMap[\"TRACK\", LINE[\"POSITION\",\"M1.2\"], nt_, x_]:=Append[Drop[x, \
-1],\n       x[[1]] < prm[[1]] || x[[1]] > prm[[2]] || (prm[[3]] < x[[3]] < prm[[4]])];\n\nwhich runs even FASTER than the compile\
d one!!)\n\nOptions      Defaul     Description\n-------------------------------------------------------------\nSingle       False\
      If True, the map is called once for the entrire particles even for NPARA > 1.\nCompletion   Null       A completion SADScrip\
t to be called after the map with the arg {x, prm}."],
p$2301=1+p$2301[[1,2]];p1$2301=StringPosition["Usage:\n\nExternapMa[\"TRACK\", n, nt_, x_]:=CompiledMap[nt, x, src, prm, opt___];\\
n\nwhere n is the location number, nt the number of turns, x the particle coordinates with the alive flag, as described for Extern\
alMap. It takes options of Rules as shown below. A charachter string src is the source code for the map, which completes a subrout\
ine having a header:\n\nimplicit none;\ninteger,intent(in):: np,nprm,nt,n;\nreal(kind=8),intent(inout):: x(np),px(np),y(np),py(np)\
,z(np),dp(np),&\n                             sy(np),sarg(np),flag(np),prm(nprm);\n\nwhere np is the number of particles, and prm \
is a list of reals of any length. The spin coordinates sy and sarg are meaningless without the flag POL. The src must ends with \"\
return;end\" to complete the subroutine, and more routines can be inserted if needed. Currently gfortran in free format is availab\
le for the compiler, and gcc will be supported in future.\n\nExample:\n\nsrc = \"flag = flag * merge(1.d0, 0.d0, x&ltprm(1) .or. x\
&gtprm(2) .or. (y&gtprm(3) .and. y&ltprm(4)));return;end\";\nprm = {-0.001, 0.001, -3e-4, 3e-4};\nExternalMap[\"TRACK\", LINE[\"PO\
SITION\",\"M1.2\"], nt_, x_]:=CompiledMap[nt, x, src, prm];\n\nworks as a special colimation at a MAP element M1.2, resulting:\n\n\
<Collimate.png\n\n(Actually the example above can be performed also by SADScript:\n\nExternalMap[\"TRACK\", LINE[\"POSITION\",\"M1\
.2\"], nt_, x_]:=Append[Drop[x, -1],\n       x[[1]] < prm[[1]] || x[[1]] > prm[[2]] || (prm[[3]] < x[[3]] < prm[[4]])];\n\nwhich r\
uns even FASTER than the compiled one!!)\n\nOptions      Defaul     Description\n-------------------------------------------------\
------------\nSingle       False      If True, the map is called once for the entrire particles even for NPARA > 1.\nCompletion   \
Null       A completion SADScript to be called after the map with the arg {x, prm}."[p$2301,-1],">::",1];
   p1$2301=If[p1$2301==={},1805,-2+p$2301+p1$2301[[1,1]]];
neq=Which["Usage:\n\nExternapMa[\"TRACK\", n, nt_, x_]:=CompiledMap[nt, x, src, prm, opt___];\n\nwhere n is the location number, n\
t the number of turns, x the particle coordinates with the alive flag, as described for ExternalMap. It takes options of Rules as \
shown below. A charachter string src is the source code for the map, which completes a subroutine having a header:\n\nimplicit non\
e;\ninteger,intent(in):: np,nprm,nt,n;\nreal(kind=8),intent(inout):: x(np),px(np),y(np),py(np),z(np),dp(np),&\n                   \
          sy(np),sarg(np),flag(np),prm(nprm);\n\nwhere np is the number of particles, and prm is a list of reals of any length. Th\
e spin coordinates sy and sarg are meaningless without the flag POL. The src must ends with \"return;end\" to complete the subrout\
ine, and more routines can be inserted if needed. Currently gfortran in free format is available for the compiler, and gcc will be\
 supported in future.\n\nExample:\n\nsrc = \"flag = flag * merge(1.d0, 0.d0, x&ltprm(1) .or. x&gtprm(2) .or. (y&gtprm(3) .and. y&l\
tprm(4)));return;end\";\nprm = {-0.001, 0.001, -3e-4, 3e-4};\nExternalMap[\"TRACK\", LINE[\"POSITION\",\"M1.2\"], nt_, x_]:=Compil\
edMap[nt, x, src, prm];\n\nworks as a special colimation at a MAP element M1.2, resulting:\n\n<Collimate.png\n\n(Actually the exam\
ple above can be performed also by SADScript:\n\nExternalMap[\"TRACK\", LINE[\"POSITION\",\"M1.2\"], nt_, x_]:=Append[Drop[x, -1],\
\n       x[[1]] < prm[[1]] || x[[1]] > prm[[2]] || (prm[[3]] < x[[3]] < prm[[4]])];\n\nwhich runs even FASTER than the compiled on\
e!!)\n\nOptions      Defaul     Description\n-------------------------------------------------------------\nSingle       False    \
  If True, the map is called once for the entrire particles even for NPARA > 1.\nCompletion   Null       A completion SADScript to\
 be called after the map with the arg {x, prm}."[p$2301,4+p$2301]==="Text[",
    lx$2301:=Help2HTML`oa$;p$2301=5+p$2301;p1$2301-=1;p2$2301=5+p1$2301;p0$2301=-9+p$2301;
If[(pe$2301=StringPosition["Usage:\n\nExternapMa[\"TRACK\", n, nt_, x_]:=CompiledMap[nt, x, src, prm, opt___];\n\nwhere n is the l\
ocation number, nt the number of turns, x the particle coordinates with the alive flag, as described for ExternalMap. It takes opt\
ions of Rules as shown below. A charachter string src is the source code for the map, which completes a subroutine having a header\
:\n\nimplicit none;\ninteger,intent(in):: np,nprm,nt,n;\nreal(kind=8),intent(inout):: x(np),px(np),y(np),py(np),z(np),dp(np),&\n  \
                           sy(np),sarg(np),flag(np),prm(nprm);\n\nwhere np is the number of particles, and prm is a list of reals \
of any length. The spin coordinates sy and sarg are meaningless without the flag POL. The src must ends with \"return;end\" to com\
plete the subroutine, and more routines can be inserted if needed. Currently gfortran in free format is available for the compiler\
, and gcc will be supported in future.\n\nExample:\n\nsrc = \"flag = flag * merge(1.d0, 0.d0, x&ltprm(1) .or. x&gtprm(2) .or. (y&g\
tprm(3) .and. y&ltprm(4)));return;end\";\nprm = {-0.001, 0.001, -3e-4, 3e-4};\nExternalMap[\"TRACK\", LINE[\"POSITION\",\"M1.2\"],\
 nt_, x_]:=CompiledMap[nt, x, src, prm];\n\nworks as a special colimation at a MAP element M1.2, resulting:\n\n<Collimate.png\n\n(\
Actually the example above can be performed also by SADScript:\n\nExternalMap[\"TRACK\", LINE[\"POSITION\",\"M1.2\"], nt_, x_]:=Ap\
pend[Drop[x, -1],\n       x[[1]] < prm[[1]] || x[[1]] > prm[[2]] || (prm[[3]] < x[[3]] < prm[[4]])];\n\nwhich runs even FASTER tha\
n the compiled one!!)\n\nOptions      Defaul     Description\n-------------------------------------------------------------\nSingl\
e       False      If True, the map is called once for the entrire particles even for NPARA > 1.\nCompletion   Null       A comple\
tion SADScript to be called after the map with the arg {x, prm}."[p$2301,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Usage:\n\nExternapMa[\"TRACK\", n, nt_, x_]:=CompiledMap[nt, x, src, prm, opt___];\n\nwhere n is the location num\
ber, nt the number of turns, x the particle coordinates with the alive flag, as described for ExternalMap. It takes options of Rul\
es as shown below. A charachter string src is the source code for the map, which completes a subroutine having a header:\n\nimplic\
it none;\ninteger,intent(in):: np,nprm,nt,n;\nreal(kind=8),intent(inout):: x(np),px(np),y(np),py(np),z(np),dp(np),&\n             \
                sy(np),sarg(np),flag(np),prm(nprm);\n\nwhere np is the number of particles, and prm is a list of reals of any leng\
th. The spin coordinates sy and sarg are meaningless without the flag POL. The src must ends with \"return;end\" to complete the s\
ubroutine, and more routines can be inserted if needed. Currently gfortran in free format is available for the compiler, and gcc w\
ill be supported in future.\n\nExample:\n\nsrc = \"flag = flag * merge(1.d0, 0.d0, x&ltprm(1) .or. x&gtprm(2) .or. (y&gtprm(3) .an\
d. y&ltprm(4)));return;end\";\nprm = {-0.001, 0.001, -3e-4, 3e-4};\nExternalMap[\"TRACK\", LINE[\"POSITION\",\"M1.2\"], nt_, x_]:=\
CompiledMap[nt, x, src, prm];\n\nworks as a special colimation at a MAP element M1.2, resulting:\n\n<Collimate.png\n\n(Actually th\
e example above can be performed also by SADScript:\n\nExternalMap[\"TRACK\", LINE[\"POSITION\",\"M1.2\"], nt_, x_]:=Append[Drop[x\
, -1],\n       x[[1]] < prm[[1]] || x[[1]] > prm[[2]] || (prm[[3]] < x[[3]] < prm[[4]])];\n\nwhich runs even FASTER than the compi\
led one!!)\n\nOptions      Defaul     Description\n-------------------------------------------------------------\nSingle       Fal\
se      If True, the map is called once for the entrire particles even for NPARA > 1.\nCompletion   Null       A completion SADScr\
ipt to be called after the map with the arg {x, prm}."[p$2301+pe$2301[[1,2]],p1$2301]]],
        p1$2301=-2+p$2301+pe$2301[[1,1]]}[[
       1]],
      0],
    1,lx$2301:=Help2HTML`o9$;p2$2301=4+p1$2301;p0$2301=-4+p$2301;0];
  If[(equ$2301=
Help2HTML`o8$["Usage:\n\nExternapMa[\"TRACK\", n, nt_, x_]:=CompiledMap[nt, x, src, prm, opt___];\n\nwhere n is the location numbe\
r, nt the number of turns, x the particle coordinates with the alive flag, as described for ExternalMap. It takes options of Rules\
 as shown below. A charachter string src is the source code for the map, which completes a subroutine having a header:\n\nimplicit\
 none;\ninteger,intent(in):: np,nprm,nt,n;\nreal(kind=8),intent(inout):: x(np),px(np),y(np),py(np),z(np),dp(np),&\n               \
              sy(np),sarg(np),flag(np),prm(nprm);\n\nwhere np is the number of particles, and prm is a list of reals of any length\
. The spin coordinates sy and sarg are meaningless without the flag POL. The src must ends with \"return;end\" to complete the sub\
routine, and more routines can be inserted if needed. Currently gfortran in free format is available for the compiler, and gcc wil\
l be supported in future.\n\nExample:\n\nsrc = \"flag = flag * merge(1.d0, 0.d0, x&ltprm(1) .or. x&gtprm(2) .or. (y&gtprm(3) .and.\
 y&ltprm(4)));return;end\";\nprm = {-0.001, 0.001, -3e-4, 3e-4};\nExternalMap[\"TRACK\", LINE[\"POSITION\",\"M1.2\"], nt_, x_]:=Co\
mpiledMap[nt, x, src, prm];\n\nworks as a special colimation at a MAP element M1.2, resulting:\n\n<Collimate.png\n\n(Actually the \
example above can be performed also by SADScript:\n\nExternalMap[\"TRACK\", LINE[\"POSITION\",\"M1.2\"], nt_, x_]:=Append[Drop[x, \
-1],\n       x[[1]] < prm[[1]] || x[[1]] > prm[[2]] || (prm[[3]] < x[[3]] < prm[[4]])];\n\nwhich runs even FASTER than the compile\
d one!!)\n\nOptions      Defaul     Description\n-------------------------------------------------------------\nSingle       False\
      If True, the map is called once for the entrire particles even for NPARA > 1.\nCompletion   Null       A completion SADScrip\
t to be called after the map with the arg {x, prm}."[p$2301,p1$2301]])===
    Undefined,
equ$2301="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Usage:\n\nExternapMa[\"TRACK\", n, nt_, x_]:\
=CompiledMap[nt, x, src, prm, opt___];\n\nwhere n is the location number, nt the number of turns, x the particle coordinates with \
the alive flag, as described for ExternalMap. It takes options of Rules as shown below. A charachter string src is the source code\
 for the map, which completes a subroutine having a header:\n\nimplicit none;\ninteger,intent(in):: np,nprm,nt,n;\nreal(kind=8),in\
tent(inout):: x(np),px(np),y(np),py(np),z(np),dp(np),&\n                             sy(np),sarg(np),flag(np),prm(nprm);\n\nwhere \
np is the number of particles, and prm is a list of reals of any length. The spin coordinates sy and sarg are meaningless without \
the flag POL. The src must ends with \"return;end\" to complete the subroutine, and more routines can be inserted if needed. Curre\
ntly gfortran in free format is available for the compiler, and gcc will be supported in future.\n\nExample:\n\nsrc = \"flag = fla\
g * merge(1.d0, 0.d0, x&ltprm(1) .or. x&gtprm(2) .or. (y&gtprm(3) .and. y&ltprm(4)));return;end\";\nprm = {-0.001, 0.001, -3e-4, 3\
e-4};\nExternalMap[\"TRACK\", LINE[\"POSITION\",\"M1.2\"], nt_, x_]:=CompiledMap[nt, x, src, prm];\n\nworks as a special colimatio\
n at a MAP element M1.2, resulting:\n\n<Collimate.png\n\n(Actually the example above can be performed also by SADScript:\n\nExtern\
alMap[\"TRACK\", LINE[\"POSITION\",\"M1.2\"], nt_, x_]:=Append[Drop[x, -1],\n       x[[1]] < prm[[1]] || x[[1]] > prm[[2]] || (prm\
[[3]] < x[[3]] < prm[[4]])];\n\nwhich runs even FASTER than the compiled one!!)\n\nOptions      Defaul     Description\n----------\
---------------------------------------------------\nSingle       False      If True, the map is called once for the entrire parti\
cles even for NPARA > 1.\nCompletion   Null       A completion SADScript to be called after the map with the arg {x, prm}."[p$2301,
         p1$2301]]=
       equ$2301;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2301},out$2301=lx$2301@Typeset["Usage:\n\nExternapMa[\"TRACK\", n, nt_, x_]:=CompiledMap[nt, x, src, prm, opt___];\n\nwhe\
re n is the location number, nt the number of turns, x the particle coordinates with the alive flag, as described for ExternalMap.\
 It takes options of Rules as shown below. A charachter string src is the source code for the map, which completes a subroutine ha\
ving a header:\n\nimplicit none;\ninteger,intent(in):: np,nprm,nt,n;\nreal(kind=8),intent(inout):: x(np),px(np),y(np),py(np),z(np)\
,dp(np),&\n                             sy(np),sarg(np),flag(np),prm(nprm);\n\nwhere np is the number of particles, and prm is a l\
ist of reals of any length. The spin coordinates sy and sarg are meaningless without the flag POL. The src must ends with \"return\
;end\" to complete the subroutine, and more routines can be inserted if needed. Currently gfortran in free format is available for\
 the compiler, and gcc will be supported in future.\n\nExample:\n\nsrc = \"flag = flag * merge(1.d0, 0.d0, x&ltprm(1) .or. x&gtprm\
(2) .or. (y&gtprm(3) .and. y&ltprm(4)));return;end\";\nprm = {-0.001, 0.001, -3e-4, 3e-4};\nExternalMap[\"TRACK\", LINE[\"POSITION\
\",\"M1.2\"], nt_, x_]:=CompiledMap[nt, x, src, prm];\n\nworks as a special colimation at a MAP element M1.2, resulting:\n\n<Colli\
mate.png\n\n(Actually the example above can be performed also by SADScript:\n\nExternalMap[\"TRACK\", LINE[\"POSITION\",\"M1.2\"],\
 nt_, x_]:=Append[Drop[x, -1],\n       x[[1]] < prm[[1]] || x[[1]] > prm[[2]] || (prm[[3]] < x[[3]] < prm[[4]])];\n\nwhich runs ev\
en FASTER than the compiled one!!)\n\nOptions      Defaul     Description\n-------------------------------------------------------\
------\nSingle       False      If True, the map is called once for the entrire particles even for NPARA > 1.\nCompletion   Null  \
     A completion SADScript to be called after the map with the arg {x, prm}."[p$2301,p1$2301],Format->Help2HTML`oB$];
        System["mv -f "//out$2301//" "//equ$2301]];
      Exit[]]];
   "Usage:\n\nExternapMa[\"TRACK\", n, nt_, x_]:=CompiledMap[nt, x, src, prm, opt___];\n\nwhere n is the location number, nt the n\
umber of turns, x the particle coordinates with the alive flag, as described for ExternalMap. It takes options of Rules as shown b\
elow. A charachter string src is the source code for the map, which completes a subroutine having a header:\n\nimplicit none;\nint\
eger,intent(in):: np,nprm,nt,n;\nreal(kind=8),intent(inout):: x(np),px(np),y(np),py(np),z(np),dp(np),&\n                          \
   sy(np),sarg(np),flag(np),prm(nprm);\n\nwhere np is the number of particles, and prm is a list of reals of any length. The spin \
coordinates sy and sarg are meaningless without the flag POL. The src must ends with \"return;end\" to complete the subroutine, an\
d more routines can be inserted if needed. Currently gfortran in free format is available for the compiler, and gcc will be suppor\
ted in future.\n\nExample:\n\nsrc = \"flag = flag * merge(1.d0, 0.d0, x&ltprm(1) .or. x&gtprm(2) .or. (y&gtprm(3) .and. y&ltprm(4)\
));return;end\";\nprm = {-0.001, 0.001, -3e-4, 3e-4};\nExternalMap[\"TRACK\", LINE[\"POSITION\",\"M1.2\"], nt_, x_]:=CompiledMap[n\
t, x, src, prm];\n\nworks as a special colimation at a MAP element M1.2, resulting:\n\n<Collimate.png\n\n(Actually the example abo\
ve can be performed also by SADScript:\n\nExternalMap[\"TRACK\", LINE[\"POSITION\",\"M1.2\"], nt_, x_]:=Append[Drop[x, -1],\n     \
  x[[1]] < prm[[1]] || x[[1]] > prm[[2]] || (prm[[3]] < x[[3]] < prm[[4]])];\n\nwhich runs even FASTER than the compiled one!!)\n\\
nOptions      Defaul     Description\n-------------------------------------------------------------\nSingle       False      If Tr\
ue, the map is called once for the entrire particles even for NPARA > 1.\nCompletion   Null       A completion SADScript to be cal\
led after the map with the arg {x, prm}."[1,Max[p0$2301,0]]//"<img  class=\"eqs\" SRC=\""//equ$2301//"\" />"//
Help2HTML`oy$["Usage:\n\nExternapMa[\"TRACK\", n, nt_, x_]:=CompiledMap[nt, x, src, prm, opt___];\n\nwhere n is the location numbe\
r, nt the number of turns, x the particle coordinates with the alive flag, as described for ExternalMap. It takes options of Rules\
 as shown below. A charachter string src is the source code for the map, which completes a subroutine having a header:\n\nimplicit\
 none;\ninteger,intent(in):: np,nprm,nt,n;\nreal(kind=8),intent(inout):: x(np),px(np),y(np),py(np),z(np),dp(np),&\n               \
              sy(np),sarg(np),flag(np),prm(nprm);\n\nwhere np is the number of particles, and prm is a list of reals of any length\
. The spin coordinates sy and sarg are meaningless without the flag POL. The src must ends with \"return;end\" to complete the sub\
routine, and more routines can be inserted if needed. Currently gfortran in free format is available for the compiler, and gcc wil\
l be supported in future.\n\nExample:\n\nsrc = \"flag = flag * merge(1.d0, 0.d0, x&ltprm(1) .or. x&gtprm(2) .or. (y&gtprm(3) .and.\
 y&ltprm(4)));return;end\";\nprm = {-0.001, 0.001, -3e-4, 3e-4};\nExternalMap[\"TRACK\", LINE[\"POSITION\",\"M1.2\"], nt_, x_]:=Co\
mpiledMap[nt, x, src, prm];\n\nworks as a special colimation at a MAP element M1.2, resulting:\n\n<Collimate.png\n\n(Actually the \
example above can be performed also by SADScript:\n\nExternalMap[\"TRACK\", LINE[\"POSITION\",\"M1.2\"], nt_, x_]:=Append[Drop[x, \
-1],\n       x[[1]] < prm[[1]] || x[[1]] > prm[[2]] || (prm[[3]] < x[[3]] < prm[[4]])];\n\nwhich runs even FASTER than the compile\
d one!!)\n\nOptions      Defaul     Description\n-------------------------------------------------------------\nSingle       False\
      If True, the map is called once for the entrire particles even for NPARA > 1.\nCompletion   Null       A completion SADScrip\
t to be called after the map with the arg {x, prm}."[p2$2301,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L390>ExternalMap</A> MAP <A HREF=#L333>POL</A></PRE>
</UL>
<LI>
<H3><A NAME=L392>
FFS</A></H3>
<PRE>If[{},
Help2HTML`oA$["FFS[command-string] executes command-string as FFS commands. Any commands can be used. Some commands CALCULATE(CAL)\
, GO, VARIABLES(VAR), SHOW returns their result, otherwise Null is returned. All outputs of the commands are suppressed.\n   FFS[c\
ommand-string,lo] directs the output of the commands to file-number lo. The file-number lo may be given by OpenWrite or OpenAppend\
.\n   The IF structure and REPEAT(REP) loop must complete within a single FFS."],
p$2304=1+p$2304[[1,2]];p1$2304=StringPosition["FFS[command-string] executes command-string as FFS commands. Any commands can be us\
ed. Some commands CALCULATE(CAL), GO, VARIABLES(VAR), SHOW returns their result, otherwise Null is returned. All outputs of the co\
mmands are suppressed.\n   FFS[command-string,lo] directs the output of the commands to file-number lo. The file-number lo may be \
given by OpenWrite or OpenAppend.\n   The IF structure and REPEAT(REP) loop must complete within a single FFS."[p$2304,-1],">::",
    1];
   p1$2304=If[p1$2304==={},451,-2+p$2304+p1$2304[[1,1]]];
neq=Which["FFS[command-string] executes command-string as FFS commands. Any commands can be used. Some commands CALCULATE(CAL), GO\
, VARIABLES(VAR), SHOW returns their result, otherwise Null is returned. All outputs of the commands are suppressed.\n   FFS[comma\
nd-string,lo] directs the output of the commands to file-number lo. The file-number lo may be given by OpenWrite or OpenAppend.\n \
  The IF structure and REPEAT(REP) loop must complete within a single FFS."[p$2304,4+p$2304]==="Text[",
    lx$2304:=Help2HTML`oa$;p$2304=5+p$2304;p1$2304-=1;p2$2304=5+p1$2304;p0$2304=-9+p$2304;
If[(pe$2304=StringPosition["FFS[command-string] executes command-string as FFS commands. Any commands can be used. Some commands C\
ALCULATE(CAL), GO, VARIABLES(VAR), SHOW returns their result, otherwise Null is returned. All outputs of the commands are suppress\
ed.\n   FFS[command-string,lo] directs the output of the commands to file-number lo. The file-number lo may be given by OpenWrite \
or OpenAppend.\n   The IF structure and REPEAT(REP) loop must complete within a single FFS."[p$2304,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["FFS[command-string] executes command-string as FFS commands. Any commands can be used. Some commands CALCULATE(CA\
L), GO, VARIABLES(VAR), SHOW returns their result, otherwise Null is returned. All outputs of the commands are suppressed.\n   FFS\
[command-string,lo] directs the output of the commands to file-number lo. The file-number lo may be given by OpenWrite or OpenAppe\
nd.\n   The IF structure and REPEAT(REP) loop must complete within a single FFS."[p$2304+pe$2304[[1,2]],p1$2304]]],
        p1$2304=-2+p$2304+pe$2304[[1,1]]}[[
       1]],
      0],
    1,lx$2304:=Help2HTML`o9$;p2$2304=4+p1$2304;p0$2304=-4+p$2304;0];
  If[(equ$2304=
Help2HTML`o8$["FFS[command-string] executes command-string as FFS commands. Any commands can be used. Some commands CALCULATE(CAL)\
, GO, VARIABLES(VAR), SHOW returns their result, otherwise Null is returned. All outputs of the commands are suppressed.\n   FFS[c\
ommand-string,lo] directs the output of the commands to file-number lo. The file-number lo may be given by OpenWrite or OpenAppend\
.\n   The IF structure and REPEAT(REP) loop must complete within a single FFS."[p$2304,p1$2304]])===
    Undefined,
equ$2304="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["FFS[command-string] executes command-string \
as FFS commands. Any commands can be used. Some commands CALCULATE(CAL), GO, VARIABLES(VAR), SHOW returns their result, otherwise \
Null is returned. All outputs of the commands are suppressed.\n   FFS[command-string,lo] directs the output of the commands to fil\
e-number lo. The file-number lo may be given by OpenWrite or OpenAppend.\n   The IF structure and REPEAT(REP) loop must complete w\
ithin a single FFS."[p$2304,p1$2304]]=
       equ$2304;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2304},out$2304=lx$2304@Typeset["FFS[command-string] executes command-string as FFS commands. Any commands can be used. So\
me commands CALCULATE(CAL), GO, VARIABLES(VAR), SHOW returns their result, otherwise Null is returned. All outputs of the commands\
 are suppressed.\n   FFS[command-string,lo] directs the output of the commands to file-number lo. The file-number lo may be given \
by OpenWrite or OpenAppend.\n   The IF structure and REPEAT(REP) loop must complete within a single FFS."[p$2304,p1$2304],
          Format->Help2HTML`oB$];
        System["mv -f "//out$2304//" "//equ$2304]];
      Exit[]]];
   "FFS[command-string] executes command-string as FFS commands. Any commands can be used. Some commands CALCULATE(CAL), GO, VARIA\
BLES(VAR), SHOW returns their result, otherwise Null is returned. All outputs of the commands are suppressed.\n   FFS[command-stri\
ng,lo] directs the output of the commands to file-number lo. The file-number lo may be given by OpenWrite or OpenAppend.\n   The I\
F structure and REPEAT(REP) loop must complete within a single FFS."[1,Max[p0$2304,0]]//"<img  class=\"eqs\" SRC=\""//equ$2304//
   "\" />"//
Help2HTML`oy$["FFS[command-string] executes command-string as FFS commands. Any commands can be used. Some commands CALCULATE(CAL)\
, GO, VARIABLES(VAR), SHOW returns their result, otherwise Null is returned. All outputs of the commands are suppressed.\n   FFS[c\
ommand-string,lo] directs the output of the commands to file-number lo. The file-number lo may be given by OpenWrite or OpenAppend\
.\n   The IF structure and REPEAT(REP) loop must complete within a single FFS."[p2$2304,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L425>Input/Output</A> <A HREF=#L432>OpenWrite</A> <A HREF=#L430>OpenAppend</A></PRE>
<LI>
<H3><A NAME=L393>
FFS$SHOW</A></H3>
<PRE>If[{},
Help2HTML`oA$["   FFS[\"SHOW\"] or FFS$SHOW[] returns the current matching conditions as a list. Each element has a form of\n\n{co\
mponent1, component2, function, goal-value, number-of-momentums, scale},\n\nwhich corresponds to the format of the print-out by SH\
OW."],
p$2307=1+p$2307[[1,2]];p1$2307=StringPosition["   FFS[\"SHOW\"] or FFS$SHOW[] returns the current matching conditions as a list. E\
ach element has a form of\n\n{component1, component2, function, goal-value, number-of-momentums, scale},\n\nwhich corresponds to t\
he format of the print-out by SHOW."[p$2307,-1],">::",1];
   p1$2307=If[p1$2307==={},242,-2+p$2307+p1$2307[[1,1]]];
neq=Which["   FFS[\"SHOW\"] or FFS$SHOW[] returns the current matching conditions as a list. Each element has a form of\n\n{compon\
ent1, component2, function, goal-value, number-of-momentums, scale},\n\nwhich corresponds to the format of the print-out by SHOW."[
      p$2307,4+p$2307]===
     "Text[",
lx$2307:=Help2HTML`oa$;p$2307=5+p$2307;p1$2307-=1;p2$2307=5+p1$2307;p0$2307=-9+p$2307;If[(pe$2307=StringPosition["   FFS[\"SHOW\"]\
 or FFS$SHOW[] returns the current matching conditions as a list. Each element has a form of\n\n{component1, component2, function,\
 goal-value, number-of-momentums, scale},\n\nwhich corresponds to the format of the print-out by SHOW."[p$2307,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["   FFS[\"SHOW\"] or FFS$SHOW[] returns the current matching conditions as a list. Each element has a form of\n\n{\
component1, component2, function, goal-value, number-of-momentums, scale},\n\nwhich corresponds to the format of the print-out by \
SHOW."[p$2307+pe$2307[[1,2]],p1$2307]]],
        p1$2307=-2+p$2307+pe$2307[[1,1]]}[[
       1]],
      0],
    1,lx$2307:=Help2HTML`o9$;p2$2307=4+p1$2307;p0$2307=-4+p$2307;0];
  If[(equ$2307=
Help2HTML`o8$["   FFS[\"SHOW\"] or FFS$SHOW[] returns the current matching conditions as a list. Each element has a form of\n\n{co\
mponent1, component2, function, goal-value, number-of-momentums, scale},\n\nwhich corresponds to the format of the print-out by SH\
OW."[p$2307,p1$2307]])===
    Undefined,
equ$2307="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["   FFS[\"SHOW\"] or FFS$SHOW[] returns the c\
urrent matching conditions as a list. Each element has a form of\n\n{component1, component2, function, goal-value, number-of-momen\
tums, scale},\n\nwhich corresponds to the format of the print-out by SHOW."[p$2307,p1$2307]]=
       equ$2307;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2307},out$2307=lx$2307@Typeset["   FFS[\"SHOW\"] or FFS$SHOW[] returns the current matching conditions as a list. Each el\
ement has a form of\n\n{component1, component2, function, goal-value, number-of-momentums, scale},\n\nwhich corresponds to the for\
mat of the print-out by SHOW."[p$2307,p1$2307],Format->Help2HTML`oB$];
        System["mv -f "//out$2307//" "//equ$2307]];
      Exit[]]];
   "   FFS[\"SHOW\"] or FFS$SHOW[] returns the current matching conditions as a list. Each element has a form of\n\n{component1, c\
omponent2, function, goal-value, number-of-momentums, scale},\n\nwhich corresponds to the format of the print-out by SHOW."[1,
    Max[p0$2307,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2307//"\" />"//
Help2HTML`oy$["   FFS[\"SHOW\"] or FFS$SHOW[] returns the current matching conditions as a list. Each element has a form of\n\n{co\
mponent1, component2, function, goal-value, number-of-momentums, scale},\n\nwhich corresponds to the format of the print-out by SH\
OW."[p2$2307,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L550>SHOW</A></PRE>
<LI>
<H3><A NAME=L394>
FitValue</A></H3>
<PRE>If[{},
Help2HTML`oA$["Usage:\n\n(1) FitValue[component, function, {id_,dp_}, goal_, now_] := body\n\nmodifies the goal of the matching of\
 function at component. The argument id_ is the orbit id for MatchingAmplitude or InitialOrbits. The argument dp_ receives the val\
ue of dp/p0. The argument goal_ is the value of the goal of the matching set by matching-function-commands. The argument now_ is t\
he current value of function.\n\nExample: FitValue[\"$$$\", \"NX\", {_,dp_}, goal_, now_] := goal + dp * xix * 2 * Pi\n\nsets the \
tune NX to have chromaticity xix.\n\n(2) FitValue[component1, component2, function, {id_,dp_}, goal_, now1_, now2_] := body\n\nmod\
ifies the value of the function at component1 for a two-component matching. Component1 is assumed upstream in the beam line. The v\
alue of body is used in place of the current value, now1. The argument id_ is the orbit id for MatchingAmplitude or InitialOrbits.\
 The argument dp_ receives the value of dp/p0. The argument goal_ is the value of the goal of the matching set by matching-functio\
n-commands. The argument now1 and now2 are the current values of the function at component1 and component2, respectively.\n\nExamp\
le: FitValue[\"QF1\", \"QF2\", \"NX\", _, goal_, now1_, now2_] := \n   If[Abs[now2-(now1+goal)] < 0.01*2*Pi , Null, now1]\n\nsets \
the tune difference between QF1 and QF2 gaol +- 0.01.\n\n   During the matching process the matching routine calls FitValue with a\
rguments, then if body returns a number, it overrides the goal give by matching-function-commands. If body returns Null, the match\
ing of function is ignored.\n   The matching-function-command is necessary besides FitValue to perform the matching. Only defining\
 FitValue does not do the matching.\n   FitValue is cleared by USE. It is hidden by VISIT and restored by BYE"],
 p$2310=1+p$2310[[1,2]];
p1$2310=StringPosition["Usage:\n\n(1) FitValue[component, function, {id_,dp_}, goal_, now_] := body\n\nmodifies the goal of the ma\
tching of function at component. The argument id_ is the orbit id for MatchingAmplitude or InitialOrbits. The argument dp_ receive\
s the value of dp/p0. The argument goal_ is the value of the goal of the matching set by matching-function-commands. The argument \
now_ is the current value of function.\n\nExample: FitValue[\"$$$\", \"NX\", {_,dp_}, goal_, now_] := goal + dp * xix * 2 * Pi\n\n\
sets the tune NX to have chromaticity xix.\n\n(2) FitValue[component1, component2, function, {id_,dp_}, goal_, now1_, now2_] := bo\
dy\n\nmodifies the value of the function at component1 for a two-component matching. Component1 is assumed upstream in the beam li\
ne. The value of body is used in place of the current value, now1. The argument id_ is the orbit id for MatchingAmplitude or Initi\
alOrbits. The argument dp_ receives the value of dp/p0. The argument goal_ is the value of the goal of the matching set by matchin\
g-function-commands. The argument now1 and now2 are the current values of the function at component1 and component2, respectively.\
\n\nExample: FitValue[\"QF1\", \"QF2\", \"NX\", _, goal_, now1_, now2_] := \n   If[Abs[now2-(now1+goal)] < 0.01*2*Pi , Null, now1]\
\n\nsets the tune difference between QF1 and QF2 gaol +- 0.01.\n\n   During the matching process the matching routine calls FitVal\
ue with arguments, then if body returns a number, it overrides the goal give by matching-function-commands. If body returns Null, \
the matching of function is ignored.\n   The matching-function-command is necessary besides FitValue to perform the matching. Only\
 defining FitValue does not do the matching.\n   FitValue is cleared by USE. It is hidden by VISIT and restored by BYE"[p$2310,-1],
    ">::",1];
   p1$2310=If[p1$2310==={},1753,-2+p$2310+p1$2310[[1,1]]];
neq=Which["Usage:\n\n(1) FitValue[component, function, {id_,dp_}, goal_, now_] := body\n\nmodifies the goal of the matching of fun\
ction at component. The argument id_ is the orbit id for MatchingAmplitude or InitialOrbits. The argument dp_ receives the value o\
f dp/p0. The argument goal_ is the value of the goal of the matching set by matching-function-commands. The argument now_ is the c\
urrent value of function.\n\nExample: FitValue[\"$$$\", \"NX\", {_,dp_}, goal_, now_] := goal + dp * xix * 2 * Pi\n\nsets the tune\
 NX to have chromaticity xix.\n\n(2) FitValue[component1, component2, function, {id_,dp_}, goal_, now1_, now2_] := body\n\nmodifie\
s the value of the function at component1 for a two-component matching. Component1 is assumed upstream in the beam line. The value\
 of body is used in place of the current value, now1. The argument id_ is the orbit id for MatchingAmplitude or InitialOrbits. The\
 argument dp_ receives the value of dp/p0. The argument goal_ is the value of the goal of the matching set by matching-function-co\
mmands. The argument now1 and now2 are the current values of the function at component1 and component2, respectively.\n\nExample: \
FitValue[\"QF1\", \"QF2\", \"NX\", _, goal_, now1_, now2_] := \n   If[Abs[now2-(now1+goal)] < 0.01*2*Pi , Null, now1]\n\nsets the \
tune difference between QF1 and QF2 gaol +- 0.01.\n\n   During the matching process the matching routine calls FitValue with argum\
ents, then if body returns a number, it overrides the goal give by matching-function-commands. If body returns Null, the matching \
of function is ignored.\n   The matching-function-command is necessary besides FitValue to perform the matching. Only defining Fit\
Value does not do the matching.\n   FitValue is cleared by USE. It is hidden by VISIT and restored by BYE"[p$2310,4+p$2310]===
     "Text[",
lx$2310:=Help2HTML`oa$;p$2310=5+p$2310;p1$2310-=1;p2$2310=5+p1$2310;p0$2310=-9+p$2310;If[(pe$2310=StringPosition["Usage:\n\n(1) Fi\
tValue[component, function, {id_,dp_}, goal_, now_] := body\n\nmodifies the goal of the matching of function at component. The arg\
ument id_ is the orbit id for MatchingAmplitude or InitialOrbits. The argument dp_ receives the value of dp/p0. The argument goal_\
 is the value of the goal of the matching set by matching-function-commands. The argument now_ is the current value of function.\n\
\nExample: FitValue[\"$$$\", \"NX\", {_,dp_}, goal_, now_] := goal + dp * xix * 2 * Pi\n\nsets the tune NX to have chromaticity xi\
x.\n\n(2) FitValue[component1, component2, function, {id_,dp_}, goal_, now1_, now2_] := body\n\nmodifies the value of the function\
 at component1 for a two-component matching. Component1 is assumed upstream in the beam line. The value of body is used in place o\
f the current value, now1. The argument id_ is the orbit id for MatchingAmplitude or InitialOrbits. The argument dp_ receives the \
value of dp/p0. The argument goal_ is the value of the goal of the matching set by matching-function-commands. The argument now1 a\
nd now2 are the current values of the function at component1 and component2, respectively.\n\nExample: FitValue[\"QF1\", \"QF2\", \
\"NX\", _, goal_, now1_, now2_] := \n   If[Abs[now2-(now1+goal)] < 0.01*2*Pi , Null, now1]\n\nsets the tune difference between QF1\
 and QF2 gaol +- 0.01.\n\n   During the matching process the matching routine calls FitValue with arguments, then if body returns \
a number, it overrides the goal give by matching-function-commands. If body returns Null, the matching of function is ignored.\n  \
 The matching-function-command is necessary besides FitValue to perform the matching. Only defining FitValue does not do the match\
ing.\n   FitValue is cleared by USE. It is hidden by VISIT and restored by BYE"[p$2310,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Usage:\n\n(1) FitValue[component, function, {id_,dp_}, goal_, now_] := body\n\nmodifies the goal of the matching \
of function at component. The argument id_ is the orbit id for MatchingAmplitude or InitialOrbits. The argument dp_ receives the v\
alue of dp/p0. The argument goal_ is the value of the goal of the matching set by matching-function-commands. The argument now_ is\
 the current value of function.\n\nExample: FitValue[\"$$$\", \"NX\", {_,dp_}, goal_, now_] := goal + dp * xix * 2 * Pi\n\nsets th\
e tune NX to have chromaticity xix.\n\n(2) FitValue[component1, component2, function, {id_,dp_}, goal_, now1_, now2_] := body\n\nm\
odifies the value of the function at component1 for a two-component matching. Component1 is assumed upstream in the beam line. The\
 value of body is used in place of the current value, now1. The argument id_ is the orbit id for MatchingAmplitude or InitialOrbit\
s. The argument dp_ receives the value of dp/p0. The argument goal_ is the value of the goal of the matching set by matching-funct\
ion-commands. The argument now1 and now2 are the current values of the function at component1 and component2, respectively.\n\nExa\
mple: FitValue[\"QF1\", \"QF2\", \"NX\", _, goal_, now1_, now2_] := \n   If[Abs[now2-(now1+goal)] < 0.01*2*Pi , Null, now1]\n\nset\
s the tune difference between QF1 and QF2 gaol +- 0.01.\n\n   During the matching process the matching routine calls FitValue with\
 arguments, then if body returns a number, it overrides the goal give by matching-function-commands. If body returns Null, the mat\
ching of function is ignored.\n   The matching-function-command is necessary besides FitValue to perform the matching. Only defini\
ng FitValue does not do the matching.\n   FitValue is cleared by USE. It is hidden by VISIT and restored by BYE"[p$2310+
            pe$2310[[1,2]],
           p1$2310]]],
        p1$2310=-2+p$2310+pe$2310[[1,1]]}[[
       1]],
      0],
    1,lx$2310:=Help2HTML`o9$;p2$2310=4+p1$2310;p0$2310=-4+p$2310;0];
  If[(equ$2310=
Help2HTML`o8$["Usage:\n\n(1) FitValue[component, function, {id_,dp_}, goal_, now_] := body\n\nmodifies the goal of the matching of\
 function at component. The argument id_ is the orbit id for MatchingAmplitude or InitialOrbits. The argument dp_ receives the val\
ue of dp/p0. The argument goal_ is the value of the goal of the matching set by matching-function-commands. The argument now_ is t\
he current value of function.\n\nExample: FitValue[\"$$$\", \"NX\", {_,dp_}, goal_, now_] := goal + dp * xix * 2 * Pi\n\nsets the \
tune NX to have chromaticity xix.\n\n(2) FitValue[component1, component2, function, {id_,dp_}, goal_, now1_, now2_] := body\n\nmod\
ifies the value of the function at component1 for a two-component matching. Component1 is assumed upstream in the beam line. The v\
alue of body is used in place of the current value, now1. The argument id_ is the orbit id for MatchingAmplitude or InitialOrbits.\
 The argument dp_ receives the value of dp/p0. The argument goal_ is the value of the goal of the matching set by matching-functio\
n-commands. The argument now1 and now2 are the current values of the function at component1 and component2, respectively.\n\nExamp\
le: FitValue[\"QF1\", \"QF2\", \"NX\", _, goal_, now1_, now2_] := \n   If[Abs[now2-(now1+goal)] < 0.01*2*Pi , Null, now1]\n\nsets \
the tune difference between QF1 and QF2 gaol +- 0.01.\n\n   During the matching process the matching routine calls FitValue with a\
rguments, then if body returns a number, it overrides the goal give by matching-function-commands. If body returns Null, the match\
ing of function is ignored.\n   The matching-function-command is necessary besides FitValue to perform the matching. Only defining\
 FitValue does not do the matching.\n   FitValue is cleared by USE. It is hidden by VISIT and restored by BYE"[p$2310,p1$2310]])===
    Undefined,
equ$2310="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Usage:\n\n(1) FitValue[component, function, \
{id_,dp_}, goal_, now_] := body\n\nmodifies the goal of the matching of function at component. The argument id_ is the orbit id fo\
r MatchingAmplitude or InitialOrbits. The argument dp_ receives the value of dp/p0. The argument goal_ is the value of the goal of\
 the matching set by matching-function-commands. The argument now_ is the current value of function.\n\nExample: FitValue[\"$$$\",\
 \"NX\", {_,dp_}, goal_, now_] := goal + dp * xix * 2 * Pi\n\nsets the tune NX to have chromaticity xix.\n\n(2) FitValue[component\
1, component2, function, {id_,dp_}, goal_, now1_, now2_] := body\n\nmodifies the value of the function at component1 for a two-com\
ponent matching. Component1 is assumed upstream in the beam line. The value of body is used in place of the current value, now1. T\
he argument id_ is the orbit id for MatchingAmplitude or InitialOrbits. The argument dp_ receives the value of dp/p0. The argument\
 goal_ is the value of the goal of the matching set by matching-function-commands. The argument now1 and now2 are the current valu\
es of the function at component1 and component2, respectively.\n\nExample: FitValue[\"QF1\", \"QF2\", \"NX\", _, goal_, now1_, now\
2_] := \n   If[Abs[now2-(now1+goal)] < 0.01*2*Pi , Null, now1]\n\nsets the tune difference between QF1 and QF2 gaol +- 0.01.\n\n  \
 During the matching process the matching routine calls FitValue with arguments, then if body returns a number, it overrides the g\
oal give by matching-function-commands. If body returns Null, the matching of function is ignored.\n   The matching-function-comma\
nd is necessary besides FitValue to perform the matching. Only defining FitValue does not do the matching.\n   FitValue is cleared\
 by USE. It is hidden by VISIT and restored by BYE"[p$2310,p1$2310]]=
       equ$2310;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2310},out$2310=lx$2310@Typeset["Usage:\n\n(1) FitValue[component, function, {id_,dp_}, goal_, now_] := body\n\nmodifies t\
he goal of the matching of function at component. The argument id_ is the orbit id for MatchingAmplitude or InitialOrbits. The arg\
ument dp_ receives the value of dp/p0. The argument goal_ is the value of the goal of the matching set by matching-function-comman\
ds. The argument now_ is the current value of function.\n\nExample: FitValue[\"$$$\", \"NX\", {_,dp_}, goal_, now_] := goal + dp *\
 xix * 2 * Pi\n\nsets the tune NX to have chromaticity xix.\n\n(2) FitValue[component1, component2, function, {id_,dp_}, goal_, no\
w1_, now2_] := body\n\nmodifies the value of the function at component1 for a two-component matching. Component1 is assumed upstre\
am in the beam line. The value of body is used in place of the current value, now1. The argument id_ is the orbit id for MatchingA\
mplitude or InitialOrbits. The argument dp_ receives the value of dp/p0. The argument goal_ is the value of the goal of the matchi\
ng set by matching-function-commands. The argument now1 and now2 are the current values of the function at component1 and componen\
t2, respectively.\n\nExample: FitValue[\"QF1\", \"QF2\", \"NX\", _, goal_, now1_, now2_] := \n   If[Abs[now2-(now1+goal)] < 0.01*2\
*Pi , Null, now1]\n\nsets the tune difference between QF1 and QF2 gaol +- 0.01.\n\n   During the matching process the matching rou\
tine calls FitValue with arguments, then if body returns a number, it overrides the goal give by matching-function-commands. If bo\
dy returns Null, the matching of function is ignored.\n   The matching-function-command is necessary besides FitValue to perform t\
he matching. Only defining FitValue does not do the matching.\n   FitValue is cleared by USE. It is hidden by VISIT and restored b\
y BYE"[p$2310,p1$2310],Format->Help2HTML`oB$];
        System["mv -f "//out$2310//" "//equ$2310]];
      Exit[]]];
   "Usage:\n\n(1) FitValue[component, function, {id_,dp_}, goal_, now_] := body\n\nmodifies the goal of the matching of function a\
t component. The argument id_ is the orbit id for MatchingAmplitude or InitialOrbits. The argument dp_ receives the value of dp/p0\
. The argument goal_ is the value of the goal of the matching set by matching-function-commands. The argument now_ is the current \
value of function.\n\nExample: FitValue[\"$$$\", \"NX\", {_,dp_}, goal_, now_] := goal + dp * xix * 2 * Pi\n\nsets the tune NX to \
have chromaticity xix.\n\n(2) FitValue[component1, component2, function, {id_,dp_}, goal_, now1_, now2_] := body\n\nmodifies the v\
alue of the function at component1 for a two-component matching. Component1 is assumed upstream in the beam line. The value of bod\
y is used in place of the current value, now1. The argument id_ is the orbit id for MatchingAmplitude or InitialOrbits. The argume\
nt dp_ receives the value of dp/p0. The argument goal_ is the value of the goal of the matching set by matching-function-commands.\
 The argument now1 and now2 are the current values of the function at component1 and component2, respectively.\n\nExample: FitValu\
e[\"QF1\", \"QF2\", \"NX\", _, goal_, now1_, now2_] := \n   If[Abs[now2-(now1+goal)] < 0.01*2*Pi , Null, now1]\n\nsets the tune di\
fference between QF1 and QF2 gaol +- 0.01.\n\n   During the matching process the matching routine calls FitValue with arguments, t\
hen if body returns a number, it overrides the goal give by matching-function-commands. If body returns Null, the matching of func\
tion is ignored.\n   The matching-function-command is necessary besides FitValue to perform the matching. Only defining FitValue d\
oes not do the matching.\n   FitValue is cleared by USE. It is hidden by VISIT and restored by BYE"[1,Max[p0$2310,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2310//"\" />"//
Help2HTML`oy$["Usage:\n\n(1) FitValue[component, function, {id_,dp_}, goal_, now_] := body\n\nmodifies the goal of the matching of\
 function at component. The argument id_ is the orbit id for MatchingAmplitude or InitialOrbits. The argument dp_ receives the val\
ue of dp/p0. The argument goal_ is the value of the goal of the matching set by matching-function-commands. The argument now_ is t\
he current value of function.\n\nExample: FitValue[\"$$$\", \"NX\", {_,dp_}, goal_, now_] := goal + dp * xix * 2 * Pi\n\nsets the \
tune NX to have chromaticity xix.\n\n(2) FitValue[component1, component2, function, {id_,dp_}, goal_, now1_, now2_] := body\n\nmod\
ifies the value of the function at component1 for a two-component matching. Component1 is assumed upstream in the beam line. The v\
alue of body is used in place of the current value, now1. The argument id_ is the orbit id for MatchingAmplitude or InitialOrbits.\
 The argument dp_ receives the value of dp/p0. The argument goal_ is the value of the goal of the matching set by matching-functio\
n-commands. The argument now1 and now2 are the current values of the function at component1 and component2, respectively.\n\nExamp\
le: FitValue[\"QF1\", \"QF2\", \"NX\", _, goal_, now1_, now2_] := \n   If[Abs[now2-(now1+goal)] < 0.01*2*Pi , Null, now1]\n\nsets \
the tune difference between QF1 and QF2 gaol +- 0.01.\n\n   During the matching process the matching routine calls FitValue with a\
rguments, then if body returns a number, it overrides the goal give by matching-function-commands. If body returns Null, the match\
ing of function is ignored.\n   The matching-function-command is necessary besides FitValue to perform the matching. Only defining\
 FitValue does not do the matching.\n   FitValue is cleared by USE. It is hidden by VISIT and restored by BYE"[p2$2310,-1]]
 ]
</PRE>
<PRE>See also:
 <A HREF=#L473>matching-function-commands</A> <A HREF=#L477>off-momentum-matching</A></PRE>
<LI>
<H3><A NAME=L395>
FitWeight</A></H3>
<PRE>If[{},
Help2HTML`oA$[" A defined function to modify the weight of matching of particular function at particular component with particular\
 momentum offset.\n\nUsage:   FitWeight[component, function, {id_,dp_}, default_] := weight;\n\nwhere\t\n\ncomponent  is the name \
of the location of the fit, like \"QF.2\", etc.\nfunction   is the name of the matching-function, like \"BX\", \"LENG\", etc.\nid_\
        is the id number of the orbit for MatchingAmplitude or InitialOrbits.\ndp_        is a variable to receive the momentum de\
viation of the fit.\ndefault_   is a variable to receive the default fit weight.\nweight     is an expression which returns the de\
sired weight.\t\n\nExample: FitWeight[\"$$$\",\"LENG\",{_,dp_},ws_]:=ws*10;\n\nmakes the weight of LENG at $$$ 10 times (100 times\
 in MatchingResidual) bigger than the default."],
p$2313=1+p$2313[[1,2]];p1$2313=StringPosition[" A defined function to modify the weight of matching of particular function at part\
icular component with particular momentum offset.\n\nUsage:   FitWeight[component, function, {id_,dp_}, default_] := weight;\n\nwh\
ere\t\n\ncomponent  is the name of the location of the fit, like \"QF.2\", etc.\nfunction   is the name of the matching-function, \
like \"BX\", \"LENG\", etc.\nid_        is the id number of the orbit for MatchingAmplitude or InitialOrbits.\ndp_        is a var\
iable to receive the momentum deviation of the fit.\ndefault_   is a variable to receive the default fit weight.\nweight     is an\
 expression which returns the desired weight.\t\n\nExample: FitWeight[\"$$$\",\"LENG\",{_,dp_},ws_]:=ws*10;\n\nmakes the weight of\
 LENG at $$$ 10 times (100 times in MatchingResidual) bigger than the default."[p$2313,-1],">::",1];
   p1$2313=If[p1$2313==={},784,-2+p$2313+p1$2313[[1,1]]];
neq=Which[" A defined function to modify the weight of matching of particular function at particular component with particular mom\
entum offset.\n\nUsage:   FitWeight[component, function, {id_,dp_}, default_] := weight;\n\nwhere\t\n\ncomponent  is the name of t\
he location of the fit, like \"QF.2\", etc.\nfunction   is the name of the matching-function, like \"BX\", \"LENG\", etc.\nid_    \
    is the id number of the orbit for MatchingAmplitude or InitialOrbits.\ndp_        is a variable to receive the momentum deviat\
ion of the fit.\ndefault_   is a variable to receive the default fit weight.\nweight     is an expression which returns the desire\
d weight.\t\n\nExample: FitWeight[\"$$$\",\"LENG\",{_,dp_},ws_]:=ws*10;\n\nmakes the weight of LENG at $$$ 10 times (100 times in \
MatchingResidual) bigger than the default."[p$2313,4+p$2313]==="Text[",
    lx$2313:=Help2HTML`oa$;p$2313=5+p$2313;p1$2313-=1;p2$2313=5+p1$2313;p0$2313=-9+p$2313;
If[(pe$2313=StringPosition[" A defined function to modify the weight of matching of particular function at particular component wi\
th particular momentum offset.\n\nUsage:   FitWeight[component, function, {id_,dp_}, default_] := weight;\n\nwhere\t\n\ncomponent \
 is the name of the location of the fit, like \"QF.2\", etc.\nfunction   is the name of the matching-function, like \"BX\", \"LENG\
\", etc.\nid_        is the id number of the orbit for MatchingAmplitude or InitialOrbits.\ndp_        is a variable to receive th\
e momentum deviation of the fit.\ndefault_   is a variable to receive the default fit weight.\nweight     is an expression which r\
eturns the desired weight.\t\n\nExample: FitWeight[\"$$$\",\"LENG\",{_,dp_},ws_]:=ws*10;\n\nmakes the weight of LENG at $$$ 10 tim\
es (100 times in MatchingResidual) bigger than the default."[p$2313,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression[" A defined function to modify the weight of matching of particular function at particular component with particul\
ar momentum offset.\n\nUsage:   FitWeight[component, function, {id_,dp_}, default_] := weight;\n\nwhere\t\n\ncomponent  is the nam\
e of the location of the fit, like \"QF.2\", etc.\nfunction   is the name of the matching-function, like \"BX\", \"LENG\", etc.\ni\
d_        is the id number of the orbit for MatchingAmplitude or InitialOrbits.\ndp_        is a variable to receive the momentum \
deviation of the fit.\ndefault_   is a variable to receive the default fit weight.\nweight     is an expression which returns the \
desired weight.\t\n\nExample: FitWeight[\"$$$\",\"LENG\",{_,dp_},ws_]:=ws*10;\n\nmakes the weight of LENG at $$$ 10 times (100 tim\
es in MatchingResidual) bigger than the default."[p$2313+pe$2313[[1,2]],p1$2313]]],
        p1$2313=-2+p$2313+pe$2313[[1,1]]}[[
       1]],
      0],
    1,lx$2313:=Help2HTML`o9$;p2$2313=4+p1$2313;p0$2313=-4+p$2313;0];
  If[(equ$2313=
Help2HTML`o8$[" A defined function to modify the weight of matching of particular function at particular component with particular\
 momentum offset.\n\nUsage:   FitWeight[component, function, {id_,dp_}, default_] := weight;\n\nwhere\t\n\ncomponent  is the name \
of the location of the fit, like \"QF.2\", etc.\nfunction   is the name of the matching-function, like \"BX\", \"LENG\", etc.\nid_\
        is the id number of the orbit for MatchingAmplitude or InitialOrbits.\ndp_        is a variable to receive the momentum de\
viation of the fit.\ndefault_   is a variable to receive the default fit weight.\nweight     is an expression which returns the de\
sired weight.\t\n\nExample: FitWeight[\"$$$\",\"LENG\",{_,dp_},ws_]:=ws*10;\n\nmakes the weight of LENG at $$$ 10 times (100 times\
 in MatchingResidual) bigger than the default."[p$2313,p1$2313]])===
    Undefined,
equ$2313="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[" A defined function to modify the weight of \
matching of particular function at particular component with particular momentum offset.\n\nUsage:   FitWeight[component, function\
, {id_,dp_}, default_] := weight;\n\nwhere\t\n\ncomponent  is the name of the location of the fit, like \"QF.2\", etc.\nfunction  \
 is the name of the matching-function, like \"BX\", \"LENG\", etc.\nid_        is the id number of the orbit for MatchingAmplitude\
 or InitialOrbits.\ndp_        is a variable to receive the momentum deviation of the fit.\ndefault_   is a variable to receive th\
e default fit weight.\nweight     is an expression which returns the desired weight.\t\n\nExample: FitWeight[\"$$$\",\"LENG\",{_,d\
p_},ws_]:=ws*10;\n\nmakes the weight of LENG at $$$ 10 times (100 times in MatchingResidual) bigger than the default."[p$2313,
         p1$2313]]=
       equ$2313;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2313},out$2313=lx$2313@Typeset[" A defined function to modify the weight of matching of particular function at particular\
 component with particular momentum offset.\n\nUsage:   FitWeight[component, function, {id_,dp_}, default_] := weight;\n\nwhere\t\\
n\ncomponent  is the name of the location of the fit, like \"QF.2\", etc.\nfunction   is the name of the matching-function, like \\
"BX\", \"LENG\", etc.\nid_        is the id number of the orbit for MatchingAmplitude or InitialOrbits.\ndp_        is a variable \
to receive the momentum deviation of the fit.\ndefault_   is a variable to receive the default fit weight.\nweight     is an expre\
ssion which returns the desired weight.\t\n\nExample: FitWeight[\"$$$\",\"LENG\",{_,dp_},ws_]:=ws*10;\n\nmakes the weight of LENG \
at $$$ 10 times (100 times in MatchingResidual) bigger than the default."[p$2313,p1$2313],Format->Help2HTML`oB$];
        System["mv -f "//out$2313//" "//equ$2313]];
      Exit[]]];
   " A defined function to modify the weight of matching of particular function at particular component with particular momentum o\
ffset.\n\nUsage:   FitWeight[component, function, {id_,dp_}, default_] := weight;\n\nwhere\t\n\ncomponent  is the name of the loca\
tion of the fit, like \"QF.2\", etc.\nfunction   is the name of the matching-function, like \"BX\", \"LENG\", etc.\nid_        is \
the id number of the orbit for MatchingAmplitude or InitialOrbits.\ndp_        is a variable to receive the momentum deviation of \
the fit.\ndefault_   is a variable to receive the default fit weight.\nweight     is an expression which returns the desired weigh\
t.\t\n\nExample: FitWeight[\"$$$\",\"LENG\",{_,dp_},ws_]:=ws*10;\n\nmakes the weight of LENG at $$$ 10 times (100 times in Matchin\
gResidual) bigger than the default."[1,Max[p0$2313,0]]//"<img  class=\"eqs\" SRC=\""//equ$2313//"\" />"//
Help2HTML`oy$[" A defined function to modify the weight of matching of particular function at particular component with particular\
 momentum offset.\n\nUsage:   FitWeight[component, function, {id_,dp_}, default_] := weight;\n\nwhere\t\n\ncomponent  is the name \
of the location of the fit, like \"QF.2\", etc.\nfunction   is the name of the matching-function, like \"BX\", \"LENG\", etc.\nid_\
        is the id number of the orbit for MatchingAmplitude or InitialOrbits.\ndp_        is a variable to receive the momentum de\
viation of the fit.\ndefault_   is a variable to receive the default fit weight.\nweight     is an expression which returns the de\
sired weight.\t\n\nExample: FitWeight[\"$$$\",\"LENG\",{_,dp_},ws_]:=ws*10;\n\nmakes the weight of LENG at $$$ 10 times (100 times\
 in MatchingResidual) bigger than the default."[p2$2313,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L473>matching-function-commands</A> <A HREF=#L500>special-variables</A> <A HREF=#L528>MatchingResidual</A></PRE>
<LI>
<H3><A NAME=L396>
GaussianCoulomb</A></H3>
<PRE><img  class="eqs" SRC="SADHelp_img/equ_200.svg" />
</PRE>
<LI>
<H3><A NAME=L397>
GeoBase</A></H3>
<PRE>If[{},
Help2HTML`oA$["GeoBase[{chi1, chi2, chi3}] converts the rotation angles of the coordinate base vectors to a transformation matrix \
{{x_gx,x_gy,x_gz}, {y_gx,y_gy,y_gz}, {z_gx,z_gy,z_gz}}"],
p$2318=1+p$2318[[1,2]];p1$2318=StringPosition["GeoBase[{chi1, chi2, chi3}] converts the rotation angles of the coordinate base vec\
tors to a transformation matrix {{x_gx,x_gy,x_gz}, {y_gx,y_gy,y_gz}, {z_gx,z_gy,z_gz}}"[p$2318,-1],">::",1];
   p1$2318=If[p1$2318==={},169,-2+p$2318+p1$2318[[1,1]]];
neq=Which["GeoBase[{chi1, chi2, chi3}] converts the rotation angles of the coordinate base vectors to a transformation matrix {{x_\
gx,x_gy,x_gz}, {y_gx,y_gy,y_gz}, {z_gx,z_gy,z_gz}}"[p$2318,4+p$2318]==="Text[",
    lx$2318:=Help2HTML`oa$;p$2318=5+p$2318;p1$2318-=1;p2$2318=5+p1$2318;p0$2318=-9+p$2318;
If[(pe$2318=StringPosition["GeoBase[{chi1, chi2, chi3}] converts the rotation angles of the coordinate base vectors to a transform\
ation matrix {{x_gx,x_gy,x_gz}, {y_gx,y_gy,y_gz}, {z_gx,z_gy,z_gz}}"[p$2318,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["GeoBase[{chi1, chi2, chi3}] converts the rotation angles of the coordinate base vectors to a transformation matri\
x {{x_gx,x_gy,x_gz}, {y_gx,y_gy,y_gz}, {z_gx,z_gy,z_gz}}"[p$2318+pe$2318[[1,2]],p1$2318]]],
        p1$2318=-2+p$2318+pe$2318[[1,1]]}[[
       1]],
      0],
    1,lx$2318:=Help2HTML`o9$;p2$2318=4+p1$2318;p0$2318=-4+p$2318;0];
  If[(equ$2318=
Help2HTML`o8$["GeoBase[{chi1, chi2, chi3}] converts the rotation angles of the coordinate base vectors to a transformation matrix \
{{x_gx,x_gy,x_gz}, {y_gx,y_gy,y_gz}, {z_gx,z_gy,z_gz}}"[p$2318,p1$2318]])===
    Undefined,
equ$2318="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["GeoBase[{chi1, chi2, chi3}] converts the rot\
ation angles of the coordinate base vectors to a transformation matrix {{x_gx,x_gy,x_gz}, {y_gx,y_gy,y_gz}, {z_gx,z_gy,z_gz}}"[p
         $2318,p1$2318]]=
       equ$2318;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2318},out$2318=lx$2318@Typeset["GeoBase[{chi1, chi2, chi3}] converts the rotation angles of the coordinate base vectors t\
o a transformation matrix {{x_gx,x_gy,x_gz}, {y_gx,y_gy,y_gz}, {z_gx,z_gy,z_gz}}"[p$2318,p1$2318],Format->Help2HTML`oB$];
        System["mv -f "//out$2318//" "//equ$2318]];
      Exit[]]];
   "GeoBase[{chi1, chi2, chi3}] converts the rotation angles of the coordinate base vectors to a transformation matrix {{x_gx,x_gy\
,x_gz}, {y_gx,y_gy,y_gz}, {z_gx,z_gy,z_gz}}"[1,Max[p0$2318,0]]//"<img  class=\"eqs\" SRC=\""//equ$2318//"\" />"//
Help2HTML`oy$["GeoBase[{chi1, chi2, chi3}] converts the rotation angles of the coordinate base vectors to a transformation matrix \
{{x_gx,x_gy,x_gz}, {y_gx,y_gy,y_gz}, {z_gx,z_gy,z_gz}}"[p2$2318,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L245>GEO</A> <A HREF=#L401>OrbitGeo</A></PRE>
<LI>
<H3><A NAME=L398>
LINE</A></H3>
<PRE>If[{},
Help2HTML`oA$["LINE[key-string, {component-pattern-string | component-position}]\n\nreturns values for key-string of components wh\
ich match component-pattern-string or located at component-position. It returns a list if more than one components match. The key-\
string and component-pattern-string can be symbols, unless values are not assigned to them. The second arg can be a fractional num\
ber to denote an intermediate value of two components.\n   If the second argument is omitted, it means all components.\n   The com\
ponent-position can be known by LINE[\"POSITION\"].\n   Key-strings \"DIR\" and component-keywords allows to be set (i.e.,\nLINE[a\
,b] = v) when component-pattern-string chooses only one component.\n   The arguments of LINE can be lists. It automatically maps a\
s\n\n   LINE[{a,b,c..},y]  means {LINE[a,y],LINE[b,y],LINE[c,y]..}\n   LINE[x,{a,b,c..}]  means {LINE[x,a],LINE[x,b],LINE[x,c]..},\
\n\nwhere both x and y can be also a list."],
p$2321=1+p$2321[[1,2]];p1$2321=StringPosition["LINE[key-string, {component-pattern-string | component-position}]\n\nreturns values\
 for key-string of components which match component-pattern-string or located at component-position. It returns a list if more tha\
n one components match. The key-string and component-pattern-string can be symbols, unless values are not assigned to them. The se\
cond arg can be a fractional number to denote an intermediate value of two components.\n   If the second argument is omitted, it m\
eans all components.\n   The component-position can be known by LINE[\"POSITION\"].\n   Key-strings \"DIR\" and component-keywords\
 allows to be set (i.e.,\nLINE[a,b] = v) when component-pattern-string chooses only one component.\n   The arguments of LINE can b\
e lists. It automatically maps as\n\n   LINE[{a,b,c..},y]  means {LINE[a,y],LINE[b,y],LINE[c,y]..}\n   LINE[x,{a,b,c..}]  means {L\
INE[x,a],LINE[x,b],LINE[x,c]..},\n\nwhere both x and y can be also a list."[p$2321,-1],">::",1];
   p1$2321=If[p1$2321==={},921,-2+p$2321+p1$2321[[1,1]]];
neq=Which["LINE[key-string, {component-pattern-string | component-position}]\n\nreturns values for key-string of components which \
match component-pattern-string or located at component-position. It returns a list if more than one components match. The key-stri\
ng and component-pattern-string can be symbols, unless values are not assigned to them. The second arg can be a fractional number \
to denote an intermediate value of two components.\n   If the second argument is omitted, it means all components.\n   The compone\
nt-position can be known by LINE[\"POSITION\"].\n   Key-strings \"DIR\" and component-keywords allows to be set (i.e.,\nLINE[a,b] \
= v) when component-pattern-string chooses only one component.\n   The arguments of LINE can be lists. It automatically maps as\n\\
n   LINE[{a,b,c..},y]  means {LINE[a,y],LINE[b,y],LINE[c,y]..}\n   LINE[x,{a,b,c..}]  means {LINE[x,a],LINE[x,b],LINE[x,c]..},\n\n\
where both x and y can be also a list."[p$2321,4+p$2321]==="Text[",
    lx$2321:=Help2HTML`oa$;p$2321=5+p$2321;p1$2321-=1;p2$2321=5+p1$2321;p0$2321=-9+p$2321;
If[(pe$2321=StringPosition["LINE[key-string, {component-pattern-string | component-position}]\n\nreturns values for key-string of \
components which match component-pattern-string or located at component-position. It returns a list if more than one components ma\
tch. The key-string and component-pattern-string can be symbols, unless values are not assigned to them. The second arg can be a f\
ractional number to denote an intermediate value of two components.\n   If the second argument is omitted, it means all components\
.\n   The component-position can be known by LINE[\"POSITION\"].\n   Key-strings \"DIR\" and component-keywords allows to be set (\
i.e.,\nLINE[a,b] = v) when component-pattern-string chooses only one component.\n   The arguments of LINE can be lists. It automat\
ically maps as\n\n   LINE[{a,b,c..},y]  means {LINE[a,y],LINE[b,y],LINE[c,y]..}\n   LINE[x,{a,b,c..}]  means {LINE[x,a],LINE[x,b],\
LINE[x,c]..},\n\nwhere both x and y can be also a list."[p$2321,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["LINE[key-string, {component-pattern-string | component-position}]\n\nreturns values for key-string of components \
which match component-pattern-string or located at component-position. It returns a list if more than one components match. The ke\
y-string and component-pattern-string can be symbols, unless values are not assigned to them. The second arg can be a fractional n\
umber to denote an intermediate value of two components.\n   If the second argument is omitted, it means all components.\n   The c\
omponent-position can be known by LINE[\"POSITION\"].\n   Key-strings \"DIR\" and component-keywords allows to be set (i.e.,\nLINE\
[a,b] = v) when component-pattern-string chooses only one component.\n   The arguments of LINE can be lists. It automatically maps\
 as\n\n   LINE[{a,b,c..},y]  means {LINE[a,y],LINE[b,y],LINE[c,y]..}\n   LINE[x,{a,b,c..}]  means {LINE[x,a],LINE[x,b],LINE[x,c]..\
},\n\nwhere both x and y can be also a list."[p$2321+pe$2321[[1,2]],p1$2321]]],
        p1$2321=-2+p$2321+pe$2321[[1,1]]}[[
       1]],
      0],
    1,lx$2321:=Help2HTML`o9$;p2$2321=4+p1$2321;p0$2321=-4+p$2321;0];
  If[(equ$2321=
Help2HTML`o8$["LINE[key-string, {component-pattern-string | component-position}]\n\nreturns values for key-string of components wh\
ich match component-pattern-string or located at component-position. It returns a list if more than one components match. The key-\
string and component-pattern-string can be symbols, unless values are not assigned to them. The second arg can be a fractional num\
ber to denote an intermediate value of two components.\n   If the second argument is omitted, it means all components.\n   The com\
ponent-position can be known by LINE[\"POSITION\"].\n   Key-strings \"DIR\" and component-keywords allows to be set (i.e.,\nLINE[a\
,b] = v) when component-pattern-string chooses only one component.\n   The arguments of LINE can be lists. It automatically maps a\
s\n\n   LINE[{a,b,c..},y]  means {LINE[a,y],LINE[b,y],LINE[c,y]..}\n   LINE[x,{a,b,c..}]  means {LINE[x,a],LINE[x,b],LINE[x,c]..},\
\n\nwhere both x and y can be also a list."[p$2321,p1$2321]])===
    Undefined,
equ$2321="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["LINE[key-string, {component-pattern-string |\
 component-position}]\n\nreturns values for key-string of components which match component-pattern-string or located at component-\
position. It returns a list if more than one components match. The key-string and component-pattern-string can be symbols, unless \
values are not assigned to them. The second arg can be a fractional number to denote an intermediate value of two components.\n   \
If the second argument is omitted, it means all components.\n   The component-position can be known by LINE[\"POSITION\"].\n   Key\
-strings \"DIR\" and component-keywords allows to be set (i.e.,\nLINE[a,b] = v) when component-pattern-string chooses only one com\
ponent.\n   The arguments of LINE can be lists. It automatically maps as\n\n   LINE[{a,b,c..},y]  means {LINE[a,y],LINE[b,y],LINE[\
c,y]..}\n   LINE[x,{a,b,c..}]  means {LINE[x,a],LINE[x,b],LINE[x,c]..},\n\nwhere both x and y can be also a list."[p$2321,p1$2321]
        ]=
       equ$2321;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2321},out$2321=lx$2321@Typeset["LINE[key-string, {component-pattern-string | component-position}]\n\nreturns values for k\
ey-string of components which match component-pattern-string or located at component-position. It returns a list if more than one \
components match. The key-string and component-pattern-string can be symbols, unless values are not assigned to them. The second a\
rg can be a fractional number to denote an intermediate value of two components.\n   If the second argument is omitted, it means a\
ll components.\n   The component-position can be known by LINE[\"POSITION\"].\n   Key-strings \"DIR\" and component-keywords allow\
s to be set (i.e.,\nLINE[a,b] = v) when component-pattern-string chooses only one component.\n   The arguments of LINE can be list\
s. It automatically maps as\n\n   LINE[{a,b,c..},y]  means {LINE[a,y],LINE[b,y],LINE[c,y]..}\n   LINE[x,{a,b,c..}]  means {LINE[x,\
a],LINE[x,b],LINE[x,c]..},\n\nwhere both x and y can be also a list."[p$2321,p1$2321],Format->Help2HTML`oB$];
        System["mv -f "//out$2321//" "//equ$2321]];
      Exit[]]];
   "LINE[key-string, {component-pattern-string | component-position}]\n\nreturns values for key-string of components which match c\
omponent-pattern-string or located at component-position. It returns a list if more than one components match. The key-string and \
component-pattern-string can be symbols, unless values are not assigned to them. The second arg can be a fractional number to deno\
te an intermediate value of two components.\n   If the second argument is omitted, it means all components.\n   The component-posi\
tion can be known by LINE[\"POSITION\"].\n   Key-strings \"DIR\" and component-keywords allows to be set (i.e.,\nLINE[a,b] = v) wh\
en component-pattern-string chooses only one component.\n   The arguments of LINE can be lists. It automatically maps as\n\n   LIN\
E[{a,b,c..},y]  means {LINE[a,y],LINE[b,y],LINE[c,y]..}\n   LINE[x,{a,b,c..}]  means {LINE[x,a],LINE[x,b],LINE[x,c]..},\n\nwhere b\
oth x and y can be also a list."[1,Max[p0$2321,0]]//"<img  class=\"eqs\" SRC=\""//equ$2321//"\" />"//
Help2HTML`oy$["LINE[key-string, {component-pattern-string | component-position}]\n\nreturns values for key-string of components wh\
ich match component-pattern-string or located at component-position. It returns a list if more than one components match. The key-\
string and component-pattern-string can be symbols, unless values are not assigned to them. The second arg can be a fractional num\
ber to denote an intermediate value of two components.\n   If the second argument is omitted, it means all components.\n   The com\
ponent-position can be known by LINE[\"POSITION\"].\n   Key-strings \"DIR\" and component-keywords allows to be set (i.e.,\nLINE[a\
,b] = v) when component-pattern-string chooses only one component.\n   The arguments of LINE can be lists. It automatically maps a\
s\n\n   LINE[{a,b,c..},y]  means {LINE[a,y],LINE[b,y],LINE[c,y]..}\n   LINE[x,{a,b,c..}]  means {LINE[x,a],LINE[x,b],LINE[x,c]..},\
\n\nwhere both x and y can be also a list."[p2$2321,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L30>components</A> <A HREF=#L562>wildcards</A> <A HREF=#L75>elements</A> <A HREF=#L387>Element</A></PRE>
<UL>
<LI>
<H3><A NAME=L399>
key-strings:LINE</A></H3>
<PRE>If[{},
Help2HTML`oA$["The key-string is not case-sensitive. Available key-strings are:\t\n\n\"LENGTH\"       Number of components in the \
beam line. No second argument.\n\"POSITION\"     Position of the component in the beam line.\n\"NAME\"         Name of the compone\
nt.\n\"TYPE\"         The internal code-number of the type of the component.\n\"TYPENAME\"     The name of the type of the compone\
nt.\n\"ELEMENT\"      The name of the corresponding element.\n\"DIR\"          The orientation of the component, +-1.\n\"S\"      \
      The orbit length to the entrance from the beginning of the beam line.\n\"LENG\"         Same as \"S\".\n\"GEO\"          Geo\
metric-functions at the entrance of the component, {{GX, GY, GZ}, {GCHI1, GCHI2, GCHI3}}.\n\"OGEO\"         Geometric-functions of\
 the orbit at the entrance of the component, {{OGX, OGY, OGZ}, {OCHI1, OCHI2, OCHI3}}.\n\"GAMMA\"        Lorentz factor gamma.\n\"\
GAMMABETA\"    Lorentz factor gamma*beta = Sqrt[gamma^2 - 1].\n\"SIGab\"        Beam matrix component, where a and b are one of X,\
 PX, Y, PY, Z, DP. If b is omitted it returns Sqrt[SIGaa] is returned. Just \"SIG\" returns the entire 6 by 6 beam matrix.\n\"SIZE\
ab\"       Beam matrix component calculated by (CODPLOT;EMIT), where a and b are one of X, PX, Y, PY, Z, DP. If b is omitted it re\
turns Sqrt[SIZEaa] is returned.- \"SIZE\" returns the entire 6 by 6 beam matrix.\n\"MULT\"         The ordered number of each comp\
onent belonging to the- same element, starting from 1.\nkeyword        The value of the keyword of the component (see below).\n\"E\
XPAND\"       Distribute the value of the default-keywords and the keywords used in the matching to all components in the beam lin\
e. No second argument.\t\n\"GX\", \"GY\", \"GZ\"  Geometric functions for the coordinate GX, GY, GZ.\n\"GCHI1\", \"GCHI2\", \"GCHI\
3\"  Geometric functions for the coordinate CHI1, CHI2, CHI3\n\"OGX\", \"OGY\", \"OGZ\", \"OCHI1\", \"OCHI2\", \"OCHI3\"  Geometri\
cal functions for the orbit.\n Setting by LINE[keyword,..] to the DEFAULT keyword for the FIRST component changes the current valu\
e of the corresponding element, because the value of an element is stored in the first component."],
 p$2324=1+p$2324[[1,2]];p1$2324=StringPosition["The key-string is not case-sensitive. Available key-strings are:\t\n\n\"LENGTH\"  \
     Number of components in the beam line. No second argument.\n\"POSITION\"     Position of the component in the beam line.\n\"N\
AME\"         Name of the component.\n\"TYPE\"         The internal code-number of the type of the component.\n\"TYPENAME\"     Th\
e name of the type of the component.\n\"ELEMENT\"      The name of the corresponding element.\n\"DIR\"          The orientation of\
 the component, +-1.\n\"S\"            The orbit length to the entrance from the beginning of the beam line.\n\"LENG\"         Sam\
e as \"S\".\n\"GEO\"          Geometric-functions at the entrance of the component, {{GX, GY, GZ}, {GCHI1, GCHI2, GCHI3}}.\n\"OGEO\
\"         Geometric-functions of the orbit at the entrance of the component, {{OGX, OGY, OGZ}, {OCHI1, OCHI2, OCHI3}}.\n\"GAMMA\"\
        Lorentz factor gamma.\n\"GAMMABETA\"    Lorentz factor gamma*beta = Sqrt[gamma^2 - 1].\n\"SIGab\"        Beam matrix compo\
nent, where a and b are one of X, PX, Y, PY, Z, DP. If b is omitted it returns Sqrt[SIGaa] is returned. Just \"SIG\" returns the e\
ntire 6 by 6 beam matrix.\n\"SIZEab\"       Beam matrix component calculated by (CODPLOT;EMIT), where a and b are one of X, PX, Y,\
 PY, Z, DP. If b is omitted it returns Sqrt[SIZEaa] is returned.- \"SIZE\" returns the entire 6 by 6 beam matrix.\n\"MULT\"       \
  The ordered number of each component belonging to the- same element, starting from 1.\nkeyword        The value of the keyword o\
f the component (see below).\n\"EXPAND\"       Distribute the value of the default-keywords and the keywords used in the matching \
to all components in the beam line. No second argument.\t\n\"GX\", \"GY\", \"GZ\"  Geometric functions for the coordinate GX, GY, \
GZ.\n\"GCHI1\", \"GCHI2\", \"GCHI3\"  Geometric functions for the coordinate CHI1, CHI2, CHI3\n\"OGX\", \"OGY\", \"OGZ\", \"OCHI1\\
", \"OCHI2\", \"OCHI3\"  Geometrical functions for the orbit.\n Setting by LINE[keyword,..] to the DEFAULT keyword for the FIRST c\
omponent changes the current value of the corresponding element, because the value of an element is stored in the first component."
    [p$2324,-1],">::",1];
   p1$2324=If[p1$2324==={},2073,-2+p$2324+p1$2324[[1,1]]];
neq=Which["The key-string is not case-sensitive. Available key-strings are:\t\n\n\"LENGTH\"       Number of components in the beam\
 line. No second argument.\n\"POSITION\"     Position of the component in the beam line.\n\"NAME\"         Name of the component.\\
n\"TYPE\"         The internal code-number of the type of the component.\n\"TYPENAME\"     The name of the type of the component.\\
n\"ELEMENT\"      The name of the corresponding element.\n\"DIR\"          The orientation of the component, +-1.\n\"S\"          \
  The orbit length to the entrance from the beginning of the beam line.\n\"LENG\"         Same as \"S\".\n\"GEO\"          Geometr\
ic-functions at the entrance of the component, {{GX, GY, GZ}, {GCHI1, GCHI2, GCHI3}}.\n\"OGEO\"         Geometric-functions of the\
 orbit at the entrance of the component, {{OGX, OGY, OGZ}, {OCHI1, OCHI2, OCHI3}}.\n\"GAMMA\"        Lorentz factor gamma.\n\"GAMM\
ABETA\"    Lorentz factor gamma*beta = Sqrt[gamma^2 - 1].\n\"SIGab\"        Beam matrix component, where a and b are one of X, PX,\
 Y, PY, Z, DP. If b is omitted it returns Sqrt[SIGaa] is returned. Just \"SIG\" returns the entire 6 by 6 beam matrix.\n\"SIZEab\"\
       Beam matrix component calculated by (CODPLOT;EMIT), where a and b are one of X, PX, Y, PY, Z, DP. If b is omitted it return\
s Sqrt[SIZEaa] is returned.- \"SIZE\" returns the entire 6 by 6 beam matrix.\n\"MULT\"         The ordered number of each componen\
t belonging to the- same element, starting from 1.\nkeyword        The value of the keyword of the component (see below).\n\"EXPAN\
D\"       Distribute the value of the default-keywords and the keywords used in the matching to all components in the beam line. N\
o second argument.\t\n\"GX\", \"GY\", \"GZ\"  Geometric functions for the coordinate GX, GY, GZ.\n\"GCHI1\", \"GCHI2\", \"GCHI3\" \
 Geometric functions for the coordinate CHI1, CHI2, CHI3\n\"OGX\", \"OGY\", \"OGZ\", \"OCHI1\", \"OCHI2\", \"OCHI3\"  Geometrical \
functions for the orbit.\n Setting by LINE[keyword,..] to the DEFAULT keyword for the FIRST component changes the current value of\
 the corresponding element, because the value of an element is stored in the first component."[p$2324,4+p$2324]==="Text[",
    lx$2324:=Help2HTML`oa$;p$2324=5+p$2324;p1$2324-=1;p2$2324=5+p1$2324;p0$2324=-9+p$2324;
If[(pe$2324=StringPosition["The key-string is not case-sensitive. Available key-strings are:\t\n\n\"LENGTH\"       Number of compo\
nents in the beam line. No second argument.\n\"POSITION\"     Position of the component in the beam line.\n\"NAME\"         Name o\
f the component.\n\"TYPE\"         The internal code-number of the type of the component.\n\"TYPENAME\"     The name of the type o\
f the component.\n\"ELEMENT\"      The name of the corresponding element.\n\"DIR\"          The orientation of the component, +-1.\
\n\"S\"            The orbit length to the entrance from the beginning of the beam line.\n\"LENG\"         Same as \"S\".\n\"GEO\"\
          Geometric-functions at the entrance of the component, {{GX, GY, GZ}, {GCHI1, GCHI2, GCHI3}}.\n\"OGEO\"         Geometric\
-functions of the orbit at the entrance of the component, {{OGX, OGY, OGZ}, {OCHI1, OCHI2, OCHI3}}.\n\"GAMMA\"        Lorentz fact\
or gamma.\n\"GAMMABETA\"    Lorentz factor gamma*beta = Sqrt[gamma^2 - 1].\n\"SIGab\"        Beam matrix component, where a and b \
are one of X, PX, Y, PY, Z, DP. If b is omitted it returns Sqrt[SIGaa] is returned. Just \"SIG\" returns the entire 6 by 6 beam ma\
trix.\n\"SIZEab\"       Beam matrix component calculated by (CODPLOT;EMIT), where a and b are one of X, PX, Y, PY, Z, DP. If b is \
omitted it returns Sqrt[SIZEaa] is returned.- \"SIZE\" returns the entire 6 by 6 beam matrix.\n\"MULT\"         The ordered number\
 of each component belonging to the- same element, starting from 1.\nkeyword        The value of the keyword of the component (see\
 below).\n\"EXPAND\"       Distribute the value of the default-keywords and the keywords used in the matching to all components in\
 the beam line. No second argument.\t\n\"GX\", \"GY\", \"GZ\"  Geometric functions for the coordinate GX, GY, GZ.\n\"GCHI1\", \"GC\
HI2\", \"GCHI3\"  Geometric functions for the coordinate CHI1, CHI2, CHI3\n\"OGX\", \"OGY\", \"OGZ\", \"OCHI1\", \"OCHI2\", \"OCHI\
3\"  Geometrical functions for the orbit.\n Setting by LINE[keyword,..] to the DEFAULT keyword for the FIRST component changes the\
 current value of the corresponding element, because the value of an element is stored in the first component."[p$2324,-2],";;;"]
        )<=>
       {},
      {Max[0,
-1+ToExpression["The key-string is not case-sensitive. Available key-strings are:\t\n\n\"LENGTH\"       Number of components in th\
e beam line. No second argument.\n\"POSITION\"     Position of the component in the beam line.\n\"NAME\"         Name of the compo\
nent.\n\"TYPE\"         The internal code-number of the type of the component.\n\"TYPENAME\"     The name of the type of the compo\
nent.\n\"ELEMENT\"      The name of the corresponding element.\n\"DIR\"          The orientation of the component, +-1.\n\"S\"    \
        The orbit length to the entrance from the beginning of the beam line.\n\"LENG\"         Same as \"S\".\n\"GEO\"          G\
eometric-functions at the entrance of the component, {{GX, GY, GZ}, {GCHI1, GCHI2, GCHI3}}.\n\"OGEO\"         Geometric-functions \
of the orbit at the entrance of the component, {{OGX, OGY, OGZ}, {OCHI1, OCHI2, OCHI3}}.\n\"GAMMA\"        Lorentz factor gamma.\n\
\"GAMMABETA\"    Lorentz factor gamma*beta = Sqrt[gamma^2 - 1].\n\"SIGab\"        Beam matrix component, where a and b are one of \
X, PX, Y, PY, Z, DP. If b is omitted it returns Sqrt[SIGaa] is returned. Just \"SIG\" returns the entire 6 by 6 beam matrix.\n\"SI\
ZEab\"       Beam matrix component calculated by (CODPLOT;EMIT), where a and b are one of X, PX, Y, PY, Z, DP. If b is omitted it \
returns Sqrt[SIZEaa] is returned.- \"SIZE\" returns the entire 6 by 6 beam matrix.\n\"MULT\"         The ordered number of each co\
mponent belonging to the- same element, starting from 1.\nkeyword        The value of the keyword of the component (see below).\n\\
"EXPAND\"       Distribute the value of the default-keywords and the keywords used in the matching to all components in the beam l\
ine. No second argument.\t\n\"GX\", \"GY\", \"GZ\"  Geometric functions for the coordinate GX, GY, GZ.\n\"GCHI1\", \"GCHI2\", \"GC\
HI3\"  Geometric functions for the coordinate CHI1, CHI2, CHI3\n\"OGX\", \"OGY\", \"OGZ\", \"OCHI1\", \"OCHI2\", \"OCHI3\"  Geomet\
rical functions for the orbit.\n Setting by LINE[keyword,..] to the DEFAULT keyword for the FIRST component changes the current va\
lue of the corresponding element, because the value of an element is stored in the first component."[p$2324+pe$2324[[1,2]],p1$2324]
          ]],
        p1$2324=-2+p$2324+pe$2324[[1,1]]}[[
       1]],
      0],
    1,lx$2324:=Help2HTML`o9$;p2$2324=4+p1$2324;p0$2324=-4+p$2324;0];
  If[(equ$2324=
Help2HTML`o8$["The key-string is not case-sensitive. Available key-strings are:\t\n\n\"LENGTH\"       Number of components in the \
beam line. No second argument.\n\"POSITION\"     Position of the component in the beam line.\n\"NAME\"         Name of the compone\
nt.\n\"TYPE\"         The internal code-number of the type of the component.\n\"TYPENAME\"     The name of the type of the compone\
nt.\n\"ELEMENT\"      The name of the corresponding element.\n\"DIR\"          The orientation of the component, +-1.\n\"S\"      \
      The orbit length to the entrance from the beginning of the beam line.\n\"LENG\"         Same as \"S\".\n\"GEO\"          Geo\
metric-functions at the entrance of the component, {{GX, GY, GZ}, {GCHI1, GCHI2, GCHI3}}.\n\"OGEO\"         Geometric-functions of\
 the orbit at the entrance of the component, {{OGX, OGY, OGZ}, {OCHI1, OCHI2, OCHI3}}.\n\"GAMMA\"        Lorentz factor gamma.\n\"\
GAMMABETA\"    Lorentz factor gamma*beta = Sqrt[gamma^2 - 1].\n\"SIGab\"        Beam matrix component, where a and b are one of X,\
 PX, Y, PY, Z, DP. If b is omitted it returns Sqrt[SIGaa] is returned. Just \"SIG\" returns the entire 6 by 6 beam matrix.\n\"SIZE\
ab\"       Beam matrix component calculated by (CODPLOT;EMIT), where a and b are one of X, PX, Y, PY, Z, DP. If b is omitted it re\
turns Sqrt[SIZEaa] is returned.- \"SIZE\" returns the entire 6 by 6 beam matrix.\n\"MULT\"         The ordered number of each comp\
onent belonging to the- same element, starting from 1.\nkeyword        The value of the keyword of the component (see below).\n\"E\
XPAND\"       Distribute the value of the default-keywords and the keywords used in the matching to all components in the beam lin\
e. No second argument.\t\n\"GX\", \"GY\", \"GZ\"  Geometric functions for the coordinate GX, GY, GZ.\n\"GCHI1\", \"GCHI2\", \"GCHI\
3\"  Geometric functions for the coordinate CHI1, CHI2, CHI3\n\"OGX\", \"OGY\", \"OGZ\", \"OCHI1\", \"OCHI2\", \"OCHI3\"  Geometri\
cal functions for the orbit.\n Setting by LINE[keyword,..] to the DEFAULT keyword for the FIRST component changes the current valu\
e of the corresponding element, because the value of an element is stored in the first component."[p$2324,p1$2324]])===
    Undefined,
equ$2324="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["The key-string is not case-sensitive. Availa\
ble key-strings are:\t\n\n\"LENGTH\"       Number of components in the beam line. No second argument.\n\"POSITION\"     Position o\
f the component in the beam line.\n\"NAME\"         Name of the component.\n\"TYPE\"         The internal code-number of the type \
of the component.\n\"TYPENAME\"     The name of the type of the component.\n\"ELEMENT\"      The name of the corresponding element\
.\n\"DIR\"          The orientation of the component, +-1.\n\"S\"            The orbit length to the entrance from the beginning o\
f the beam line.\n\"LENG\"         Same as \"S\".\n\"GEO\"          Geometric-functions at the entrance of the component, {{GX, GY\
, GZ}, {GCHI1, GCHI2, GCHI3}}.\n\"OGEO\"         Geometric-functions of the orbit at the entrance of the component, {{OGX, OGY, OG\
Z}, {OCHI1, OCHI2, OCHI3}}.\n\"GAMMA\"        Lorentz factor gamma.\n\"GAMMABETA\"    Lorentz factor gamma*beta = Sqrt[gamma^2 - 1\
].\n\"SIGab\"        Beam matrix component, where a and b are one of X, PX, Y, PY, Z, DP. If b is omitted it returns Sqrt[SIGaa] i\
s returned. Just \"SIG\" returns the entire 6 by 6 beam matrix.\n\"SIZEab\"       Beam matrix component calculated by (CODPLOT;EMI\
T), where a and b are one of X, PX, Y, PY, Z, DP. If b is omitted it returns Sqrt[SIZEaa] is returned.- \"SIZE\" returns the entir\
e 6 by 6 beam matrix.\n\"MULT\"         The ordered number of each component belonging to the- same element, starting from 1.\nkey\
word        The value of the keyword of the component (see below).\n\"EXPAND\"       Distribute the value of the default-keywords \
and the keywords used in the matching to all components in the beam line. No second argument.\t\n\"GX\", \"GY\", \"GZ\"  Geometric\
 functions for the coordinate GX, GY, GZ.\n\"GCHI1\", \"GCHI2\", \"GCHI3\"  Geometric functions for the coordinate CHI1, CHI2, CHI\
3\n\"OGX\", \"OGY\", \"OGZ\", \"OCHI1\", \"OCHI2\", \"OCHI3\"  Geometrical functions for the orbit.\n Setting by LINE[keyword,..] \
to the DEFAULT keyword for the FIRST component changes the current value of the corresponding element, because the value of an ele\
ment is stored in the first component."[p$2324,p1$2324]]=
       equ$2324;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2324},out$2324=lx$2324@Typeset["The key-string is not case-sensitive. Available key-strings are:\t\n\n\"LENGTH\"       Nu\
mber of components in the beam line. No second argument.\n\"POSITION\"     Position of the component in the beam line.\n\"NAME\"  \
       Name of the component.\n\"TYPE\"         The internal code-number of the type of the component.\n\"TYPENAME\"     The name \
of the type of the component.\n\"ELEMENT\"      The name of the corresponding element.\n\"DIR\"          The orientation of the co\
mponent, +-1.\n\"S\"            The orbit length to the entrance from the beginning of the beam line.\n\"LENG\"         Same as \"\
S\".\n\"GEO\"          Geometric-functions at the entrance of the component, {{GX, GY, GZ}, {GCHI1, GCHI2, GCHI3}}.\n\"OGEO\"     \
    Geometric-functions of the orbit at the entrance of the component, {{OGX, OGY, OGZ}, {OCHI1, OCHI2, OCHI3}}.\n\"GAMMA\"       \
 Lorentz factor gamma.\n\"GAMMABETA\"    Lorentz factor gamma*beta = Sqrt[gamma^2 - 1].\n\"SIGab\"        Beam matrix component, w\
here a and b are one of X, PX, Y, PY, Z, DP. If b is omitted it returns Sqrt[SIGaa] is returned. Just \"SIG\" returns the entire 6\
 by 6 beam matrix.\n\"SIZEab\"       Beam matrix component calculated by (CODPLOT;EMIT), where a and b are one of X, PX, Y, PY, Z,\
 DP. If b is omitted it returns Sqrt[SIZEaa] is returned.- \"SIZE\" returns the entire 6 by 6 beam matrix.\n\"MULT\"         The o\
rdered number of each component belonging to the- same element, starting from 1.\nkeyword        The value of the keyword of the c\
omponent (see below).\n\"EXPAND\"       Distribute the value of the default-keywords and the keywords used in the matching to all \
components in the beam line. No second argument.\t\n\"GX\", \"GY\", \"GZ\"  Geometric functions for the coordinate GX, GY, GZ.\n\"\
GCHI1\", \"GCHI2\", \"GCHI3\"  Geometric functions for the coordinate CHI1, CHI2, CHI3\n\"OGX\", \"OGY\", \"OGZ\", \"OCHI1\", \"OC\
HI2\", \"OCHI3\"  Geometrical functions for the orbit.\n Setting by LINE[keyword,..] to the DEFAULT keyword for the FIRST componen\
t changes the current value of the corresponding element, because the value of an element is stored in the first component."[p$2324
           ,p1$2324],Format->Help2HTML`oB$];
        System["mv -f "//out$2324//" "//equ$2324]];
      Exit[]]];
   "The key-string is not case-sensitive. Available key-strings are:\t\n\n\"LENGTH\"       Number of components in the beam line. \
No second argument.\n\"POSITION\"     Position of the component in the beam line.\n\"NAME\"         Name of the component.\n\"TYPE\
\"         The internal code-number of the type of the component.\n\"TYPENAME\"     The name of the type of the component.\n\"ELEM\
ENT\"      The name of the corresponding element.\n\"DIR\"          The orientation of the component, +-1.\n\"S\"            The o\
rbit length to the entrance from the beginning of the beam line.\n\"LENG\"         Same as \"S\".\n\"GEO\"          Geometric-func\
tions at the entrance of the component, {{GX, GY, GZ}, {GCHI1, GCHI2, GCHI3}}.\n\"OGEO\"         Geometric-functions of the orbit \
at the entrance of the component, {{OGX, OGY, OGZ}, {OCHI1, OCHI2, OCHI3}}.\n\"GAMMA\"        Lorentz factor gamma.\n\"GAMMABETA\"\
    Lorentz factor gamma*beta = Sqrt[gamma^2 - 1].\n\"SIGab\"        Beam matrix component, where a and b are one of X, PX, Y, PY,\
 Z, DP. If b is omitted it returns Sqrt[SIGaa] is returned. Just \"SIG\" returns the entire 6 by 6 beam matrix.\n\"SIZEab\"       \
Beam matrix component calculated by (CODPLOT;EMIT), where a and b are one of X, PX, Y, PY, Z, DP. If b is omitted it returns Sqrt[\
SIZEaa] is returned.- \"SIZE\" returns the entire 6 by 6 beam matrix.\n\"MULT\"         The ordered number of each component belon\
ging to the- same element, starting from 1.\nkeyword        The value of the keyword of the component (see below).\n\"EXPAND\"    \
   Distribute the value of the default-keywords and the keywords used in the matching to all components in the beam line. No secon\
d argument.\t\n\"GX\", \"GY\", \"GZ\"  Geometric functions for the coordinate GX, GY, GZ.\n\"GCHI1\", \"GCHI2\", \"GCHI3\"  Geomet\
ric functions for the coordinate CHI1, CHI2, CHI3\n\"OGX\", \"OGY\", \"OGZ\", \"OCHI1\", \"OCHI2\", \"OCHI3\"  Geometrical functio\
ns for the orbit.\n Setting by LINE[keyword,..] to the DEFAULT keyword for the FIRST component changes the current value of the co\
rresponding element, because the value of an element is stored in the first component."[1,Max[p0$2324,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2324//"\" />"//
Help2HTML`oy$["The key-string is not case-sensitive. Available key-strings are:\t\n\n\"LENGTH\"       Number of components in the \
beam line. No second argument.\n\"POSITION\"     Position of the component in the beam line.\n\"NAME\"         Name of the compone\
nt.\n\"TYPE\"         The internal code-number of the type of the component.\n\"TYPENAME\"     The name of the type of the compone\
nt.\n\"ELEMENT\"      The name of the corresponding element.\n\"DIR\"          The orientation of the component, +-1.\n\"S\"      \
      The orbit length to the entrance from the beginning of the beam line.\n\"LENG\"         Same as \"S\".\n\"GEO\"          Geo\
metric-functions at the entrance of the component, {{GX, GY, GZ}, {GCHI1, GCHI2, GCHI3}}.\n\"OGEO\"         Geometric-functions of\
 the orbit at the entrance of the component, {{OGX, OGY, OGZ}, {OCHI1, OCHI2, OCHI3}}.\n\"GAMMA\"        Lorentz factor gamma.\n\"\
GAMMABETA\"    Lorentz factor gamma*beta = Sqrt[gamma^2 - 1].\n\"SIGab\"        Beam matrix component, where a and b are one of X,\
 PX, Y, PY, Z, DP. If b is omitted it returns Sqrt[SIGaa] is returned. Just \"SIG\" returns the entire 6 by 6 beam matrix.\n\"SIZE\
ab\"       Beam matrix component calculated by (CODPLOT;EMIT), where a and b are one of X, PX, Y, PY, Z, DP. If b is omitted it re\
turns Sqrt[SIZEaa] is returned.- \"SIZE\" returns the entire 6 by 6 beam matrix.\n\"MULT\"         The ordered number of each comp\
onent belonging to the- same element, starting from 1.\nkeyword        The value of the keyword of the component (see below).\n\"E\
XPAND\"       Distribute the value of the default-keywords and the keywords used in the matching to all components in the beam lin\
e. No second argument.\t\n\"GX\", \"GY\", \"GZ\"  Geometric functions for the coordinate GX, GY, GZ.\n\"GCHI1\", \"GCHI2\", \"GCHI\
3\"  Geometric functions for the coordinate CHI1, CHI2, CHI3\n\"OGX\", \"OGY\", \"OGZ\", \"OCHI1\", \"OCHI2\", \"OCHI3\"  Geometri\
cal functions for the orbit.\n Setting by LINE[keyword,..] to the DEFAULT keyword for the FIRST component changes the current valu\
e of the corresponding element, because the value of an element is stored in the first component."[p2$2324,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L30>components</A> <A HREF=#L468>geometric-functions</A> <A HREF=#L75>elements</A> <A HREF=#L136>keywords</A> <A HREF=#L113>default-keyword</A> <A HREF=#L387>Element</A></PRE>
</UL>
<LI>
<H3><A NAME=L400>
OptimizeOptics</A></H3>
<PRE>If[{},
Help2HTML`oA$["Usage: OptimizeOptics[options]\n\noptimizes (1 + MatchingResidual) or any function using DownhillSimplex with varia\
bles specified by FREE. Unlike GO, any keyword of any element can be a variable.\n   OptimizeOptics returns the final simplex. The\
 variables are set to the values which give the minimum of the function so far at the end.\n\nOptions:\n   All options for Downhil\
lSimplex are valid.\n   OptimizeFunction -> fun is the function to be minimized. The default is\n      ((FFS[\"CALC\"];1+MatchingR\
esidual)&).\n   InitialSimplex -> initial sets the initial simplex to initial. The\n      default is Null, which mean to create in\
itial from the current value\n      of the variables. Its format is same as for initial of \n      DownhillSimplex\n   SimplexSize\
 -> size is the initial size of the simplex. Each variable\n      is relatively shifted by this amount from the current value.\n\n\
Example:\n   free Q* Q* L\n   fit nx .3 ny .2\n   OptimizeOptics[]\n\noptimizes the optics by changing the lengths of quads which \
are not allowed by GO, as well as K1 of quads."],
p$2327=1+p$2327[[1,2]];p1$2327=StringPosition["Usage: OptimizeOptics[options]\n\noptimizes (1 + MatchingResidual) or any function \
using DownhillSimplex with variables specified by FREE. Unlike GO, any keyword of any element can be a variable.\n   OptimizeOptic\
s returns the final simplex. The variables are set to the values which give the minimum of the function so far at the end.\n\nOpti\
ons:\n   All options for DownhillSimplex are valid.\n   OptimizeFunction -> fun is the function to be minimized. The default is\n \
     ((FFS[\"CALC\"];1+MatchingResidual)&).\n   InitialSimplex -> initial sets the initial simplex to initial. The\n      default \
is Null, which mean to create initial from the current value\n      of the variables. Its format is same as for initial of \n     \
 DownhillSimplex\n   SimplexSize -> size is the initial size of the simplex. Each variable\n      is relatively shifted by this am\
ount from the current value.\n\nExample:\n   free Q* Q* L\n   fit nx .3 ny .2\n   OptimizeOptics[]\n\noptimizes the optics by chan\
ging the lengths of quads which are not allowed by GO, as well as K1 of quads."[p$2327,-1],">::",1];
   p1$2327=If[p1$2327==={},1048,-2+p$2327+p1$2327[[1,1]]];
neq=Which["Usage: OptimizeOptics[options]\n\noptimizes (1 + MatchingResidual) or any function using DownhillSimplex with variables\
 specified by FREE. Unlike GO, any keyword of any element can be a variable.\n   OptimizeOptics returns the final simplex. The var\
iables are set to the values which give the minimum of the function so far at the end.\n\nOptions:\n   All options for DownhillSim\
plex are valid.\n   OptimizeFunction -> fun is the function to be minimized. The default is\n      ((FFS[\"CALC\"];1+MatchingResid\
ual)&).\n   InitialSimplex -> initial sets the initial simplex to initial. The\n      default is Null, which mean to create initia\
l from the current value\n      of the variables. Its format is same as for initial of \n      DownhillSimplex\n   SimplexSize -> \
size is the initial size of the simplex. Each variable\n      is relatively shifted by this amount from the current value.\n\nExam\
ple:\n   free Q* Q* L\n   fit nx .3 ny .2\n   OptimizeOptics[]\n\noptimizes the optics by changing the lengths of quads which are \
not allowed by GO, as well as K1 of quads."[p$2327,4+p$2327]==="Text[",
    lx$2327:=Help2HTML`oa$;p$2327=5+p$2327;p1$2327-=1;p2$2327=5+p1$2327;p0$2327=-9+p$2327;
If[(pe$2327=StringPosition["Usage: OptimizeOptics[options]\n\noptimizes (1 + MatchingResidual) or any function using DownhillSimpl\
ex with variables specified by FREE. Unlike GO, any keyword of any element can be a variable.\n   OptimizeOptics returns the final\
 simplex. The variables are set to the values which give the minimum of the function so far at the end.\n\nOptions:\n   All option\
s for DownhillSimplex are valid.\n   OptimizeFunction -> fun is the function to be minimized. The default is\n      ((FFS[\"CALC\"\
];1+MatchingResidual)&).\n   InitialSimplex -> initial sets the initial simplex to initial. The\n      default is Null, which mean\
 to create initial from the current value\n      of the variables. Its format is same as for initial of \n      DownhillSimplex\n \
  SimplexSize -> size is the initial size of the simplex. Each variable\n      is relatively shifted by this amount from the curre\
nt value.\n\nExample:\n   free Q* Q* L\n   fit nx .3 ny .2\n   OptimizeOptics[]\n\noptimizes the optics by changing the lengths of\
 quads which are not allowed by GO, as well as K1 of quads."[p$2327,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Usage: OptimizeOptics[options]\n\noptimizes (1 + MatchingResidual) or any function using DownhillSimplex with var\
iables specified by FREE. Unlike GO, any keyword of any element can be a variable.\n   OptimizeOptics returns the final simplex. T\
he variables are set to the values which give the minimum of the function so far at the end.\n\nOptions:\n   All options for Downh\
illSimplex are valid.\n   OptimizeFunction -> fun is the function to be minimized. The default is\n      ((FFS[\"CALC\"];1+Matchin\
gResidual)&).\n   InitialSimplex -> initial sets the initial simplex to initial. The\n      default is Null, which mean to create \
initial from the current value\n      of the variables. Its format is same as for initial of \n      DownhillSimplex\n   SimplexSi\
ze -> size is the initial size of the simplex. Each variable\n      is relatively shifted by this amount from the current value.\n\
\nExample:\n   free Q* Q* L\n   fit nx .3 ny .2\n   OptimizeOptics[]\n\noptimizes the optics by changing the lengths of quads whic\
h are not allowed by GO, as well as K1 of quads."[p$2327+pe$2327[[1,2]],p1$2327]]],
        p1$2327=-2+p$2327+pe$2327[[1,1]]}[[
       1]],
      0],
    1,lx$2327:=Help2HTML`o9$;p2$2327=4+p1$2327;p0$2327=-4+p$2327;0];
  If[(equ$2327=
Help2HTML`o8$["Usage: OptimizeOptics[options]\n\noptimizes (1 + MatchingResidual) or any function using DownhillSimplex with varia\
bles specified by FREE. Unlike GO, any keyword of any element can be a variable.\n   OptimizeOptics returns the final simplex. The\
 variables are set to the values which give the minimum of the function so far at the end.\n\nOptions:\n   All options for Downhil\
lSimplex are valid.\n   OptimizeFunction -> fun is the function to be minimized. The default is\n      ((FFS[\"CALC\"];1+MatchingR\
esidual)&).\n   InitialSimplex -> initial sets the initial simplex to initial. The\n      default is Null, which mean to create in\
itial from the current value\n      of the variables. Its format is same as for initial of \n      DownhillSimplex\n   SimplexSize\
 -> size is the initial size of the simplex. Each variable\n      is relatively shifted by this amount from the current value.\n\n\
Example:\n   free Q* Q* L\n   fit nx .3 ny .2\n   OptimizeOptics[]\n\noptimizes the optics by changing the lengths of quads which \
are not allowed by GO, as well as K1 of quads."[p$2327,p1$2327]])===
    Undefined,
equ$2327="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Usage: OptimizeOptics[options]\n\noptimizes \
(1 + MatchingResidual) or any function using DownhillSimplex with variables specified by FREE. Unlike GO, any keyword of any eleme\
nt can be a variable.\n   OptimizeOptics returns the final simplex. The variables are set to the values which give the minimum of \
the function so far at the end.\n\nOptions:\n   All options for DownhillSimplex are valid.\n   OptimizeFunction -> fun is the func\
tion to be minimized. The default is\n      ((FFS[\"CALC\"];1+MatchingResidual)&).\n   InitialSimplex -> initial sets the initial \
simplex to initial. The\n      default is Null, which mean to create initial from the current value\n      of the variables. Its f\
ormat is same as for initial of \n      DownhillSimplex\n   SimplexSize -> size is the initial size of the simplex. Each variable\\
n      is relatively shifted by this amount from the current value.\n\nExample:\n   free Q* Q* L\n   fit nx .3 ny .2\n   OptimizeO\
ptics[]\n\noptimizes the optics by changing the lengths of quads which are not allowed by GO, as well as K1 of quads."[p$2327,
         p1$2327]]=
       equ$2327;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2327},out$2327=lx$2327@Typeset["Usage: OptimizeOptics[options]\n\noptimizes (1 + MatchingResidual) or any function using \
DownhillSimplex with variables specified by FREE. Unlike GO, any keyword of any element can be a variable.\n   OptimizeOptics retu\
rns the final simplex. The variables are set to the values which give the minimum of the function so far at the end.\n\nOptions:\n\
   All options for DownhillSimplex are valid.\n   OptimizeFunction -> fun is the function to be minimized. The default is\n      (\
(FFS[\"CALC\"];1+MatchingResidual)&).\n   InitialSimplex -> initial sets the initial simplex to initial. The\n      default is Nul\
l, which mean to create initial from the current value\n      of the variables. Its format is same as for initial of \n      Downh\
illSimplex\n   SimplexSize -> size is the initial size of the simplex. Each variable\n      is relatively shifted by this amount f\
rom the current value.\n\nExample:\n   free Q* Q* L\n   fit nx .3 ny .2\n   OptimizeOptics[]\n\noptimizes the optics by changing t\
he lengths of quads which are not allowed by GO, as well as K1 of quads."[p$2327,p1$2327],Format->Help2HTML`oB$];
        System["mv -f "//out$2327//" "//equ$2327]];
      Exit[]]];
   "Usage: OptimizeOptics[options]\n\noptimizes (1 + MatchingResidual) or any function using DownhillSimplex with variables specif\
ied by FREE. Unlike GO, any keyword of any element can be a variable.\n   OptimizeOptics returns the final simplex. The variables \
are set to the values which give the minimum of the function so far at the end.\n\nOptions:\n   All options for DownhillSimplex ar\
e valid.\n   OptimizeFunction -> fun is the function to be minimized. The default is\n      ((FFS[\"CALC\"];1+MatchingResidual)&).\
\n   InitialSimplex -> initial sets the initial simplex to initial. The\n      default is Null, which mean to create initial from \
the current value\n      of the variables. Its format is same as for initial of \n      DownhillSimplex\n   SimplexSize -> size is\
 the initial size of the simplex. Each variable\n      is relatively shifted by this amount from the current value.\n\nExample:\n \
  free Q* Q* L\n   fit nx .3 ny .2\n   OptimizeOptics[]\n\noptimizes the optics by changing the lengths of quads which are not all\
owed by GO, as well as K1 of quads."[1,Max[p0$2327,0]]//"<img  class=\"eqs\" SRC=\""//equ$2327//"\" />"//
Help2HTML`oy$["Usage: OptimizeOptics[options]\n\noptimizes (1 + MatchingResidual) or any function using DownhillSimplex with varia\
bles specified by FREE. Unlike GO, any keyword of any element can be a variable.\n   OptimizeOptics returns the final simplex. The\
 variables are set to the values which give the minimum of the function so far at the end.\n\nOptions:\n   All options for Downhil\
lSimplex are valid.\n   OptimizeFunction -> fun is the function to be minimized. The default is\n      ((FFS[\"CALC\"];1+MatchingR\
esidual)&).\n   InitialSimplex -> initial sets the initial simplex to initial. The\n      default is Null, which mean to create in\
itial from the current value\n      of the variables. Its format is same as for initial of \n      DownhillSimplex\n   SimplexSize\
 -> size is the initial size of the simplex. Each variable\n      is relatively shifted by this amount from the current value.\n\n\
Example:\n   free Q* Q* L\n   fit nx .3 ny .2\n   OptimizeOptics[]\n\noptimizes the optics by changing the lengths of quads which \
are not allowed by GO, as well as K1 of quads."[p2$2327,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L366>DownhillSimplex</A></PRE>
<LI>
<H3><A NAME=L401>
OrbitGeo</A></H3>
<PRE>If[{},Help2HTML`oA$["OrbitGeo[location] returns the geometry {GX, GY, GZ} of the current (not design) orbit."],
 p$2330=1+p$2330[[1,2]];
  p1$2330=StringPosition["OrbitGeo[location] returns the geometry {GX, GY, GZ} of the current (not design) orbit."[p$2330,-1],
    ">::",1];
   p1$2330=If[p1$2330==={},87,-2+p$2330+p1$2330[[1,1]]];
  neq=Which["OrbitGeo[location] returns the geometry {GX, GY, GZ} of the current (not design) orbit."[p$2330,4+p$2330]==="Text[",
    lx$2330:=Help2HTML`oa$;p$2330=5+p$2330;p1$2330-=1;p2$2330=5+p1$2330;p0$2330=-9+p$2330;
     If[(pe$2330=StringPosition["OrbitGeo[location] returns the geometry {GX, GY, GZ} of the current (not design) orbit."[p$2330,-2
          ],
         ";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression["OrbitGeo[location] returns the geometry {GX, GY, GZ} of the current (not design) orbit."[p$2330+pe$2330[[
             1,2]],
           p1$2330]]],
        p1$2330=-2+p$2330+pe$2330[[1,1]]}[[
       1]],
      0],
    1,lx$2330:=Help2HTML`o9$;p2$2330=4+p1$2330;p0$2330=-4+p$2330;0];
  If[(equ$2330=
     Help2HTML`o8$["OrbitGeo[location] returns the geometry {GX, GY, GZ} of the current (not design) orbit."[p$2330,p1$2330]])===
    Undefined,
   equ$2330="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "OrbitGeo[location] returns the geometry {GX, GY, GZ} of the current (not design) orbit."[p$2330,p1$2330]]=
       equ$2330;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$2330},out$2330=lx$2330@Typeset[
          "OrbitGeo[location] returns the geometry {GX, GY, GZ} of the current (not design) orbit."[p$2330,p1$2330],
          Format->Help2HTML`oB$];
        System["mv -f "//out$2330//" "//equ$2330]];
      Exit[]]];
   "OrbitGeo[location] returns the geometry {GX, GY, GZ} of the current (not design) orbit."[1,Max[p0$2330,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2330//"\" />"//
   Help2HTML`oy$["OrbitGeo[location] returns the geometry {GX, GY, GZ} of the current (not design) orbit."[p2$2330,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L245>GEO</A> <A HREF=#L397>GeoBase</A></PRE>
<LI>
<H3><A NAME=L402>
RadiationField</A></H3>
<PRE>If[{},
Help2HTML`oA$["To calculate the field of the synchrotron radiation from particles, first record trajectories of particles. This is\
 done by the function TrackParticles with a new flag RADLIGHT on. When RADLIGHT is on, TrackParticles returns a list\n\n   {beam, \
trajectory} ,\n\nwhere beam is a list as {location, coordinates}, and trajectory is a list\n\n   { {t1 .. tm}, {x1 ..xm}, {y1 .. y\
m}, {z1 .. zm} }, ..\n\nwhere {t,x,y,z}_i is the coordinates of the particle at i-th point in the trajectory. The origin and the d\
irection of the spatial coordinates are the same as GEO coordinate {GX, GY, GZ}. One can track many particles at the same time by \
TrackParticles, so the trajectory has the dimensions {np, m}, where np is the number of particles.\n\n   After the trajectory is o\
btained, one can calculate the field in time domain\nat any observation point. This is done by the function RadiationFiled as\n\n \
  field = RadiationField[ trajectory[[i]], obs];\n\nwhere trajectory[[i]] is the trajectory of the i-th particle, and obs is the s\
patial coordinate of the observation point in the GEO coordinate. The output field is a list\n\n   { {tau1 .. taum},\n     {Ex1 ..\
 Exm}, {Ey1 .. Eym}, {Ez1 .. Ezm},\n     {Hx1 .. Hxm}, {Hy1 .. Hym}, {Hz1 .. Hzm},\n     {Sx1 .. Sxm}, {Sy1 .. Sym}, {Sz1 .. Hzm} \
}\n\nwhere H = (n x E)/(c mu0) and S = E x H , and tau is the observation time.\n   RadiationField uses the Feynmann-Heviside form\
ula\n\n   E = (mu0 e*CHARGE/4pi) (c^2n/R^2 + R/c d(c^2n/R^2)/dt + d^2n/dt^2) ,\n where n and R are the direction vector and the di\
stance from the electron at the retarded time to an observation point. \n   The derivatives in the above formula is calculated usi\
ng the spline\ninterpolation.\n\n   Next one can calculate the spectrum of the field by RadiationSpectrum as\n\n   spect = Radiati\
onSpectrum[ {field[[1]], field[[k]]},\n        {lambda1, lambda2, dlambda} ] ,\n\nwhere filed[[k]] is one of the fields calculated\
 by RadiationField. The range of the wavelength is given as a list above. The output spectrum spect is a list as\n\n   { {k1 .. kk\
}, {c1 .. ck}, {s1 .. sk} } ,\n\nwhere k1 .. kk is the wave number k = omega/c, c1 .. ck and s1 .. sk are the cosine and sine inte\
grals of the field in tau1 .. taum , i.e.,\n\n   ck + I sk = Integrate[ field[tau] Exp[I c k tau] dtau] .\n\n   An example is seen\
 in $(SAD_ROOTPATH)/sad/examples.sad ."],
p$2333=1+p$2333[[1,2]];p1$2333=StringPosition["To calculate the field of the synchrotron radiation from particles, first record tr\
ajectories of particles. This is done by the function TrackParticles with a new flag RADLIGHT on. When RADLIGHT is on, TrackPartic\
les returns a list\n\n   {beam, trajectory} ,\n\nwhere beam is a list as {location, coordinates}, and trajectory is a list\n\n   {\
 {t1 .. tm}, {x1 ..xm}, {y1 .. ym}, {z1 .. zm} }, ..\n\nwhere {t,x,y,z}_i is the coordinates of the particle at i-th point in the \
trajectory. The origin and the direction of the spatial coordinates are the same as GEO coordinate {GX, GY, GZ}. One can track man\
y particles at the same time by TrackParticles, so the trajectory has the dimensions {np, m}, where np is the number of particles.\
\n\n   After the trajectory is obtained, one can calculate the field in time domain\nat any observation point. This is done by the\
 function RadiationFiled as\n\n   field = RadiationField[ trajectory[[i]], obs];\n\nwhere trajectory[[i]] is the trajectory of the\
 i-th particle, and obs is the spatial coordinate of the observation point in the GEO coordinate. The output field is a list\n\n  \
 { {tau1 .. taum},\n     {Ex1 .. Exm}, {Ey1 .. Eym}, {Ez1 .. Ezm},\n     {Hx1 .. Hxm}, {Hy1 .. Hym}, {Hz1 .. Hzm},\n     {Sx1 .. S\
xm}, {Sy1 .. Sym}, {Sz1 .. Hzm} }\n\nwhere H = (n x E)/(c mu0) and S = E x H , and tau is the observation time.\n   RadiationField\
 uses the Feynmann-Heviside formula\n\n   E = (mu0 e*CHARGE/4pi) (c^2n/R^2 + R/c d(c^2n/R^2)/dt + d^2n/dt^2) ,\n where n and R are\
 the direction vector and the distance from the electron at the retarded time to an observation point. \n   The derivatives in the\
 above formula is calculated using the spline\ninterpolation.\n\n   Next one can calculate the spectrum of the field by RadiationS\
pectrum as\n\n   spect = RadiationSpectrum[ {field[[1]], field[[k]]},\n        {lambda1, lambda2, dlambda} ] ,\n\nwhere filed[[k]]\
 is one of the fields calculated by RadiationField. The range of the wavelength is given as a list above. The output spectrum spec\
t is a list as\n\n   { {k1 .. kk}, {c1 .. ck}, {s1 .. sk} } ,\n\nwhere k1 .. kk is the wave number k = omega/c, c1 .. ck and s1 ..\
 sk are the cosine and sine integrals of the field in tau1 .. taum , i.e.,\n\n   ck + I sk = Integrate[ field[tau] Exp[I c k tau] \
dtau] .\n\n   An example is seen in $(SAD_ROOTPATH)/sad/examples.sad ."[p$2333,-1],">::",1];
   p1$2333=If[p1$2333==={},2320,-2+p$2333+p1$2333[[1,1]]];
neq=Which["To calculate the field of the synchrotron radiation from particles, first record trajectories of particles. This is don\
e by the function TrackParticles with a new flag RADLIGHT on. When RADLIGHT is on, TrackParticles returns a list\n\n   {beam, traj\
ectory} ,\n\nwhere beam is a list as {location, coordinates}, and trajectory is a list\n\n   { {t1 .. tm}, {x1 ..xm}, {y1 .. ym}, \
{z1 .. zm} }, ..\n\nwhere {t,x,y,z}_i is the coordinates of the particle at i-th point in the trajectory. The origin and the direc\
tion of the spatial coordinates are the same as GEO coordinate {GX, GY, GZ}. One can track many particles at the same time by Trac\
kParticles, so the trajectory has the dimensions {np, m}, where np is the number of particles.\n\n   After the trajectory is obtai\
ned, one can calculate the field in time domain\nat any observation point. This is done by the function RadiationFiled as\n\n   fi\
eld = RadiationField[ trajectory[[i]], obs];\n\nwhere trajectory[[i]] is the trajectory of the i-th particle, and obs is the spati\
al coordinate of the observation point in the GEO coordinate. The output field is a list\n\n   { {tau1 .. taum},\n     {Ex1 .. Exm\
}, {Ey1 .. Eym}, {Ez1 .. Ezm},\n     {Hx1 .. Hxm}, {Hy1 .. Hym}, {Hz1 .. Hzm},\n     {Sx1 .. Sxm}, {Sy1 .. Sym}, {Sz1 .. Hzm} }\n\\
nwhere H = (n x E)/(c mu0) and S = E x H , and tau is the observation time.\n   RadiationField uses the Feynmann-Heviside formula\\
n\n   E = (mu0 e*CHARGE/4pi) (c^2n/R^2 + R/c d(c^2n/R^2)/dt + d^2n/dt^2) ,\n where n and R are the direction vector and the distan\
ce from the electron at the retarded time to an observation point. \n   The derivatives in the above formula is calculated using t\
he spline\ninterpolation.\n\n   Next one can calculate the spectrum of the field by RadiationSpectrum as\n\n   spect = RadiationSp\
ectrum[ {field[[1]], field[[k]]},\n        {lambda1, lambda2, dlambda} ] ,\n\nwhere filed[[k]] is one of the fields calculated by \
RadiationField. The range of the wavelength is given as a list above. The output spectrum spect is a list as\n\n   { {k1 .. kk}, {\
c1 .. ck}, {s1 .. sk} } ,\n\nwhere k1 .. kk is the wave number k = omega/c, c1 .. ck and s1 .. sk are the cosine and sine integral\
s of the field in tau1 .. taum , i.e.,\n\n   ck + I sk = Integrate[ field[tau] Exp[I c k tau] dtau] .\n\n   An example is seen in \
$(SAD_ROOTPATH)/sad/examples.sad ."[p$2333,4+p$2333]==="Text[",
    lx$2333:=Help2HTML`oa$;p$2333=5+p$2333;p1$2333-=1;p2$2333=5+p1$2333;p0$2333=-9+p$2333;
If[(pe$2333=StringPosition["To calculate the field of the synchrotron radiation from particles, first record trajectories of parti\
cles. This is done by the function TrackParticles with a new flag RADLIGHT on. When RADLIGHT is on, TrackParticles returns a list\\
n\n   {beam, trajectory} ,\n\nwhere beam is a list as {location, coordinates}, and trajectory is a list\n\n   { {t1 .. tm}, {x1 ..\
xm}, {y1 .. ym}, {z1 .. zm} }, ..\n\nwhere {t,x,y,z}_i is the coordinates of the particle at i-th point in the trajectory. The ori\
gin and the direction of the spatial coordinates are the same as GEO coordinate {GX, GY, GZ}. One can track many particles at the \
same time by TrackParticles, so the trajectory has the dimensions {np, m}, where np is the number of particles.\n\n   After the tr\
ajectory is obtained, one can calculate the field in time domain\nat any observation point. This is done by the function Radiation\
Filed as\n\n   field = RadiationField[ trajectory[[i]], obs];\n\nwhere trajectory[[i]] is the trajectory of the i-th particle, and\
 obs is the spatial coordinate of the observation point in the GEO coordinate. The output field is a list\n\n   { {tau1 .. taum},\\
n     {Ex1 .. Exm}, {Ey1 .. Eym}, {Ez1 .. Ezm},\n     {Hx1 .. Hxm}, {Hy1 .. Hym}, {Hz1 .. Hzm},\n     {Sx1 .. Sxm}, {Sy1 .. Sym}, \
{Sz1 .. Hzm} }\n\nwhere H = (n x E)/(c mu0) and S = E x H , and tau is the observation time.\n   RadiationField uses the Feynmann-\
Heviside formula\n\n   E = (mu0 e*CHARGE/4pi) (c^2n/R^2 + R/c d(c^2n/R^2)/dt + d^2n/dt^2) ,\n where n and R are the direction vect\
or and the distance from the electron at the retarded time to an observation point. \n   The derivatives in the above formula is c\
alculated using the spline\ninterpolation.\n\n   Next one can calculate the spectrum of the field by RadiationSpectrum as\n\n   sp\
ect = RadiationSpectrum[ {field[[1]], field[[k]]},\n        {lambda1, lambda2, dlambda} ] ,\n\nwhere filed[[k]] is one of the fiel\
ds calculated by RadiationField. The range of the wavelength is given as a list above. The output spectrum spect is a list as\n\n \
  { {k1 .. kk}, {c1 .. ck}, {s1 .. sk} } ,\n\nwhere k1 .. kk is the wave number k = omega/c, c1 .. ck and s1 .. sk are the cosine \
and sine integrals of the field in tau1 .. taum , i.e.,\n\n   ck + I sk = Integrate[ field[tau] Exp[I c k tau] dtau] .\n\n   An ex\
ample is seen in $(SAD_ROOTPATH)/sad/examples.sad ."[p$2333,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["To calculate the field of the synchrotron radiation from particles, first record trajectories of particles. This \
is done by the function TrackParticles with a new flag RADLIGHT on. When RADLIGHT is on, TrackParticles returns a list\n\n   {beam\
, trajectory} ,\n\nwhere beam is a list as {location, coordinates}, and trajectory is a list\n\n   { {t1 .. tm}, {x1 ..xm}, {y1 ..\
 ym}, {z1 .. zm} }, ..\n\nwhere {t,x,y,z}_i is the coordinates of the particle at i-th point in the trajectory. The origin and the\
 direction of the spatial coordinates are the same as GEO coordinate {GX, GY, GZ}. One can track many particles at the same time b\
y TrackParticles, so the trajectory has the dimensions {np, m}, where np is the number of particles.\n\n   After the trajectory is\
 obtained, one can calculate the field in time domain\nat any observation point. This is done by the function RadiationFiled as\n\\
n   field = RadiationField[ trajectory[[i]], obs];\n\nwhere trajectory[[i]] is the trajectory of the i-th particle, and obs is the\
 spatial coordinate of the observation point in the GEO coordinate. The output field is a list\n\n   { {tau1 .. taum},\n     {Ex1 \
.. Exm}, {Ey1 .. Eym}, {Ez1 .. Ezm},\n     {Hx1 .. Hxm}, {Hy1 .. Hym}, {Hz1 .. Hzm},\n     {Sx1 .. Sxm}, {Sy1 .. Sym}, {Sz1 .. Hzm\
} }\n\nwhere H = (n x E)/(c mu0) and S = E x H , and tau is the observation time.\n   RadiationField uses the Feynmann-Heviside fo\
rmula\n\n   E = (mu0 e*CHARGE/4pi) (c^2n/R^2 + R/c d(c^2n/R^2)/dt + d^2n/dt^2) ,\n where n and R are the direction vector and the \
distance from the electron at the retarded time to an observation point. \n   The derivatives in the above formula is calculated u\
sing the spline\ninterpolation.\n\n   Next one can calculate the spectrum of the field by RadiationSpectrum as\n\n   spect = Radia\
tionSpectrum[ {field[[1]], field[[k]]},\n        {lambda1, lambda2, dlambda} ] ,\n\nwhere filed[[k]] is one of the fields calculat\
ed by RadiationField. The range of the wavelength is given as a list above. The output spectrum spect is a list as\n\n   { {k1 .. \
kk}, {c1 .. ck}, {s1 .. sk} } ,\n\nwhere k1 .. kk is the wave number k = omega/c, c1 .. ck and s1 .. sk are the cosine and sine in\
tegrals of the field in tau1 .. taum , i.e.,\n\n   ck + I sk = Integrate[ field[tau] Exp[I c k tau] dtau] .\n\n   An example is se\
en in $(SAD_ROOTPATH)/sad/examples.sad ."[p$2333+pe$2333[[1,2]],p1$2333]]],
        p1$2333=-2+p$2333+pe$2333[[1,1]]}[[
       1]],
      0],
    1,lx$2333:=Help2HTML`o9$;p2$2333=4+p1$2333;p0$2333=-4+p$2333;0];
  If[(equ$2333=
Help2HTML`o8$["To calculate the field of the synchrotron radiation from particles, first record trajectories of particles. This is\
 done by the function TrackParticles with a new flag RADLIGHT on. When RADLIGHT is on, TrackParticles returns a list\n\n   {beam, \
trajectory} ,\n\nwhere beam is a list as {location, coordinates}, and trajectory is a list\n\n   { {t1 .. tm}, {x1 ..xm}, {y1 .. y\
m}, {z1 .. zm} }, ..\n\nwhere {t,x,y,z}_i is the coordinates of the particle at i-th point in the trajectory. The origin and the d\
irection of the spatial coordinates are the same as GEO coordinate {GX, GY, GZ}. One can track many particles at the same time by \
TrackParticles, so the trajectory has the dimensions {np, m}, where np is the number of particles.\n\n   After the trajectory is o\
btained, one can calculate the field in time domain\nat any observation point. This is done by the function RadiationFiled as\n\n \
  field = RadiationField[ trajectory[[i]], obs];\n\nwhere trajectory[[i]] is the trajectory of the i-th particle, and obs is the s\
patial coordinate of the observation point in the GEO coordinate. The output field is a list\n\n   { {tau1 .. taum},\n     {Ex1 ..\
 Exm}, {Ey1 .. Eym}, {Ez1 .. Ezm},\n     {Hx1 .. Hxm}, {Hy1 .. Hym}, {Hz1 .. Hzm},\n     {Sx1 .. Sxm}, {Sy1 .. Sym}, {Sz1 .. Hzm} \
}\n\nwhere H = (n x E)/(c mu0) and S = E x H , and tau is the observation time.\n   RadiationField uses the Feynmann-Heviside form\
ula\n\n   E = (mu0 e*CHARGE/4pi) (c^2n/R^2 + R/c d(c^2n/R^2)/dt + d^2n/dt^2) ,\n where n and R are the direction vector and the di\
stance from the electron at the retarded time to an observation point. \n   The derivatives in the above formula is calculated usi\
ng the spline\ninterpolation.\n\n   Next one can calculate the spectrum of the field by RadiationSpectrum as\n\n   spect = Radiati\
onSpectrum[ {field[[1]], field[[k]]},\n        {lambda1, lambda2, dlambda} ] ,\n\nwhere filed[[k]] is one of the fields calculated\
 by RadiationField. The range of the wavelength is given as a list above. The output spectrum spect is a list as\n\n   { {k1 .. kk\
}, {c1 .. ck}, {s1 .. sk} } ,\n\nwhere k1 .. kk is the wave number k = omega/c, c1 .. ck and s1 .. sk are the cosine and sine inte\
grals of the field in tau1 .. taum , i.e.,\n\n   ck + I sk = Integrate[ field[tau] Exp[I c k tau] dtau] .\n\n   An example is seen\
 in $(SAD_ROOTPATH)/sad/examples.sad ."[p$2333,p1$2333]])===
    Undefined,
equ$2333="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["To calculate the field of the synchrotron ra\
diation from particles, first record trajectories of particles. This is done by the function TrackParticles with a new flag RADLIG\
HT on. When RADLIGHT is on, TrackParticles returns a list\n\n   {beam, trajectory} ,\n\nwhere beam is a list as {location, coordin\
ates}, and trajectory is a list\n\n   { {t1 .. tm}, {x1 ..xm}, {y1 .. ym}, {z1 .. zm} }, ..\n\nwhere {t,x,y,z}_i is the coordinate\
s of the particle at i-th point in the trajectory. The origin and the direction of the spatial coordinates are the same as GEO coo\
rdinate {GX, GY, GZ}. One can track many particles at the same time by TrackParticles, so the trajectory has the dimensions {np, m\
}, where np is the number of particles.\n\n   After the trajectory is obtained, one can calculate the field in time domain\nat any\
 observation point. This is done by the function RadiationFiled as\n\n   field = RadiationField[ trajectory[[i]], obs];\n\nwhere t\
rajectory[[i]] is the trajectory of the i-th particle, and obs is the spatial coordinate of the observation point in the GEO coord\
inate. The output field is a list\n\n   { {tau1 .. taum},\n     {Ex1 .. Exm}, {Ey1 .. Eym}, {Ez1 .. Ezm},\n     {Hx1 .. Hxm}, {Hy1\
 .. Hym}, {Hz1 .. Hzm},\n     {Sx1 .. Sxm}, {Sy1 .. Sym}, {Sz1 .. Hzm} }\n\nwhere H = (n x E)/(c mu0) and S = E x H , and tau is t\
he observation time.\n   RadiationField uses the Feynmann-Heviside formula\n\n   E = (mu0 e*CHARGE/4pi) (c^2n/R^2 + R/c d(c^2n/R^2\
)/dt + d^2n/dt^2) ,\n where n and R are the direction vector and the distance from the electron at the retarded time to an observa\
tion point. \n   The derivatives in the above formula is calculated using the spline\ninterpolation.\n\n   Next one can calculate \
the spectrum of the field by RadiationSpectrum as\n\n   spect = RadiationSpectrum[ {field[[1]], field[[k]]},\n        {lambda1, la\
mbda2, dlambda} ] ,\n\nwhere filed[[k]] is one of the fields calculated by RadiationField. The range of the wavelength is given as\
 a list above. The output spectrum spect is a list as\n\n   { {k1 .. kk}, {c1 .. ck}, {s1 .. sk} } ,\n\nwhere k1 .. kk is the wave\
 number k = omega/c, c1 .. ck and s1 .. sk are the cosine and sine integrals of the field in tau1 .. taum , i.e.,\n\n   ck + I sk \
= Integrate[ field[tau] Exp[I c k tau] dtau] .\n\n   An example is seen in $(SAD_ROOTPATH)/sad/examples.sad ."[p$2333,p1$2333]]=
       equ$2333;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2333},out$2333=lx$2333@Typeset["To calculate the field of the synchrotron radiation from particles, first record trajecto\
ries of particles. This is done by the function TrackParticles with a new flag RADLIGHT on. When RADLIGHT is on, TrackParticles re\
turns a list\n\n   {beam, trajectory} ,\n\nwhere beam is a list as {location, coordinates}, and trajectory is a list\n\n   { {t1 .\
. tm}, {x1 ..xm}, {y1 .. ym}, {z1 .. zm} }, ..\n\nwhere {t,x,y,z}_i is the coordinates of the particle at i-th point in the trajec\
tory. The origin and the direction of the spatial coordinates are the same as GEO coordinate {GX, GY, GZ}. One can track many part\
icles at the same time by TrackParticles, so the trajectory has the dimensions {np, m}, where np is the number of particles.\n\n  \
 After the trajectory is obtained, one can calculate the field in time domain\nat any observation point. This is done by the funct\
ion RadiationFiled as\n\n   field = RadiationField[ trajectory[[i]], obs];\n\nwhere trajectory[[i]] is the trajectory of the i-th \
particle, and obs is the spatial coordinate of the observation point in the GEO coordinate. The output field is a list\n\n   { {ta\
u1 .. taum},\n     {Ex1 .. Exm}, {Ey1 .. Eym}, {Ez1 .. Ezm},\n     {Hx1 .. Hxm}, {Hy1 .. Hym}, {Hz1 .. Hzm},\n     {Sx1 .. Sxm}, {\
Sy1 .. Sym}, {Sz1 .. Hzm} }\n\nwhere H = (n x E)/(c mu0) and S = E x H , and tau is the observation time.\n   RadiationField uses \
the Feynmann-Heviside formula\n\n   E = (mu0 e*CHARGE/4pi) (c^2n/R^2 + R/c d(c^2n/R^2)/dt + d^2n/dt^2) ,\n where n and R are the d\
irection vector and the distance from the electron at the retarded time to an observation point. \n   The derivatives in the above\
 formula is calculated using the spline\ninterpolation.\n\n   Next one can calculate the spectrum of the field by RadiationSpectru\
m as\n\n   spect = RadiationSpectrum[ {field[[1]], field[[k]]},\n        {lambda1, lambda2, dlambda} ] ,\n\nwhere filed[[k]] is on\
e of the fields calculated by RadiationField. The range of the wavelength is given as a list above. The output spectrum spect is a\
 list as\n\n   { {k1 .. kk}, {c1 .. ck}, {s1 .. sk} } ,\n\nwhere k1 .. kk is the wave number k = omega/c, c1 .. ck and s1 .. sk ar\
e the cosine and sine integrals of the field in tau1 .. taum , i.e.,\n\n   ck + I sk = Integrate[ field[tau] Exp[I c k tau] dtau] \
.\n\n   An example is seen in $(SAD_ROOTPATH)/sad/examples.sad ."[p$2333,p1$2333],Format->Help2HTML`oB$];
        System["mv -f "//out$2333//" "//equ$2333]];
      Exit[]]];
   "To calculate the field of the synchrotron radiation from particles, first record trajectories of particles. This is done by th\
e function TrackParticles with a new flag RADLIGHT on. When RADLIGHT is on, TrackParticles returns a list\n\n   {beam, trajectory}\
 ,\n\nwhere beam is a list as {location, coordinates}, and trajectory is a list\n\n   { {t1 .. tm}, {x1 ..xm}, {y1 .. ym}, {z1 .. \
zm} }, ..\n\nwhere {t,x,y,z}_i is the coordinates of the particle at i-th point in the trajectory. The origin and the direction of\
 the spatial coordinates are the same as GEO coordinate {GX, GY, GZ}. One can track many particles at the same time by TrackPartic\
les, so the trajectory has the dimensions {np, m}, where np is the number of particles.\n\n   After the trajectory is obtained, on\
e can calculate the field in time domain\nat any observation point. This is done by the function RadiationFiled as\n\n   field = R\
adiationField[ trajectory[[i]], obs];\n\nwhere trajectory[[i]] is the trajectory of the i-th particle, and obs is the spatial coor\
dinate of the observation point in the GEO coordinate. The output field is a list\n\n   { {tau1 .. taum},\n     {Ex1 .. Exm}, {Ey1\
 .. Eym}, {Ez1 .. Ezm},\n     {Hx1 .. Hxm}, {Hy1 .. Hym}, {Hz1 .. Hzm},\n     {Sx1 .. Sxm}, {Sy1 .. Sym}, {Sz1 .. Hzm} }\n\nwhere \
H = (n x E)/(c mu0) and S = E x H , and tau is the observation time.\n   RadiationField uses the Feynmann-Heviside formula\n\n   E\
 = (mu0 e*CHARGE/4pi) (c^2n/R^2 + R/c d(c^2n/R^2)/dt + d^2n/dt^2) ,\n where n and R are the direction vector and the distance from\
 the electron at the retarded time to an observation point. \n   The derivatives in the above formula is calculated using the spli\
ne\ninterpolation.\n\n   Next one can calculate the spectrum of the field by RadiationSpectrum as\n\n   spect = RadiationSpectrum[\
 {field[[1]], field[[k]]},\n        {lambda1, lambda2, dlambda} ] ,\n\nwhere filed[[k]] is one of the fields calculated by Radiati\
onField. The range of the wavelength is given as a list above. The output spectrum spect is a list as\n\n   { {k1 .. kk}, {c1 .. c\
k}, {s1 .. sk} } ,\n\nwhere k1 .. kk is the wave number k = omega/c, c1 .. ck and s1 .. sk are the cosine and sine integrals of th\
e field in tau1 .. taum , i.e.,\n\n   ck + I sk = Integrate[ field[tau] Exp[I c k tau] dtau] .\n\n   An example is seen in $(SAD_R\
OOTPATH)/sad/examples.sad ."[1,Max[p0$2333,0]]//"<img  class=\"eqs\" SRC=\""//equ$2333//"\" />"//
Help2HTML`oy$["To calculate the field of the synchrotron radiation from particles, first record trajectories of particles. This is\
 done by the function TrackParticles with a new flag RADLIGHT on. When RADLIGHT is on, TrackParticles returns a list\n\n   {beam, \
trajectory} ,\n\nwhere beam is a list as {location, coordinates}, and trajectory is a list\n\n   { {t1 .. tm}, {x1 ..xm}, {y1 .. y\
m}, {z1 .. zm} }, ..\n\nwhere {t,x,y,z}_i is the coordinates of the particle at i-th point in the trajectory. The origin and the d\
irection of the spatial coordinates are the same as GEO coordinate {GX, GY, GZ}. One can track many particles at the same time by \
TrackParticles, so the trajectory has the dimensions {np, m}, where np is the number of particles.\n\n   After the trajectory is o\
btained, one can calculate the field in time domain\nat any observation point. This is done by the function RadiationFiled as\n\n \
  field = RadiationField[ trajectory[[i]], obs];\n\nwhere trajectory[[i]] is the trajectory of the i-th particle, and obs is the s\
patial coordinate of the observation point in the GEO coordinate. The output field is a list\n\n   { {tau1 .. taum},\n     {Ex1 ..\
 Exm}, {Ey1 .. Eym}, {Ez1 .. Ezm},\n     {Hx1 .. Hxm}, {Hy1 .. Hym}, {Hz1 .. Hzm},\n     {Sx1 .. Sxm}, {Sy1 .. Sym}, {Sz1 .. Hzm} \
}\n\nwhere H = (n x E)/(c mu0) and S = E x H , and tau is the observation time.\n   RadiationField uses the Feynmann-Heviside form\
ula\n\n   E = (mu0 e*CHARGE/4pi) (c^2n/R^2 + R/c d(c^2n/R^2)/dt + d^2n/dt^2) ,\n where n and R are the direction vector and the di\
stance from the electron at the retarded time to an observation point. \n   The derivatives in the above formula is calculated usi\
ng the spline\ninterpolation.\n\n   Next one can calculate the spectrum of the field by RadiationSpectrum as\n\n   spect = Radiati\
onSpectrum[ {field[[1]], field[[k]]},\n        {lambda1, lambda2, dlambda} ] ,\n\nwhere filed[[k]] is one of the fields calculated\
 by RadiationField. The range of the wavelength is given as a list above. The output spectrum spect is a list as\n\n   { {k1 .. kk\
}, {c1 .. ck}, {s1 .. sk} } ,\n\nwhere k1 .. kk is the wave number k = omega/c, c1 .. ck and s1 .. sk are the cosine and sine inte\
grals of the field in tau1 .. taum , i.e.,\n\n   ck + I sk = Integrate[ field[tau] Exp[I c k tau] dtau] .\n\n   An example is seen\
 in $(SAD_ROOTPATH)/sad/examples.sad ."[p2$2333,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L409>TrackParticles</A> <A HREF=#L339>RADLIGHT</A></PRE>
<LI>
<H3><A NAME=L403>
RadiationSpectrum</A></H3>
<PRE>If[{},
Help2HTML`oA$["To calculate the field of the synchrotron radiation from particles, first record trajectories of particles. This is\
 done by the function TrackParticles with a new flag RADLIGHT on. When RADLIGHT is on, TrackParticles returns a list\n\n   {beam, \
trajectory} ,\n\nwhere beam is a list as {location, coordinates}, and trajectory is a list\n\n   { {t1 .. tm}, {x1 ..xm}, {y1 .. y\
m}, {z1 .. zm} }, ..\n\nwhere {t,x,y,z}_i is the coordinates of the particle at i-th point in the trajectory. The origin and the d\
irection of the spatial coordinates are the same as GEO coordinate {GX, GY, GZ}. One can track many particles at the same time by \
TrackParticles, so the trajectory has the dimensions {np, m}, where np is the number of particles.\n\n   After the trajectory is o\
btained, one can calculate the field in time domain\nat any observation point. This is done by the function RadiationFiled as\n\n \
  field = RadiationField[ trajectory[[i]], obs];\n\nwhere trajectory[[i]] is the trajectory of the i-th particle, and obs is the s\
patial coordinate of the observation point in the GEO coordinate. The output field is a list\n\n   { {tau1 .. taum},\n     {Ex1 ..\
 Exm}, {Ey1 .. Eym}, {Ez1 .. Ezm},\n     {Hx1 .. Hxm}, {Hy1 .. Hym}, {Hz1 .. Hzm},\n     {Sx1 .. Sxm}, {Sy1 .. Sym}, {Sz1 .. Hzm} \
}\n\nwhere H = (n x E)/(c mu0) and S = E x H , and tau is the observation time.\n   RadiationField uses the Feynmann-Heviside form\
ula\n\n   E = (mu0 e*CHARGE/4pi) (c^2n/R^2 + R/c d(c^2n/R^2)/dt + d^2n/dt^2) ,\n where n and R are the direction vector and the di\
stance from the electron at the retarded time to an observation point. \n   The derivatives in the above formula is calculated usi\
ng the spline\ninterpolation.\n\n   Next one can calculate the spectrum of the field by RadiationSpectrum as\n\n   spect = Radiati\
onSpectrum[ {field[[1]], field[[k]]},\n        {lambda1, lambda2, dlambda} ] ,\n\nwhere filed[[k]] is one of the fields calculated\
 by RadiationField. The range of the wavelength is given as a list above. The output spectrum spect is a list as\n\n   { {k1 .. kk\
}, {c1 .. ck}, {s1 .. sk} } ,\n\nwhere k1 .. kk is the wave number k = omega/c, c1 .. ck and s1 .. sk are the cosine and sine inte\
grals of the field in tau1 .. taum , i.e.,\n\n   ck + I sk = Integrate[ field[tau] Exp[I c k tau] dtau] .\n\n   An example is seen\
 in $(SAD_ROOTPATH)/sad/examples.sad ."],
p$2336=1+p$2336[[1,2]];p1$2336=StringPosition["To calculate the field of the synchrotron radiation from particles, first record tr\
ajectories of particles. This is done by the function TrackParticles with a new flag RADLIGHT on. When RADLIGHT is on, TrackPartic\
les returns a list\n\n   {beam, trajectory} ,\n\nwhere beam is a list as {location, coordinates}, and trajectory is a list\n\n   {\
 {t1 .. tm}, {x1 ..xm}, {y1 .. ym}, {z1 .. zm} }, ..\n\nwhere {t,x,y,z}_i is the coordinates of the particle at i-th point in the \
trajectory. The origin and the direction of the spatial coordinates are the same as GEO coordinate {GX, GY, GZ}. One can track man\
y particles at the same time by TrackParticles, so the trajectory has the dimensions {np, m}, where np is the number of particles.\
\n\n   After the trajectory is obtained, one can calculate the field in time domain\nat any observation point. This is done by the\
 function RadiationFiled as\n\n   field = RadiationField[ trajectory[[i]], obs];\n\nwhere trajectory[[i]] is the trajectory of the\
 i-th particle, and obs is the spatial coordinate of the observation point in the GEO coordinate. The output field is a list\n\n  \
 { {tau1 .. taum},\n     {Ex1 .. Exm}, {Ey1 .. Eym}, {Ez1 .. Ezm},\n     {Hx1 .. Hxm}, {Hy1 .. Hym}, {Hz1 .. Hzm},\n     {Sx1 .. S\
xm}, {Sy1 .. Sym}, {Sz1 .. Hzm} }\n\nwhere H = (n x E)/(c mu0) and S = E x H , and tau is the observation time.\n   RadiationField\
 uses the Feynmann-Heviside formula\n\n   E = (mu0 e*CHARGE/4pi) (c^2n/R^2 + R/c d(c^2n/R^2)/dt + d^2n/dt^2) ,\n where n and R are\
 the direction vector and the distance from the electron at the retarded time to an observation point. \n   The derivatives in the\
 above formula is calculated using the spline\ninterpolation.\n\n   Next one can calculate the spectrum of the field by RadiationS\
pectrum as\n\n   spect = RadiationSpectrum[ {field[[1]], field[[k]]},\n        {lambda1, lambda2, dlambda} ] ,\n\nwhere filed[[k]]\
 is one of the fields calculated by RadiationField. The range of the wavelength is given as a list above. The output spectrum spec\
t is a list as\n\n   { {k1 .. kk}, {c1 .. ck}, {s1 .. sk} } ,\n\nwhere k1 .. kk is the wave number k = omega/c, c1 .. ck and s1 ..\
 sk are the cosine and sine integrals of the field in tau1 .. taum , i.e.,\n\n   ck + I sk = Integrate[ field[tau] Exp[I c k tau] \
dtau] .\n\n   An example is seen in $(SAD_ROOTPATH)/sad/examples.sad ."[p$2336,-1],">::",1];
   p1$2336=If[p1$2336==={},2320,-2+p$2336+p1$2336[[1,1]]];
neq=Which["To calculate the field of the synchrotron radiation from particles, first record trajectories of particles. This is don\
e by the function TrackParticles with a new flag RADLIGHT on. When RADLIGHT is on, TrackParticles returns a list\n\n   {beam, traj\
ectory} ,\n\nwhere beam is a list as {location, coordinates}, and trajectory is a list\n\n   { {t1 .. tm}, {x1 ..xm}, {y1 .. ym}, \
{z1 .. zm} }, ..\n\nwhere {t,x,y,z}_i is the coordinates of the particle at i-th point in the trajectory. The origin and the direc\
tion of the spatial coordinates are the same as GEO coordinate {GX, GY, GZ}. One can track many particles at the same time by Trac\
kParticles, so the trajectory has the dimensions {np, m}, where np is the number of particles.\n\n   After the trajectory is obtai\
ned, one can calculate the field in time domain\nat any observation point. This is done by the function RadiationFiled as\n\n   fi\
eld = RadiationField[ trajectory[[i]], obs];\n\nwhere trajectory[[i]] is the trajectory of the i-th particle, and obs is the spati\
al coordinate of the observation point in the GEO coordinate. The output field is a list\n\n   { {tau1 .. taum},\n     {Ex1 .. Exm\
}, {Ey1 .. Eym}, {Ez1 .. Ezm},\n     {Hx1 .. Hxm}, {Hy1 .. Hym}, {Hz1 .. Hzm},\n     {Sx1 .. Sxm}, {Sy1 .. Sym}, {Sz1 .. Hzm} }\n\\
nwhere H = (n x E)/(c mu0) and S = E x H , and tau is the observation time.\n   RadiationField uses the Feynmann-Heviside formula\\
n\n   E = (mu0 e*CHARGE/4pi) (c^2n/R^2 + R/c d(c^2n/R^2)/dt + d^2n/dt^2) ,\n where n and R are the direction vector and the distan\
ce from the electron at the retarded time to an observation point. \n   The derivatives in the above formula is calculated using t\
he spline\ninterpolation.\n\n   Next one can calculate the spectrum of the field by RadiationSpectrum as\n\n   spect = RadiationSp\
ectrum[ {field[[1]], field[[k]]},\n        {lambda1, lambda2, dlambda} ] ,\n\nwhere filed[[k]] is one of the fields calculated by \
RadiationField. The range of the wavelength is given as a list above. The output spectrum spect is a list as\n\n   { {k1 .. kk}, {\
c1 .. ck}, {s1 .. sk} } ,\n\nwhere k1 .. kk is the wave number k = omega/c, c1 .. ck and s1 .. sk are the cosine and sine integral\
s of the field in tau1 .. taum , i.e.,\n\n   ck + I sk = Integrate[ field[tau] Exp[I c k tau] dtau] .\n\n   An example is seen in \
$(SAD_ROOTPATH)/sad/examples.sad ."[p$2336,4+p$2336]==="Text[",
    lx$2336:=Help2HTML`oa$;p$2336=5+p$2336;p1$2336-=1;p2$2336=5+p1$2336;p0$2336=-9+p$2336;
If[(pe$2336=StringPosition["To calculate the field of the synchrotron radiation from particles, first record trajectories of parti\
cles. This is done by the function TrackParticles with a new flag RADLIGHT on. When RADLIGHT is on, TrackParticles returns a list\\
n\n   {beam, trajectory} ,\n\nwhere beam is a list as {location, coordinates}, and trajectory is a list\n\n   { {t1 .. tm}, {x1 ..\
xm}, {y1 .. ym}, {z1 .. zm} }, ..\n\nwhere {t,x,y,z}_i is the coordinates of the particle at i-th point in the trajectory. The ori\
gin and the direction of the spatial coordinates are the same as GEO coordinate {GX, GY, GZ}. One can track many particles at the \
same time by TrackParticles, so the trajectory has the dimensions {np, m}, where np is the number of particles.\n\n   After the tr\
ajectory is obtained, one can calculate the field in time domain\nat any observation point. This is done by the function Radiation\
Filed as\n\n   field = RadiationField[ trajectory[[i]], obs];\n\nwhere trajectory[[i]] is the trajectory of the i-th particle, and\
 obs is the spatial coordinate of the observation point in the GEO coordinate. The output field is a list\n\n   { {tau1 .. taum},\\
n     {Ex1 .. Exm}, {Ey1 .. Eym}, {Ez1 .. Ezm},\n     {Hx1 .. Hxm}, {Hy1 .. Hym}, {Hz1 .. Hzm},\n     {Sx1 .. Sxm}, {Sy1 .. Sym}, \
{Sz1 .. Hzm} }\n\nwhere H = (n x E)/(c mu0) and S = E x H , and tau is the observation time.\n   RadiationField uses the Feynmann-\
Heviside formula\n\n   E = (mu0 e*CHARGE/4pi) (c^2n/R^2 + R/c d(c^2n/R^2)/dt + d^2n/dt^2) ,\n where n and R are the direction vect\
or and the distance from the electron at the retarded time to an observation point. \n   The derivatives in the above formula is c\
alculated using the spline\ninterpolation.\n\n   Next one can calculate the spectrum of the field by RadiationSpectrum as\n\n   sp\
ect = RadiationSpectrum[ {field[[1]], field[[k]]},\n        {lambda1, lambda2, dlambda} ] ,\n\nwhere filed[[k]] is one of the fiel\
ds calculated by RadiationField. The range of the wavelength is given as a list above. The output spectrum spect is a list as\n\n \
  { {k1 .. kk}, {c1 .. ck}, {s1 .. sk} } ,\n\nwhere k1 .. kk is the wave number k = omega/c, c1 .. ck and s1 .. sk are the cosine \
and sine integrals of the field in tau1 .. taum , i.e.,\n\n   ck + I sk = Integrate[ field[tau] Exp[I c k tau] dtau] .\n\n   An ex\
ample is seen in $(SAD_ROOTPATH)/sad/examples.sad ."[p$2336,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["To calculate the field of the synchrotron radiation from particles, first record trajectories of particles. This \
is done by the function TrackParticles with a new flag RADLIGHT on. When RADLIGHT is on, TrackParticles returns a list\n\n   {beam\
, trajectory} ,\n\nwhere beam is a list as {location, coordinates}, and trajectory is a list\n\n   { {t1 .. tm}, {x1 ..xm}, {y1 ..\
 ym}, {z1 .. zm} }, ..\n\nwhere {t,x,y,z}_i is the coordinates of the particle at i-th point in the trajectory. The origin and the\
 direction of the spatial coordinates are the same as GEO coordinate {GX, GY, GZ}. One can track many particles at the same time b\
y TrackParticles, so the trajectory has the dimensions {np, m}, where np is the number of particles.\n\n   After the trajectory is\
 obtained, one can calculate the field in time domain\nat any observation point. This is done by the function RadiationFiled as\n\\
n   field = RadiationField[ trajectory[[i]], obs];\n\nwhere trajectory[[i]] is the trajectory of the i-th particle, and obs is the\
 spatial coordinate of the observation point in the GEO coordinate. The output field is a list\n\n   { {tau1 .. taum},\n     {Ex1 \
.. Exm}, {Ey1 .. Eym}, {Ez1 .. Ezm},\n     {Hx1 .. Hxm}, {Hy1 .. Hym}, {Hz1 .. Hzm},\n     {Sx1 .. Sxm}, {Sy1 .. Sym}, {Sz1 .. Hzm\
} }\n\nwhere H = (n x E)/(c mu0) and S = E x H , and tau is the observation time.\n   RadiationField uses the Feynmann-Heviside fo\
rmula\n\n   E = (mu0 e*CHARGE/4pi) (c^2n/R^2 + R/c d(c^2n/R^2)/dt + d^2n/dt^2) ,\n where n and R are the direction vector and the \
distance from the electron at the retarded time to an observation point. \n   The derivatives in the above formula is calculated u\
sing the spline\ninterpolation.\n\n   Next one can calculate the spectrum of the field by RadiationSpectrum as\n\n   spect = Radia\
tionSpectrum[ {field[[1]], field[[k]]},\n        {lambda1, lambda2, dlambda} ] ,\n\nwhere filed[[k]] is one of the fields calculat\
ed by RadiationField. The range of the wavelength is given as a list above. The output spectrum spect is a list as\n\n   { {k1 .. \
kk}, {c1 .. ck}, {s1 .. sk} } ,\n\nwhere k1 .. kk is the wave number k = omega/c, c1 .. ck and s1 .. sk are the cosine and sine in\
tegrals of the field in tau1 .. taum , i.e.,\n\n   ck + I sk = Integrate[ field[tau] Exp[I c k tau] dtau] .\n\n   An example is se\
en in $(SAD_ROOTPATH)/sad/examples.sad ."[p$2336+pe$2336[[1,2]],p1$2336]]],
        p1$2336=-2+p$2336+pe$2336[[1,1]]}[[
       1]],
      0],
    1,lx$2336:=Help2HTML`o9$;p2$2336=4+p1$2336;p0$2336=-4+p$2336;0];
  If[(equ$2336=
Help2HTML`o8$["To calculate the field of the synchrotron radiation from particles, first record trajectories of particles. This is\
 done by the function TrackParticles with a new flag RADLIGHT on. When RADLIGHT is on, TrackParticles returns a list\n\n   {beam, \
trajectory} ,\n\nwhere beam is a list as {location, coordinates}, and trajectory is a list\n\n   { {t1 .. tm}, {x1 ..xm}, {y1 .. y\
m}, {z1 .. zm} }, ..\n\nwhere {t,x,y,z}_i is the coordinates of the particle at i-th point in the trajectory. The origin and the d\
irection of the spatial coordinates are the same as GEO coordinate {GX, GY, GZ}. One can track many particles at the same time by \
TrackParticles, so the trajectory has the dimensions {np, m}, where np is the number of particles.\n\n   After the trajectory is o\
btained, one can calculate the field in time domain\nat any observation point. This is done by the function RadiationFiled as\n\n \
  field = RadiationField[ trajectory[[i]], obs];\n\nwhere trajectory[[i]] is the trajectory of the i-th particle, and obs is the s\
patial coordinate of the observation point in the GEO coordinate. The output field is a list\n\n   { {tau1 .. taum},\n     {Ex1 ..\
 Exm}, {Ey1 .. Eym}, {Ez1 .. Ezm},\n     {Hx1 .. Hxm}, {Hy1 .. Hym}, {Hz1 .. Hzm},\n     {Sx1 .. Sxm}, {Sy1 .. Sym}, {Sz1 .. Hzm} \
}\n\nwhere H = (n x E)/(c mu0) and S = E x H , and tau is the observation time.\n   RadiationField uses the Feynmann-Heviside form\
ula\n\n   E = (mu0 e*CHARGE/4pi) (c^2n/R^2 + R/c d(c^2n/R^2)/dt + d^2n/dt^2) ,\n where n and R are the direction vector and the di\
stance from the electron at the retarded time to an observation point. \n   The derivatives in the above formula is calculated usi\
ng the spline\ninterpolation.\n\n   Next one can calculate the spectrum of the field by RadiationSpectrum as\n\n   spect = Radiati\
onSpectrum[ {field[[1]], field[[k]]},\n        {lambda1, lambda2, dlambda} ] ,\n\nwhere filed[[k]] is one of the fields calculated\
 by RadiationField. The range of the wavelength is given as a list above. The output spectrum spect is a list as\n\n   { {k1 .. kk\
}, {c1 .. ck}, {s1 .. sk} } ,\n\nwhere k1 .. kk is the wave number k = omega/c, c1 .. ck and s1 .. sk are the cosine and sine inte\
grals of the field in tau1 .. taum , i.e.,\n\n   ck + I sk = Integrate[ field[tau] Exp[I c k tau] dtau] .\n\n   An example is seen\
 in $(SAD_ROOTPATH)/sad/examples.sad ."[p$2336,p1$2336]])===
    Undefined,
equ$2336="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["To calculate the field of the synchrotron ra\
diation from particles, first record trajectories of particles. This is done by the function TrackParticles with a new flag RADLIG\
HT on. When RADLIGHT is on, TrackParticles returns a list\n\n   {beam, trajectory} ,\n\nwhere beam is a list as {location, coordin\
ates}, and trajectory is a list\n\n   { {t1 .. tm}, {x1 ..xm}, {y1 .. ym}, {z1 .. zm} }, ..\n\nwhere {t,x,y,z}_i is the coordinate\
s of the particle at i-th point in the trajectory. The origin and the direction of the spatial coordinates are the same as GEO coo\
rdinate {GX, GY, GZ}. One can track many particles at the same time by TrackParticles, so the trajectory has the dimensions {np, m\
}, where np is the number of particles.\n\n   After the trajectory is obtained, one can calculate the field in time domain\nat any\
 observation point. This is done by the function RadiationFiled as\n\n   field = RadiationField[ trajectory[[i]], obs];\n\nwhere t\
rajectory[[i]] is the trajectory of the i-th particle, and obs is the spatial coordinate of the observation point in the GEO coord\
inate. The output field is a list\n\n   { {tau1 .. taum},\n     {Ex1 .. Exm}, {Ey1 .. Eym}, {Ez1 .. Ezm},\n     {Hx1 .. Hxm}, {Hy1\
 .. Hym}, {Hz1 .. Hzm},\n     {Sx1 .. Sxm}, {Sy1 .. Sym}, {Sz1 .. Hzm} }\n\nwhere H = (n x E)/(c mu0) and S = E x H , and tau is t\
he observation time.\n   RadiationField uses the Feynmann-Heviside formula\n\n   E = (mu0 e*CHARGE/4pi) (c^2n/R^2 + R/c d(c^2n/R^2\
)/dt + d^2n/dt^2) ,\n where n and R are the direction vector and the distance from the electron at the retarded time to an observa\
tion point. \n   The derivatives in the above formula is calculated using the spline\ninterpolation.\n\n   Next one can calculate \
the spectrum of the field by RadiationSpectrum as\n\n   spect = RadiationSpectrum[ {field[[1]], field[[k]]},\n        {lambda1, la\
mbda2, dlambda} ] ,\n\nwhere filed[[k]] is one of the fields calculated by RadiationField. The range of the wavelength is given as\
 a list above. The output spectrum spect is a list as\n\n   { {k1 .. kk}, {c1 .. ck}, {s1 .. sk} } ,\n\nwhere k1 .. kk is the wave\
 number k = omega/c, c1 .. ck and s1 .. sk are the cosine and sine integrals of the field in tau1 .. taum , i.e.,\n\n   ck + I sk \
= Integrate[ field[tau] Exp[I c k tau] dtau] .\n\n   An example is seen in $(SAD_ROOTPATH)/sad/examples.sad ."[p$2336,p1$2336]]=
       equ$2336;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2336},out$2336=lx$2336@Typeset["To calculate the field of the synchrotron radiation from particles, first record trajecto\
ries of particles. This is done by the function TrackParticles with a new flag RADLIGHT on. When RADLIGHT is on, TrackParticles re\
turns a list\n\n   {beam, trajectory} ,\n\nwhere beam is a list as {location, coordinates}, and trajectory is a list\n\n   { {t1 .\
. tm}, {x1 ..xm}, {y1 .. ym}, {z1 .. zm} }, ..\n\nwhere {t,x,y,z}_i is the coordinates of the particle at i-th point in the trajec\
tory. The origin and the direction of the spatial coordinates are the same as GEO coordinate {GX, GY, GZ}. One can track many part\
icles at the same time by TrackParticles, so the trajectory has the dimensions {np, m}, where np is the number of particles.\n\n  \
 After the trajectory is obtained, one can calculate the field in time domain\nat any observation point. This is done by the funct\
ion RadiationFiled as\n\n   field = RadiationField[ trajectory[[i]], obs];\n\nwhere trajectory[[i]] is the trajectory of the i-th \
particle, and obs is the spatial coordinate of the observation point in the GEO coordinate. The output field is a list\n\n   { {ta\
u1 .. taum},\n     {Ex1 .. Exm}, {Ey1 .. Eym}, {Ez1 .. Ezm},\n     {Hx1 .. Hxm}, {Hy1 .. Hym}, {Hz1 .. Hzm},\n     {Sx1 .. Sxm}, {\
Sy1 .. Sym}, {Sz1 .. Hzm} }\n\nwhere H = (n x E)/(c mu0) and S = E x H , and tau is the observation time.\n   RadiationField uses \
the Feynmann-Heviside formula\n\n   E = (mu0 e*CHARGE/4pi) (c^2n/R^2 + R/c d(c^2n/R^2)/dt + d^2n/dt^2) ,\n where n and R are the d\
irection vector and the distance from the electron at the retarded time to an observation point. \n   The derivatives in the above\
 formula is calculated using the spline\ninterpolation.\n\n   Next one can calculate the spectrum of the field by RadiationSpectru\
m as\n\n   spect = RadiationSpectrum[ {field[[1]], field[[k]]},\n        {lambda1, lambda2, dlambda} ] ,\n\nwhere filed[[k]] is on\
e of the fields calculated by RadiationField. The range of the wavelength is given as a list above. The output spectrum spect is a\
 list as\n\n   { {k1 .. kk}, {c1 .. ck}, {s1 .. sk} } ,\n\nwhere k1 .. kk is the wave number k = omega/c, c1 .. ck and s1 .. sk ar\
e the cosine and sine integrals of the field in tau1 .. taum , i.e.,\n\n   ck + I sk = Integrate[ field[tau] Exp[I c k tau] dtau] \
.\n\n   An example is seen in $(SAD_ROOTPATH)/sad/examples.sad ."[p$2336,p1$2336],Format->Help2HTML`oB$];
        System["mv -f "//out$2336//" "//equ$2336]];
      Exit[]]];
   "To calculate the field of the synchrotron radiation from particles, first record trajectories of particles. This is done by th\
e function TrackParticles with a new flag RADLIGHT on. When RADLIGHT is on, TrackParticles returns a list\n\n   {beam, trajectory}\
 ,\n\nwhere beam is a list as {location, coordinates}, and trajectory is a list\n\n   { {t1 .. tm}, {x1 ..xm}, {y1 .. ym}, {z1 .. \
zm} }, ..\n\nwhere {t,x,y,z}_i is the coordinates of the particle at i-th point in the trajectory. The origin and the direction of\
 the spatial coordinates are the same as GEO coordinate {GX, GY, GZ}. One can track many particles at the same time by TrackPartic\
les, so the trajectory has the dimensions {np, m}, where np is the number of particles.\n\n   After the trajectory is obtained, on\
e can calculate the field in time domain\nat any observation point. This is done by the function RadiationFiled as\n\n   field = R\
adiationField[ trajectory[[i]], obs];\n\nwhere trajectory[[i]] is the trajectory of the i-th particle, and obs is the spatial coor\
dinate of the observation point in the GEO coordinate. The output field is a list\n\n   { {tau1 .. taum},\n     {Ex1 .. Exm}, {Ey1\
 .. Eym}, {Ez1 .. Ezm},\n     {Hx1 .. Hxm}, {Hy1 .. Hym}, {Hz1 .. Hzm},\n     {Sx1 .. Sxm}, {Sy1 .. Sym}, {Sz1 .. Hzm} }\n\nwhere \
H = (n x E)/(c mu0) and S = E x H , and tau is the observation time.\n   RadiationField uses the Feynmann-Heviside formula\n\n   E\
 = (mu0 e*CHARGE/4pi) (c^2n/R^2 + R/c d(c^2n/R^2)/dt + d^2n/dt^2) ,\n where n and R are the direction vector and the distance from\
 the electron at the retarded time to an observation point. \n   The derivatives in the above formula is calculated using the spli\
ne\ninterpolation.\n\n   Next one can calculate the spectrum of the field by RadiationSpectrum as\n\n   spect = RadiationSpectrum[\
 {field[[1]], field[[k]]},\n        {lambda1, lambda2, dlambda} ] ,\n\nwhere filed[[k]] is one of the fields calculated by Radiati\
onField. The range of the wavelength is given as a list above. The output spectrum spect is a list as\n\n   { {k1 .. kk}, {c1 .. c\
k}, {s1 .. sk} } ,\n\nwhere k1 .. kk is the wave number k = omega/c, c1 .. ck and s1 .. sk are the cosine and sine integrals of th\
e field in tau1 .. taum , i.e.,\n\n   ck + I sk = Integrate[ field[tau] Exp[I c k tau] dtau] .\n\n   An example is seen in $(SAD_R\
OOTPATH)/sad/examples.sad ."[1,Max[p0$2336,0]]//"<img  class=\"eqs\" SRC=\""//equ$2336//"\" />"//
Help2HTML`oy$["To calculate the field of the synchrotron radiation from particles, first record trajectories of particles. This is\
 done by the function TrackParticles with a new flag RADLIGHT on. When RADLIGHT is on, TrackParticles returns a list\n\n   {beam, \
trajectory} ,\n\nwhere beam is a list as {location, coordinates}, and trajectory is a list\n\n   { {t1 .. tm}, {x1 ..xm}, {y1 .. y\
m}, {z1 .. zm} }, ..\n\nwhere {t,x,y,z}_i is the coordinates of the particle at i-th point in the trajectory. The origin and the d\
irection of the spatial coordinates are the same as GEO coordinate {GX, GY, GZ}. One can track many particles at the same time by \
TrackParticles, so the trajectory has the dimensions {np, m}, where np is the number of particles.\n\n   After the trajectory is o\
btained, one can calculate the field in time domain\nat any observation point. This is done by the function RadiationFiled as\n\n \
  field = RadiationField[ trajectory[[i]], obs];\n\nwhere trajectory[[i]] is the trajectory of the i-th particle, and obs is the s\
patial coordinate of the observation point in the GEO coordinate. The output field is a list\n\n   { {tau1 .. taum},\n     {Ex1 ..\
 Exm}, {Ey1 .. Eym}, {Ez1 .. Ezm},\n     {Hx1 .. Hxm}, {Hy1 .. Hym}, {Hz1 .. Hzm},\n     {Sx1 .. Sxm}, {Sy1 .. Sym}, {Sz1 .. Hzm} \
}\n\nwhere H = (n x E)/(c mu0) and S = E x H , and tau is the observation time.\n   RadiationField uses the Feynmann-Heviside form\
ula\n\n   E = (mu0 e*CHARGE/4pi) (c^2n/R^2 + R/c d(c^2n/R^2)/dt + d^2n/dt^2) ,\n where n and R are the direction vector and the di\
stance from the electron at the retarded time to an observation point. \n   The derivatives in the above formula is calculated usi\
ng the spline\ninterpolation.\n\n   Next one can calculate the spectrum of the field by RadiationSpectrum as\n\n   spect = Radiati\
onSpectrum[ {field[[1]], field[[k]]},\n        {lambda1, lambda2, dlambda} ] ,\n\nwhere filed[[k]] is one of the fields calculated\
 by RadiationField. The range of the wavelength is given as a list above. The output spectrum spect is a list as\n\n   { {k1 .. kk\
}, {c1 .. ck}, {s1 .. sk} } ,\n\nwhere k1 .. kk is the wave number k = omega/c, c1 .. ck and s1 .. sk are the cosine and sine inte\
grals of the field in tau1 .. taum , i.e.,\n\n   ck + I sk = Integrate[ field[tau] Exp[I c k tau] dtau] .\n\n   An example is seen\
 in $(SAD_ROOTPATH)/sad/examples.sad ."[p2$2336,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L409>TrackParticles</A> <A HREF=#L339>RADLIGHT</A></PRE>
<LI>
<H3><A NAME=L404>
SetElement</A></H3>
<PRE>If[{},
Help2HTML`oA$["Create/set/read a MAIN-level element.\n\nUsage: SetElement[ element-name, element-type, options]\n\nwhere\n\n   ele\
ment-name: name of the element, either a symbol or a string\n   element-type: type of the element, a symbol, a string, or a number\
\n   options: one or more rules or list of rules of the form\n            keyword -> value or keyword :> value, to set the corresp\
onding\n            value of keyword of the element.\n\n   SetElement returns a list of information of the element, in the suitabl\
e form for applying SetElement again.\n   You can define a new element by SetElement.\n   You can change the values of keywords of\
 the element.\n   You cannot, however, change the type of an existing element, nor cannot delete the element.\n   The element-type\
 can be Null. If so, a null type is assumed for a new element.\n\nExamples:\n\n   LINE A = ( .. );\n   QUAD QF = (K1 = 0.2);\n   .\
..\n   FFS USE = A;\n     ...\n    SetElement[\"QF\"]                     ! reads values of QF.\n    SetElement[\"QF\",\"QUAD\"]  \
            ! same as above.\n    SetElement[\"QF\",\"BEND\"]              ! error because QF is QUAD.\n    SetElement[\"QF\",,{\"\
K1\"->0.1}]        ! set K1 of QF to 0.1 .\n    SetElement[\"QF\",\"QUAD\",{\"K1\"->0.1}]  ! same as above.\n\n !Assuming QF1 and \
QF2 are undefined yet:\n\n    SetElement[\"QF1\",\"QUAD\",{\"K1\"->0.1}] ! create a new QUAD QF1 with K1=0.1 .\n    SetElement[\"Q\
F2\",,{\"K1\"->0.1}]       ! error because no type with key.\n    SetElement[\"QF2\"]                    ! This is OK.\n    SetEle\
ment[\"QF2\",\"QUAD\"]             ! Now the type of QF2 is defined."],
p$2339=1+p$2339[[1,2]];p1$2339=StringPosition["Create/set/read a MAIN-level element.\n\nUsage: SetElement[ element-name, element-t\
ype, options]\n\nwhere\n\n   element-name: name of the element, either a symbol or a string\n   element-type: type of the element,\
 a symbol, a string, or a number\n   options: one or more rules or list of rules of the form\n            keyword -> value or keyw\
ord :> value, to set the corresponding\n            value of keyword of the element.\n\n   SetElement returns a list of informatio\
n of the element, in the suitable form for applying SetElement again.\n   You can define a new element by SetElement.\n   You can \
change the values of keywords of the element.\n   You cannot, however, change the type of an existing element, nor cannot delete t\
he element.\n   The element-type can be Null. If so, a null type is assumed for a new element.\n\nExamples:\n\n   LINE A = ( .. );\
\n   QUAD QF = (K1 = 0.2);\n   ...\n   FFS USE = A;\n     ...\n    SetElement[\"QF\"]                     ! reads values of QF.\n \
   SetElement[\"QF\",\"QUAD\"]              ! same as above.\n    SetElement[\"QF\",\"BEND\"]              ! error because QF is Q\
UAD.\n    SetElement[\"QF\",,{\"K1\"->0.1}]        ! set K1 of QF to 0.1 .\n    SetElement[\"QF\",\"QUAD\",{\"K1\"->0.1}]  ! same \
as above.\n\n !Assuming QF1 and QF2 are undefined yet:\n\n    SetElement[\"QF1\",\"QUAD\",{\"K1\"->0.1}] ! create a new QUAD QF1 w\
ith K1=0.1 .\n    SetElement[\"QF2\",,{\"K1\"->0.1}]       ! error because no type with key.\n    SetElement[\"QF2\"]             \
       ! This is OK.\n    SetElement[\"QF2\",\"QUAD\"]             ! Now the type of QF2 is defined."[p$2339,-1],">::",1];
   p1$2339=If[p1$2339==={},1541,-2+p$2339+p1$2339[[1,1]]];
neq=Which["Create/set/read a MAIN-level element.\n\nUsage: SetElement[ element-name, element-type, options]\n\nwhere\n\n   element\
-name: name of the element, either a symbol or a string\n   element-type: type of the element, a symbol, a string, or a number\n  \
 options: one or more rules or list of rules of the form\n            keyword -> value or keyword :> value, to set the correspondi\
ng\n            value of keyword of the element.\n\n   SetElement returns a list of information of the element, in the suitable fo\
rm for applying SetElement again.\n   You can define a new element by SetElement.\n   You can change the values of keywords of the\
 element.\n   You cannot, however, change the type of an existing element, nor cannot delete the element.\n   The element-type can\
 be Null. If so, a null type is assumed for a new element.\n\nExamples:\n\n   LINE A = ( .. );\n   QUAD QF = (K1 = 0.2);\n   ...\n\
   FFS USE = A;\n     ...\n    SetElement[\"QF\"]                     ! reads values of QF.\n    SetElement[\"QF\",\"QUAD\"]      \
        ! same as above.\n    SetElement[\"QF\",\"BEND\"]              ! error because QF is QUAD.\n    SetElement[\"QF\",,{\"K1\"\
->0.1}]        ! set K1 of QF to 0.1 .\n    SetElement[\"QF\",\"QUAD\",{\"K1\"->0.1}]  ! same as above.\n\n !Assuming QF1 and QF2 \
are undefined yet:\n\n    SetElement[\"QF1\",\"QUAD\",{\"K1\"->0.1}] ! create a new QUAD QF1 with K1=0.1 .\n    SetElement[\"QF2\"\
,,{\"K1\"->0.1}]       ! error because no type with key.\n    SetElement[\"QF2\"]                    ! This is OK.\n    SetElement\
[\"QF2\",\"QUAD\"]             ! Now the type of QF2 is defined."[p$2339,4+p$2339]==="Text[",
    lx$2339:=Help2HTML`oa$;p$2339=5+p$2339;p1$2339-=1;p2$2339=5+p1$2339;p0$2339=-9+p$2339;
If[(pe$2339=StringPosition["Create/set/read a MAIN-level element.\n\nUsage: SetElement[ element-name, element-type, options]\n\nwh\
ere\n\n   element-name: name of the element, either a symbol or a string\n   element-type: type of the element, a symbol, a string\
, or a number\n   options: one or more rules or list of rules of the form\n            keyword -> value or keyword :> value, to se\
t the corresponding\n            value of keyword of the element.\n\n   SetElement returns a list of information of the element, i\
n the suitable form for applying SetElement again.\n   You can define a new element by SetElement.\n   You can change the values o\
f keywords of the element.\n   You cannot, however, change the type of an existing element, nor cannot delete the element.\n   The\
 element-type can be Null. If so, a null type is assumed for a new element.\n\nExamples:\n\n   LINE A = ( .. );\n   QUAD QF = (K1 \
= 0.2);\n   ...\n   FFS USE = A;\n     ...\n    SetElement[\"QF\"]                     ! reads values of QF.\n    SetElement[\"QF\\
",\"QUAD\"]              ! same as above.\n    SetElement[\"QF\",\"BEND\"]              ! error because QF is QUAD.\n    SetElemen\
t[\"QF\",,{\"K1\"->0.1}]        ! set K1 of QF to 0.1 .\n    SetElement[\"QF\",\"QUAD\",{\"K1\"->0.1}]  ! same as above.\n\n !Assu\
ming QF1 and QF2 are undefined yet:\n\n    SetElement[\"QF1\",\"QUAD\",{\"K1\"->0.1}] ! create a new QUAD QF1 with K1=0.1 .\n    S\
etElement[\"QF2\",,{\"K1\"->0.1}]       ! error because no type with key.\n    SetElement[\"QF2\"]                    ! This is OK\
.\n    SetElement[\"QF2\",\"QUAD\"]             ! Now the type of QF2 is defined."[p$2339,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Create/set/read a MAIN-level element.\n\nUsage: SetElement[ element-name, element-type, options]\n\nwhere\n\n   e\
lement-name: name of the element, either a symbol or a string\n   element-type: type of the element, a symbol, a string, or a numb\
er\n   options: one or more rules or list of rules of the form\n            keyword -> value or keyword :> value, to set the corre\
sponding\n            value of keyword of the element.\n\n   SetElement returns a list of information of the element, in the suita\
ble form for applying SetElement again.\n   You can define a new element by SetElement.\n   You can change the values of keywords \
of the element.\n   You cannot, however, change the type of an existing element, nor cannot delete the element.\n   The element-ty\
pe can be Null. If so, a null type is assumed for a new element.\n\nExamples:\n\n   LINE A = ( .. );\n   QUAD QF = (K1 = 0.2);\n  \
 ...\n   FFS USE = A;\n     ...\n    SetElement[\"QF\"]                     ! reads values of QF.\n    SetElement[\"QF\",\"QUAD\"]\
              ! same as above.\n    SetElement[\"QF\",\"BEND\"]              ! error because QF is QUAD.\n    SetElement[\"QF\",,{\
\"K1\"->0.1}]        ! set K1 of QF to 0.1 .\n    SetElement[\"QF\",\"QUAD\",{\"K1\"->0.1}]  ! same as above.\n\n !Assuming QF1 an\
d QF2 are undefined yet:\n\n    SetElement[\"QF1\",\"QUAD\",{\"K1\"->0.1}] ! create a new QUAD QF1 with K1=0.1 .\n    SetElement[\\
"QF2\",,{\"K1\"->0.1}]       ! error because no type with key.\n    SetElement[\"QF2\"]                    ! This is OK.\n    SetE\
lement[\"QF2\",\"QUAD\"]             ! Now the type of QF2 is defined."[p$2339+pe$2339[[1,2]],p1$2339]]],
        p1$2339=-2+p$2339+pe$2339[[1,1]]}[[
       1]],
      0],
    1,lx$2339:=Help2HTML`o9$;p2$2339=4+p1$2339;p0$2339=-4+p$2339;0];
  If[(equ$2339=
Help2HTML`o8$["Create/set/read a MAIN-level element.\n\nUsage: SetElement[ element-name, element-type, options]\n\nwhere\n\n   ele\
ment-name: name of the element, either a symbol or a string\n   element-type: type of the element, a symbol, a string, or a number\
\n   options: one or more rules or list of rules of the form\n            keyword -> value or keyword :> value, to set the corresp\
onding\n            value of keyword of the element.\n\n   SetElement returns a list of information of the element, in the suitabl\
e form for applying SetElement again.\n   You can define a new element by SetElement.\n   You can change the values of keywords of\
 the element.\n   You cannot, however, change the type of an existing element, nor cannot delete the element.\n   The element-type\
 can be Null. If so, a null type is assumed for a new element.\n\nExamples:\n\n   LINE A = ( .. );\n   QUAD QF = (K1 = 0.2);\n   .\
..\n   FFS USE = A;\n     ...\n    SetElement[\"QF\"]                     ! reads values of QF.\n    SetElement[\"QF\",\"QUAD\"]  \
            ! same as above.\n    SetElement[\"QF\",\"BEND\"]              ! error because QF is QUAD.\n    SetElement[\"QF\",,{\"\
K1\"->0.1}]        ! set K1 of QF to 0.1 .\n    SetElement[\"QF\",\"QUAD\",{\"K1\"->0.1}]  ! same as above.\n\n !Assuming QF1 and \
QF2 are undefined yet:\n\n    SetElement[\"QF1\",\"QUAD\",{\"K1\"->0.1}] ! create a new QUAD QF1 with K1=0.1 .\n    SetElement[\"Q\
F2\",,{\"K1\"->0.1}]       ! error because no type with key.\n    SetElement[\"QF2\"]                    ! This is OK.\n    SetEle\
ment[\"QF2\",\"QUAD\"]             ! Now the type of QF2 is defined."[p$2339,p1$2339]])===
    Undefined,
equ$2339="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Create/set/read a MAIN-level element.\n\nUsa\
ge: SetElement[ element-name, element-type, options]\n\nwhere\n\n   element-name: name of the element, either a symbol or a string\
\n   element-type: type of the element, a symbol, a string, or a number\n   options: one or more rules or list of rules of the for\
m\n            keyword -> value or keyword :> value, to set the corresponding\n            value of keyword of the element.\n\n   \
SetElement returns a list of information of the element, in the suitable form for applying SetElement again.\n   You can define a \
new element by SetElement.\n   You can change the values of keywords of the element.\n   You cannot, however, change the type of a\
n existing element, nor cannot delete the element.\n   The element-type can be Null. If so, a null type is assumed for a new eleme\
nt.\n\nExamples:\n\n   LINE A = ( .. );\n   QUAD QF = (K1 = 0.2);\n   ...\n   FFS USE = A;\n     ...\n    SetElement[\"QF\"]      \
               ! reads values of QF.\n    SetElement[\"QF\",\"QUAD\"]              ! same as above.\n    SetElement[\"QF\",\"BEND\\
"]              ! error because QF is QUAD.\n    SetElement[\"QF\",,{\"K1\"->0.1}]        ! set K1 of QF to 0.1 .\n    SetElement[\
\"QF\",\"QUAD\",{\"K1\"->0.1}]  ! same as above.\n\n !Assuming QF1 and QF2 are undefined yet:\n\n    SetElement[\"QF1\",\"QUAD\",{\
\"K1\"->0.1}] ! create a new QUAD QF1 with K1=0.1 .\n    SetElement[\"QF2\",,{\"K1\"->0.1}]       ! error because no type with key\
.\n    SetElement[\"QF2\"]                    ! This is OK.\n    SetElement[\"QF2\",\"QUAD\"]             ! Now the type of QF2 is\
 defined."[p$2339,p1$2339]]=
       equ$2339;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2339},out$2339=lx$2339@Typeset["Create/set/read a MAIN-level element.\n\nUsage: SetElement[ element-name, element-type, o\
ptions]\n\nwhere\n\n   element-name: name of the element, either a symbol or a string\n   element-type: type of the element, a sym\
bol, a string, or a number\n   options: one or more rules or list of rules of the form\n            keyword -> value or keyword :>\
 value, to set the corresponding\n            value of keyword of the element.\n\n   SetElement returns a list of information of t\
he element, in the suitable form for applying SetElement again.\n   You can define a new element by SetElement.\n   You can change\
 the values of keywords of the element.\n   You cannot, however, change the type of an existing element, nor cannot delete the ele\
ment.\n   The element-type can be Null. If so, a null type is assumed for a new element.\n\nExamples:\n\n   LINE A = ( .. );\n   Q\
UAD QF = (K1 = 0.2);\n   ...\n   FFS USE = A;\n     ...\n    SetElement[\"QF\"]                     ! reads values of QF.\n    Set\
Element[\"QF\",\"QUAD\"]              ! same as above.\n    SetElement[\"QF\",\"BEND\"]              ! error because QF is QUAD.\n\
    SetElement[\"QF\",,{\"K1\"->0.1}]        ! set K1 of QF to 0.1 .\n    SetElement[\"QF\",\"QUAD\",{\"K1\"->0.1}]  ! same as abo\
ve.\n\n !Assuming QF1 and QF2 are undefined yet:\n\n    SetElement[\"QF1\",\"QUAD\",{\"K1\"->0.1}] ! create a new QUAD QF1 with K1\
=0.1 .\n    SetElement[\"QF2\",,{\"K1\"->0.1}]       ! error because no type with key.\n    SetElement[\"QF2\"]                   \
 ! This is OK.\n    SetElement[\"QF2\",\"QUAD\"]             ! Now the type of QF2 is defined."[p$2339,p1$2339],
          Format->Help2HTML`oB$];
        System["mv -f "//out$2339//" "//equ$2339]];
      Exit[]]];
   "Create/set/read a MAIN-level element.\n\nUsage: SetElement[ element-name, element-type, options]\n\nwhere\n\n   element-name: \
name of the element, either a symbol or a string\n   element-type: type of the element, a symbol, a string, or a number\n   option\
s: one or more rules or list of rules of the form\n            keyword -> value or keyword :> value, to set the corresponding\n   \
         value of keyword of the element.\n\n   SetElement returns a list of information of the element, in the suitable form for \
applying SetElement again.\n   You can define a new element by SetElement.\n   You can change the values of keywords of the elemen\
t.\n   You cannot, however, change the type of an existing element, nor cannot delete the element.\n   The element-type can be Nul\
l. If so, a null type is assumed for a new element.\n\nExamples:\n\n   LINE A = ( .. );\n   QUAD QF = (K1 = 0.2);\n   ...\n   FFS \
USE = A;\n     ...\n    SetElement[\"QF\"]                     ! reads values of QF.\n    SetElement[\"QF\",\"QUAD\"]             \
 ! same as above.\n    SetElement[\"QF\",\"BEND\"]              ! error because QF is QUAD.\n    SetElement[\"QF\",,{\"K1\"->0.1}]\
        ! set K1 of QF to 0.1 .\n    SetElement[\"QF\",\"QUAD\",{\"K1\"->0.1}]  ! same as above.\n\n !Assuming QF1 and QF2 are und\
efined yet:\n\n    SetElement[\"QF1\",\"QUAD\",{\"K1\"->0.1}] ! create a new QUAD QF1 with K1=0.1 .\n    SetElement[\"QF2\",,{\"K1\
\"->0.1}]       ! error because no type with key.\n    SetElement[\"QF2\"]                    ! This is OK.\n    SetElement[\"QF2\\
",\"QUAD\"]             ! Now the type of QF2 is defined."[1,Max[p0$2339,0]]//"<img  class=\"eqs\" SRC=\""//equ$2339//"\" />"//
   Help2HTML`oy$["Create/set/read a MAIN-level element.\n\nUsage: SetElement[ element-name, element-type, options]\n\nwhere\n\n   \
element-name: name of the element, either a symbol or a string\n   element-type: type of the element, a symbol, a string, or a num\
ber\n   options: one or more rules or list of rules of the form\n            keyword -> value or keyword :> value, to set the corr\
esponding\n            value of keyword of the element.\n\n   SetElement returns a list of information of the element, in the suit\
able form for applying SetElement again.\n   You can define a new element by SetElement.\n   You can change the values of keywords\
 of the element.\n   You cannot, however, change the type of an existing element, nor cannot delete the element.\n   The element-t\
ype can be Null. If so, a null type is assumed for a new element.\n\nExamples:\n\n   LINE A = ( .. );\n   QUAD QF = (K1 = 0.2);\n \
  ...\n   FFS USE = A;\n     ...\n    SetElement[\"QF\"]                     ! reads values of QF.\n    SetElement[\"QF\",\"QUAD\"\
]              ! same as above.\n    SetElement[\"QF\",\"BEND\"]              ! error because QF is QUAD.\n    SetElement[\"QF\",,\
{\"K1\"->0.1}]        ! set K1 of QF to 0.1 .\n    SetElement[\"QF\",\"QUAD\",{\"K1\"->0.1}]  ! same as above.\n\n !Assuming QF1 a\
nd QF2 are undefined yet:\n\n    SetElement[\"QF1\",\"QUAD\",{\"K1\"->0.1}] ! create a new QUAD QF1 with K1=0.1 .\n    SetElement[\
\"QF2\",,{\"K1\"->0.1}]       ! error because no type with key.\n    SetElement[\"QF2\"]                    ! This is OK.\n    Set\
Element[\"QF2\",\"QUAD\"]             ! Now the type of QF2 is defined."[p2$2339,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L75>elements</A> <A HREF=#L136>keywords</A> <A HREF=#L387>Element</A></PRE>
<LI>
<H3><A NAME=L405>
SurvivedParticles</A></H3>
<PRE>If[{},
Help2HTML`oA$["SurvivedParticles[x]\n\nreturns the list of 6 coordinates and the flag of the survived particles in x. The form of \
x is {x, px/p0, y, py/p0, z, dp/p0, flag}, where each is a list of length of the number of particles. If all particles are lost, i\
t is a list of seven null lists."],
p$2342=1+p$2342[[1,2]];p1$2342=StringPosition["SurvivedParticles[x]\n\nreturns the list of 6 coordinates and the flag of the survi\
ved particles in x. The form of x is {x, px/p0, y, py/p0, z, dp/p0, flag}, where each is a list of length of the number of particl\
es. If all particles are lost, it is a list of seven null lists."[p$2342,-1],">::",1];
   p1$2342=If[p1$2342==={},275,-2+p$2342+p1$2342[[1,1]]];
neq=Which["SurvivedParticles[x]\n\nreturns the list of 6 coordinates and the flag of the survived particles in x. The form of x is\
 {x, px/p0, y, py/p0, z, dp/p0, flag}, where each is a list of length of the number of particles. If all particles are lost, it is\
 a list of seven null lists."[p$2342,4+p$2342]==="Text[",
    lx$2342:=Help2HTML`oa$;p$2342=5+p$2342;p1$2342-=1;p2$2342=5+p1$2342;p0$2342=-9+p$2342;
If[(pe$2342=StringPosition["SurvivedParticles[x]\n\nreturns the list of 6 coordinates and the flag of the survived particles in x.\
 The form of x is {x, px/p0, y, py/p0, z, dp/p0, flag}, where each is a list of length of the number of particles. If all particle\
s are lost, it is a list of seven null lists."[p$2342,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["SurvivedParticles[x]\n\nreturns the list of 6 coordinates and the flag of the survived particles in x. The form o\
f x is {x, px/p0, y, py/p0, z, dp/p0, flag}, where each is a list of length of the number of particles. If all particles are lost,\
 it is a list of seven null lists."[p$2342+pe$2342[[1,2]],p1$2342]]],
        p1$2342=-2+p$2342+pe$2342[[1,1]]}[[
       1]],
      0],
    1,lx$2342:=Help2HTML`o9$;p2$2342=4+p1$2342;p0$2342=-4+p$2342;0];
  If[(equ$2342=
Help2HTML`o8$["SurvivedParticles[x]\n\nreturns the list of 6 coordinates and the flag of the survived particles in x. The form of \
x is {x, px/p0, y, py/p0, z, dp/p0, flag}, where each is a list of length of the number of particles. If all particles are lost, i\
t is a list of seven null lists."[p$2342,p1$2342]])===
    Undefined,
equ$2342="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["SurvivedParticles[x]\n\nreturns the list of \
6 coordinates and the flag of the survived particles in x. The form of x is {x, px/p0, y, py/p0, z, dp/p0, flag}, where each is a \
list of length of the number of particles. If all particles are lost, it is a list of seven null lists."[p$2342,p1$2342]]=
       equ$2342;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2342},out$2342=lx$2342@Typeset["SurvivedParticles[x]\n\nreturns the list of 6 coordinates and the flag of the survived pa\
rticles in x. The form of x is {x, px/p0, y, py/p0, z, dp/p0, flag}, where each is a list of length of the number of particles. If\
 all particles are lost, it is a list of seven null lists."[p$2342,p1$2342],Format->Help2HTML`oB$];
        System["mv -f "//out$2342//" "//equ$2342]];
      Exit[]]];
   "SurvivedParticles[x]\n\nreturns the list of 6 coordinates and the flag of the survived particles in x. The form of x is {x, px\
/p0, y, py/p0, z, dp/p0, flag}, where each is a list of length of the number of particles. If all particles are lost, it is a list\
 of seven null lists."[1,Max[p0$2342,0]]//"<img  class=\"eqs\" SRC=\""//equ$2342//"\" />"//
Help2HTML`oy$["SurvivedParticles[x]\n\nreturns the list of 6 coordinates and the flag of the survived particles in x. The form of \
x is {x, px/p0, y, py/p0, z, dp/p0, flag}, where each is a list of length of the number of particles. If all particles are lost, i\
t is a list of seven null lists."[p2$2342,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L409>TrackParticles</A></PRE>
<LI>
<H3><A NAME=L406>
SymplecticJ</A></H3>
<PRE>SymplecticJ[n] returns an n by n symplectic matrix:

<img  class="eqs" SRC="SADHelp_img/equ_212.svg" />
</PRE>
<LI>
<H3><A NAME=L407>
SynchroBetaEmittance</A></H3>
<PRE>If[{},
Help2HTML`oA$["SynchroBetaEmittance calculates equilibrium emittance under influence of synchrotron motion and chromaticity.\n\nUs\
age:\n\n   SynchroBetaEmittance[{nus0, nus1, dnus},options]\n\nor\n\n   SynchroBetaEmittance[nus0,options]\n\nwhere nus0, nus1, an\
d dnus are the starting, ending and step size of synchrotron tune, respectively. If only nus0 is given, calculation is done only f\
or nus0. The returned value is a list:\n\n   {{nus, emitx, emity, emitxp, emityp, conv}, ... }\n\nwhere nus, emitx, emity, emitxp,\
 emityp, conv are the synchrotron tune, equilibrium horizontal and vertical emittances, horizontal and vertical projected emittanc\
es, and the convergence, respectively. When conv is negative, calculation failed to converge, and the returned emittances are not \
reliable.\n\nOptions               Type        Default     Meaning\n-----------------------------------------------------------\nA\
zimuthalModes        Real        9           Number of azimuthal modes"],
p$2347=1+p$2347[[1,2]];p1$2347=StringPosition["SynchroBetaEmittance calculates equilibrium emittance under influence of synchrotro\
n motion and chromaticity.\n\nUsage:\n\n   SynchroBetaEmittance[{nus0, nus1, dnus},options]\n\nor\n\n   SynchroBetaEmittance[nus0,\
options]\n\nwhere nus0, nus1, and dnus are the starting, ending and step size of synchrotron tune, respectively. If only nus0 is g\
iven, calculation is done only for nus0. The returned value is a list:\n\n   {{nus, emitx, emity, emitxp, emityp, conv}, ... }\n\n\
where nus, emitx, emity, emitxp, emityp, conv are the synchrotron tune, equilibrium horizontal and vertical emittances, horizontal\
 and vertical projected emittances, and the convergence, respectively. When conv is negative, calculation failed to converge, and \
the returned emittances are not reliable.\n\nOptions               Type        Default     Meaning\n------------------------------\
-----------------------------\nAzimuthalModes        Real        9           Number of azimuthal modes"[p$2347,-1],">::",1];
   p1$2347=If[p1$2347==={},947,-2+p$2347+p1$2347[[1,1]]];
neq=Which["SynchroBetaEmittance calculates equilibrium emittance under influence of synchrotron motion and chromaticity.\n\nUsage:\
\n\n   SynchroBetaEmittance[{nus0, nus1, dnus},options]\n\nor\n\n   SynchroBetaEmittance[nus0,options]\n\nwhere nus0, nus1, and dn\
us are the starting, ending and step size of synchrotron tune, respectively. If only nus0 is given, calculation is done only for n\
us0. The returned value is a list:\n\n   {{nus, emitx, emity, emitxp, emityp, conv}, ... }\n\nwhere nus, emitx, emity, emitxp, emi\
typ, conv are the synchrotron tune, equilibrium horizontal and vertical emittances, horizontal and vertical projected emittances, \
and the convergence, respectively. When conv is negative, calculation failed to converge, and the returned emittances are not reli\
able.\n\nOptions               Type        Default     Meaning\n-----------------------------------------------------------\nAzimu\
thalModes        Real        9           Number of azimuthal modes"[p$2347,4+p$2347]==="Text[",
    lx$2347:=Help2HTML`oa$;p$2347=5+p$2347;p1$2347-=1;p2$2347=5+p1$2347;p0$2347=-9+p$2347;
If[(pe$2347=StringPosition["SynchroBetaEmittance calculates equilibrium emittance under influence of synchrotron motion and chroma\
ticity.\n\nUsage:\n\n   SynchroBetaEmittance[{nus0, nus1, dnus},options]\n\nor\n\n   SynchroBetaEmittance[nus0,options]\n\nwhere n\
us0, nus1, and dnus are the starting, ending and step size of synchrotron tune, respectively. If only nus0 is given, calculation i\
s done only for nus0. The returned value is a list:\n\n   {{nus, emitx, emity, emitxp, emityp, conv}, ... }\n\nwhere nus, emitx, e\
mity, emitxp, emityp, conv are the synchrotron tune, equilibrium horizontal and vertical emittances, horizontal and vertical proje\
cted emittances, and the convergence, respectively. When conv is negative, calculation failed to converge, and the returned emitta\
nces are not reliable.\n\nOptions               Type        Default     Meaning\n-------------------------------------------------\
----------\nAzimuthalModes        Real        9           Number of azimuthal modes"[p$2347,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["SynchroBetaEmittance calculates equilibrium emittance under influence of synchrotron motion and chromaticity.\n\n\
Usage:\n\n   SynchroBetaEmittance[{nus0, nus1, dnus},options]\n\nor\n\n   SynchroBetaEmittance[nus0,options]\n\nwhere nus0, nus1, \
and dnus are the starting, ending and step size of synchrotron tune, respectively. If only nus0 is given, calculation is done only\
 for nus0. The returned value is a list:\n\n   {{nus, emitx, emity, emitxp, emityp, conv}, ... }\n\nwhere nus, emitx, emity, emitx\
p, emityp, conv are the synchrotron tune, equilibrium horizontal and vertical emittances, horizontal and vertical projected emitta\
nces, and the convergence, respectively. When conv is negative, calculation failed to converge, and the returned emittances are no\
t reliable.\n\nOptions               Type        Default     Meaning\n-----------------------------------------------------------\\
nAzimuthalModes        Real        9           Number of azimuthal modes"[p$2347+pe$2347[[1,2]],p1$2347]]],
        p1$2347=-2+p$2347+pe$2347[[1,1]]}[[
       1]],
      0],
    1,lx$2347:=Help2HTML`o9$;p2$2347=4+p1$2347;p0$2347=-4+p$2347;0];
  If[(equ$2347=
Help2HTML`o8$["SynchroBetaEmittance calculates equilibrium emittance under influence of synchrotron motion and chromaticity.\n\nUs\
age:\n\n   SynchroBetaEmittance[{nus0, nus1, dnus},options]\n\nor\n\n   SynchroBetaEmittance[nus0,options]\n\nwhere nus0, nus1, an\
d dnus are the starting, ending and step size of synchrotron tune, respectively. If only nus0 is given, calculation is done only f\
or nus0. The returned value is a list:\n\n   {{nus, emitx, emity, emitxp, emityp, conv}, ... }\n\nwhere nus, emitx, emity, emitxp,\
 emityp, conv are the synchrotron tune, equilibrium horizontal and vertical emittances, horizontal and vertical projected emittanc\
es, and the convergence, respectively. When conv is negative, calculation failed to converge, and the returned emittances are not \
reliable.\n\nOptions               Type        Default     Meaning\n-----------------------------------------------------------\nA\
zimuthalModes        Real        9           Number of azimuthal modes"[p$2347,p1$2347]])===
    Undefined,
equ$2347="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["SynchroBetaEmittance calculates equilibrium \
emittance under influence of synchrotron motion and chromaticity.\n\nUsage:\n\n   SynchroBetaEmittance[{nus0, nus1, dnus},options]\
\n\nor\n\n   SynchroBetaEmittance[nus0,options]\n\nwhere nus0, nus1, and dnus are the starting, ending and step size of synchrotro\
n tune, respectively. If only nus0 is given, calculation is done only for nus0. The returned value is a list:\n\n   {{nus, emitx, \
emity, emitxp, emityp, conv}, ... }\n\nwhere nus, emitx, emity, emitxp, emityp, conv are the synchrotron tune, equilibrium horizon\
tal and vertical emittances, horizontal and vertical projected emittances, and the convergence, respectively. When conv is negativ\
e, calculation failed to converge, and the returned emittances are not reliable.\n\nOptions               Type        Default     \
Meaning\n-----------------------------------------------------------\nAzimuthalModes        Real        9           Number of azim\
uthal modes"[p$2347,p1$2347]]=
       equ$2347;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2347},out$2347=lx$2347@Typeset["SynchroBetaEmittance calculates equilibrium emittance under influence of synchrotron moti\
on and chromaticity.\n\nUsage:\n\n   SynchroBetaEmittance[{nus0, nus1, dnus},options]\n\nor\n\n   SynchroBetaEmittance[nus0,option\
s]\n\nwhere nus0, nus1, and dnus are the starting, ending and step size of synchrotron tune, respectively. If only nus0 is given, \
calculation is done only for nus0. The returned value is a list:\n\n   {{nus, emitx, emity, emitxp, emityp, conv}, ... }\n\nwhere \
nus, emitx, emity, emitxp, emityp, conv are the synchrotron tune, equilibrium horizontal and vertical emittances, horizontal and v\
ertical projected emittances, and the convergence, respectively. When conv is negative, calculation failed to converge, and the re\
turned emittances are not reliable.\n\nOptions               Type        Default     Meaning\n------------------------------------\
-----------------------\nAzimuthalModes        Real        9           Number of azimuthal modes"[p$2347,p1$2347],
          Format->Help2HTML`oB$];
        System["mv -f "//out$2347//" "//equ$2347]];
      Exit[]]];
   "SynchroBetaEmittance calculates equilibrium emittance under influence of synchrotron motion and chromaticity.\n\nUsage:\n\n   \
SynchroBetaEmittance[{nus0, nus1, dnus},options]\n\nor\n\n   SynchroBetaEmittance[nus0,options]\n\nwhere nus0, nus1, and dnus are \
the starting, ending and step size of synchrotron tune, respectively. If only nus0 is given, calculation is done only for nus0. Th\
e returned value is a list:\n\n   {{nus, emitx, emity, emitxp, emityp, conv}, ... }\n\nwhere nus, emitx, emity, emitxp, emityp, co\
nv are the synchrotron tune, equilibrium horizontal and vertical emittances, horizontal and vertical projected emittances, and the\
 convergence, respectively. When conv is negative, calculation failed to converge, and the returned emittances are not reliable.\n\
\nOptions               Type        Default     Meaning\n-----------------------------------------------------------\nAzimuthalMod\
es        Real        9           Number of azimuthal modes"[1,Max[p0$2347,0]]//"<img  class=\"eqs\" SRC=\""//equ$2347//"\" />"//
   Help2HTML`oy$["SynchroBetaEmittance calculates equilibrium emittance under influence of synchrotron motion and chromaticity.\n\\
nUsage:\n\n   SynchroBetaEmittance[{nus0, nus1, dnus},options]\n\nor\n\n   SynchroBetaEmittance[nus0,options]\n\nwhere nus0, nus1,\
 and dnus are the starting, ending and step size of synchrotron tune, respectively. If only nus0 is given, calculation is done onl\
y for nus0. The returned value is a list:\n\n   {{nus, emitx, emity, emitxp, emityp, conv}, ... }\n\nwhere nus, emitx, emity, emit\
xp, emityp, conv are the synchrotron tune, equilibrium horizontal and vertical emittances, horizontal and vertical projected emitt\
ances, and the convergence, respectively. When conv is negative, calculation failed to converge, and the returned emittances are n\
ot reliable.\n\nOptions               Type        Default     Meaning\n-----------------------------------------------------------\
\nAzimuthalModes        Real        9           Number of azimuthal modes"[p2$2347,-1]]
]</PRE>
<PRE>See also:
 SYNCHTOBETA(SYNCHROB) <A HREF=#L55>equilibrium-beam-envelope</A></PRE>
<LI>
<H3><A NAME=L408>
TouschekLifetime</A></H3>
<PRE>If[{},
Help2HTML`oA$["TouschekLifetime interpolates the data calculated by EMIT or Emittance[]. There are three ways of usage:\n\n   Tous\
chekLifetime[Infinity, Infinity, nz]: Touschek lifetime in seconds\n     with momentum aperture nz * SIGE.\n\n   TouschekLifetime[\
nx, Infinity, nz]: Touschek lifetime in seconds\n     with acceptance 2Jx/(nx * (EMITX+EMITY)) + 2Jz/(nz * EMITZ) < 1.\n\n   Tousc\
hekLifetime[Infinity, ny, nz]: Touschek lifetime in seconds\n     with acceptance 2Jy/(ny * (EMITX+EMITY)) + 2Jz/(nz * EMITZ) < 1.\
\n\nEMIT or Emittance[] with INTRA must precede TouschekLifetime."],
p$2350=1+p$2350[[1,2]];p1$2350=StringPosition["TouschekLifetime interpolates the data calculated by EMIT or Emittance[]. There are\
 three ways of usage:\n\n   TouschekLifetime[Infinity, Infinity, nz]: Touschek lifetime in seconds\n     with momentum aperture nz\
 * SIGE.\n\n   TouschekLifetime[nx, Infinity, nz]: Touschek lifetime in seconds\n     with acceptance 2Jx/(nx * (EMITX+EMITY)) + 2\
Jz/(nz * EMITZ) < 1.\n\n   TouschekLifetime[Infinity, ny, nz]: Touschek lifetime in seconds\n     with acceptance 2Jy/(ny * (EMITX\
+EMITY)) + 2Jz/(nz * EMITZ) < 1.\n\nEMIT or Emittance[] with INTRA must precede TouschekLifetime."[p$2350,-1],">::",1];
   p1$2350=If[p1$2350==={},559,-2+p$2350+p1$2350[[1,1]]];
neq=Which["TouschekLifetime interpolates the data calculated by EMIT or Emittance[]. There are three ways of usage:\n\n   Touschek\
Lifetime[Infinity, Infinity, nz]: Touschek lifetime in seconds\n     with momentum aperture nz * SIGE.\n\n   TouschekLifetime[nx, \
Infinity, nz]: Touschek lifetime in seconds\n     with acceptance 2Jx/(nx * (EMITX+EMITY)) + 2Jz/(nz * EMITZ) < 1.\n\n   TouschekL\
ifetime[Infinity, ny, nz]: Touschek lifetime in seconds\n     with acceptance 2Jy/(ny * (EMITX+EMITY)) + 2Jz/(nz * EMITZ) < 1.\n\n\
EMIT or Emittance[] with INTRA must precede TouschekLifetime."[p$2350,4+p$2350]==="Text[",
    lx$2350:=Help2HTML`oa$;p$2350=5+p$2350;p1$2350-=1;p2$2350=5+p1$2350;p0$2350=-9+p$2350;
If[(pe$2350=StringPosition["TouschekLifetime interpolates the data calculated by EMIT or Emittance[]. There are three ways of usag\
e:\n\n   TouschekLifetime[Infinity, Infinity, nz]: Touschek lifetime in seconds\n     with momentum aperture nz * SIGE.\n\n   Tous\
chekLifetime[nx, Infinity, nz]: Touschek lifetime in seconds\n     with acceptance 2Jx/(nx * (EMITX+EMITY)) + 2Jz/(nz * EMITZ) < 1\
.\n\n   TouschekLifetime[Infinity, ny, nz]: Touschek lifetime in seconds\n     with acceptance 2Jy/(ny * (EMITX+EMITY)) + 2Jz/(nz \
* EMITZ) < 1.\n\nEMIT or Emittance[] with INTRA must precede TouschekLifetime."[p$2350,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["TouschekLifetime interpolates the data calculated by EMIT or Emittance[]. There are three ways of usage:\n\n   To\
uschekLifetime[Infinity, Infinity, nz]: Touschek lifetime in seconds\n     with momentum aperture nz * SIGE.\n\n   TouschekLifetim\
e[nx, Infinity, nz]: Touschek lifetime in seconds\n     with acceptance 2Jx/(nx * (EMITX+EMITY)) + 2Jz/(nz * EMITZ) < 1.\n\n   Tou\
schekLifetime[Infinity, ny, nz]: Touschek lifetime in seconds\n     with acceptance 2Jy/(ny * (EMITX+EMITY)) + 2Jz/(nz * EMITZ) < \
1.\n\nEMIT or Emittance[] with INTRA must precede TouschekLifetime."[p$2350+pe$2350[[1,2]],p1$2350]]],
        p1$2350=-2+p$2350+pe$2350[[1,1]]}[[
       1]],
      0],
    1,lx$2350:=Help2HTML`o9$;p2$2350=4+p1$2350;p0$2350=-4+p$2350;0];
  If[(equ$2350=
Help2HTML`o8$["TouschekLifetime interpolates the data calculated by EMIT or Emittance[]. There are three ways of usage:\n\n   Tous\
chekLifetime[Infinity, Infinity, nz]: Touschek lifetime in seconds\n     with momentum aperture nz * SIGE.\n\n   TouschekLifetime[\
nx, Infinity, nz]: Touschek lifetime in seconds\n     with acceptance 2Jx/(nx * (EMITX+EMITY)) + 2Jz/(nz * EMITZ) < 1.\n\n   Tousc\
hekLifetime[Infinity, ny, nz]: Touschek lifetime in seconds\n     with acceptance 2Jy/(ny * (EMITX+EMITY)) + 2Jz/(nz * EMITZ) < 1.\
\n\nEMIT or Emittance[] with INTRA must precede TouschekLifetime."[p$2350,p1$2350]])===
    Undefined,
equ$2350="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["TouschekLifetime interpolates the data calcu\
lated by EMIT or Emittance[]. There are three ways of usage:\n\n   TouschekLifetime[Infinity, Infinity, nz]: Touschek lifetime in \
seconds\n     with momentum aperture nz * SIGE.\n\n   TouschekLifetime[nx, Infinity, nz]: Touschek lifetime in seconds\n     with \
acceptance 2Jx/(nx * (EMITX+EMITY)) + 2Jz/(nz * EMITZ) < 1.\n\n   TouschekLifetime[Infinity, ny, nz]: Touschek lifetime in seconds\
\n     with acceptance 2Jy/(ny * (EMITX+EMITY)) + 2Jz/(nz * EMITZ) < 1.\n\nEMIT or Emittance[] with INTRA must precede TouschekLif\
etime."[p$2350,p1$2350]]=
       equ$2350;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2350},out$2350=lx$2350@Typeset["TouschekLifetime interpolates the data calculated by EMIT or Emittance[]. There are three\
 ways of usage:\n\n   TouschekLifetime[Infinity, Infinity, nz]: Touschek lifetime in seconds\n     with momentum aperture nz * SIG\
E.\n\n   TouschekLifetime[nx, Infinity, nz]: Touschek lifetime in seconds\n     with acceptance 2Jx/(nx * (EMITX+EMITY)) + 2Jz/(nz\
 * EMITZ) < 1.\n\n   TouschekLifetime[Infinity, ny, nz]: Touschek lifetime in seconds\n     with acceptance 2Jy/(ny * (EMITX+EMITY\
)) + 2Jz/(nz * EMITZ) < 1.\n\nEMIT or Emittance[] with INTRA must precede TouschekLifetime."[p$2350,p1$2350],
          Format->Help2HTML`oB$];
        System["mv -f "//out$2350//" "//equ$2350]];
      Exit[]]];
   "TouschekLifetime interpolates the data calculated by EMIT or Emittance[]. There are three ways of usage:\n\n   TouschekLifetim\
e[Infinity, Infinity, nz]: Touschek lifetime in seconds\n     with momentum aperture nz * SIGE.\n\n   TouschekLifetime[nx, Infinit\
y, nz]: Touschek lifetime in seconds\n     with acceptance 2Jx/(nx * (EMITX+EMITY)) + 2Jz/(nz * EMITZ) < 1.\n\n   TouschekLifetime\
[Infinity, ny, nz]: Touschek lifetime in seconds\n     with acceptance 2Jy/(ny * (EMITX+EMITY)) + 2Jz/(nz * EMITZ) < 1.\n\nEMIT or\
 Emittance[] with INTRA must precede TouschekLifetime."[1,Max[p0$2350,0]]//"<img  class=\"eqs\" SRC=\""//equ$2350//"\" />"//
   Help2HTML`oy$["TouschekLifetime interpolates the data calculated by EMIT or Emittance[]. There are three ways of usage:\n\n   T\
ouschekLifetime[Infinity, Infinity, nz]: Touschek lifetime in seconds\n     with momentum aperture nz * SIGE.\n\n   TouschekLifeti\
me[nx, Infinity, nz]: Touschek lifetime in seconds\n     with acceptance 2Jx/(nx * (EMITX+EMITY)) + 2Jz/(nz * EMITZ) < 1.\n\n   To\
uschekLifetime[Infinity, ny, nz]: Touschek lifetime in seconds\n     with acceptance 2Jy/(ny * (EMITX+EMITY)) + 2Jz/(nz * EMITZ) <\
 1.\n\nEMIT or Emittance[] with INTRA must precede TouschekLifetime."[p2$2350,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L295>EMITTANCE(EMIT)</A> <A HREF=#L389>Emittance</A> <A HREF=#L325>INTRA</A> <A HREF=#L530>MINCOUP</A> <A HREF=#L55>equilibrium-beam-envelope</A></PRE>
<LI>
<H3><A NAME=L409>
TrackParticles</A></H3>
<PRE>If[{},
Help2HTML`oA$["TrackParticles[beam, destination-component, nbegin, nend]\n\nreturns a beam after the tracking at the entrance of t\
he destination- component. The destination can be specified by the name of the component or by a number obtained by LINE[\"POSITIO\
N\", component]. If destination is omitted, the end of the line is assumed.\n\nThe argument nbegin is the initial turn number to b\
e passed to tracking to indicate it is in the n-th turn. The number is increased by 1 when it passes the end of beam line. If nbeg\
in is omitted, 1 is assumed.\n\nThe argument nend is the last turn number. The default is nbegin.\n\n   The variable beam and also\
 the result of TrackParticles are lists of the form \n\n   {location, coordinates}\n\nwhere location is the position-number of the\
 starting point. If location is same as or in the downstream of destination, the tracking is done by folding across the beginning \
of the beam line. The coordinates are in a list of {7 or 9, np} form, where np is the number of particles. The first 6 or 8 elemen\
ts of coordinates specifie either\n\n   {x, px/p0, y, py/p0, z, dp/p0} (NOPOL)\n   {x, px/p0, y, py/p0, z, dp/p0, sarg, sy} (POL)\\
n\nin this order, depending on POL. The row [[-1, i]] is the alive flag which is True (==1) when the particle is alive, and False \
(==0) when lost.\n\n   If the flag POL is on, TrackParticles performs spin tracking. Then the coordinates has two more components \
sy and sarg, which correspond to the y-component of the classical spin vector and the angle ArcTan[sx, sz], respectively. If POL i\
s on, another flag RADPOL turns on the Sokolov-Ternov effect.\n\n   When a flag RADLIGHT is on, TrackParticles returns the traject\
ories of particles which are used to calculate the radiation fields. See RadiationField and RadiationSpectrum.\n\nWhen PHOTONS is \
ON (default is OFF), TrackParticles generates a list of all photons radiated through the tracking. The list is assigned to a symbo\
l PhotonList.\n\nWhen LOSSMAP is ON (default is OFF), the input list must have two more lines resulting in a shape of {9 or 11, np\
}. Then TrackParticles returns into these lines the component and the turn where the loss of each particle is detected."],
 p$2353=1+p$2353[[1,2]];
p1$2353=StringPosition["TrackParticles[beam, destination-component, nbegin, nend]\n\nreturns a beam after the tracking at the entr\
ance of the destination- component. The destination can be specified by the name of the component or by a number obtained by LINE[\
\"POSITION\", component]. If destination is omitted, the end of the line is assumed.\n\nThe argument nbegin is the initial turn nu\
mber to be passed to tracking to indicate it is in the n-th turn. The number is increased by 1 when it passes the end of beam line\
. If nbegin is omitted, 1 is assumed.\n\nThe argument nend is the last turn number. The default is nbegin.\n\n   The variable beam\
 and also the result of TrackParticles are lists of the form \n\n   {location, coordinates}\n\nwhere location is the position-numb\
er of the starting point. If location is same as or in the downstream of destination, the tracking is done by folding across the b\
eginning of the beam line. The coordinates are in a list of {7 or 9, np} form, where np is the number of particles. The first 6 or\
 8 elements of coordinates specifie either\n\n   {x, px/p0, y, py/p0, z, dp/p0} (NOPOL)\n   {x, px/p0, y, py/p0, z, dp/p0, sarg, s\
y} (POL)\n\nin this order, depending on POL. The row [[-1, i]] is the alive flag which is True (==1) when the particle is alive, a\
nd False (==0) when lost.\n\n   If the flag POL is on, TrackParticles performs spin tracking. Then the coordinates has two more co\
mponents sy and sarg, which correspond to the y-component of the classical spin vector and the angle ArcTan[sx, sz], respectively.\
 If POL is on, another flag RADPOL turns on the Sokolov-Ternov effect.\n\n   When a flag RADLIGHT is on, TrackParticles returns th\
e trajectories of particles which are used to calculate the radiation fields. See RadiationField and RadiationSpectrum.\n\nWhen PH\
OTONS is ON (default is OFF), TrackParticles generates a list of all photons radiated through the tracking. The list is assigned t\
o a symbol PhotonList.\n\nWhen LOSSMAP is ON (default is OFF), the input list must have two more lines resulting in a shape of {9 \
or 11, np}. Then TrackParticles returns into these lines the component and the turn where the loss of each particle is detected."[
     p$2353,-1],
    ">::",1];
   p1$2353=If[p1$2353==={},2157,-2+p$2353+p1$2353[[1,1]]];
neq=Which["TrackParticles[beam, destination-component, nbegin, nend]\n\nreturns a beam after the tracking at the entrance of the d\
estination- component. The destination can be specified by the name of the component or by a number obtained by LINE[\"POSITION\",\
 component]. If destination is omitted, the end of the line is assumed.\n\nThe argument nbegin is the initial turn number to be pa\
ssed to tracking to indicate it is in the n-th turn. The number is increased by 1 when it passes the end of beam line. If nbegin i\
s omitted, 1 is assumed.\n\nThe argument nend is the last turn number. The default is nbegin.\n\n   The variable beam and also the\
 result of TrackParticles are lists of the form \n\n   {location, coordinates}\n\nwhere location is the position-number of the sta\
rting point. If location is same as or in the downstream of destination, the tracking is done by folding across the beginning of t\
he beam line. The coordinates are in a list of {7 or 9, np} form, where np is the number of particles. The first 6 or 8 elements o\
f coordinates specifie either\n\n   {x, px/p0, y, py/p0, z, dp/p0} (NOPOL)\n   {x, px/p0, y, py/p0, z, dp/p0, sarg, sy} (POL)\n\ni\
n this order, depending on POL. The row [[-1, i]] is the alive flag which is True (==1) when the particle is alive, and False (==0\
) when lost.\n\n   If the flag POL is on, TrackParticles performs spin tracking. Then the coordinates has two more components sy a\
nd sarg, which correspond to the y-component of the classical spin vector and the angle ArcTan[sx, sz], respectively. If POL is on\
, another flag RADPOL turns on the Sokolov-Ternov effect.\n\n   When a flag RADLIGHT is on, TrackParticles returns the trajectorie\
s of particles which are used to calculate the radiation fields. See RadiationField and RadiationSpectrum.\n\nWhen PHOTONS is ON (\
default is OFF), TrackParticles generates a list of all photons radiated through the tracking. The list is assigned to a symbol Ph\
otonList.\n\nWhen LOSSMAP is ON (default is OFF), the input list must have two more lines resulting in a shape of {9 or 11, np}. T\
hen TrackParticles returns into these lines the component and the turn where the loss of each particle is detected."[p$2353,
      4+p$2353]===
     "Text[",
lx$2353:=Help2HTML`oa$;p$2353=5+p$2353;p1$2353-=1;p2$2353=5+p1$2353;p0$2353=-9+p$2353;If[(pe$2353=StringPosition["TrackParticles[b\
eam, destination-component, nbegin, nend]\n\nreturns a beam after the tracking at the entrance of the destination- component. The \
destination can be specified by the name of the component or by a number obtained by LINE[\"POSITION\", component]. If destination\
 is omitted, the end of the line is assumed.\n\nThe argument nbegin is the initial turn number to be passed to tracking to indicat\
e it is in the n-th turn. The number is increased by 1 when it passes the end of beam line. If nbegin is omitted, 1 is assumed.\n\\
nThe argument nend is the last turn number. The default is nbegin.\n\n   The variable beam and also the result of TrackParticles a\
re lists of the form \n\n   {location, coordinates}\n\nwhere location is the position-number of the starting point. If location is\
 same as or in the downstream of destination, the tracking is done by folding across the beginning of the beam line. The coordinat\
es are in a list of {7 or 9, np} form, where np is the number of particles. The first 6 or 8 elements of coordinates specifie eith\
er\n\n   {x, px/p0, y, py/p0, z, dp/p0} (NOPOL)\n   {x, px/p0, y, py/p0, z, dp/p0, sarg, sy} (POL)\n\nin this order, depending on \
POL. The row [[-1, i]] is the alive flag which is True (==1) when the particle is alive, and False (==0) when lost.\n\n   If the f\
lag POL is on, TrackParticles performs spin tracking. Then the coordinates has two more components sy and sarg, which correspond t\
o the y-component of the classical spin vector and the angle ArcTan[sx, sz], respectively. If POL is on, another flag RADPOL turns\
 on the Sokolov-Ternov effect.\n\n   When a flag RADLIGHT is on, TrackParticles returns the trajectories of particles which are us\
ed to calculate the radiation fields. See RadiationField and RadiationSpectrum.\n\nWhen PHOTONS is ON (default is OFF), TrackParti\
cles generates a list of all photons radiated through the tracking. The list is assigned to a symbol PhotonList.\n\nWhen LOSSMAP i\
s ON (default is OFF), the input list must have two more lines resulting in a shape of {9 or 11, np}. Then TrackParticles returns \
into these lines the component and the turn where the loss of each particle is detected."[p$2353,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["TrackParticles[beam, destination-component, nbegin, nend]\n\nreturns a beam after the tracking at the entrance of\
 the destination- component. The destination can be specified by the name of the component or by a number obtained by LINE[\"POSIT\
ION\", component]. If destination is omitted, the end of the line is assumed.\n\nThe argument nbegin is the initial turn number to\
 be passed to tracking to indicate it is in the n-th turn. The number is increased by 1 when it passes the end of beam line. If nb\
egin is omitted, 1 is assumed.\n\nThe argument nend is the last turn number. The default is nbegin.\n\n   The variable beam and al\
so the result of TrackParticles are lists of the form \n\n   {location, coordinates}\n\nwhere location is the position-number of t\
he starting point. If location is same as or in the downstream of destination, the tracking is done by folding across the beginnin\
g of the beam line. The coordinates are in a list of {7 or 9, np} form, where np is the number of particles. The first 6 or 8 elem\
ents of coordinates specifie either\n\n   {x, px/p0, y, py/p0, z, dp/p0} (NOPOL)\n   {x, px/p0, y, py/p0, z, dp/p0, sarg, sy} (POL\
)\n\nin this order, depending on POL. The row [[-1, i]] is the alive flag which is True (==1) when the particle is alive, and Fals\
e (==0) when lost.\n\n   If the flag POL is on, TrackParticles performs spin tracking. Then the coordinates has two more component\
s sy and sarg, which correspond to the y-component of the classical spin vector and the angle ArcTan[sx, sz], respectively. If POL\
 is on, another flag RADPOL turns on the Sokolov-Ternov effect.\n\n   When a flag RADLIGHT is on, TrackParticles returns the traje\
ctories of particles which are used to calculate the radiation fields. See RadiationField and RadiationSpectrum.\n\nWhen PHOTONS i\
s ON (default is OFF), TrackParticles generates a list of all photons radiated through the tracking. The list is assigned to a sym\
bol PhotonList.\n\nWhen LOSSMAP is ON (default is OFF), the input list must have two more lines resulting in a shape of {9 or 11, \
np}. Then TrackParticles returns into these lines the component and the turn where the loss of each particle is detected."[p$2353+
            pe$2353[[1,2]],
           p1$2353]]],
        p1$2353=-2+p$2353+pe$2353[[1,1]]}[[
       1]],
      0],
    1,lx$2353:=Help2HTML`o9$;p2$2353=4+p1$2353;p0$2353=-4+p$2353;0];
  If[(equ$2353=
Help2HTML`o8$["TrackParticles[beam, destination-component, nbegin, nend]\n\nreturns a beam after the tracking at the entrance of t\
he destination- component. The destination can be specified by the name of the component or by a number obtained by LINE[\"POSITIO\
N\", component]. If destination is omitted, the end of the line is assumed.\n\nThe argument nbegin is the initial turn number to b\
e passed to tracking to indicate it is in the n-th turn. The number is increased by 1 when it passes the end of beam line. If nbeg\
in is omitted, 1 is assumed.\n\nThe argument nend is the last turn number. The default is nbegin.\n\n   The variable beam and also\
 the result of TrackParticles are lists of the form \n\n   {location, coordinates}\n\nwhere location is the position-number of the\
 starting point. If location is same as or in the downstream of destination, the tracking is done by folding across the beginning \
of the beam line. The coordinates are in a list of {7 or 9, np} form, where np is the number of particles. The first 6 or 8 elemen\
ts of coordinates specifie either\n\n   {x, px/p0, y, py/p0, z, dp/p0} (NOPOL)\n   {x, px/p0, y, py/p0, z, dp/p0, sarg, sy} (POL)\\
n\nin this order, depending on POL. The row [[-1, i]] is the alive flag which is True (==1) when the particle is alive, and False \
(==0) when lost.\n\n   If the flag POL is on, TrackParticles performs spin tracking. Then the coordinates has two more components \
sy and sarg, which correspond to the y-component of the classical spin vector and the angle ArcTan[sx, sz], respectively. If POL i\
s on, another flag RADPOL turns on the Sokolov-Ternov effect.\n\n   When a flag RADLIGHT is on, TrackParticles returns the traject\
ories of particles which are used to calculate the radiation fields. See RadiationField and RadiationSpectrum.\n\nWhen PHOTONS is \
ON (default is OFF), TrackParticles generates a list of all photons radiated through the tracking. The list is assigned to a symbo\
l PhotonList.\n\nWhen LOSSMAP is ON (default is OFF), the input list must have two more lines resulting in a shape of {9 or 11, np\
}. Then TrackParticles returns into these lines the component and the turn where the loss of each particle is detected."[p$2353,
       p1$2353]])===
    Undefined,
equ$2353="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["TrackParticles[beam, destination-component, \
nbegin, nend]\n\nreturns a beam after the tracking at the entrance of the destination- component. The destination can be specified\
 by the name of the component or by a number obtained by LINE[\"POSITION\", component]. If destination is omitted, the end of the \
line is assumed.\n\nThe argument nbegin is the initial turn number to be passed to tracking to indicate it is in the n-th turn. Th\
e number is increased by 1 when it passes the end of beam line. If nbegin is omitted, 1 is assumed.\n\nThe argument nend is the la\
st turn number. The default is nbegin.\n\n   The variable beam and also the result of TrackParticles are lists of the form \n\n   \
{location, coordinates}\n\nwhere location is the position-number of the starting point. If location is same as or in the downstrea\
m of destination, the tracking is done by folding across the beginning of the beam line. The coordinates are in a list of {7 or 9,\
 np} form, where np is the number of particles. The first 6 or 8 elements of coordinates specifie either\n\n   {x, px/p0, y, py/p0\
, z, dp/p0} (NOPOL)\n   {x, px/p0, y, py/p0, z, dp/p0, sarg, sy} (POL)\n\nin this order, depending on POL. The row [[-1, i]] is th\
e alive flag which is True (==1) when the particle is alive, and False (==0) when lost.\n\n   If the flag POL is on, TrackParticle\
s performs spin tracking. Then the coordinates has two more components sy and sarg, which correspond to the y-component of the cla\
ssical spin vector and the angle ArcTan[sx, sz], respectively. If POL is on, another flag RADPOL turns on the Sokolov-Ternov effec\
t.\n\n   When a flag RADLIGHT is on, TrackParticles returns the trajectories of particles which are used to calculate the radiatio\
n fields. See RadiationField and RadiationSpectrum.\n\nWhen PHOTONS is ON (default is OFF), TrackParticles generates a list of all\
 photons radiated through the tracking. The list is assigned to a symbol PhotonList.\n\nWhen LOSSMAP is ON (default is OFF), the i\
nput list must have two more lines resulting in a shape of {9 or 11, np}. Then TrackParticles returns into these lines the compone\
nt and the turn where the loss of each particle is detected."[p$2353,p1$2353]]=
       equ$2353;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2353},out$2353=lx$2353@Typeset["TrackParticles[beam, destination-component, nbegin, nend]\n\nreturns a beam after the tra\
cking at the entrance of the destination- component. The destination can be specified by the name of the component or by a number \
obtained by LINE[\"POSITION\", component]. If destination is omitted, the end of the line is assumed.\n\nThe argument nbegin is th\
e initial turn number to be passed to tracking to indicate it is in the n-th turn. The number is increased by 1 when it passes the\
 end of beam line. If nbegin is omitted, 1 is assumed.\n\nThe argument nend is the last turn number. The default is nbegin.\n\n   \
The variable beam and also the result of TrackParticles are lists of the form \n\n   {location, coordinates}\n\nwhere location is \
the position-number of the starting point. If location is same as or in the downstream of destination, the tracking is done by fol\
ding across the beginning of the beam line. The coordinates are in a list of {7 or 9, np} form, where np is the number of particle\
s. The first 6 or 8 elements of coordinates specifie either\n\n   {x, px/p0, y, py/p0, z, dp/p0} (NOPOL)\n   {x, px/p0, y, py/p0, \
z, dp/p0, sarg, sy} (POL)\n\nin this order, depending on POL. The row [[-1, i]] is the alive flag which is True (==1) when the par\
ticle is alive, and False (==0) when lost.\n\n   If the flag POL is on, TrackParticles performs spin tracking. Then the coordinate\
s has two more components sy and sarg, which correspond to the y-component of the classical spin vector and the angle ArcTan[sx, s\
z], respectively. If POL is on, another flag RADPOL turns on the Sokolov-Ternov effect.\n\n   When a flag RADLIGHT is on, TrackPar\
ticles returns the trajectories of particles which are used to calculate the radiation fields. See RadiationField and RadiationSpe\
ctrum.\n\nWhen PHOTONS is ON (default is OFF), TrackParticles generates a list of all photons radiated through the tracking. The l\
ist is assigned to a symbol PhotonList.\n\nWhen LOSSMAP is ON (default is OFF), the input list must have two more lines resulting \
in a shape of {9 or 11, np}. Then TrackParticles returns into these lines the component and the turn where the loss of each partic\
le is detected."[p$2353,p1$2353],Format->Help2HTML`oB$];
        System["mv -f "//out$2353//" "//equ$2353]];
      Exit[]]];
   "TrackParticles[beam, destination-component, nbegin, nend]\n\nreturns a beam after the tracking at the entrance of the destinat\
ion- component. The destination can be specified by the name of the component or by a number obtained by LINE[\"POSITION\", compon\
ent]. If destination is omitted, the end of the line is assumed.\n\nThe argument nbegin is the initial turn number to be passed to\
 tracking to indicate it is in the n-th turn. The number is increased by 1 when it passes the end of beam line. If nbegin is omitt\
ed, 1 is assumed.\n\nThe argument nend is the last turn number. The default is nbegin.\n\n   The variable beam and also the result\
 of TrackParticles are lists of the form \n\n   {location, coordinates}\n\nwhere location is the position-number of the starting p\
oint. If location is same as or in the downstream of destination, the tracking is done by folding across the beginning of the beam\
 line. The coordinates are in a list of {7 or 9, np} form, where np is the number of particles. The first 6 or 8 elements of coord\
inates specifie either\n\n   {x, px/p0, y, py/p0, z, dp/p0} (NOPOL)\n   {x, px/p0, y, py/p0, z, dp/p0, sarg, sy} (POL)\n\nin this \
order, depending on POL. The row [[-1, i]] is the alive flag which is True (==1) when the particle is alive, and False (==0) when \
lost.\n\n   If the flag POL is on, TrackParticles performs spin tracking. Then the coordinates has two more components sy and sarg\
, which correspond to the y-component of the classical spin vector and the angle ArcTan[sx, sz], respectively. If POL is on, anoth\
er flag RADPOL turns on the Sokolov-Ternov effect.\n\n   When a flag RADLIGHT is on, TrackParticles returns the trajectories of pa\
rticles which are used to calculate the radiation fields. See RadiationField and RadiationSpectrum.\n\nWhen PHOTONS is ON (default\
 is OFF), TrackParticles generates a list of all photons radiated through the tracking. The list is assigned to a symbol PhotonLis\
t.\n\nWhen LOSSMAP is ON (default is OFF), the input list must have two more lines resulting in a shape of {9 or 11, np}. Then Tra\
ckParticles returns into these lines the component and the turn where the loss of each particle is detected."[1,Max[p0$2353,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2353//"\" />"//
Help2HTML`oy$["TrackParticles[beam, destination-component, nbegin, nend]\n\nreturns a beam after the tracking at the entrance of t\
he destination- component. The destination can be specified by the name of the component or by a number obtained by LINE[\"POSITIO\
N\", component]. If destination is omitted, the end of the line is assumed.\n\nThe argument nbegin is the initial turn number to b\
e passed to tracking to indicate it is in the n-th turn. The number is increased by 1 when it passes the end of beam line. If nbeg\
in is omitted, 1 is assumed.\n\nThe argument nend is the last turn number. The default is nbegin.\n\n   The variable beam and also\
 the result of TrackParticles are lists of the form \n\n   {location, coordinates}\n\nwhere location is the position-number of the\
 starting point. If location is same as or in the downstream of destination, the tracking is done by folding across the beginning \
of the beam line. The coordinates are in a list of {7 or 9, np} form, where np is the number of particles. The first 6 or 8 elemen\
ts of coordinates specifie either\n\n   {x, px/p0, y, py/p0, z, dp/p0} (NOPOL)\n   {x, px/p0, y, py/p0, z, dp/p0, sarg, sy} (POL)\\
n\nin this order, depending on POL. The row [[-1, i]] is the alive flag which is True (==1) when the particle is alive, and False \
(==0) when lost.\n\n   If the flag POL is on, TrackParticles performs spin tracking. Then the coordinates has two more components \
sy and sarg, which correspond to the y-component of the classical spin vector and the angle ArcTan[sx, sz], respectively. If POL i\
s on, another flag RADPOL turns on the Sokolov-Ternov effect.\n\n   When a flag RADLIGHT is on, TrackParticles returns the traject\
ories of particles which are used to calculate the radiation fields. See RadiationField and RadiationSpectrum.\n\nWhen PHOTONS is \
ON (default is OFF), TrackParticles generates a list of all photons radiated through the tracking. The list is assigned to a symbo\
l PhotonList.\n\nWhen LOSSMAP is ON (default is OFF), the input list must have two more lines resulting in a shape of {9 or 11, np\
}. Then TrackParticles returns into these lines the component and the turn where the loss of each particle is detected."[p2$2353,-1
     ]]
]</PRE>
<PRE>See also:
 <A HREF=#L30>components</A> <A HREF=#L398>LINE</A> <A HREF=#L332>PHOTONS</A> <A HREF=#L541>PhotonList</A> <A HREF=#L339>RADLIGHT</A> <A HREF=#L408>TouschekLifetime</A> <A HREF=#L413>WakeFunction</A> <A HREF=#L405>SurvivedParticles</A>
 <A HREF=#L329>LOSSMAP</A> <A HREF=#L333>POL</A> <A HREF=#L340>RADPOL</A></PRE>
<LI>
<H3><A NAME=L410>
Twiss</A></H3>
<PRE>If[{},
Help2HTML`oA$[" Twiss[optical-function, component] returns the value of the optical-function at the entrance of component. The val\
ues are those calculated by the last CALCULATE(CALC) or GO commands, or CalculateOptics function.\n The second argument, component\
 can be a name of component, a component number, or a list of them. If the number has a fraction, the intermediate value in the co\
mponent is calculated.\n Twiss[\"ALL\",component] or Twiss[\"*\",component] returns all 28 optical-functions at the entrance of co\
mponent as a list:\n\n{AX, BX, GMX, NX, AY, BY, GMY, NY, EX, EPX, EY, EPY, R1, R2, R3, R4, DETR, DX, DPX, DY, DPY, DZ, DDP, AZ, BZ\
, GMZ, NZ, ZX, ZPX, ZY, ZPY},\n\nwhich can be directly used in CalculateOptics. In the current version, however, parameters after \
AZ are uninteresting, because it always returns 1 for BZ and zeros for the others. \"R\"//optical-function refers the reference op\
tics. \"D\"//optical-function refers the difference between the current and the referece optics. \"RALL\" and \"DAL\" mean the all\
 optical functions for the reference optics and the differences, respectively.\n   Keywords \"PEX\", \"PEPX\", \"PEY\", \"PEPY\", \
\"PZX\", \"PZPX\", \"PZY\", \"PZPY\" return dispersions in the physical coordinate.\n   Keywords \"LENGTH\", \"GAMMA\", \"GAMMABET\
A\", \"S\", \"SIGab\" return the same results as for the function LINE.\n   The units of NX, NY, NZ are in radian."],
 p$2356=1+p$2356[[1,2]];
p1$2356=StringPosition[" Twiss[optical-function, component] returns the value of the optical-function at the entrance of component\
. The values are those calculated by the last CALCULATE(CALC) or GO commands, or CalculateOptics function.\n The second argument, \
component can be a name of component, a component number, or a list of them. If the number has a fraction, the intermediate value \
in the component is calculated.\n Twiss[\"ALL\",component] or Twiss[\"*\",component] returns all 28 optical-functions at the entra\
nce of component as a list:\n\n{AX, BX, GMX, NX, AY, BY, GMY, NY, EX, EPX, EY, EPY, R1, R2, R3, R4, DETR, DX, DPX, DY, DPY, DZ, DD\
P, AZ, BZ, GMZ, NZ, ZX, ZPX, ZY, ZPY},\n\nwhich can be directly used in CalculateOptics. In the current version, however, paramete\
rs after AZ are uninteresting, because it always returns 1 for BZ and zeros for the others. \"R\"//optical-function refers the ref\
erence optics. \"D\"//optical-function refers the difference between the current and the referece optics. \"RALL\" and \"DAL\" mea\
n the all optical functions for the reference optics and the differences, respectively.\n   Keywords \"PEX\", \"PEPX\", \"PEY\", \\
"PEPY\", \"PZX\", \"PZPX\", \"PZY\", \"PZPY\" return dispersions in the physical coordinate.\n   Keywords \"LENGTH\", \"GAMMA\", \\
"GAMMABETA\", \"S\", \"SIGab\" return the same results as for the function LINE.\n   The units of NX, NY, NZ are in radian."[p$2356
     ,-1],
    ">::",1];
   p1$2356=If[p1$2356==={},1352,-2+p$2356+p1$2356[[1,1]]];
neq=Which[" Twiss[optical-function, component] returns the value of the optical-function at the entrance of component. The values \
are those calculated by the last CALCULATE(CALC) or GO commands, or CalculateOptics function.\n The second argument, component can\
 be a name of component, a component number, or a list of them. If the number has a fraction, the intermediate value in the compon\
ent is calculated.\n Twiss[\"ALL\",component] or Twiss[\"*\",component] returns all 28 optical-functions at the entrance of compon\
ent as a list:\n\n{AX, BX, GMX, NX, AY, BY, GMY, NY, EX, EPX, EY, EPY, R1, R2, R3, R4, DETR, DX, DPX, DY, DPY, DZ, DDP, AZ, BZ, GM\
Z, NZ, ZX, ZPX, ZY, ZPY},\n\nwhich can be directly used in CalculateOptics. In the current version, however, parameters after AZ a\
re uninteresting, because it always returns 1 for BZ and zeros for the others. \"R\"//optical-function refers the reference optics\
. \"D\"//optical-function refers the difference between the current and the referece optics. \"RALL\" and \"DAL\" mean the all opt\
ical functions for the reference optics and the differences, respectively.\n   Keywords \"PEX\", \"PEPX\", \"PEY\", \"PEPY\", \"PZ\
X\", \"PZPX\", \"PZY\", \"PZPY\" return dispersions in the physical coordinate.\n   Keywords \"LENGTH\", \"GAMMA\", \"GAMMABETA\",\
 \"S\", \"SIGab\" return the same results as for the function LINE.\n   The units of NX, NY, NZ are in radian."[p$2356,4+p$2356]===
     "Text[",
lx$2356:=Help2HTML`oa$;p$2356=5+p$2356;p1$2356-=1;p2$2356=5+p1$2356;p0$2356=-9+p$2356;If[(pe$2356=StringPosition[" Twiss[optical-f\
unction, component] returns the value of the optical-function at the entrance of component. The values are those calculated by the\
 last CALCULATE(CALC) or GO commands, or CalculateOptics function.\n The second argument, component can be a name of component, a \
component number, or a list of them. If the number has a fraction, the intermediate value in the component is calculated.\n Twiss[\
\"ALL\",component] or Twiss[\"*\",component] returns all 28 optical-functions at the entrance of component as a list:\n\n{AX, BX, \
GMX, NX, AY, BY, GMY, NY, EX, EPX, EY, EPY, R1, R2, R3, R4, DETR, DX, DPX, DY, DPY, DZ, DDP, AZ, BZ, GMZ, NZ, ZX, ZPX, ZY, ZPY},\n\
\nwhich can be directly used in CalculateOptics. In the current version, however, parameters after AZ are uninteresting, because i\
t always returns 1 for BZ and zeros for the others. \"R\"//optical-function refers the reference optics. \"D\"//optical-function r\
efers the difference between the current and the referece optics. \"RALL\" and \"DAL\" mean the all optical functions for the refe\
rence optics and the differences, respectively.\n   Keywords \"PEX\", \"PEPX\", \"PEY\", \"PEPY\", \"PZX\", \"PZPX\", \"PZY\", \"P\
ZPY\" return dispersions in the physical coordinate.\n   Keywords \"LENGTH\", \"GAMMA\", \"GAMMABETA\", \"S\", \"SIGab\" return th\
e same results as for the function LINE.\n   The units of NX, NY, NZ are in radian."[p$2356,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression[" Twiss[optical-function, component] returns the value of the optical-function at the entrance of component. The v\
alues are those calculated by the last CALCULATE(CALC) or GO commands, or CalculateOptics function.\n The second argument, compone\
nt can be a name of component, a component number, or a list of them. If the number has a fraction, the intermediate value in the \
component is calculated.\n Twiss[\"ALL\",component] or Twiss[\"*\",component] returns all 28 optical-functions at the entrance of \
component as a list:\n\n{AX, BX, GMX, NX, AY, BY, GMY, NY, EX, EPX, EY, EPY, R1, R2, R3, R4, DETR, DX, DPX, DY, DPY, DZ, DDP, AZ, \
BZ, GMZ, NZ, ZX, ZPX, ZY, ZPY},\n\nwhich can be directly used in CalculateOptics. In the current version, however, parameters afte\
r AZ are uninteresting, because it always returns 1 for BZ and zeros for the others. \"R\"//optical-function refers the reference \
optics. \"D\"//optical-function refers the difference between the current and the referece optics. \"RALL\" and \"DAL\" mean the a\
ll optical functions for the reference optics and the differences, respectively.\n   Keywords \"PEX\", \"PEPX\", \"PEY\", \"PEPY\"\
, \"PZX\", \"PZPX\", \"PZY\", \"PZPY\" return dispersions in the physical coordinate.\n   Keywords \"LENGTH\", \"GAMMA\", \"GAMMAB\
ETA\", \"S\", \"SIGab\" return the same results as for the function LINE.\n   The units of NX, NY, NZ are in radian."[p$2356+
            pe$2356[[1,2]],
           p1$2356]]],
        p1$2356=-2+p$2356+pe$2356[[1,1]]}[[
       1]],
      0],
    1,lx$2356:=Help2HTML`o9$;p2$2356=4+p1$2356;p0$2356=-4+p$2356;0];
  If[(equ$2356=
Help2HTML`o8$[" Twiss[optical-function, component] returns the value of the optical-function at the entrance of component. The val\
ues are those calculated by the last CALCULATE(CALC) or GO commands, or CalculateOptics function.\n The second argument, component\
 can be a name of component, a component number, or a list of them. If the number has a fraction, the intermediate value in the co\
mponent is calculated.\n Twiss[\"ALL\",component] or Twiss[\"*\",component] returns all 28 optical-functions at the entrance of co\
mponent as a list:\n\n{AX, BX, GMX, NX, AY, BY, GMY, NY, EX, EPX, EY, EPY, R1, R2, R3, R4, DETR, DX, DPX, DY, DPY, DZ, DDP, AZ, BZ\
, GMZ, NZ, ZX, ZPX, ZY, ZPY},\n\nwhich can be directly used in CalculateOptics. In the current version, however, parameters after \
AZ are uninteresting, because it always returns 1 for BZ and zeros for the others. \"R\"//optical-function refers the reference op\
tics. \"D\"//optical-function refers the difference between the current and the referece optics. \"RALL\" and \"DAL\" mean the all\
 optical functions for the reference optics and the differences, respectively.\n   Keywords \"PEX\", \"PEPX\", \"PEY\", \"PEPY\", \
\"PZX\", \"PZPX\", \"PZY\", \"PZPY\" return dispersions in the physical coordinate.\n   Keywords \"LENGTH\", \"GAMMA\", \"GAMMABET\
A\", \"S\", \"SIGab\" return the same results as for the function LINE.\n   The units of NX, NY, NZ are in radian."[p$2356,p1$2356]
      ])===
    Undefined,
equ$2356="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[" Twiss[optical-function, component] returns \
the value of the optical-function at the entrance of component. The values are those calculated by the last CALCULATE(CALC) or GO \
commands, or CalculateOptics function.\n The second argument, component can be a name of component, a component number, or a list \
of them. If the number has a fraction, the intermediate value in the component is calculated.\n Twiss[\"ALL\",component] or Twiss[\
\"*\",component] returns all 28 optical-functions at the entrance of component as a list:\n\n{AX, BX, GMX, NX, AY, BY, GMY, NY, EX\
, EPX, EY, EPY, R1, R2, R3, R4, DETR, DX, DPX, DY, DPY, DZ, DDP, AZ, BZ, GMZ, NZ, ZX, ZPX, ZY, ZPY},\n\nwhich can be directly used\
 in CalculateOptics. In the current version, however, parameters after AZ are uninteresting, because it always returns 1 for BZ an\
d zeros for the others. \"R\"//optical-function refers the reference optics. \"D\"//optical-function refers the difference between\
 the current and the referece optics. \"RALL\" and \"DAL\" mean the all optical functions for the reference optics and the differe\
nces, respectively.\n   Keywords \"PEX\", \"PEPX\", \"PEY\", \"PEPY\", \"PZX\", \"PZPX\", \"PZY\", \"PZPY\" return dispersions in \
the physical coordinate.\n   Keywords \"LENGTH\", \"GAMMA\", \"GAMMABETA\", \"S\", \"SIGab\" return the same results as for the fu\
nction LINE.\n   The units of NX, NY, NZ are in radian."[p$2356,p1$2356]]=
       equ$2356;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2356},out$2356=lx$2356@Typeset[" Twiss[optical-function, component] returns the value of the optical-function at the entr\
ance of component. The values are those calculated by the last CALCULATE(CALC) or GO commands, or CalculateOptics function.\n The \
second argument, component can be a name of component, a component number, or a list of them. If the number has a fraction, the in\
termediate value in the component is calculated.\n Twiss[\"ALL\",component] or Twiss[\"*\",component] returns all 28 optical-funct\
ions at the entrance of component as a list:\n\n{AX, BX, GMX, NX, AY, BY, GMY, NY, EX, EPX, EY, EPY, R1, R2, R3, R4, DETR, DX, DPX\
, DY, DPY, DZ, DDP, AZ, BZ, GMZ, NZ, ZX, ZPX, ZY, ZPY},\n\nwhich can be directly used in CalculateOptics. In the current version, \
however, parameters after AZ are uninteresting, because it always returns 1 for BZ and zeros for the others. \"R\"//optical-functi\
on refers the reference optics. \"D\"//optical-function refers the difference between the current and the referece optics. \"RALL\\
" and \"DAL\" mean the all optical functions for the reference optics and the differences, respectively.\n   Keywords \"PEX\", \"P\
EPX\", \"PEY\", \"PEPY\", \"PZX\", \"PZPX\", \"PZY\", \"PZPY\" return dispersions in the physical coordinate.\n   Keywords \"LENGT\
H\", \"GAMMA\", \"GAMMABETA\", \"S\", \"SIGab\" return the same results as for the function LINE.\n   The units of NX, NY, NZ are \
in radian."[p$2356,p1$2356],Format->Help2HTML`oB$];
        System["mv -f "//out$2356//" "//equ$2356]];
      Exit[]]];
   " Twiss[optical-function, component] returns the value of the optical-function at the entrance of component. The values are tho\
se calculated by the last CALCULATE(CALC) or GO commands, or CalculateOptics function.\n The second argument, component can be a n\
ame of component, a component number, or a list of them. If the number has a fraction, the intermediate value in the component is \
calculated.\n Twiss[\"ALL\",component] or Twiss[\"*\",component] returns all 28 optical-functions at the entrance of component as \
a list:\n\n{AX, BX, GMX, NX, AY, BY, GMY, NY, EX, EPX, EY, EPY, R1, R2, R3, R4, DETR, DX, DPX, DY, DPY, DZ, DDP, AZ, BZ, GMZ, NZ, \
ZX, ZPX, ZY, ZPY},\n\nwhich can be directly used in CalculateOptics. In the current version, however, parameters after AZ are unin\
teresting, because it always returns 1 for BZ and zeros for the others. \"R\"//optical-function refers the reference optics. \"D\"\
//optical-function refers the difference between the current and the referece optics. \"RALL\" and \"DAL\" mean the all optical fu\
nctions for the reference optics and the differences, respectively.\n   Keywords \"PEX\", \"PEPX\", \"PEY\", \"PEPY\", \"PZX\", \"\
PZPX\", \"PZY\", \"PZPY\" return dispersions in the physical coordinate.\n   Keywords \"LENGTH\", \"GAMMA\", \"GAMMABETA\", \"S\",\
 \"SIGab\" return the same results as for the function LINE.\n   The units of NX, NY, NZ are in radian."[1,Max[p0$2356,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2356//"\" />"//
Help2HTML`oy$[" Twiss[optical-function, component] returns the value of the optical-function at the entrance of component. The val\
ues are those calculated by the last CALCULATE(CALC) or GO commands, or CalculateOptics function.\n The second argument, component\
 can be a name of component, a component number, or a list of them. If the number has a fraction, the intermediate value in the co\
mponent is calculated.\n Twiss[\"ALL\",component] or Twiss[\"*\",component] returns all 28 optical-functions at the entrance of co\
mponent as a list:\n\n{AX, BX, GMX, NX, AY, BY, GMY, NY, EX, EPX, EY, EPY, R1, R2, R3, R4, DETR, DX, DPX, DY, DPY, DZ, DDP, AZ, BZ\
, GMZ, NZ, ZX, ZPX, ZY, ZPY},\n\nwhich can be directly used in CalculateOptics. In the current version, however, parameters after \
AZ are uninteresting, because it always returns 1 for BZ and zeros for the others. \"R\"//optical-function refers the reference op\
tics. \"D\"//optical-function refers the difference between the current and the referece optics. \"RALL\" and \"DAL\" mean the all\
 optical functions for the reference optics and the differences, respectively.\n   Keywords \"PEX\", \"PEPX\", \"PEY\", \"PEPY\", \
\"PZX\", \"PZPX\", \"PZY\", \"PZPY\" return dispersions in the physical coordinate.\n   Keywords \"LENGTH\", \"GAMMA\", \"GAMMABET\
A\", \"S\", \"SIGab\" return the same results as for the function LINE.\n   The units of NX, NY, NZ are in radian."[p2$2356,-1]]
 ]
</PRE>
<PRE>See also:
 <A HREF=#L72>DRAW</A> <A HREF=#L478>optical-functions</A> <A HREF=#L52>extended-Twiss-parameters</A> CalculateOptics <A HREF=#L398>LINE</A> <A HREF=#L490>reference-optics</A></PRE>
<LI>
<H3><A NAME=L411>
VariableRange</A></H3>
<PRE>If[{},
Help2HTML`oA$["Usage:   VariableRange[element, keyword ,v_] := expression\n\nwhere the current value of the element:keyword is pas\
sed in v_, and expression should give False when the value is out of range.\n\nExample: VariableRange[\"QF\",\"ROTATE\",v_]:= -0.1\
 < v < 0.1;\n\nThis restricts the range of the rotation angle of QF within +-100 mrad.\n\n         VariableRange[_,\"ROTATE\",v_]:\
= -0.1 < v < 0.1;\n\nThis specifies the same for all elements.\n   The expression can also return the range as a list {vmin, vmax}\
, which may give more chance of solution-finding for the matching routine.\n   VariableRange only acts for variables used in the m\
atching with the FREE command."],
p$2359=1+p$2359[[1,2]];p1$2359=StringPosition["Usage:   VariableRange[element, keyword ,v_] := expression\n\nwhere the current val\
ue of the element:keyword is passed in v_, and expression should give False when the value is out of range.\n\nExample: VariableRa\
nge[\"QF\",\"ROTATE\",v_]:= -0.1 < v < 0.1;\n\nThis restricts the range of the rotation angle of QF within +-100 mrad.\n\n        \
 VariableRange[_,\"ROTATE\",v_]:= -0.1 < v < 0.1;\n\nThis specifies the same for all elements.\n   The expression can also return \
the range as a list {vmin, vmax}, which may give more chance of solution-finding for the matching routine.\n   VariableRange only \
acts for variables used in the matching with the FREE command."[p$2359,-1],">::",1];
   p1$2359=If[p1$2359==={},647,-2+p$2359+p1$2359[[1,1]]];
neq=Which["Usage:   VariableRange[element, keyword ,v_] := expression\n\nwhere the current value of the element:keyword is passed \
in v_, and expression should give False when the value is out of range.\n\nExample: VariableRange[\"QF\",\"ROTATE\",v_]:= -0.1 < v\
 < 0.1;\n\nThis restricts the range of the rotation angle of QF within +-100 mrad.\n\n         VariableRange[_,\"ROTATE\",v_]:= -0\
.1 < v < 0.1;\n\nThis specifies the same for all elements.\n   The expression can also return the range as a list {vmin, vmax}, wh\
ich may give more chance of solution-finding for the matching routine.\n   VariableRange only acts for variables used in the match\
ing with the FREE command."[p$2359,4+p$2359]==="Text[",
    lx$2359:=Help2HTML`oa$;p$2359=5+p$2359;p1$2359-=1;p2$2359=5+p1$2359;p0$2359=-9+p$2359;
If[(pe$2359=StringPosition["Usage:   VariableRange[element, keyword ,v_] := expression\n\nwhere the current value of the element:k\
eyword is passed in v_, and expression should give False when the value is out of range.\n\nExample: VariableRange[\"QF\",\"ROTATE\
\",v_]:= -0.1 < v < 0.1;\n\nThis restricts the range of the rotation angle of QF within +-100 mrad.\n\n         VariableRange[_,\"\
ROTATE\",v_]:= -0.1 < v < 0.1;\n\nThis specifies the same for all elements.\n   The expression can also return the range as a list\
 {vmin, vmax}, which may give more chance of solution-finding for the matching routine.\n   VariableRange only acts for variables \
used in the matching with the FREE command."[p$2359,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Usage:   VariableRange[element, keyword ,v_] := expression\n\nwhere the current value of the element:keyword is p\
assed in v_, and expression should give False when the value is out of range.\n\nExample: VariableRange[\"QF\",\"ROTATE\",v_]:= -0\
.1 < v < 0.1;\n\nThis restricts the range of the rotation angle of QF within +-100 mrad.\n\n         VariableRange[_,\"ROTATE\",v_\
]:= -0.1 < v < 0.1;\n\nThis specifies the same for all elements.\n   The expression can also return the range as a list {vmin, vma\
x}, which may give more chance of solution-finding for the matching routine.\n   VariableRange only acts for variables used in the\
 matching with the FREE command."[p$2359+pe$2359[[1,2]],p1$2359]]],
        p1$2359=-2+p$2359+pe$2359[[1,1]]}[[
       1]],
      0],
    1,lx$2359:=Help2HTML`o9$;p2$2359=4+p1$2359;p0$2359=-4+p$2359;0];
  If[(equ$2359=
Help2HTML`o8$["Usage:   VariableRange[element, keyword ,v_] := expression\n\nwhere the current value of the element:keyword is pas\
sed in v_, and expression should give False when the value is out of range.\n\nExample: VariableRange[\"QF\",\"ROTATE\",v_]:= -0.1\
 < v < 0.1;\n\nThis restricts the range of the rotation angle of QF within +-100 mrad.\n\n         VariableRange[_,\"ROTATE\",v_]:\
= -0.1 < v < 0.1;\n\nThis specifies the same for all elements.\n   The expression can also return the range as a list {vmin, vmax}\
, which may give more chance of solution-finding for the matching routine.\n   VariableRange only acts for variables used in the m\
atching with the FREE command."[p$2359,p1$2359]])===
    Undefined,
equ$2359="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Usage:   VariableRange[element, keyword ,v_]\
 := expression\n\nwhere the current value of the element:keyword is passed in v_, and expression should give False when the value \
is out of range.\n\nExample: VariableRange[\"QF\",\"ROTATE\",v_]:= -0.1 < v < 0.1;\n\nThis restricts the range of the rotation ang\
le of QF within +-100 mrad.\n\n         VariableRange[_,\"ROTATE\",v_]:= -0.1 < v < 0.1;\n\nThis specifies the same for all elemen\
ts.\n   The expression can also return the range as a list {vmin, vmax}, which may give more chance of solution-finding for the ma\
tching routine.\n   VariableRange only acts for variables used in the matching with the FREE command."[p$2359,p1$2359]]=
       equ$2359;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2359},out$2359=lx$2359@Typeset["Usage:   VariableRange[element, keyword ,v_] := expression\n\nwhere the current value of \
the element:keyword is passed in v_, and expression should give False when the value is out of range.\n\nExample: VariableRange[\"\
QF\",\"ROTATE\",v_]:= -0.1 < v < 0.1;\n\nThis restricts the range of the rotation angle of QF within +-100 mrad.\n\n         Varia\
bleRange[_,\"ROTATE\",v_]:= -0.1 < v < 0.1;\n\nThis specifies the same for all elements.\n   The expression can also return the ra\
nge as a list {vmin, vmax}, which may give more chance of solution-finding for the matching routine.\n   VariableRange only acts f\
or variables used in the matching with the FREE command."[p$2359,p1$2359],Format->Help2HTML`oB$];
        System["mv -f "//out$2359//" "//equ$2359]];
      Exit[]]];
   "Usage:   VariableRange[element, keyword ,v_] := expression\n\nwhere the current value of the element:keyword is passed in v_, \
and expression should give False when the value is out of range.\n\nExample: VariableRange[\"QF\",\"ROTATE\",v_]:= -0.1 < v < 0.1;\
\n\nThis restricts the range of the rotation angle of QF within +-100 mrad.\n\n         VariableRange[_,\"ROTATE\",v_]:= -0.1 < v \
< 0.1;\n\nThis specifies the same for all elements.\n   The expression can also return the range as a list {vmin, vmax}, which may\
 give more chance of solution-finding for the matching routine.\n   VariableRange only acts for variables used in the matching wit\
h the FREE command."[1,Max[p0$2359,0]]//"<img  class=\"eqs\" SRC=\""//equ$2359//"\" />"//
Help2HTML`oy$["Usage:   VariableRange[element, keyword ,v_] := expression\n\nwhere the current value of the element:keyword is pas\
sed in v_, and expression should give False when the value is out of range.\n\nExample: VariableRange[\"QF\",\"ROTATE\",v_]:= -0.1\
 < v < 0.1;\n\nThis restricts the range of the rotation angle of QF within +-100 mrad.\n\n         VariableRange[_,\"ROTATE\",v_]:\
= -0.1 < v < 0.1;\n\nThis specifies the same for all elements.\n   The expression can also return the range as a list {vmin, vmax}\
, which may give more chance of solution-finding for the matching routine.\n   VariableRange only acts for variables used in the m\
atching with the FREE command."[p2$2359,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L466>FREE</A> <A HREF=#L497>set-value-of-element</A></PRE>
<LI>
<H3><A NAME=L412>
VariableWeight</A></H3>
<PRE>If[{},
Help2HTML`oA$["Usage:   VariableWeight[element, keyword ,v_] := expression\n\nwhere the default weight for matching with element:k\
eyword is passed in v_, and expression should return a modified value of weight. If non-real is returned, the default weight is us\
ed.\n\nExample: VariableWeight[\"QF\",\"K1\",v_]:= 0.1*v;\n\nreduces the weight of QF1:K1 to 1/10 of the default value.\n\n   The \
weight also affects the step size of the numerical derivative of the response. A smaller weight makes the step size larger.\n\n   \
VariableWeight only acts for variables used in the matching with the FREE command."],
 p$2362=1+p$2362[[1,2]];p1$2362=StringPosition["Usage:   VariableWeight[element, keyword ,v_] := expression\n\nwhere the default w\
eight for matching with element:keyword is passed in v_, and expression should return a modified value of weight. If non-real is r\
eturned, the default weight is used.\n\nExample: VariableWeight[\"QF\",\"K1\",v_]:= 0.1*v;\n\nreduces the weight of QF1:K1 to 1/10\
 of the default value.\n\n   The weight also affects the step size of the numerical derivative of the response. A smaller weight m\
akes the step size larger.\n\n   VariableWeight only acts for variables used in the matching with the FREE command."[p$2362,-1],
    ">::",1];
   p1$2362=If[p1$2362==={},573,-2+p$2362+p1$2362[[1,1]]];
neq=Which["Usage:   VariableWeight[element, keyword ,v_] := expression\n\nwhere the default weight for matching with element:keywo\
rd is passed in v_, and expression should return a modified value of weight. If non-real is returned, the default weight is used.\\
n\nExample: VariableWeight[\"QF\",\"K1\",v_]:= 0.1*v;\n\nreduces the weight of QF1:K1 to 1/10 of the default value.\n\n   The weig\
ht also affects the step size of the numerical derivative of the response. A smaller weight makes the step size larger.\n\n   Vari\
ableWeight only acts for variables used in the matching with the FREE command."[p$2362,4+p$2362]==="Text[",
    lx$2362:=Help2HTML`oa$;p$2362=5+p$2362;p1$2362-=1;p2$2362=5+p1$2362;p0$2362=-9+p$2362;
If[(pe$2362=StringPosition["Usage:   VariableWeight[element, keyword ,v_] := expression\n\nwhere the default weight for matching w\
ith element:keyword is passed in v_, and expression should return a modified value of weight. If non-real is returned, the default\
 weight is used.\n\nExample: VariableWeight[\"QF\",\"K1\",v_]:= 0.1*v;\n\nreduces the weight of QF1:K1 to 1/10 of the default valu\
e.\n\n   The weight also affects the step size of the numerical derivative of the response. A smaller weight makes the step size l\
arger.\n\n   VariableWeight only acts for variables used in the matching with the FREE command."[p$2362,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Usage:   VariableWeight[element, keyword ,v_] := expression\n\nwhere the default weight for matching with element\
:keyword is passed in v_, and expression should return a modified value of weight. If non-real is returned, the default weight is \
used.\n\nExample: VariableWeight[\"QF\",\"K1\",v_]:= 0.1*v;\n\nreduces the weight of QF1:K1 to 1/10 of the default value.\n\n   Th\
e weight also affects the step size of the numerical derivative of the response. A smaller weight makes the step size larger.\n\n \
  VariableWeight only acts for variables used in the matching with the FREE command."[p$2362+pe$2362[[1,2]],p1$2362]]],
        p1$2362=-2+p$2362+pe$2362[[1,1]]}[[
       1]],
      0],
    1,lx$2362:=Help2HTML`o9$;p2$2362=4+p1$2362;p0$2362=-4+p$2362;0];
  If[(equ$2362=
Help2HTML`o8$["Usage:   VariableWeight[element, keyword ,v_] := expression\n\nwhere the default weight for matching with element:k\
eyword is passed in v_, and expression should return a modified value of weight. If non-real is returned, the default weight is us\
ed.\n\nExample: VariableWeight[\"QF\",\"K1\",v_]:= 0.1*v;\n\nreduces the weight of QF1:K1 to 1/10 of the default value.\n\n   The \
weight also affects the step size of the numerical derivative of the response. A smaller weight makes the step size larger.\n\n   \
VariableWeight only acts for variables used in the matching with the FREE command."[p$2362,p1$2362]])===
    Undefined,
equ$2362="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Usage:   VariableWeight[element, keyword ,v_\
] := expression\n\nwhere the default weight for matching with element:keyword is passed in v_, and expression should return a modi\
fied value of weight. If non-real is returned, the default weight is used.\n\nExample: VariableWeight[\"QF\",\"K1\",v_]:= 0.1*v;\n\
\nreduces the weight of QF1:K1 to 1/10 of the default value.\n\n   The weight also affects the step size of the numerical derivati\
ve of the response. A smaller weight makes the step size larger.\n\n   VariableWeight only acts for variables used in the matching\
 with the FREE command."[p$2362,p1$2362]]=
       equ$2362;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2362},out$2362=lx$2362@Typeset["Usage:   VariableWeight[element, keyword ,v_] := expression\n\nwhere the default weight f\
or matching with element:keyword is passed in v_, and expression should return a modified value of weight. If non-real is returned\
, the default weight is used.\n\nExample: VariableWeight[\"QF\",\"K1\",v_]:= 0.1*v;\n\nreduces the weight of QF1:K1 to 1/10 of the\
 default value.\n\n   The weight also affects the step size of the numerical derivative of the response. A smaller weight makes th\
e step size larger.\n\n   VariableWeight only acts for variables used in the matching with the FREE command."[p$2362,p1$2362],
          Format->Help2HTML`oB$];
        System["mv -f "//out$2362//" "//equ$2362]];
      Exit[]]];
   "Usage:   VariableWeight[element, keyword ,v_] := expression\n\nwhere the default weight for matching with element:keyword is p\
assed in v_, and expression should return a modified value of weight. If non-real is returned, the default weight is used.\n\nExam\
ple: VariableWeight[\"QF\",\"K1\",v_]:= 0.1*v;\n\nreduces the weight of QF1:K1 to 1/10 of the default value.\n\n   The weight also\
 affects the step size of the numerical derivative of the response. A smaller weight makes the step size larger.\n\n   VariableWei\
ght only acts for variables used in the matching with the FREE command."[1,Max[p0$2362,0]]//"<img  class=\"eqs\" SRC=\""//
   equ$2362//"\" />"//
Help2HTML`oy$["Usage:   VariableWeight[element, keyword ,v_] := expression\n\nwhere the default weight for matching with element:k\
eyword is passed in v_, and expression should return a modified value of weight. If non-real is returned, the default weight is us\
ed.\n\nExample: VariableWeight[\"QF\",\"K1\",v_]:= 0.1*v;\n\nreduces the weight of QF1:K1 to 1/10 of the default value.\n\n   The \
weight also affects the step size of the numerical derivative of the response. A smaller weight makes the step size larger.\n\n   \
VariableWeight only acts for variables used in the matching with the FREE command."[p2$2362,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L466>FREE</A> <A HREF=#L497>set-value-of-element</A></PRE>
<LI>
<H3><A NAME=L413>
WakeFunction</A></H3>
<PRE>If[{},
Help2HTML`oA$["   WakeFunction[Longitudinal, comp]={{z1, wl1}, ..., {zn, wln}};\n   WakeFunction[Transverse,   comp]={{z1, wt1}, .\
.., {zn, wtn}};\n\nspecify longitudinal and transverse dipole wake functions at a component comp (string). Each functions is a lis\
t of {z, w} where z is the distance (z>=0) and w is the value of the wake, in the unit of either V/C or V/C/m.\n   The wake functi\
ons are applied at the component comp, giving kicks to each orbit whose initial conditions are given by InitialOrbits. The suffici\
ent number of orbits depends on the situation.\n   WakeFunction is valid only when TRPT and INS, and also either TWAKE or LWAKE is\
 ON.\n   For tracking, it is only valid in TrackParticles."],
p$2365=1+p$2365[[1,2]];p1$2365=StringPosition["   WakeFunction[Longitudinal, comp]={{z1, wl1}, ..., {zn, wln}};\n   WakeFunction[T\
ransverse,   comp]={{z1, wt1}, ..., {zn, wtn}};\n\nspecify longitudinal and transverse dipole wake functions at a component comp (\
string). Each functions is a list of {z, w} where z is the distance (z>=0) and w is the value of the wake, in the unit of either V\
/C or V/C/m.\n   The wake functions are applied at the component comp, giving kicks to each orbit whose initial conditions are giv\
en by InitialOrbits. The sufficient number of orbits depends on the situation.\n   WakeFunction is valid only when TRPT and INS, a\
nd also either TWAKE or LWAKE is ON.\n   For tracking, it is only valid in TrackParticles."[p$2365,-1],">::",1];
   p1$2365=If[p1$2365==={},687,-2+p$2365+p1$2365[[1,1]]];
neq=Which["   WakeFunction[Longitudinal, comp]={{z1, wl1}, ..., {zn, wln}};\n   WakeFunction[Transverse,   comp]={{z1, wt1}, ..., \
{zn, wtn}};\n\nspecify longitudinal and transverse dipole wake functions at a component comp (string). Each functions is a list of\
 {z, w} where z is the distance (z>=0) and w is the value of the wake, in the unit of either V/C or V/C/m.\n   The wake functions \
are applied at the component comp, giving kicks to each orbit whose initial conditions are given by InitialOrbits. The sufficient \
number of orbits depends on the situation.\n   WakeFunction is valid only when TRPT and INS, and also either TWAKE or LWAKE is ON.\
\n   For tracking, it is only valid in TrackParticles."[p$2365,4+p$2365]==="Text[",
    lx$2365:=Help2HTML`oa$;p$2365=5+p$2365;p1$2365-=1;p2$2365=5+p1$2365;p0$2365=-9+p$2365;
If[(pe$2365=StringPosition["   WakeFunction[Longitudinal, comp]={{z1, wl1}, ..., {zn, wln}};\n   WakeFunction[Transverse,   comp]=\
{{z1, wt1}, ..., {zn, wtn}};\n\nspecify longitudinal and transverse dipole wake functions at a component comp (string). Each funct\
ions is a list of {z, w} where z is the distance (z>=0) and w is the value of the wake, in the unit of either V/C or V/C/m.\n   Th\
e wake functions are applied at the component comp, giving kicks to each orbit whose initial conditions are given by InitialOrbits\
. The sufficient number of orbits depends on the situation.\n   WakeFunction is valid only when TRPT and INS, and also either TWAK\
E or LWAKE is ON.\n   For tracking, it is only valid in TrackParticles."[p$2365,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["   WakeFunction[Longitudinal, comp]={{z1, wl1}, ..., {zn, wln}};\n   WakeFunction[Transverse,   comp]={{z1, wt1},\
 ..., {zn, wtn}};\n\nspecify longitudinal and transverse dipole wake functions at a component comp (string). Each functions is a l\
ist of {z, w} where z is the distance (z>=0) and w is the value of the wake, in the unit of either V/C or V/C/m.\n   The wake func\
tions are applied at the component comp, giving kicks to each orbit whose initial conditions are given by InitialOrbits. The suffi\
cient number of orbits depends on the situation.\n   WakeFunction is valid only when TRPT and INS, and also either TWAKE or LWAKE \
is ON.\n   For tracking, it is only valid in TrackParticles."[p$2365+pe$2365[[1,2]],p1$2365]]],
        p1$2365=-2+p$2365+pe$2365[[1,1]]}[[
       1]],
      0],
    1,lx$2365:=Help2HTML`o9$;p2$2365=4+p1$2365;p0$2365=-4+p$2365;0];
  If[(equ$2365=
Help2HTML`o8$["   WakeFunction[Longitudinal, comp]={{z1, wl1}, ..., {zn, wln}};\n   WakeFunction[Transverse,   comp]={{z1, wt1}, .\
.., {zn, wtn}};\n\nspecify longitudinal and transverse dipole wake functions at a component comp (string). Each functions is a lis\
t of {z, w} where z is the distance (z>=0) and w is the value of the wake, in the unit of either V/C or V/C/m.\n   The wake functi\
ons are applied at the component comp, giving kicks to each orbit whose initial conditions are given by InitialOrbits. The suffici\
ent number of orbits depends on the situation.\n   WakeFunction is valid only when TRPT and INS, and also either TWAKE or LWAKE is\
 ON.\n   For tracking, it is only valid in TrackParticles."[p$2365,p1$2365]])===
    Undefined,
equ$2365="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["   WakeFunction[Longitudinal, comp]={{z1, wl\
1}, ..., {zn, wln}};\n   WakeFunction[Transverse,   comp]={{z1, wt1}, ..., {zn, wtn}};\n\nspecify longitudinal and transverse dipo\
le wake functions at a component comp (string). Each functions is a list of {z, w} where z is the distance (z>=0) and w is the val\
ue of the wake, in the unit of either V/C or V/C/m.\n   The wake functions are applied at the component comp, giving kicks to each\
 orbit whose initial conditions are given by InitialOrbits. The sufficient number of orbits depends on the situation.\n   WakeFunc\
tion is valid only when TRPT and INS, and also either TWAKE or LWAKE is ON.\n   For tracking, it is only valid in TrackParticles."[
         p$2365,p1$2365]]=
       equ$2365;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2365},out$2365=lx$2365@Typeset["   WakeFunction[Longitudinal, comp]={{z1, wl1}, ..., {zn, wln}};\n   WakeFunction[Transve\
rse,   comp]={{z1, wt1}, ..., {zn, wtn}};\n\nspecify longitudinal and transverse dipole wake functions at a component comp (string\
). Each functions is a list of {z, w} where z is the distance (z>=0) and w is the value of the wake, in the unit of either V/C or \
V/C/m.\n   The wake functions are applied at the component comp, giving kicks to each orbit whose initial conditions are given by \
InitialOrbits. The sufficient number of orbits depends on the situation.\n   WakeFunction is valid only when TRPT and INS, and als\
o either TWAKE or LWAKE is ON.\n   For tracking, it is only valid in TrackParticles."[p$2365,p1$2365],Format->Help2HTML`oB$];
        System["mv -f "//out$2365//" "//equ$2365]];
      Exit[]]];
   "   WakeFunction[Longitudinal, comp]={{z1, wl1}, ..., {zn, wln}};\n   WakeFunction[Transverse,   comp]={{z1, wt1}, ..., {zn, wt\
n}};\n\nspecify longitudinal and transverse dipole wake functions at a component comp (string). Each functions is a list of {z, w}\
 where z is the distance (z>=0) and w is the value of the wake, in the unit of either V/C or V/C/m.\n   The wake functions are app\
lied at the component comp, giving kicks to each orbit whose initial conditions are given by InitialOrbits. The sufficient number \
of orbits depends on the situation.\n   WakeFunction is valid only when TRPT and INS, and also either TWAKE or LWAKE is ON.\n   Fo\
r tracking, it is only valid in TrackParticles."[1,Max[p0$2365,0]]//"<img  class=\"eqs\" SRC=\""//equ$2365//"\" />"//
   Help2HTML`oy$["   WakeFunction[Longitudinal, comp]={{z1, wl1}, ..., {zn, wln}};\n   WakeFunction[Transverse,   comp]={{z1, wt1}\
, ..., {zn, wtn}};\n\nspecify longitudinal and transverse dipole wake functions at a component comp (string). Each functions is a \
list of {z, w} where z is the distance (z>=0) and w is the value of the wake, in the unit of either V/C or V/C/m.\n   The wake fun\
ctions are applied at the component comp, giving kicks to each orbit whose initial conditions are given by InitialOrbits. The suff\
icient number of orbits depends on the situation.\n   WakeFunction is valid only when TRPT and INS, and also either TWAKE or LWAKE\
 is ON.\n   For tracking, it is only valid in TrackParticles."[p2$2365,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L409>TrackParticles</A> <A HREF=#L352>TRPT</A> <A HREF=#L324>INS</A> <A HREF=#L353>TWAKE</A> <A HREF=#L330>LWAKE</A></PRE>
</UL>
<LI>
<H3><A NAME=L414>
Graphics</A></H3>
<PRE>If[{},
Help2HTML`oA$["Graphics represents an object for 2D graphics with the form\nGraphics[primitives, options]. Up to now available pri\
mitives are:\n\nCircle[{cx,cy},rx, options]             : Circle. \nCircle[{cx,cy},{rx,ry}, options]        : Oval. \nPoints[{{x1,\
y1} .. {x2,y2}}, options]   : Points.\nPoints[{{x1,y1,dx,dy} .. {x2,y2,dx,dy}}, options]  : Points with error bars.\nLine[{{x1,y1}\
 .. {x2,y2}}, options]     : Line.\nLine[{{x1,y1,dx,dy} .. {x2,y2,dx,dy}}, options]    : Line with error bars.\nRectangle[{x1,y1},\
 {x2,y2}]             : A box.\nRectangle[{x1,y1}, {x2,y2}, graphic]    : Graphics in a box.\nPolygon[{{x1,y1} .. {x2,y2}}, option\
s]  : Polygon.\nText[{string, {x,y}}, options]          : Text-string at {x,y}.\n\nPossible options and their defaults values of G\
raphics are:\n\noption           default         optional values\n------------------------------------------------\nAspectRatio   \
   GoldenRatio     any positive number\nDisplayFunction  $DisplayFunction  Identity or Null to suppress display\nDetach           \
False           True to run tdr asynchronously\nEpilog           {}              List of primitives\nFrame            True        \
    False to erase outline, ticks, ticklabels.\nFrameClick       True            to allow click on frame to change options.\nFrame\
Label       {\"\",\"\",\"\",\"\"}   List of strings\nFrameTicks       {Both,Both,Ticks,Ticks}\n                                 No\
ne to turn off ticks and labels\n                                 Both to turn on ticks and labels\n                              \
   Ticks to turn on ticks only\n                                 << For bottom tick >>\n                                 False is \
same as Ticks\n                                 True is same as Both\n                                 << For top tick >>\n       \
                          False is same as None\n                                 True is same as Ticks\n                         \
        << For left & right ticks >>\n                                 False is same as None\n                                 Tru\
e is same as Both\n                                 If a form {___, _List} is given where\n                                 the Li\
st is a list of {coord, label, opt___}\n                                 label is displayed at coord with option opt.\n           \
                      If a form {___, fun} is given and \n                                 fun[coord,exp,org] returns a list of op\
tions\n                                 for Canvas[Create$Text], it is displayed at major\n                                 ticks \
at coord. exp is the exponent and org is the\n                                 original label.\nGridLines        Automatic       A\
utomatic to draw grid lines at major ticks\n                                 {Automatic,None} for only x\n                        \
         {None,Automatic} for only y\n                                 Both, Minor, and Major can be also used.\nPlotLabel        \
\"\"              string\nPlotRange        Automatic       {ymin,ymax} or {{xmin,xmax},{ymin,ymax}}\nProlog           {}          \
    List of promitives\nScale            {Linear,Linear} Log, Date\nTickSize         1               relative size of ticks.\nFram\
eThickness   Automatic       thickness of the frame line incl. ticks.\nLegend           \"\"              shows legend-string.\nFo\
ntScale        1               Relative size of fonts for FrameLabel, FrameTicks.\nFrameFontScale   1               Relative size \
of fonts for FrameLabel.\n                                 If Real, applied to all frames. If List, applied to\n                  \
               bottom, left, top, right, supplemented 1s to the right.\nTickFontScale    1               Relative size of fonts fo\
r FrameTicks.\n                                 If Real, applied to all frames. If List, applied to\n                             \
    bottom, left, top, right, supplemented 1s to the right.\nLegendFontScale  1               Relative size of fonts for Legend.\n\
\nOptions for primitives:\n\nFor Text:\noption           default         optional values\n----------------------------------------\
--------\nTextAlign        \"\"              \"CENTER\"\nTextCases        \"\"              string to represent CASES of TopDrawer\
\nTextPosition     \"\"              \"DATA\" to represent the position by data\n                                 coordinates\nTex\
tRotate       0\nTextSize         1               relative size of a character\nPlotColor        \"Black\"         one of \"White\\
", \"Black\", \"Red\",\n                                 \"Green\",\"Blue\",\"Yellow\",\n                                 \"Magent\
a\",\"Cyan\"\n\nFor Point\noption           default         optional values\n------------------------------------------------\nPoi\
ntSize        1               relative size of a point\nPointSymbol      \"1O\"            Symbol for PLOT of TopDrawer, or Bar\n \
                                \"6O\",\"7O\",\"8O\",\"9O\" are triangles\n                                 in CanvasDrawer.\nPlot\
Color        \"Black\"         one of \"White\", \"Black\", \"Red\",\n                                 \"Green\",\"Blue\",\"Yellow\
\",\n                                 \"Magenta\",\"Cyan\"\nErrorBarTickSize 1               length of error bar ticks.\n\nFor Lin\
e\noption           default         optional values\n------------------------------------------------\nDashing          \"1\"     \
        character string or a list of numbers to\n                                 represent the dashing of the line.\nPlot       \
      True            whether plot symbols at data points.\n                                 If True, PointSize and PointSymbol ar\
e\n                                 effective (see above).\nPlotColor        \"Black\"         one of \"White\", \"Black\", \"Red\\
",\n                                 \"Green\",\"Blue\",\"Yellow\",\n                                 \"Magenta\",\"Cyan\"\nErrorB\
arTickSize 1               length of error bar ticks.\nThickness        1               thickness of line\n\nFor Polygon\noption  \
         default         optional values\n------------------------------------------------\nPlot             False           wheth\
er plot symbols at data points.\n                                 If True, PointSize and PointSymbol are\n                        \
         effective (see above).\nPointSize        1               relative size of a point\nPointSymbol      \"1O\"            Sym\
bol for PLOT of TopDrawer, or Bar\n                                 \"6O\",\"7O\",\"8O\",\"9O\" are triangles\n                   \
              in CanvasDrawer.\nPointColor       \"forest green\"  point fill color.\nPointBorderColor Automatic       point borde\
r color.\n                                 Automatic measn PointColor.\nPointTags        Null            points tag string or list\
 of tag strings.\nPlotJoined       True            whether plot border line of polygon.\nThickness        1               thicknes\
s of border line\n\nDashing          \"1\"             character string or a list of numbers to\n                                 \
represent the dashing of the line.\nPlotColor        \"black\"         border line color.\nLineTags         Null            border\
 line tag string.\nFillColor        Null            polygon fill color.\n                                 Null means empty polygon\
.\nTags             False           polygon tag string.\n\n   ListPlot accepts options for Graphics, Point, and Line.   Show accep\
ts\noptions for Graphics.   The output is written to file #9 (fort.9 in OSF1 and\nftn09 in HP-UX) in TopDrawer commands.   If SAD \
is running on X, the plot is\nalso done immediately.\n\nExamples:\n  g1=ListPlot[{{1,2},{10,20}},Scale->Log,PlotJoined->True,\n   \
 DisplayFunction->Identity];\n  g2=ListPlot[{{1,15},{10,3}},Scale->Log,PlotJoined->True,Dashing->\"1 0.3\",\n    DisplayFunction->\
Identity,Plot->False];\n  g3=ListPlot[{{1,2.5},{5,10},{10,12}},Scale->Log,\n    DisplayFunction->Identity];\n  Show[g1,g2,g3,Frame\
Label->{\"X (mm)\",\"Log(Y)\"},PlotLabel->\"Test Plot\",\n      AspectRatio->1];"],
p$2368=1+p$2368[[1,2]];p1$2368=StringPosition["Graphics represents an object for 2D graphics with the form\nGraphics[primitives, o\
ptions]. Up to now available primitives are:\n\nCircle[{cx,cy},rx, options]             : Circle. \nCircle[{cx,cy},{rx,ry}, option\
s]        : Oval. \nPoints[{{x1,y1} .. {x2,y2}}, options]   : Points.\nPoints[{{x1,y1,dx,dy} .. {x2,y2,dx,dy}}, options]  : Points\
 with error bars.\nLine[{{x1,y1} .. {x2,y2}}, options]     : Line.\nLine[{{x1,y1,dx,dy} .. {x2,y2,dx,dy}}, options]    : Line with\
 error bars.\nRectangle[{x1,y1}, {x2,y2}]             : A box.\nRectangle[{x1,y1}, {x2,y2}, graphic]    : Graphics in a box.\nPoly\
gon[{{x1,y1} .. {x2,y2}}, options]  : Polygon.\nText[{string, {x,y}}, options]          : Text-string at {x,y}.\n\nPossible option\
s and their defaults values of Graphics are:\n\noption           default         optional values\n--------------------------------\
----------------\nAspectRatio      GoldenRatio     any positive number\nDisplayFunction  $DisplayFunction  Identity or Null to sup\
press display\nDetach           False           True to run tdr asynchronously\nEpilog           {}              List of primitive\
s\nFrame            True            False to erase outline, ticks, ticklabels.\nFrameClick       True            to allow click on\
 frame to change options.\nFrameLabel       {\"\",\"\",\"\",\"\"}   List of strings\nFrameTicks       {Both,Both,Ticks,Ticks}\n   \
                              None to turn off ticks and labels\n                                 Both to turn on ticks and labels\
\n                                 Ticks to turn on ticks only\n                                 << For bottom tick >>\n          \
                       False is same as Ticks\n                                 True is same as Both\n                            \
     << For top tick >>\n                                 False is same as None\n                                 True is same as \
Ticks\n                                 << For left & right ticks >>\n                                 False is same as None\n    \
                             True is same as Both\n                                 If a form {___, _List} is given where\n       \
                          the List is a list of {coord, label, opt___}\n                                 label is displayed at coo\
rd with option opt.\n                                 If a form {___, fun} is given and \n                                 fun[coo\
rd,exp,org] returns a list of options\n                                 for Canvas[Create$Text], it is displayed at major\n       \
                          ticks at coord. exp is the exponent and org is the\n                                 original label.\nGr\
idLines        Automatic       Automatic to draw grid lines at major ticks\n                                 {Automatic,None} for \
only x\n                                 {None,Automatic} for only y\n                                 Both, Minor, and Major can \
be also used.\nPlotLabel        \"\"              string\nPlotRange        Automatic       {ymin,ymax} or {{xmin,xmax},{ymin,ymax}\
}\nProlog           {}              List of promitives\nScale            {Linear,Linear} Log, Date\nTickSize         1            \
   relative size of ticks.\nFrameThickness   Automatic       thickness of the frame line incl. ticks.\nLegend           \"\"      \
        shows legend-string.\nFontScale        1               Relative size of fonts for FrameLabel, FrameTicks.\nFrameFontScale \
  1               Relative size of fonts for FrameLabel.\n                                 If Real, applied to all frames. If List\
, applied to\n                                 bottom, left, top, right, supplemented 1s to the right.\nTickFontScale    1        \
       Relative size of fonts for FrameTicks.\n                                 If Real, applied to all frames. If List, applied t\
o\n                                 bottom, left, top, right, supplemented 1s to the right.\nLegendFontScale  1               Rela\
tive size of fonts for Legend.\n\nOptions for primitives:\n\nFor Text:\noption           default         optional values\n--------\
----------------------------------------\nTextAlign        \"\"              \"CENTER\"\nTextCases        \"\"              string\
 to represent CASES of TopDrawer\nTextPosition     \"\"              \"DATA\" to represent the position by data\n                 \
                coordinates\nTextRotate       0\nTextSize         1               relative size of a character\nPlotColor        \\
"Black\"         one of \"White\", \"Black\", \"Red\",\n                                 \"Green\",\"Blue\",\"Yellow\",\n         \
                        \"Magenta\",\"Cyan\"\n\nFor Point\noption           default         optional values\n---------------------\
---------------------------\nPointSize        1               relative size of a point\nPointSymbol      \"1O\"            Symbol \
for PLOT of TopDrawer, or Bar\n                                 \"6O\",\"7O\",\"8O\",\"9O\" are triangles\n                       \
          in CanvasDrawer.\nPlotColor        \"Black\"         one of \"White\", \"Black\", \"Red\",\n                            \
     \"Green\",\"Blue\",\"Yellow\",\n                                 \"Magenta\",\"Cyan\"\nErrorBarTickSize 1               lengt\
h of error bar ticks.\n\nFor Line\noption           default         optional values\n---------------------------------------------\
---\nDashing          \"1\"             character string or a list of numbers to\n                                 represent the d\
ashing of the line.\nPlot             True            whether plot symbols at data points.\n                                 If Tr\
ue, PointSize and PointSymbol are\n                                 effective (see above).\nPlotColor        \"Black\"         one\
 of \"White\", \"Black\", \"Red\",\n                                 \"Green\",\"Blue\",\"Yellow\",\n                             \
    \"Magenta\",\"Cyan\"\nErrorBarTickSize 1               length of error bar ticks.\nThickness        1               thickness \
of line\n\nFor Polygon\noption           default         optional values\n------------------------------------------------\nPlot  \
           False           whether plot symbols at data points.\n                                 If True, PointSize and PointSymb\
ol are\n                                 effective (see above).\nPointSize        1               relative size of a point\nPointS\
ymbol      \"1O\"            Symbol for PLOT of TopDrawer, or Bar\n                                 \"6O\",\"7O\",\"8O\",\"9O\" ar\
e triangles\n                                 in CanvasDrawer.\nPointColor       \"forest green\"  point fill color.\nPointBorderC\
olor Automatic       point border color.\n                                 Automatic measn PointColor.\nPointTags        Null     \
       points tag string or list of tag strings.\nPlotJoined       True            whether plot border line of polygon.\nThickness\
        1               thickness of border line\n\nDashing          \"1\"             character string or a list of numbers to\n \
                                represent the dashing of the line.\nPlotColor        \"black\"         border line color.\nLineTag\
s         Null            border line tag string.\nFillColor        Null            polygon fill color.\n                         \
        Null means empty polygon.\nTags             False           polygon tag string.\n\n   ListPlot accepts options for Graphic\
s, Point, and Line.   Show accepts\noptions for Graphics.   The output is written to file #9 (fort.9 in OSF1 and\nftn09 in HP-UX) \
in TopDrawer commands.   If SAD is running on X, the plot is\nalso done immediately.\n\nExamples:\n  g1=ListPlot[{{1,2},{10,20}},S\
cale->Log,PlotJoined->True,\n    DisplayFunction->Identity];\n  g2=ListPlot[{{1,15},{10,3}},Scale->Log,PlotJoined->True,Dashing->\\
"1 0.3\",\n    DisplayFunction->Identity,Plot->False];\n  g3=ListPlot[{{1,2.5},{5,10},{10,12}},Scale->Log,\n    DisplayFunction->I\
dentity];\n  Show[g1,g2,g3,FrameLabel->{\"X (mm)\",\"Log(Y)\"},PlotLabel->\"Test Plot\",\n      AspectRatio->1];"[p$2368,-1],">::",
    1];
   p1$2368=If[p1$2368==={},7868,-2+p$2368+p1$2368[[1,1]]];
neq=Which["Graphics represents an object for 2D graphics with the form\nGraphics[primitives, options]. Up to now available primiti\
ves are:\n\nCircle[{cx,cy},rx, options]             : Circle. \nCircle[{cx,cy},{rx,ry}, options]        : Oval. \nPoints[{{x1,y1} \
.. {x2,y2}}, options]   : Points.\nPoints[{{x1,y1,dx,dy} .. {x2,y2,dx,dy}}, options]  : Points with error bars.\nLine[{{x1,y1} .. \
{x2,y2}}, options]     : Line.\nLine[{{x1,y1,dx,dy} .. {x2,y2,dx,dy}}, options]    : Line with error bars.\nRectangle[{x1,y1}, {x2\
,y2}]             : A box.\nRectangle[{x1,y1}, {x2,y2}, graphic]    : Graphics in a box.\nPolygon[{{x1,y1} .. {x2,y2}}, options]  \
: Polygon.\nText[{string, {x,y}}, options]          : Text-string at {x,y}.\n\nPossible options and their defaults values of Graph\
ics are:\n\noption           default         optional values\n------------------------------------------------\nAspectRatio      G\
oldenRatio     any positive number\nDisplayFunction  $DisplayFunction  Identity or Null to suppress display\nDetach           Fals\
e           True to run tdr asynchronously\nEpilog           {}              List of primitives\nFrame            True            \
False to erase outline, ticks, ticklabels.\nFrameClick       True            to allow click on frame to change options.\nFrameLabe\
l       {\"\",\"\",\"\",\"\"}   List of strings\nFrameTicks       {Both,Both,Ticks,Ticks}\n                                 None t\
o turn off ticks and labels\n                                 Both to turn on ticks and labels\n                                 T\
icks to turn on ticks only\n                                 << For bottom tick >>\n                                 False is same\
 as Ticks\n                                 True is same as Both\n                                 << For top tick >>\n           \
                      False is same as None\n                                 True is same as Ticks\n                             \
    << For left & right ticks >>\n                                 False is same as None\n                                 True is\
 same as Both\n                                 If a form {___, _List} is given where\n                                 the List i\
s a list of {coord, label, opt___}\n                                 label is displayed at coord with option opt.\n               \
                  If a form {___, fun} is given and \n                                 fun[coord,exp,org] returns a list of option\
s\n                                 for Canvas[Create$Text], it is displayed at major\n                                 ticks at c\
oord. exp is the exponent and org is the\n                                 original label.\nGridLines        Automatic       Autom\
atic to draw grid lines at major ticks\n                                 {Automatic,None} for only x\n                            \
     {None,Automatic} for only y\n                                 Both, Minor, and Major can be also used.\nPlotLabel        \"\"\
              string\nPlotRange        Automatic       {ymin,ymax} or {{xmin,xmax},{ymin,ymax}}\nProlog           {}              \
List of promitives\nScale            {Linear,Linear} Log, Date\nTickSize         1               relative size of ticks.\nFrameThi\
ckness   Automatic       thickness of the frame line incl. ticks.\nLegend           \"\"              shows legend-string.\nFontSc\
ale        1               Relative size of fonts for FrameLabel, FrameTicks.\nFrameFontScale   1               Relative size of f\
onts for FrameLabel.\n                                 If Real, applied to all frames. If List, applied to\n                      \
           bottom, left, top, right, supplemented 1s to the right.\nTickFontScale    1               Relative size of fonts for Fr\
ameTicks.\n                                 If Real, applied to all frames. If List, applied to\n                                 \
bottom, left, top, right, supplemented 1s to the right.\nLegendFontScale  1               Relative size of fonts for Legend.\n\nOp\
tions for primitives:\n\nFor Text:\noption           default         optional values\n--------------------------------------------\
----\nTextAlign        \"\"              \"CENTER\"\nTextCases        \"\"              string to represent CASES of TopDrawer\nTe\
xtPosition     \"\"              \"DATA\" to represent the position by data\n                                 coordinates\nTextRot\
ate       0\nTextSize         1               relative size of a character\nPlotColor        \"Black\"         one of \"White\", \\
"Black\", \"Red\",\n                                 \"Green\",\"Blue\",\"Yellow\",\n                                 \"Magenta\",\
\"Cyan\"\n\nFor Point\noption           default         optional values\n------------------------------------------------\nPointSi\
ze        1               relative size of a point\nPointSymbol      \"1O\"            Symbol for PLOT of TopDrawer, or Bar\n     \
                            \"6O\",\"7O\",\"8O\",\"9O\" are triangles\n                                 in CanvasDrawer.\nPlotColo\
r        \"Black\"         one of \"White\", \"Black\", \"Red\",\n                                 \"Green\",\"Blue\",\"Yellow\",\\
n                                 \"Magenta\",\"Cyan\"\nErrorBarTickSize 1               length of error bar ticks.\n\nFor Line\no\
ption           default         optional values\n------------------------------------------------\nDashing          \"1\"         \
    character string or a list of numbers to\n                                 represent the dashing of the line.\nPlot           \
  True            whether plot symbols at data points.\n                                 If True, PointSize and PointSymbol are\n \
                                effective (see above).\nPlotColor        \"Black\"         one of \"White\", \"Black\", \"Red\",\n\
                                 \"Green\",\"Blue\",\"Yellow\",\n                                 \"Magenta\",\"Cyan\"\nErrorBarTi\
ckSize 1               length of error bar ticks.\nThickness        1               thickness of line\n\nFor Polygon\noption      \
     default         optional values\n------------------------------------------------\nPlot             False           whether p\
lot symbols at data points.\n                                 If True, PointSize and PointSymbol are\n                            \
     effective (see above).\nPointSize        1               relative size of a point\nPointSymbol      \"1O\"            Symbol \
for PLOT of TopDrawer, or Bar\n                                 \"6O\",\"7O\",\"8O\",\"9O\" are triangles\n                       \
          in CanvasDrawer.\nPointColor       \"forest green\"  point fill color.\nPointBorderColor Automatic       point border co\
lor.\n                                 Automatic measn PointColor.\nPointTags        Null            points tag string or list of \
tag strings.\nPlotJoined       True            whether plot border line of polygon.\nThickness        1               thickness of\
 border line\n\nDashing          \"1\"             character string or a list of numbers to\n                                 repr\
esent the dashing of the line.\nPlotColor        \"black\"         border line color.\nLineTags         Null            border lin\
e tag string.\nFillColor        Null            polygon fill color.\n                                 Null means empty polygon.\nT\
ags             False           polygon tag string.\n\n   ListPlot accepts options for Graphics, Point, and Line.   Show accepts\n\
options for Graphics.   The output is written to file #9 (fort.9 in OSF1 and\nftn09 in HP-UX) in TopDrawer commands.   If SAD is r\
unning on X, the plot is\nalso done immediately.\n\nExamples:\n  g1=ListPlot[{{1,2},{10,20}},Scale->Log,PlotJoined->True,\n    Dis\
playFunction->Identity];\n  g2=ListPlot[{{1,15},{10,3}},Scale->Log,PlotJoined->True,Dashing->\"1 0.3\",\n    DisplayFunction->Iden\
tity,Plot->False];\n  g3=ListPlot[{{1,2.5},{5,10},{10,12}},Scale->Log,\n    DisplayFunction->Identity];\n  Show[g1,g2,g3,FrameLabe\
l->{\"X (mm)\",\"Log(Y)\"},PlotLabel->\"Test Plot\",\n      AspectRatio->1];"[p$2368,4+p$2368]==="Text[",
    lx$2368:=Help2HTML`oa$;p$2368=5+p$2368;p1$2368-=1;p2$2368=5+p1$2368;p0$2368=-9+p$2368;
If[(pe$2368=StringPosition["Graphics represents an object for 2D graphics with the form\nGraphics[primitives, options]. Up to now \
available primitives are:\n\nCircle[{cx,cy},rx, options]             : Circle. \nCircle[{cx,cy},{rx,ry}, options]        : Oval. \\
nPoints[{{x1,y1} .. {x2,y2}}, options]   : Points.\nPoints[{{x1,y1,dx,dy} .. {x2,y2,dx,dy}}, options]  : Points with error bars.\n\
Line[{{x1,y1} .. {x2,y2}}, options]     : Line.\nLine[{{x1,y1,dx,dy} .. {x2,y2,dx,dy}}, options]    : Line with error bars.\nRecta\
ngle[{x1,y1}, {x2,y2}]             : A box.\nRectangle[{x1,y1}, {x2,y2}, graphic]    : Graphics in a box.\nPolygon[{{x1,y1} .. {x2\
,y2}}, options]  : Polygon.\nText[{string, {x,y}}, options]          : Text-string at {x,y}.\n\nPossible options and their default\
s values of Graphics are:\n\noption           default         optional values\n------------------------------------------------\nA\
spectRatio      GoldenRatio     any positive number\nDisplayFunction  $DisplayFunction  Identity or Null to suppress display\nDeta\
ch           False           True to run tdr asynchronously\nEpilog           {}              List of primitives\nFrame           \
 True            False to erase outline, ticks, ticklabels.\nFrameClick       True            to allow click on frame to change op\
tions.\nFrameLabel       {\"\",\"\",\"\",\"\"}   List of strings\nFrameTicks       {Both,Both,Ticks,Ticks}\n                      \
           None to turn off ticks and labels\n                                 Both to turn on ticks and labels\n                 \
                Ticks to turn on ticks only\n                                 << For bottom tick >>\n                             \
    False is same as Ticks\n                                 True is same as Both\n                                 << For top tic\
k >>\n                                 False is same as None\n                                 True is same as Ticks\n            \
                     << For left & right ticks >>\n                                 False is same as None\n                       \
          True is same as Both\n                                 If a form {___, _List} is given where\n                          \
       the List is a list of {coord, label, opt___}\n                                 label is displayed at coord with option opt.\
\n                                 If a form {___, fun} is given and \n                                 fun[coord,exp,org] returns\
 a list of options\n                                 for Canvas[Create$Text], it is displayed at major\n                          \
       ticks at coord. exp is the exponent and org is the\n                                 original label.\nGridLines        Auto\
matic       Automatic to draw grid lines at major ticks\n                                 {Automatic,None} for only x\n           \
                      {None,Automatic} for only y\n                                 Both, Minor, and Major can be also used.\nPlot\
Label        \"\"              string\nPlotRange        Automatic       {ymin,ymax} or {{xmin,xmax},{ymin,ymax}}\nProlog          \
 {}              List of promitives\nScale            {Linear,Linear} Log, Date\nTickSize         1               relative size of\
 ticks.\nFrameThickness   Automatic       thickness of the frame line incl. ticks.\nLegend           \"\"              shows legen\
d-string.\nFontScale        1               Relative size of fonts for FrameLabel, FrameTicks.\nFrameFontScale   1               R\
elative size of fonts for FrameLabel.\n                                 If Real, applied to all frames. If List, applied to\n     \
                            bottom, left, top, right, supplemented 1s to the right.\nTickFontScale    1               Relative siz\
e of fonts for FrameTicks.\n                                 If Real, applied to all frames. If List, applied to\n                \
                 bottom, left, top, right, supplemented 1s to the right.\nLegendFontScale  1               Relative size of fonts \
for Legend.\n\nOptions for primitives:\n\nFor Text:\noption           default         optional values\n---------------------------\
---------------------\nTextAlign        \"\"              \"CENTER\"\nTextCases        \"\"              string to represent CASES\
 of TopDrawer\nTextPosition     \"\"              \"DATA\" to represent the position by data\n                                 coo\
rdinates\nTextRotate       0\nTextSize         1               relative size of a character\nPlotColor        \"Black\"         on\
e of \"White\", \"Black\", \"Red\",\n                                 \"Green\",\"Blue\",\"Yellow\",\n                            \
     \"Magenta\",\"Cyan\"\n\nFor Point\noption           default         optional values\n----------------------------------------\
--------\nPointSize        1               relative size of a point\nPointSymbol      \"1O\"            Symbol for PLOT of TopDraw\
er, or Bar\n                                 \"6O\",\"7O\",\"8O\",\"9O\" are triangles\n                                 in Canvas\
Drawer.\nPlotColor        \"Black\"         one of \"White\", \"Black\", \"Red\",\n                                 \"Green\",\"Bl\
ue\",\"Yellow\",\n                                 \"Magenta\",\"Cyan\"\nErrorBarTickSize 1               length of error bar tick\
s.\n\nFor Line\noption           default         optional values\n------------------------------------------------\nDashing       \
   \"1\"             character string or a list of numbers to\n                                 represent the dashing of the line.\
\nPlot             True            whether plot symbols at data points.\n                                 If True, PointSize and P\
ointSymbol are\n                                 effective (see above).\nPlotColor        \"Black\"         one of \"White\", \"Bl\
ack\", \"Red\",\n                                 \"Green\",\"Blue\",\"Yellow\",\n                                 \"Magenta\",\"C\
yan\"\nErrorBarTickSize 1               length of error bar ticks.\nThickness        1               thickness of line\n\nFor Poly\
gon\noption           default         optional values\n------------------------------------------------\nPlot             False   \
        whether plot symbols at data points.\n                                 If True, PointSize and PointSymbol are\n           \
                      effective (see above).\nPointSize        1               relative size of a point\nPointSymbol      \"1O\"  \
          Symbol for PLOT of TopDrawer, or Bar\n                                 \"6O\",\"7O\",\"8O\",\"9O\" are triangles\n      \
                           in CanvasDrawer.\nPointColor       \"forest green\"  point fill color.\nPointBorderColor Automatic     \
  point border color.\n                                 Automatic measn PointColor.\nPointTags        Null            points tag s\
tring or list of tag strings.\nPlotJoined       True            whether plot border line of polygon.\nThickness        1          \
     thickness of border line\n\nDashing          \"1\"             character string or a list of numbers to\n                    \
             represent the dashing of the line.\nPlotColor        \"black\"         border line color.\nLineTags         Null     \
       border line tag string.\nFillColor        Null            polygon fill color.\n                                 Null means \
empty polygon.\nTags             False           polygon tag string.\n\n   ListPlot accepts options for Graphics, Point, and Line.\
   Show accepts\noptions for Graphics.   The output is written to file #9 (fort.9 in OSF1 and\nftn09 in HP-UX) in TopDrawer comman\
ds.   If SAD is running on X, the plot is\nalso done immediately.\n\nExamples:\n  g1=ListPlot[{{1,2},{10,20}},Scale->Log,PlotJoine\
d->True,\n    DisplayFunction->Identity];\n  g2=ListPlot[{{1,15},{10,3}},Scale->Log,PlotJoined->True,Dashing->\"1 0.3\",\n    Disp\
layFunction->Identity,Plot->False];\n  g3=ListPlot[{{1,2.5},{5,10},{10,12}},Scale->Log,\n    DisplayFunction->Identity];\n  Show[g\
1,g2,g3,FrameLabel->{\"X (mm)\",\"Log(Y)\"},PlotLabel->\"Test Plot\",\n      AspectRatio->1];"[p$2368,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Graphics represents an object for 2D graphics with the form\nGraphics[primitives, options]. Up to now available p\
rimitives are:\n\nCircle[{cx,cy},rx, options]             : Circle. \nCircle[{cx,cy},{rx,ry}, options]        : Oval. \nPoints[{{x\
1,y1} .. {x2,y2}}, options]   : Points.\nPoints[{{x1,y1,dx,dy} .. {x2,y2,dx,dy}}, options]  : Points with error bars.\nLine[{{x1,y\
1} .. {x2,y2}}, options]     : Line.\nLine[{{x1,y1,dx,dy} .. {x2,y2,dx,dy}}, options]    : Line with error bars.\nRectangle[{x1,y1\
}, {x2,y2}]             : A box.\nRectangle[{x1,y1}, {x2,y2}, graphic]    : Graphics in a box.\nPolygon[{{x1,y1} .. {x2,y2}}, opti\
ons]  : Polygon.\nText[{string, {x,y}}, options]          : Text-string at {x,y}.\n\nPossible options and their defaults values of\
 Graphics are:\n\noption           default         optional values\n------------------------------------------------\nAspectRatio \
     GoldenRatio     any positive number\nDisplayFunction  $DisplayFunction  Identity or Null to suppress display\nDetach         \
  False           True to run tdr asynchronously\nEpilog           {}              List of primitives\nFrame            True      \
      False to erase outline, ticks, ticklabels.\nFrameClick       True            to allow click on frame to change options.\nFra\
meLabel       {\"\",\"\",\"\",\"\"}   List of strings\nFrameTicks       {Both,Both,Ticks,Ticks}\n                                 \
None to turn off ticks and labels\n                                 Both to turn on ticks and labels\n                            \
     Ticks to turn on ticks only\n                                 << For bottom tick >>\n                                 False i\
s same as Ticks\n                                 True is same as Both\n                                 << For top tick >>\n     \
                            False is same as None\n                                 True is same as Ticks\n                       \
          << For left & right ticks >>\n                                 False is same as None\n                                 T\
rue is same as Both\n                                 If a form {___, _List} is given where\n                                 the \
List is a list of {coord, label, opt___}\n                                 label is displayed at coord with option opt.\n         \
                        If a form {___, fun} is given and \n                                 fun[coord,exp,org] returns a list of \
options\n                                 for Canvas[Create$Text], it is displayed at major\n                                 tick\
s at coord. exp is the exponent and org is the\n                                 original label.\nGridLines        Automatic      \
 Automatic to draw grid lines at major ticks\n                                 {Automatic,None} for only x\n                      \
           {None,Automatic} for only y\n                                 Both, Minor, and Major can be also used.\nPlotLabel      \
  \"\"              string\nPlotRange        Automatic       {ymin,ymax} or {{xmin,xmax},{ymin,ymax}}\nProlog           {}        \
      List of promitives\nScale            {Linear,Linear} Log, Date\nTickSize         1               relative size of ticks.\nFr\
ameThickness   Automatic       thickness of the frame line incl. ticks.\nLegend           \"\"              shows legend-string.\n\
FontScale        1               Relative size of fonts for FrameLabel, FrameTicks.\nFrameFontScale   1               Relative siz\
e of fonts for FrameLabel.\n                                 If Real, applied to all frames. If List, applied to\n                \
                 bottom, left, top, right, supplemented 1s to the right.\nTickFontScale    1               Relative size of fonts \
for FrameTicks.\n                                 If Real, applied to all frames. If List, applied to\n                           \
      bottom, left, top, right, supplemented 1s to the right.\nLegendFontScale  1               Relative size of fonts for Legend.\
\n\nOptions for primitives:\n\nFor Text:\noption           default         optional values\n--------------------------------------\
----------\nTextAlign        \"\"              \"CENTER\"\nTextCases        \"\"              string to represent CASES of TopDraw\
er\nTextPosition     \"\"              \"DATA\" to represent the position by data\n                                 coordinates\nT\
extRotate       0\nTextSize         1               relative size of a character\nPlotColor        \"Black\"         one of \"Whit\
e\", \"Black\", \"Red\",\n                                 \"Green\",\"Blue\",\"Yellow\",\n                                 \"Mage\
nta\",\"Cyan\"\n\nFor Point\noption           default         optional values\n------------------------------------------------\nP\
ointSize        1               relative size of a point\nPointSymbol      \"1O\"            Symbol for PLOT of TopDrawer, or Bar\\
n                                 \"6O\",\"7O\",\"8O\",\"9O\" are triangles\n                                 in CanvasDrawer.\nPl\
otColor        \"Black\"         one of \"White\", \"Black\", \"Red\",\n                                 \"Green\",\"Blue\",\"Yell\
ow\",\n                                 \"Magenta\",\"Cyan\"\nErrorBarTickSize 1               length of error bar ticks.\n\nFor L\
ine\noption           default         optional values\n------------------------------------------------\nDashing          \"1\"   \
          character string or a list of numbers to\n                                 represent the dashing of the line.\nPlot     \
        True            whether plot symbols at data points.\n                                 If True, PointSize and PointSymbol \
are\n                                 effective (see above).\nPlotColor        \"Black\"         one of \"White\", \"Black\", \"Re\
d\",\n                                 \"Green\",\"Blue\",\"Yellow\",\n                                 \"Magenta\",\"Cyan\"\nErro\
rBarTickSize 1               length of error bar ticks.\nThickness        1               thickness of line\n\nFor Polygon\noption\
           default         optional values\n------------------------------------------------\nPlot             False           whe\
ther plot symbols at data points.\n                                 If True, PointSize and PointSymbol are\n                      \
           effective (see above).\nPointSize        1               relative size of a point\nPointSymbol      \"1O\"            S\
ymbol for PLOT of TopDrawer, or Bar\n                                 \"6O\",\"7O\",\"8O\",\"9O\" are triangles\n                 \
                in CanvasDrawer.\nPointColor       \"forest green\"  point fill color.\nPointBorderColor Automatic       point bor\
der color.\n                                 Automatic measn PointColor.\nPointTags        Null            points tag string or li\
st of tag strings.\nPlotJoined       True            whether plot border line of polygon.\nThickness        1               thickn\
ess of border line\n\nDashing          \"1\"             character string or a list of numbers to\n                               \
  represent the dashing of the line.\nPlotColor        \"black\"         border line color.\nLineTags         Null            bord\
er line tag string.\nFillColor        Null            polygon fill color.\n                                 Null means empty polyg\
on.\nTags             False           polygon tag string.\n\n   ListPlot accepts options for Graphics, Point, and Line.   Show acc\
epts\noptions for Graphics.   The output is written to file #9 (fort.9 in OSF1 and\nftn09 in HP-UX) in TopDrawer commands.   If SA\
D is running on X, the plot is\nalso done immediately.\n\nExamples:\n  g1=ListPlot[{{1,2},{10,20}},Scale->Log,PlotJoined->True,\n \
   DisplayFunction->Identity];\n  g2=ListPlot[{{1,15},{10,3}},Scale->Log,PlotJoined->True,Dashing->\"1 0.3\",\n    DisplayFunction\
->Identity,Plot->False];\n  g3=ListPlot[{{1,2.5},{5,10},{10,12}},Scale->Log,\n    DisplayFunction->Identity];\n  Show[g1,g2,g3,Fra\
meLabel->{\"X (mm)\",\"Log(Y)\"},PlotLabel->\"Test Plot\",\n      AspectRatio->1];"[p$2368+pe$2368[[1,2]],p1$2368]]],
        p1$2368=-2+p$2368+pe$2368[[1,1]]}[[
       1]],
      0],
    1,lx$2368:=Help2HTML`o9$;p2$2368=4+p1$2368;p0$2368=-4+p$2368;0];
  If[(equ$2368=
Help2HTML`o8$["Graphics represents an object for 2D graphics with the form\nGraphics[primitives, options]. Up to now available pri\
mitives are:\n\nCircle[{cx,cy},rx, options]             : Circle. \nCircle[{cx,cy},{rx,ry}, options]        : Oval. \nPoints[{{x1,\
y1} .. {x2,y2}}, options]   : Points.\nPoints[{{x1,y1,dx,dy} .. {x2,y2,dx,dy}}, options]  : Points with error bars.\nLine[{{x1,y1}\
 .. {x2,y2}}, options]     : Line.\nLine[{{x1,y1,dx,dy} .. {x2,y2,dx,dy}}, options]    : Line with error bars.\nRectangle[{x1,y1},\
 {x2,y2}]             : A box.\nRectangle[{x1,y1}, {x2,y2}, graphic]    : Graphics in a box.\nPolygon[{{x1,y1} .. {x2,y2}}, option\
s]  : Polygon.\nText[{string, {x,y}}, options]          : Text-string at {x,y}.\n\nPossible options and their defaults values of G\
raphics are:\n\noption           default         optional values\n------------------------------------------------\nAspectRatio   \
   GoldenRatio     any positive number\nDisplayFunction  $DisplayFunction  Identity or Null to suppress display\nDetach           \
False           True to run tdr asynchronously\nEpilog           {}              List of primitives\nFrame            True        \
    False to erase outline, ticks, ticklabels.\nFrameClick       True            to allow click on frame to change options.\nFrame\
Label       {\"\",\"\",\"\",\"\"}   List of strings\nFrameTicks       {Both,Both,Ticks,Ticks}\n                                 No\
ne to turn off ticks and labels\n                                 Both to turn on ticks and labels\n                              \
   Ticks to turn on ticks only\n                                 << For bottom tick >>\n                                 False is \
same as Ticks\n                                 True is same as Both\n                                 << For top tick >>\n       \
                          False is same as None\n                                 True is same as Ticks\n                         \
        << For left & right ticks >>\n                                 False is same as None\n                                 Tru\
e is same as Both\n                                 If a form {___, _List} is given where\n                                 the Li\
st is a list of {coord, label, opt___}\n                                 label is displayed at coord with option opt.\n           \
                      If a form {___, fun} is given and \n                                 fun[coord,exp,org] returns a list of op\
tions\n                                 for Canvas[Create$Text], it is displayed at major\n                                 ticks \
at coord. exp is the exponent and org is the\n                                 original label.\nGridLines        Automatic       A\
utomatic to draw grid lines at major ticks\n                                 {Automatic,None} for only x\n                        \
         {None,Automatic} for only y\n                                 Both, Minor, and Major can be also used.\nPlotLabel        \
\"\"              string\nPlotRange        Automatic       {ymin,ymax} or {{xmin,xmax},{ymin,ymax}}\nProlog           {}          \
    List of promitives\nScale            {Linear,Linear} Log, Date\nTickSize         1               relative size of ticks.\nFram\
eThickness   Automatic       thickness of the frame line incl. ticks.\nLegend           \"\"              shows legend-string.\nFo\
ntScale        1               Relative size of fonts for FrameLabel, FrameTicks.\nFrameFontScale   1               Relative size \
of fonts for FrameLabel.\n                                 If Real, applied to all frames. If List, applied to\n                  \
               bottom, left, top, right, supplemented 1s to the right.\nTickFontScale    1               Relative size of fonts fo\
r FrameTicks.\n                                 If Real, applied to all frames. If List, applied to\n                             \
    bottom, left, top, right, supplemented 1s to the right.\nLegendFontScale  1               Relative size of fonts for Legend.\n\
\nOptions for primitives:\n\nFor Text:\noption           default         optional values\n----------------------------------------\
--------\nTextAlign        \"\"              \"CENTER\"\nTextCases        \"\"              string to represent CASES of TopDrawer\
\nTextPosition     \"\"              \"DATA\" to represent the position by data\n                                 coordinates\nTex\
tRotate       0\nTextSize         1               relative size of a character\nPlotColor        \"Black\"         one of \"White\\
", \"Black\", \"Red\",\n                                 \"Green\",\"Blue\",\"Yellow\",\n                                 \"Magent\
a\",\"Cyan\"\n\nFor Point\noption           default         optional values\n------------------------------------------------\nPoi\
ntSize        1               relative size of a point\nPointSymbol      \"1O\"            Symbol for PLOT of TopDrawer, or Bar\n \
                                \"6O\",\"7O\",\"8O\",\"9O\" are triangles\n                                 in CanvasDrawer.\nPlot\
Color        \"Black\"         one of \"White\", \"Black\", \"Red\",\n                                 \"Green\",\"Blue\",\"Yellow\
\",\n                                 \"Magenta\",\"Cyan\"\nErrorBarTickSize 1               length of error bar ticks.\n\nFor Lin\
e\noption           default         optional values\n------------------------------------------------\nDashing          \"1\"     \
        character string or a list of numbers to\n                                 represent the dashing of the line.\nPlot       \
      True            whether plot symbols at data points.\n                                 If True, PointSize and PointSymbol ar\
e\n                                 effective (see above).\nPlotColor        \"Black\"         one of \"White\", \"Black\", \"Red\\
",\n                                 \"Green\",\"Blue\",\"Yellow\",\n                                 \"Magenta\",\"Cyan\"\nErrorB\
arTickSize 1               length of error bar ticks.\nThickness        1               thickness of line\n\nFor Polygon\noption  \
         default         optional values\n------------------------------------------------\nPlot             False           wheth\
er plot symbols at data points.\n                                 If True, PointSize and PointSymbol are\n                        \
         effective (see above).\nPointSize        1               relative size of a point\nPointSymbol      \"1O\"            Sym\
bol for PLOT of TopDrawer, or Bar\n                                 \"6O\",\"7O\",\"8O\",\"9O\" are triangles\n                   \
              in CanvasDrawer.\nPointColor       \"forest green\"  point fill color.\nPointBorderColor Automatic       point borde\
r color.\n                                 Automatic measn PointColor.\nPointTags        Null            points tag string or list\
 of tag strings.\nPlotJoined       True            whether plot border line of polygon.\nThickness        1               thicknes\
s of border line\n\nDashing          \"1\"             character string or a list of numbers to\n                                 \
represent the dashing of the line.\nPlotColor        \"black\"         border line color.\nLineTags         Null            border\
 line tag string.\nFillColor        Null            polygon fill color.\n                                 Null means empty polygon\
.\nTags             False           polygon tag string.\n\n   ListPlot accepts options for Graphics, Point, and Line.   Show accep\
ts\noptions for Graphics.   The output is written to file #9 (fort.9 in OSF1 and\nftn09 in HP-UX) in TopDrawer commands.   If SAD \
is running on X, the plot is\nalso done immediately.\n\nExamples:\n  g1=ListPlot[{{1,2},{10,20}},Scale->Log,PlotJoined->True,\n   \
 DisplayFunction->Identity];\n  g2=ListPlot[{{1,15},{10,3}},Scale->Log,PlotJoined->True,Dashing->\"1 0.3\",\n    DisplayFunction->\
Identity,Plot->False];\n  g3=ListPlot[{{1,2.5},{5,10},{10,12}},Scale->Log,\n    DisplayFunction->Identity];\n  Show[g1,g2,g3,Frame\
Label->{\"X (mm)\",\"Log(Y)\"},PlotLabel->\"Test Plot\",\n      AspectRatio->1];"[p$2368,p1$2368]])===
    Undefined,
equ$2368="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Graphics represents an object for 2D graphic\
s with the form\nGraphics[primitives, options]. Up to now available primitives are:\n\nCircle[{cx,cy},rx, options]             : C\
ircle. \nCircle[{cx,cy},{rx,ry}, options]        : Oval. \nPoints[{{x1,y1} .. {x2,y2}}, options]   : Points.\nPoints[{{x1,y1,dx,dy\
} .. {x2,y2,dx,dy}}, options]  : Points with error bars.\nLine[{{x1,y1} .. {x2,y2}}, options]     : Line.\nLine[{{x1,y1,dx,dy} .. \
{x2,y2,dx,dy}}, options]    : Line with error bars.\nRectangle[{x1,y1}, {x2,y2}]             : A box.\nRectangle[{x1,y1}, {x2,y2},\
 graphic]    : Graphics in a box.\nPolygon[{{x1,y1} .. {x2,y2}}, options]  : Polygon.\nText[{string, {x,y}}, options]          : T\
ext-string at {x,y}.\n\nPossible options and their defaults values of Graphics are:\n\noption           default         optional v\
alues\n------------------------------------------------\nAspectRatio      GoldenRatio     any positive number\nDisplayFunction  $D\
isplayFunction  Identity or Null to suppress display\nDetach           False           True to run tdr asynchronously\nEpilog     \
      {}              List of primitives\nFrame            True            False to erase outline, ticks, ticklabels.\nFrameClick \
      True            to allow click on frame to change options.\nFrameLabel       {\"\",\"\",\"\",\"\"}   List of strings\nFrameT\
icks       {Both,Both,Ticks,Ticks}\n                                 None to turn off ticks and labels\n                          \
       Both to turn on ticks and labels\n                                 Ticks to turn on ticks only\n                           \
      << For bottom tick >>\n                                 False is same as Ticks\n                                 True is sam\
e as Both\n                                 << For top tick >>\n                                 False is same as None\n          \
                       True is same as Ticks\n                                 << For left & right ticks >>\n                     \
            False is same as None\n                                 True is same as Both\n                                 If a fo\
rm {___, _List} is given where\n                                 the List is a list of {coord, label, opt___}\n                   \
              label is displayed at coord with option opt.\n                                 If a form {___, fun} is given and \n \
                                fun[coord,exp,org] returns a list of options\n                                 for Canvas[Create$T\
ext], it is displayed at major\n                                 ticks at coord. exp is the exponent and org is the\n             \
                    original label.\nGridLines        Automatic       Automatic to draw grid lines at major ticks\n               \
                  {Automatic,None} for only x\n                                 {None,Automatic} for only y\n                     \
            Both, Minor, and Major can be also used.\nPlotLabel        \"\"              string\nPlotRange        Automatic       \
{ymin,ymax} or {{xmin,xmax},{ymin,ymax}}\nProlog           {}              List of promitives\nScale            {Linear,Linear} Lo\
g, Date\nTickSize         1               relative size of ticks.\nFrameThickness   Automatic       thickness of the frame line in\
cl. ticks.\nLegend           \"\"              shows legend-string.\nFontScale        1               Relative size of fonts for F\
rameLabel, FrameTicks.\nFrameFontScale   1               Relative size of fonts for FrameLabel.\n                                 \
If Real, applied to all frames. If List, applied to\n                                 bottom, left, top, right, supplemented 1s to\
 the right.\nTickFontScale    1               Relative size of fonts for FrameTicks.\n                                 If Real, ap\
plied to all frames. If List, applied to\n                                 bottom, left, top, right, supplemented 1s to the right.\
\nLegendFontScale  1               Relative size of fonts for Legend.\n\nOptions for primitives:\n\nFor Text:\noption           de\
fault         optional values\n------------------------------------------------\nTextAlign        \"\"              \"CENTER\"\nTe\
xtCases        \"\"              string to represent CASES of TopDrawer\nTextPosition     \"\"              \"DATA\" to represent \
the position by data\n                                 coordinates\nTextRotate       0\nTextSize         1               relative \
size of a character\nPlotColor        \"Black\"         one of \"White\", \"Black\", \"Red\",\n                                 \"\
Green\",\"Blue\",\"Yellow\",\n                                 \"Magenta\",\"Cyan\"\n\nFor Point\noption           default        \
 optional values\n------------------------------------------------\nPointSize        1               relative size of a point\nPoi\
ntSymbol      \"1O\"            Symbol for PLOT of TopDrawer, or Bar\n                                 \"6O\",\"7O\",\"8O\",\"9O\"\
 are triangles\n                                 in CanvasDrawer.\nPlotColor        \"Black\"         one of \"White\", \"Black\",\
 \"Red\",\n                                 \"Green\",\"Blue\",\"Yellow\",\n                                 \"Magenta\",\"Cyan\"\\
nErrorBarTickSize 1               length of error bar ticks.\n\nFor Line\noption           default         optional values\n------\
------------------------------------------\nDashing          \"1\"             character string or a list of numbers to\n         \
                        represent the dashing of the line.\nPlot             True            whether plot symbols at data points.\\
n                                 If True, PointSize and PointSymbol are\n                                 effective (see above).\\
nPlotColor        \"Black\"         one of \"White\", \"Black\", \"Red\",\n                                 \"Green\",\"Blue\",\"Y\
ellow\",\n                                 \"Magenta\",\"Cyan\"\nErrorBarTickSize 1               length of error bar ticks.\nThic\
kness        1               thickness of line\n\nFor Polygon\noption           default         optional values\n-----------------\
-------------------------------\nPlot             False           whether plot symbols at data points.\n                          \
       If True, PointSize and PointSymbol are\n                                 effective (see above).\nPointSize        1        \
       relative size of a point\nPointSymbol      \"1O\"            Symbol for PLOT of TopDrawer, or Bar\n                        \
         \"6O\",\"7O\",\"8O\",\"9O\" are triangles\n                                 in CanvasDrawer.\nPointColor       \"forest g\
reen\"  point fill color.\nPointBorderColor Automatic       point border color.\n                                 Automatic measn \
PointColor.\nPointTags        Null            points tag string or list of tag strings.\nPlotJoined       True            whether \
plot border line of polygon.\nThickness        1               thickness of border line\n\nDashing          \"1\"             char\
acter string or a list of numbers to\n                                 represent the dashing of the line.\nPlotColor        \"blac\
k\"         border line color.\nLineTags         Null            border line tag string.\nFillColor        Null            polygon\
 fill color.\n                                 Null means empty polygon.\nTags             False           polygon tag string.\n\n\
   ListPlot accepts options for Graphics, Point, and Line.   Show accepts\noptions for Graphics.   The output is written to file #\
9 (fort.9 in OSF1 and\nftn09 in HP-UX) in TopDrawer commands.   If SAD is running on X, the plot is\nalso done immediately.\n\nExa\
mples:\n  g1=ListPlot[{{1,2},{10,20}},Scale->Log,PlotJoined->True,\n    DisplayFunction->Identity];\n  g2=ListPlot[{{1,15},{10,3}}\
,Scale->Log,PlotJoined->True,Dashing->\"1 0.3\",\n    DisplayFunction->Identity,Plot->False];\n  g3=ListPlot[{{1,2.5},{5,10},{10,1\
2}},Scale->Log,\n    DisplayFunction->Identity];\n  Show[g1,g2,g3,FrameLabel->{\"X (mm)\",\"Log(Y)\"},PlotLabel->\"Test Plot\",\n \
     AspectRatio->1];"[p$2368,p1$2368]]=
       equ$2368;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2368},out$2368=lx$2368@Typeset["Graphics represents an object for 2D graphics with the form\nGraphics[primitives, options\
]. Up to now available primitives are:\n\nCircle[{cx,cy},rx, options]             : Circle. \nCircle[{cx,cy},{rx,ry}, options]    \
    : Oval. \nPoints[{{x1,y1} .. {x2,y2}}, options]   : Points.\nPoints[{{x1,y1,dx,dy} .. {x2,y2,dx,dy}}, options]  : Points with \
error bars.\nLine[{{x1,y1} .. {x2,y2}}, options]     : Line.\nLine[{{x1,y1,dx,dy} .. {x2,y2,dx,dy}}, options]    : Line with error\
 bars.\nRectangle[{x1,y1}, {x2,y2}]             : A box.\nRectangle[{x1,y1}, {x2,y2}, graphic]    : Graphics in a box.\nPolygon[{{\
x1,y1} .. {x2,y2}}, options]  : Polygon.\nText[{string, {x,y}}, options]          : Text-string at {x,y}.\n\nPossible options and \
their defaults values of Graphics are:\n\noption           default         optional values\n--------------------------------------\
----------\nAspectRatio      GoldenRatio     any positive number\nDisplayFunction  $DisplayFunction  Identity or Null to suppress \
display\nDetach           False           True to run tdr asynchronously\nEpilog           {}              List of primitives\nFra\
me            True            False to erase outline, ticks, ticklabels.\nFrameClick       True            to allow click on frame\
 to change options.\nFrameLabel       {\"\",\"\",\"\",\"\"}   List of strings\nFrameTicks       {Both,Both,Ticks,Ticks}\n         \
                        None to turn off ticks and labels\n                                 Both to turn on ticks and labels\n    \
                             Ticks to turn on ticks only\n                                 << For bottom tick >>\n                \
                 False is same as Ticks\n                                 True is same as Both\n                                 <\
< For top tick >>\n                                 False is same as None\n                                 True is same as Ticks\\
n                                 << For left & right ticks >>\n                                 False is same as None\n          \
                       True is same as Both\n                                 If a form {___, _List} is given where\n             \
                    the List is a list of {coord, label, opt___}\n                                 label is displayed at coord wit\
h option opt.\n                                 If a form {___, fun} is given and \n                                 fun[coord,exp\
,org] returns a list of options\n                                 for Canvas[Create$Text], it is displayed at major\n             \
                    ticks at coord. exp is the exponent and org is the\n                                 original label.\nGridLine\
s        Automatic       Automatic to draw grid lines at major ticks\n                                 {Automatic,None} for only x\
\n                                 {None,Automatic} for only y\n                                 Both, Minor, and Major can be als\
o used.\nPlotLabel        \"\"              string\nPlotRange        Automatic       {ymin,ymax} or {{xmin,xmax},{ymin,ymax}}\nPro\
log           {}              List of promitives\nScale            {Linear,Linear} Log, Date\nTickSize         1               rel\
ative size of ticks.\nFrameThickness   Automatic       thickness of the frame line incl. ticks.\nLegend           \"\"            \
  shows legend-string.\nFontScale        1               Relative size of fonts for FrameLabel, FrameTicks.\nFrameFontScale   1   \
            Relative size of fonts for FrameLabel.\n                                 If Real, applied to all frames. If List, appl\
ied to\n                                 bottom, left, top, right, supplemented 1s to the right.\nTickFontScale    1              \
 Relative size of fonts for FrameTicks.\n                                 If Real, applied to all frames. If List, applied to\n   \
                              bottom, left, top, right, supplemented 1s to the right.\nLegendFontScale  1               Relative s\
ize of fonts for Legend.\n\nOptions for primitives:\n\nFor Text:\noption           default         optional values\n--------------\
----------------------------------\nTextAlign        \"\"              \"CENTER\"\nTextCases        \"\"              string to re\
present CASES of TopDrawer\nTextPosition     \"\"              \"DATA\" to represent the position by data\n                       \
          coordinates\nTextRotate       0\nTextSize         1               relative size of a character\nPlotColor        \"Black\
\"         one of \"White\", \"Black\", \"Red\",\n                                 \"Green\",\"Blue\",\"Yellow\",\n               \
                  \"Magenta\",\"Cyan\"\n\nFor Point\noption           default         optional values\n---------------------------\
---------------------\nPointSize        1               relative size of a point\nPointSymbol      \"1O\"            Symbol for PL\
OT of TopDrawer, or Bar\n                                 \"6O\",\"7O\",\"8O\",\"9O\" are triangles\n                             \
    in CanvasDrawer.\nPlotColor        \"Black\"         one of \"White\", \"Black\", \"Red\",\n                                 \\
"Green\",\"Blue\",\"Yellow\",\n                                 \"Magenta\",\"Cyan\"\nErrorBarTickSize 1               length of e\
rror bar ticks.\n\nFor Line\noption           default         optional values\n------------------------------------------------\nD\
ashing          \"1\"             character string or a list of numbers to\n                                 represent the dashing\
 of the line.\nPlot             True            whether plot symbols at data points.\n                                 If True, Po\
intSize and PointSymbol are\n                                 effective (see above).\nPlotColor        \"Black\"         one of \"\
White\", \"Black\", \"Red\",\n                                 \"Green\",\"Blue\",\"Yellow\",\n                                 \"\
Magenta\",\"Cyan\"\nErrorBarTickSize 1               length of error bar ticks.\nThickness        1               thickness of lin\
e\n\nFor Polygon\noption           default         optional values\n------------------------------------------------\nPlot        \
     False           whether plot symbols at data points.\n                                 If True, PointSize and PointSymbol are\
\n                                 effective (see above).\nPointSize        1               relative size of a point\nPointSymbol \
     \"1O\"            Symbol for PLOT of TopDrawer, or Bar\n                                 \"6O\",\"7O\",\"8O\",\"9O\" are tria\
ngles\n                                 in CanvasDrawer.\nPointColor       \"forest green\"  point fill color.\nPointBorderColor A\
utomatic       point border color.\n                                 Automatic measn PointColor.\nPointTags        Null           \
 points tag string or list of tag strings.\nPlotJoined       True            whether plot border line of polygon.\nThickness      \
  1               thickness of border line\n\nDashing          \"1\"             character string or a list of numbers to\n       \
                          represent the dashing of the line.\nPlotColor        \"black\"         border line color.\nLineTags     \
    Null            border line tag string.\nFillColor        Null            polygon fill color.\n                               \
  Null means empty polygon.\nTags             False           polygon tag string.\n\n   ListPlot accepts options for Graphics, Poi\
nt, and Line.   Show accepts\noptions for Graphics.   The output is written to file #9 (fort.9 in OSF1 and\nftn09 in HP-UX) in Top\
Drawer commands.   If SAD is running on X, the plot is\nalso done immediately.\n\nExamples:\n  g1=ListPlot[{{1,2},{10,20}},Scale->\
Log,PlotJoined->True,\n    DisplayFunction->Identity];\n  g2=ListPlot[{{1,15},{10,3}},Scale->Log,PlotJoined->True,Dashing->\"1 0.3\
\",\n    DisplayFunction->Identity,Plot->False];\n  g3=ListPlot[{{1,2.5},{5,10},{10,12}},Scale->Log,\n    DisplayFunction->Identit\
y];\n  Show[g1,g2,g3,FrameLabel->{\"X (mm)\",\"Log(Y)\"},PlotLabel->\"Test Plot\",\n      AspectRatio->1];"[p$2368,p1$2368],
          Format->Help2HTML`oB$];
        System["mv -f "//out$2368//" "//equ$2368]];
      Exit[]]];
   "Graphics represents an object for 2D graphics with the form\nGraphics[primitives, options]. Up to now available primitives are\
:\n\nCircle[{cx,cy},rx, options]             : Circle. \nCircle[{cx,cy},{rx,ry}, options]        : Oval. \nPoints[{{x1,y1} .. {x2,\
y2}}, options]   : Points.\nPoints[{{x1,y1,dx,dy} .. {x2,y2,dx,dy}}, options]  : Points with error bars.\nLine[{{x1,y1} .. {x2,y2}\
}, options]     : Line.\nLine[{{x1,y1,dx,dy} .. {x2,y2,dx,dy}}, options]    : Line with error bars.\nRectangle[{x1,y1}, {x2,y2}]  \
           : A box.\nRectangle[{x1,y1}, {x2,y2}, graphic]    : Graphics in a box.\nPolygon[{{x1,y1} .. {x2,y2}}, options]  : Polyg\
on.\nText[{string, {x,y}}, options]          : Text-string at {x,y}.\n\nPossible options and their defaults values of Graphics are\
:\n\noption           default         optional values\n------------------------------------------------\nAspectRatio      GoldenRa\
tio     any positive number\nDisplayFunction  $DisplayFunction  Identity or Null to suppress display\nDetach           False      \
     True to run tdr asynchronously\nEpilog           {}              List of primitives\nFrame            True            False t\
o erase outline, ticks, ticklabels.\nFrameClick       True            to allow click on frame to change options.\nFrameLabel      \
 {\"\",\"\",\"\",\"\"}   List of strings\nFrameTicks       {Both,Both,Ticks,Ticks}\n                                 None to turn \
off ticks and labels\n                                 Both to turn on ticks and labels\n                                 Ticks to\
 turn on ticks only\n                                 << For bottom tick >>\n                                 False is same as Tic\
ks\n                                 True is same as Both\n                                 << For top tick >>\n                  \
               False is same as None\n                                 True is same as Ticks\n                                 << \
For left & right ticks >>\n                                 False is same as None\n                                 True is same a\
s Both\n                                 If a form {___, _List} is given where\n                                 the List is a lis\
t of {coord, label, opt___}\n                                 label is displayed at coord with option opt.\n                      \
           If a form {___, fun} is given and \n                                 fun[coord,exp,org] returns a list of options\n    \
                             for Canvas[Create$Text], it is displayed at major\n                                 ticks at coord. e\
xp is the exponent and org is the\n                                 original label.\nGridLines        Automatic       Automatic to\
 draw grid lines at major ticks\n                                 {Automatic,None} for only x\n                                 {N\
one,Automatic} for only y\n                                 Both, Minor, and Major can be also used.\nPlotLabel        \"\"       \
       string\nPlotRange        Automatic       {ymin,ymax} or {{xmin,xmax},{ymin,ymax}}\nProlog           {}              List of\
 promitives\nScale            {Linear,Linear} Log, Date\nTickSize         1               relative size of ticks.\nFrameThickness \
  Automatic       thickness of the frame line incl. ticks.\nLegend           \"\"              shows legend-string.\nFontScale    \
    1               Relative size of fonts for FrameLabel, FrameTicks.\nFrameFontScale   1               Relative size of fonts fo\
r FrameLabel.\n                                 If Real, applied to all frames. If List, applied to\n                             \
    bottom, left, top, right, supplemented 1s to the right.\nTickFontScale    1               Relative size of fonts for FrameTick\
s.\n                                 If Real, applied to all frames. If List, applied to\n                                 bottom,\
 left, top, right, supplemented 1s to the right.\nLegendFontScale  1               Relative size of fonts for Legend.\n\nOptions f\
or primitives:\n\nFor Text:\noption           default         optional values\n------------------------------------------------\nT\
extAlign        \"\"              \"CENTER\"\nTextCases        \"\"              string to represent CASES of TopDrawer\nTextPosit\
ion     \"\"              \"DATA\" to represent the position by data\n                                 coordinates\nTextRotate    \
   0\nTextSize         1               relative size of a character\nPlotColor        \"Black\"         one of \"White\", \"Black\\
", \"Red\",\n                                 \"Green\",\"Blue\",\"Yellow\",\n                                 \"Magenta\",\"Cyan\\
"\n\nFor Point\noption           default         optional values\n------------------------------------------------\nPointSize     \
   1               relative size of a point\nPointSymbol      \"1O\"            Symbol for PLOT of TopDrawer, or Bar\n            \
                     \"6O\",\"7O\",\"8O\",\"9O\" are triangles\n                                 in CanvasDrawer.\nPlotColor      \
  \"Black\"         one of \"White\", \"Black\", \"Red\",\n                                 \"Green\",\"Blue\",\"Yellow\",\n      \
                           \"Magenta\",\"Cyan\"\nErrorBarTickSize 1               length of error bar ticks.\n\nFor Line\noption  \
         default         optional values\n------------------------------------------------\nDashing          \"1\"             cha\
racter string or a list of numbers to\n                                 represent the dashing of the line.\nPlot             True \
           whether plot symbols at data points.\n                                 If True, PointSize and PointSymbol are\n        \
                         effective (see above).\nPlotColor        \"Black\"         one of \"White\", \"Black\", \"Red\",\n       \
                          \"Green\",\"Blue\",\"Yellow\",\n                                 \"Magenta\",\"Cyan\"\nErrorBarTickSize \
1               length of error bar ticks.\nThickness        1               thickness of line\n\nFor Polygon\noption           de\
fault         optional values\n------------------------------------------------\nPlot             False           whether plot sym\
bols at data points.\n                                 If True, PointSize and PointSymbol are\n                                 ef\
fective (see above).\nPointSize        1               relative size of a point\nPointSymbol      \"1O\"            Symbol for PLO\
T of TopDrawer, or Bar\n                                 \"6O\",\"7O\",\"8O\",\"9O\" are triangles\n                              \
   in CanvasDrawer.\nPointColor       \"forest green\"  point fill color.\nPointBorderColor Automatic       point border color.\n \
                                Automatic measn PointColor.\nPointTags        Null            points tag string or list of tag str\
ings.\nPlotJoined       True            whether plot border line of polygon.\nThickness        1               thickness of border\
 line\n\nDashing          \"1\"             character string or a list of numbers to\n                                 represent t\
he dashing of the line.\nPlotColor        \"black\"         border line color.\nLineTags         Null            border line tag s\
tring.\nFillColor        Null            polygon fill color.\n                                 Null means empty polygon.\nTags    \
         False           polygon tag string.\n\n   ListPlot accepts options for Graphics, Point, and Line.   Show accepts\noptions\
 for Graphics.   The output is written to file #9 (fort.9 in OSF1 and\nftn09 in HP-UX) in TopDrawer commands.   If SAD is running \
on X, the plot is\nalso done immediately.\n\nExamples:\n  g1=ListPlot[{{1,2},{10,20}},Scale->Log,PlotJoined->True,\n    DisplayFun\
ction->Identity];\n  g2=ListPlot[{{1,15},{10,3}},Scale->Log,PlotJoined->True,Dashing->\"1 0.3\",\n    DisplayFunction->Identity,Pl\
ot->False];\n  g3=ListPlot[{{1,2.5},{5,10},{10,12}},Scale->Log,\n    DisplayFunction->Identity];\n  Show[g1,g2,g3,FrameLabel->{\"X\
 (mm)\",\"Log(Y)\"},PlotLabel->\"Test Plot\",\n      AspectRatio->1];"[1,Max[p0$2368,0]]//"<img  class=\"eqs\" SRC=\""//equ$2368//
   "\" />"//
Help2HTML`oy$["Graphics represents an object for 2D graphics with the form\nGraphics[primitives, options]. Up to now available pri\
mitives are:\n\nCircle[{cx,cy},rx, options]             : Circle. \nCircle[{cx,cy},{rx,ry}, options]        : Oval. \nPoints[{{x1,\
y1} .. {x2,y2}}, options]   : Points.\nPoints[{{x1,y1,dx,dy} .. {x2,y2,dx,dy}}, options]  : Points with error bars.\nLine[{{x1,y1}\
 .. {x2,y2}}, options]     : Line.\nLine[{{x1,y1,dx,dy} .. {x2,y2,dx,dy}}, options]    : Line with error bars.\nRectangle[{x1,y1},\
 {x2,y2}]             : A box.\nRectangle[{x1,y1}, {x2,y2}, graphic]    : Graphics in a box.\nPolygon[{{x1,y1} .. {x2,y2}}, option\
s]  : Polygon.\nText[{string, {x,y}}, options]          : Text-string at {x,y}.\n\nPossible options and their defaults values of G\
raphics are:\n\noption           default         optional values\n------------------------------------------------\nAspectRatio   \
   GoldenRatio     any positive number\nDisplayFunction  $DisplayFunction  Identity or Null to suppress display\nDetach           \
False           True to run tdr asynchronously\nEpilog           {}              List of primitives\nFrame            True        \
    False to erase outline, ticks, ticklabels.\nFrameClick       True            to allow click on frame to change options.\nFrame\
Label       {\"\",\"\",\"\",\"\"}   List of strings\nFrameTicks       {Both,Both,Ticks,Ticks}\n                                 No\
ne to turn off ticks and labels\n                                 Both to turn on ticks and labels\n                              \
   Ticks to turn on ticks only\n                                 << For bottom tick >>\n                                 False is \
same as Ticks\n                                 True is same as Both\n                                 << For top tick >>\n       \
                          False is same as None\n                                 True is same as Ticks\n                         \
        << For left & right ticks >>\n                                 False is same as None\n                                 Tru\
e is same as Both\n                                 If a form {___, _List} is given where\n                                 the Li\
st is a list of {coord, label, opt___}\n                                 label is displayed at coord with option opt.\n           \
                      If a form {___, fun} is given and \n                                 fun[coord,exp,org] returns a list of op\
tions\n                                 for Canvas[Create$Text], it is displayed at major\n                                 ticks \
at coord. exp is the exponent and org is the\n                                 original label.\nGridLines        Automatic       A\
utomatic to draw grid lines at major ticks\n                                 {Automatic,None} for only x\n                        \
         {None,Automatic} for only y\n                                 Both, Minor, and Major can be also used.\nPlotLabel        \
\"\"              string\nPlotRange        Automatic       {ymin,ymax} or {{xmin,xmax},{ymin,ymax}}\nProlog           {}          \
    List of promitives\nScale            {Linear,Linear} Log, Date\nTickSize         1               relative size of ticks.\nFram\
eThickness   Automatic       thickness of the frame line incl. ticks.\nLegend           \"\"              shows legend-string.\nFo\
ntScale        1               Relative size of fonts for FrameLabel, FrameTicks.\nFrameFontScale   1               Relative size \
of fonts for FrameLabel.\n                                 If Real, applied to all frames. If List, applied to\n                  \
               bottom, left, top, right, supplemented 1s to the right.\nTickFontScale    1               Relative size of fonts fo\
r FrameTicks.\n                                 If Real, applied to all frames. If List, applied to\n                             \
    bottom, left, top, right, supplemented 1s to the right.\nLegendFontScale  1               Relative size of fonts for Legend.\n\
\nOptions for primitives:\n\nFor Text:\noption           default         optional values\n----------------------------------------\
--------\nTextAlign        \"\"              \"CENTER\"\nTextCases        \"\"              string to represent CASES of TopDrawer\
\nTextPosition     \"\"              \"DATA\" to represent the position by data\n                                 coordinates\nTex\
tRotate       0\nTextSize         1               relative size of a character\nPlotColor        \"Black\"         one of \"White\\
", \"Black\", \"Red\",\n                                 \"Green\",\"Blue\",\"Yellow\",\n                                 \"Magent\
a\",\"Cyan\"\n\nFor Point\noption           default         optional values\n------------------------------------------------\nPoi\
ntSize        1               relative size of a point\nPointSymbol      \"1O\"            Symbol for PLOT of TopDrawer, or Bar\n \
                                \"6O\",\"7O\",\"8O\",\"9O\" are triangles\n                                 in CanvasDrawer.\nPlot\
Color        \"Black\"         one of \"White\", \"Black\", \"Red\",\n                                 \"Green\",\"Blue\",\"Yellow\
\",\n                                 \"Magenta\",\"Cyan\"\nErrorBarTickSize 1               length of error bar ticks.\n\nFor Lin\
e\noption           default         optional values\n------------------------------------------------\nDashing          \"1\"     \
        character string or a list of numbers to\n                                 represent the dashing of the line.\nPlot       \
      True            whether plot symbols at data points.\n                                 If True, PointSize and PointSymbol ar\
e\n                                 effective (see above).\nPlotColor        \"Black\"         one of \"White\", \"Black\", \"Red\\
",\n                                 \"Green\",\"Blue\",\"Yellow\",\n                                 \"Magenta\",\"Cyan\"\nErrorB\
arTickSize 1               length of error bar ticks.\nThickness        1               thickness of line\n\nFor Polygon\noption  \
         default         optional values\n------------------------------------------------\nPlot             False           wheth\
er plot symbols at data points.\n                                 If True, PointSize and PointSymbol are\n                        \
         effective (see above).\nPointSize        1               relative size of a point\nPointSymbol      \"1O\"            Sym\
bol for PLOT of TopDrawer, or Bar\n                                 \"6O\",\"7O\",\"8O\",\"9O\" are triangles\n                   \
              in CanvasDrawer.\nPointColor       \"forest green\"  point fill color.\nPointBorderColor Automatic       point borde\
r color.\n                                 Automatic measn PointColor.\nPointTags        Null            points tag string or list\
 of tag strings.\nPlotJoined       True            whether plot border line of polygon.\nThickness        1               thicknes\
s of border line\n\nDashing          \"1\"             character string or a list of numbers to\n                                 \
represent the dashing of the line.\nPlotColor        \"black\"         border line color.\nLineTags         Null            border\
 line tag string.\nFillColor        Null            polygon fill color.\n                                 Null means empty polygon\
.\nTags             False           polygon tag string.\n\n   ListPlot accepts options for Graphics, Point, and Line.   Show accep\
ts\noptions for Graphics.   The output is written to file #9 (fort.9 in OSF1 and\nftn09 in HP-UX) in TopDrawer commands.   If SAD \
is running on X, the plot is\nalso done immediately.\n\nExamples:\n  g1=ListPlot[{{1,2},{10,20}},Scale->Log,PlotJoined->True,\n   \
 DisplayFunction->Identity];\n  g2=ListPlot[{{1,15},{10,3}},Scale->Log,PlotJoined->True,Dashing->\"1 0.3\",\n    DisplayFunction->\
Identity,Plot->False];\n  g3=ListPlot[{{1,2.5},{5,10},{10,12}},Scale->Log,\n    DisplayFunction->Identity];\n  Show[g1,g2,g3,Frame\
Label->{\"X (mm)\",\"Log(Y)\"},PlotLabel->\"Test Plot\",\n      AspectRatio->1];"[p2$2368,-1]]
]</PRE>
<UL>
<LI>
<H3><A NAME=L415>
BeamPlot</A></H3>
<PRE>If[{},
Help2HTML`oA$["Usage: BeamPlot[loc, axes, options]\n\nplots a beam ellipse at a location loc, for axes. Axes are given by a list \\
n{ax, ay}, where ax and ay are one of \"X\", \"PX\", \"Y\", \"PY\", \"Z\", \"DP\".\nThe beam envelope should be calculated by (COD\
PLOT;EMIT) or BEAM commands before\nBeamPlot.\n\noptions       defaults\n-----------------------------------------\nOrbit         \
True                Uses Twiss[\"DX\",loc], etc. as the center of\n                                  ellipse.\nSizeFunction  \"SIZ\
E\"              If \"SIG\", LINE[\"SIG\"] is used.\n                                  LINE[\"SIZE\"] is the default.\nAspectRatio\
   1\nDataRange     Default             If Default, PlotRange becomes square for\n                                  axes = {\"X\",\
 \"Y\"} or {\"PX\", \"PY\"}"],
p$2370=1+p$2370[[1,2]];p1$2370=StringPosition["Usage: BeamPlot[loc, axes, options]\n\nplots a beam ellipse at a location loc, for \
axes. Axes are given by a list \n{ax, ay}, where ax and ay are one of \"X\", \"PX\", \"Y\", \"PY\", \"Z\", \"DP\".\nThe beam envel\
ope should be calculated by (CODPLOT;EMIT) or BEAM commands before\nBeamPlot.\n\noptions       defaults\n-------------------------\
----------------\nOrbit         True                Uses Twiss[\"DX\",loc], etc. as the center of\n                               \
   ellipse.\nSizeFunction  \"SIZE\"              If \"SIG\", LINE[\"SIG\"] is used.\n                                  LINE[\"SIZE\
\"] is the default.\nAspectRatio   1\nDataRange     Default             If Default, PlotRange becomes square for\n                \
                  axes = {\"X\", \"Y\"} or {\"PX\", \"PY\"}"[p$2370,-1],">::",1];
   p1$2370=If[p1$2370==={},747,-2+p$2370+p1$2370[[1,1]]];
neq=Which["Usage: BeamPlot[loc, axes, options]\n\nplots a beam ellipse at a location loc, for axes. Axes are given by a list \n{ax\
, ay}, where ax and ay are one of \"X\", \"PX\", \"Y\", \"PY\", \"Z\", \"DP\".\nThe beam envelope should be calculated by (CODPLOT\
;EMIT) or BEAM commands before\nBeamPlot.\n\noptions       defaults\n-----------------------------------------\nOrbit         True\
                Uses Twiss[\"DX\",loc], etc. as the center of\n                                  ellipse.\nSizeFunction  \"SIZE\" \
             If \"SIG\", LINE[\"SIG\"] is used.\n                                  LINE[\"SIZE\"] is the default.\nAspectRatio   1\
\nDataRange     Default             If Default, PlotRange becomes square for\n                                  axes = {\"X\", \"Y\
\"} or {\"PX\", \"PY\"}"[p$2370,4+p$2370]==="Text[",
    lx$2370:=Help2HTML`oa$;p$2370=5+p$2370;p1$2370-=1;p2$2370=5+p1$2370;p0$2370=-9+p$2370;
If[(pe$2370=StringPosition["Usage: BeamPlot[loc, axes, options]\n\nplots a beam ellipse at a location loc, for axes. Axes are give\
n by a list \n{ax, ay}, where ax and ay are one of \"X\", \"PX\", \"Y\", \"PY\", \"Z\", \"DP\".\nThe beam envelope should be calcu\
lated by (CODPLOT;EMIT) or BEAM commands before\nBeamPlot.\n\noptions       defaults\n-----------------------------------------\nO\
rbit         True                Uses Twiss[\"DX\",loc], etc. as the center of\n                                  ellipse.\nSizeFu\
nction  \"SIZE\"              If \"SIG\", LINE[\"SIG\"] is used.\n                                  LINE[\"SIZE\"] is the default.\
\nAspectRatio   1\nDataRange     Default             If Default, PlotRange becomes square for\n                                  a\
xes = {\"X\", \"Y\"} or {\"PX\", \"PY\"}"[p$2370,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Usage: BeamPlot[loc, axes, options]\n\nplots a beam ellipse at a location loc, for axes. Axes are given by a list\
 \n{ax, ay}, where ax and ay are one of \"X\", \"PX\", \"Y\", \"PY\", \"Z\", \"DP\".\nThe beam envelope should be calculated by (C\
ODPLOT;EMIT) or BEAM commands before\nBeamPlot.\n\noptions       defaults\n-----------------------------------------\nOrbit       \
  True                Uses Twiss[\"DX\",loc], etc. as the center of\n                                  ellipse.\nSizeFunction  \"S\
IZE\"              If \"SIG\", LINE[\"SIG\"] is used.\n                                  LINE[\"SIZE\"] is the default.\nAspectRat\
io   1\nDataRange     Default             If Default, PlotRange becomes square for\n                                  axes = {\"X\\
", \"Y\"} or {\"PX\", \"PY\"}"[p$2370+pe$2370[[1,2]],p1$2370]]],
        p1$2370=-2+p$2370+pe$2370[[1,1]]}[[
       1]],
      0],
    1,lx$2370:=Help2HTML`o9$;p2$2370=4+p1$2370;p0$2370=-4+p$2370;0];
  If[(equ$2370=
Help2HTML`o8$["Usage: BeamPlot[loc, axes, options]\n\nplots a beam ellipse at a location loc, for axes. Axes are given by a list \\
n{ax, ay}, where ax and ay are one of \"X\", \"PX\", \"Y\", \"PY\", \"Z\", \"DP\".\nThe beam envelope should be calculated by (COD\
PLOT;EMIT) or BEAM commands before\nBeamPlot.\n\noptions       defaults\n-----------------------------------------\nOrbit         \
True                Uses Twiss[\"DX\",loc], etc. as the center of\n                                  ellipse.\nSizeFunction  \"SIZ\
E\"              If \"SIG\", LINE[\"SIG\"] is used.\n                                  LINE[\"SIZE\"] is the default.\nAspectRatio\
   1\nDataRange     Default             If Default, PlotRange becomes square for\n                                  axes = {\"X\",\
 \"Y\"} or {\"PX\", \"PY\"}"[p$2370,p1$2370]])===
    Undefined,
equ$2370="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Usage: BeamPlot[loc, axes, options]\n\nplots\
 a beam ellipse at a location loc, for axes. Axes are given by a list \n{ax, ay}, where ax and ay are one of \"X\", \"PX\", \"Y\",\
 \"PY\", \"Z\", \"DP\".\nThe beam envelope should be calculated by (CODPLOT;EMIT) or BEAM commands before\nBeamPlot.\n\noptions   \
    defaults\n-----------------------------------------\nOrbit         True                Uses Twiss[\"DX\",loc], etc. as the cen\
ter of\n                                  ellipse.\nSizeFunction  \"SIZE\"              If \"SIG\", LINE[\"SIG\"] is used.\n      \
                            LINE[\"SIZE\"] is the default.\nAspectRatio   1\nDataRange     Default             If Default, PlotRan\
ge becomes square for\n                                  axes = {\"X\", \"Y\"} or {\"PX\", \"PY\"}"[p$2370,p1$2370]]=
       equ$2370;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2370},out$2370=lx$2370@Typeset["Usage: BeamPlot[loc, axes, options]\n\nplots a beam ellipse at a location loc, for axes. \
Axes are given by a list \n{ax, ay}, where ax and ay are one of \"X\", \"PX\", \"Y\", \"PY\", \"Z\", \"DP\".\nThe beam envelope sh\
ould be calculated by (CODPLOT;EMIT) or BEAM commands before\nBeamPlot.\n\noptions       defaults\n-------------------------------\
----------\nOrbit         True                Uses Twiss[\"DX\",loc], etc. as the center of\n                                  ell\
ipse.\nSizeFunction  \"SIZE\"              If \"SIG\", LINE[\"SIG\"] is used.\n                                  LINE[\"SIZE\"] is\
 the default.\nAspectRatio   1\nDataRange     Default             If Default, PlotRange becomes square for\n                      \
            axes = {\"X\", \"Y\"} or {\"PX\", \"PY\"}"[p$2370,p1$2370],Format->Help2HTML`oB$];
        System["mv -f "//out$2370//" "//equ$2370]];
      Exit[]]];
   "Usage: BeamPlot[loc, axes, options]\n\nplots a beam ellipse at a location loc, for axes. Axes are given by a list \n{ax, ay}, \
where ax and ay are one of \"X\", \"PX\", \"Y\", \"PY\", \"Z\", \"DP\".\nThe beam envelope should be calculated by (CODPLOT;EMIT) \
or BEAM commands before\nBeamPlot.\n\noptions       defaults\n-----------------------------------------\nOrbit         True       \
         Uses Twiss[\"DX\",loc], etc. as the center of\n                                  ellipse.\nSizeFunction  \"SIZE\"        \
      If \"SIG\", LINE[\"SIG\"] is used.\n                                  LINE[\"SIZE\"] is the default.\nAspectRatio   1\nDataR\
ange     Default             If Default, PlotRange becomes square for\n                                  axes = {\"X\", \"Y\"} or \
{\"PX\", \"PY\"}"[1,Max[p0$2370,0]]//"<img  class=\"eqs\" SRC=\""//equ$2370//"\" />"//
Help2HTML`oy$["Usage: BeamPlot[loc, axes, options]\n\nplots a beam ellipse at a location loc, for axes. Axes are given by a list \\
n{ax, ay}, where ax and ay are one of \"X\", \"PX\", \"Y\", \"PY\", \"Z\", \"DP\".\nThe beam envelope should be calculated by (COD\
PLOT;EMIT) or BEAM commands before\nBeamPlot.\n\noptions       defaults\n-----------------------------------------\nOrbit         \
True                Uses Twiss[\"DX\",loc], etc. as the center of\n                                  ellipse.\nSizeFunction  \"SIZ\
E\"              If \"SIG\", LINE[\"SIG\"] is used.\n                                  LINE[\"SIZE\"] is the default.\nAspectRatio\
   1\nDataRange     Default             If Default, PlotRange becomes square for\n                                  axes = {\"X\",\
 \"Y\"} or {\"PX\", \"PY\"}"[p2$2370,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L13>BEAMSIZE(BEAM)</A> <A HREF=#L295>EMITTANCE(EMIT)</A> <A HREF=#L308>CODPLOT</A></PRE>
<LI>
<H3><A NAME=L416>
ColumnPlot</A></H3>
<PRE>If[{},
Help2HTML`oA$["Usage:  ColumnPlot[data, options, ...]\n\nplots a column plot.\n1) If data is a 1D vector, it makes a simple column\
 plot.\n2) If data is a 2D matrix, it makes a multiple-column plot.\n3) If data is a 3D list, it makes a stacked, multiple-column \
plot.\n\nBesides options common for all plotting functions, ColumnPlot has its own\noptions:\n\nOption           Value          De\
fault             Action\n---------------------------------------------------------------------------\nColumnOffset    0 < number \
< 1  0.15            Ratio of spacing of columns\nReference        number         0               Where column starts\nOrientation\
     Vertical        Vertical        Orientation of columns\n                Horizontal\nColumnLabel     List of Str.    Automatic\
       Labels for each column\n                Function                        Scale for column number\n                None      \
                      No labels\nFillColor       color                           Colors to fill columns\n                list of c\
olors\nMeshStyle       bitmap                          Bitmap to fill columns\n                list of bitmaps                 to \
distinguish stacking\nTextSize        positive number 1               relative label size\nPlotNull        True or False   False  \
         plot a minimal rect for 0 occurrence\n\nExample:\n  g=ColumnPlot[{{{1,1,2},{2,2,3}}, {{1,4,2},{2,2,3}}, {{1,3,2},{2,2,3}}\
}, Orientation->Horizontal];\n  Update[];\n\n<ColumnPlot.png"],
p$2373=1+p$2373[[1,2]];p1$2373=StringPosition["Usage:  ColumnPlot[data, options, ...]\n\nplots a column plot.\n1) If data is a 1D \
vector, it makes a simple column plot.\n2) If data is a 2D matrix, it makes a multiple-column plot.\n3) If data is a 3D list, it m\
akes a stacked, multiple-column plot.\n\nBesides options common for all plotting functions, ColumnPlot has its own\noptions:\n\nOp\
tion           Value          Default             Action\n------------------------------------------------------------------------\
---\nColumnOffset    0 < number < 1  0.15            Ratio of spacing of columns\nReference        number         0               \
Where column starts\nOrientation     Vertical        Vertical        Orientation of columns\n                Horizontal\nColumnLab\
el     List of Str.    Automatic       Labels for each column\n                Function                        Scale for column nu\
mber\n                None                            No labels\nFillColor       color                           Colors to fill co\
lumns\n                list of colors\nMeshStyle       bitmap                          Bitmap to fill columns\n                lis\
t of bitmaps                 to distinguish stacking\nTextSize        positive number 1               relative label size\nPlotNul\
l        True or False   False           plot a minimal rect for 0 occurrence\n\nExample:\n  g=ColumnPlot[{{{1,1,2},{2,2,3}}, {{1,\
4,2},{2,2,3}}, {{1,3,2},{2,2,3}}}, Orientation->Horizontal];\n  Update[];\n\n<ColumnPlot.png"[p$2373,-1],">::",1];
   p1$2373=If[p1$2373==={},1445,-2+p$2373+p1$2373[[1,1]]];
neq=Which["Usage:  ColumnPlot[data, options, ...]\n\nplots a column plot.\n1) If data is a 1D vector, it makes a simple column plo\
t.\n2) If data is a 2D matrix, it makes a multiple-column plot.\n3) If data is a 3D list, it makes a stacked, multiple-column plot\
.\n\nBesides options common for all plotting functions, ColumnPlot has its own\noptions:\n\nOption           Value          Defaul\
t             Action\n---------------------------------------------------------------------------\nColumnOffset    0 < number < 1 \
 0.15            Ratio of spacing of columns\nReference        number         0               Where column starts\nOrientation    \
 Vertical        Vertical        Orientation of columns\n                Horizontal\nColumnLabel     List of Str.    Automatic    \
   Labels for each column\n                Function                        Scale for column number\n                None          \
                  No labels\nFillColor       color                           Colors to fill columns\n                list of color\
s\nMeshStyle       bitmap                          Bitmap to fill columns\n                list of bitmaps                 to dist\
inguish stacking\nTextSize        positive number 1               relative label size\nPlotNull        True or False   False      \
     plot a minimal rect for 0 occurrence\n\nExample:\n  g=ColumnPlot[{{{1,1,2},{2,2,3}}, {{1,4,2},{2,2,3}}, {{1,3,2},{2,2,3}}}, O\
rientation->Horizontal];\n  Update[];\n\n<ColumnPlot.png"[p$2373,4+p$2373]==="Text[",
    lx$2373:=Help2HTML`oa$;p$2373=5+p$2373;p1$2373-=1;p2$2373=5+p1$2373;p0$2373=-9+p$2373;
If[(pe$2373=StringPosition["Usage:  ColumnPlot[data, options, ...]\n\nplots a column plot.\n1) If data is a 1D vector, it makes a \
simple column plot.\n2) If data is a 2D matrix, it makes a multiple-column plot.\n3) If data is a 3D list, it makes a stacked, mul\
tiple-column plot.\n\nBesides options common for all plotting functions, ColumnPlot has its own\noptions:\n\nOption           Valu\
e          Default             Action\n---------------------------------------------------------------------------\nColumnOffset  \
  0 < number < 1  0.15            Ratio of spacing of columns\nReference        number         0               Where column starts\
\nOrientation     Vertical        Vertical        Orientation of columns\n                Horizontal\nColumnLabel     List of Str.\
    Automatic       Labels for each column\n                Function                        Scale for column number\n             \
   None                            No labels\nFillColor       color                           Colors to fill columns\n            \
    list of colors\nMeshStyle       bitmap                          Bitmap to fill columns\n                list of bitmaps       \
          to distinguish stacking\nTextSize        positive number 1               relative label size\nPlotNull        True or Fa\
lse   False           plot a minimal rect for 0 occurrence\n\nExample:\n  g=ColumnPlot[{{{1,1,2},{2,2,3}}, {{1,4,2},{2,2,3}}, {{1,\
3,2},{2,2,3}}}, Orientation->Horizontal];\n  Update[];\n\n<ColumnPlot.png"[p$2373,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Usage:  ColumnPlot[data, options, ...]\n\nplots a column plot.\n1) If data is a 1D vector, it makes a simple colu\
mn plot.\n2) If data is a 2D matrix, it makes a multiple-column plot.\n3) If data is a 3D list, it makes a stacked, multiple-colum\
n plot.\n\nBesides options common for all plotting functions, ColumnPlot has its own\noptions:\n\nOption           Value          \
Default             Action\n---------------------------------------------------------------------------\nColumnOffset    0 < numbe\
r < 1  0.15            Ratio of spacing of columns\nReference        number         0               Where column starts\nOrientati\
on     Vertical        Vertical        Orientation of columns\n                Horizontal\nColumnLabel     List of Str.    Automat\
ic       Labels for each column\n                Function                        Scale for column number\n                None    \
                        No labels\nFillColor       color                           Colors to fill columns\n                list of\
 colors\nMeshStyle       bitmap                          Bitmap to fill columns\n                list of bitmaps                 t\
o distinguish stacking\nTextSize        positive number 1               relative label size\nPlotNull        True or False   False\
           plot a minimal rect for 0 occurrence\n\nExample:\n  g=ColumnPlot[{{{1,1,2},{2,2,3}}, {{1,4,2},{2,2,3}}, {{1,3,2},{2,2,3\
}}}, Orientation->Horizontal];\n  Update[];\n\n<ColumnPlot.png"[p$2373+pe$2373[[1,2]],p1$2373]]],
        p1$2373=-2+p$2373+pe$2373[[1,1]]}[[
       1]],
      0],
    1,lx$2373:=Help2HTML`o9$;p2$2373=4+p1$2373;p0$2373=-4+p$2373;0];
  If[(equ$2373=
Help2HTML`o8$["Usage:  ColumnPlot[data, options, ...]\n\nplots a column plot.\n1) If data is a 1D vector, it makes a simple column\
 plot.\n2) If data is a 2D matrix, it makes a multiple-column plot.\n3) If data is a 3D list, it makes a stacked, multiple-column \
plot.\n\nBesides options common for all plotting functions, ColumnPlot has its own\noptions:\n\nOption           Value          De\
fault             Action\n---------------------------------------------------------------------------\nColumnOffset    0 < number \
< 1  0.15            Ratio of spacing of columns\nReference        number         0               Where column starts\nOrientation\
     Vertical        Vertical        Orientation of columns\n                Horizontal\nColumnLabel     List of Str.    Automatic\
       Labels for each column\n                Function                        Scale for column number\n                None      \
                      No labels\nFillColor       color                           Colors to fill columns\n                list of c\
olors\nMeshStyle       bitmap                          Bitmap to fill columns\n                list of bitmaps                 to \
distinguish stacking\nTextSize        positive number 1               relative label size\nPlotNull        True or False   False  \
         plot a minimal rect for 0 occurrence\n\nExample:\n  g=ColumnPlot[{{{1,1,2},{2,2,3}}, {{1,4,2},{2,2,3}}, {{1,3,2},{2,2,3}}\
}, Orientation->Horizontal];\n  Update[];\n\n<ColumnPlot.png"[p$2373,p1$2373]])===
    Undefined,
equ$2373="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Usage:  ColumnPlot[data, options, ...]\n\npl\
ots a column plot.\n1) If data is a 1D vector, it makes a simple column plot.\n2) If data is a 2D matrix, it makes a multiple-colu\
mn plot.\n3) If data is a 3D list, it makes a stacked, multiple-column plot.\n\nBesides options common for all plotting functions,\
 ColumnPlot has its own\noptions:\n\nOption           Value          Default             Action\n---------------------------------\
------------------------------------------\nColumnOffset    0 < number < 1  0.15            Ratio of spacing of columns\nReference\
        number         0               Where column starts\nOrientation     Vertical        Vertical        Orientation of columns\
\n                Horizontal\nColumnLabel     List of Str.    Automatic       Labels for each column\n                Function    \
                    Scale for column number\n                None                            No labels\nFillColor       color     \
                      Colors to fill columns\n                list of colors\nMeshStyle       bitmap                          Bitm\
ap to fill columns\n                list of bitmaps                 to distinguish stacking\nTextSize        positive number 1    \
           relative label size\nPlotNull        True or False   False           plot a minimal rect for 0 occurrence\n\nExample:\n\
  g=ColumnPlot[{{{1,1,2},{2,2,3}}, {{1,4,2},{2,2,3}}, {{1,3,2},{2,2,3}}}, Orientation->Horizontal];\n  Update[];\n\n<ColumnPlot.pn\
g"[p$2373,p1$2373]]=
       equ$2373;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2373},out$2373=lx$2373@Typeset["Usage:  ColumnPlot[data, options, ...]\n\nplots a column plot.\n1) If data is a 1D vector\
, it makes a simple column plot.\n2) If data is a 2D matrix, it makes a multiple-column plot.\n3) If data is a 3D list, it makes a\
 stacked, multiple-column plot.\n\nBesides options common for all plotting functions, ColumnPlot has its own\noptions:\n\nOption  \
         Value          Default             Action\n---------------------------------------------------------------------------\nC\
olumnOffset    0 < number < 1  0.15            Ratio of spacing of columns\nReference        number         0               Where \
column starts\nOrientation     Vertical        Vertical        Orientation of columns\n                Horizontal\nColumnLabel    \
 List of Str.    Automatic       Labels for each column\n                Function                        Scale for column number\n\
                None                            No labels\nFillColor       color                           Colors to fill columns\\
n                list of colors\nMeshStyle       bitmap                          Bitmap to fill columns\n                list of b\
itmaps                 to distinguish stacking\nTextSize        positive number 1               relative label size\nPlotNull     \
   True or False   False           plot a minimal rect for 0 occurrence\n\nExample:\n  g=ColumnPlot[{{{1,1,2},{2,2,3}}, {{1,4,2},{\
2,2,3}}, {{1,3,2},{2,2,3}}}, Orientation->Horizontal];\n  Update[];\n\n<ColumnPlot.png"[p$2373,p1$2373],Format->Help2HTML`oB$];
        System["mv -f "//out$2373//" "//equ$2373]];
      Exit[]]];
   "Usage:  ColumnPlot[data, options, ...]\n\nplots a column plot.\n1) If data is a 1D vector, it makes a simple column plot.\n2) \
If data is a 2D matrix, it makes a multiple-column plot.\n3) If data is a 3D list, it makes a stacked, multiple-column plot.\n\nBe\
sides options common for all plotting functions, ColumnPlot has its own\noptions:\n\nOption           Value          Default      \
       Action\n---------------------------------------------------------------------------\nColumnOffset    0 < number < 1  0.15  \
          Ratio of spacing of columns\nReference        number         0               Where column starts\nOrientation     Vertic\
al        Vertical        Orientation of columns\n                Horizontal\nColumnLabel     List of Str.    Automatic       Labe\
ls for each column\n                Function                        Scale for column number\n                None                 \
           No labels\nFillColor       color                           Colors to fill columns\n                list of colors\nMesh\
Style       bitmap                          Bitmap to fill columns\n                list of bitmaps                 to distinguish\
 stacking\nTextSize        positive number 1               relative label size\nPlotNull        True or False   False           pl\
ot a minimal rect for 0 occurrence\n\nExample:\n  g=ColumnPlot[{{{1,1,2},{2,2,3}}, {{1,4,2},{2,2,3}}, {{1,3,2},{2,2,3}}}, Orientat\
ion->Horizontal];\n  Update[];\n\n<ColumnPlot.png"[1,Max[p0$2373,0]]//"<img  class=\"eqs\" SRC=\""//equ$2373//"\" />"//
   Help2HTML`oy$["Usage:  ColumnPlot[data, options, ...]\n\nplots a column plot.\n1) If data is a 1D vector, it makes a simple col\
umn plot.\n2) If data is a 2D matrix, it makes a multiple-column plot.\n3) If data is a 3D list, it makes a stacked, multiple-colu\
mn plot.\n\nBesides options common for all plotting functions, ColumnPlot has its own\noptions:\n\nOption           Value         \
 Default             Action\n---------------------------------------------------------------------------\nColumnOffset    0 < numb\
er < 1  0.15            Ratio of spacing of columns\nReference        number         0               Where column starts\nOrientat\
ion     Vertical        Vertical        Orientation of columns\n                Horizontal\nColumnLabel     List of Str.    Automa\
tic       Labels for each column\n                Function                        Scale for column number\n                None   \
                         No labels\nFillColor       color                           Colors to fill columns\n                list o\
f colors\nMeshStyle       bitmap                          Bitmap to fill columns\n                list of bitmaps                 \
to distinguish stacking\nTextSize        positive number 1               relative label size\nPlotNull        True or False   Fals\
e           plot a minimal rect for 0 occurrence\n\nExample:\n  g=ColumnPlot[{{{1,1,2},{2,2,3}}, {{1,4,2},{2,2,3}}, {{1,3,2},{2,2,\
3}}}, Orientation->Horizontal];\n  Update[];\n\n<ColumnPlot.png"[p2$2373,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L414>Graphics</A></PRE>
<LI>
<H3><A NAME=L417>
FitPlot</A></H3>
<PRE>If[{},
Help2HTML`oA$["Usage: FitPlot[data, fun, var, {par1,ini1}, .. , {parn, inin}, opt].\n\noptions        defaults\n------------------\
-----------------------\nFunctionLabel  Default     Shows the fit function within FrameLabel[[3]].\nResultLabel    Default     Sho\
ws the fit results within FrameLabel[[3]].\n"],
p$2376=1+p$2376[[1,2]];p1$2376=StringPosition["Usage: FitPlot[data, fun, var, {par1,ini1}, .. , {parn, inin}, opt].\n\noptions    \
    defaults\n-----------------------------------------\nFunctionLabel  Default     Shows the fit function within FrameLabel[[3]].\
\nResultLabel    Default     Shows the fit results within FrameLabel[[3]].\n"[p$2376,-1],">::",1];
   p1$2376=If[p1$2376==={},283,-2+p$2376+p1$2376[[1,1]]];
neq=Which["Usage: FitPlot[data, fun, var, {par1,ini1}, .. , {parn, inin}, opt].\n\noptions        defaults\n----------------------\
-------------------\nFunctionLabel  Default     Shows the fit function within FrameLabel[[3]].\nResultLabel    Default     Shows t\
he fit results within FrameLabel[[3]].\n"[p$2376,4+p$2376]==="Text[",
    lx$2376:=Help2HTML`oa$;p$2376=5+p$2376;p1$2376-=1;p2$2376=5+p1$2376;p0$2376=-9+p$2376;
If[(pe$2376=StringPosition["Usage: FitPlot[data, fun, var, {par1,ini1}, .. , {parn, inin}, opt].\n\noptions        defaults\n-----\
------------------------------------\nFunctionLabel  Default     Shows the fit function within FrameLabel[[3]].\nResultLabel    De\
fault     Shows the fit results within FrameLabel[[3]].\n"[p$2376,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Usage: FitPlot[data, fun, var, {par1,ini1}, .. , {parn, inin}, opt].\n\noptions        defaults\n----------------\
-------------------------\nFunctionLabel  Default     Shows the fit function within FrameLabel[[3]].\nResultLabel    Default     S\
hows the fit results within FrameLabel[[3]].\n"[p$2376+pe$2376[[1,2]],p1$2376]]],
        p1$2376=-2+p$2376+pe$2376[[1,1]]}[[
       1]],
      0],
    1,lx$2376:=Help2HTML`o9$;p2$2376=4+p1$2376;p0$2376=-4+p$2376;0];
  If[(equ$2376=
Help2HTML`o8$["Usage: FitPlot[data, fun, var, {par1,ini1}, .. , {parn, inin}, opt].\n\noptions        defaults\n------------------\
-----------------------\nFunctionLabel  Default     Shows the fit function within FrameLabel[[3]].\nResultLabel    Default     Sho\
ws the fit results within FrameLabel[[3]].\n"[p$2376,p1$2376]])===
    Undefined,
equ$2376="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Usage: FitPlot[data, fun, var, {par1,ini1}, \
.. , {parn, inin}, opt].\n\noptions        defaults\n-----------------------------------------\nFunctionLabel  Default     Shows t\
he fit function within FrameLabel[[3]].\nResultLabel    Default     Shows the fit results within FrameLabel[[3]].\n"[p$2376,p1$2376
         ]]=
       equ$2376;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2376},out$2376=lx$2376@Typeset["Usage: FitPlot[data, fun, var, {par1,ini1}, .. , {parn, inin}, opt].\n\noptions        de\
faults\n-----------------------------------------\nFunctionLabel  Default     Shows the fit function within FrameLabel[[3]].\nResu\
ltLabel    Default     Shows the fit results within FrameLabel[[3]].\n"[p$2376,p1$2376],Format->Help2HTML`oB$];
        System["mv -f "//out$2376//" "//equ$2376]];
      Exit[]]];
   "Usage: FitPlot[data, fun, var, {par1,ini1}, .. , {parn, inin}, opt].\n\noptions        defaults\n-----------------------------\
------------\nFunctionLabel  Default     Shows the fit function within FrameLabel[[3]].\nResultLabel    Default     Shows the fit \
results within FrameLabel[[3]].\n"[1,Max[p0$2376,0]]//"<img  class=\"eqs\" SRC=\""//equ$2376//"\" />"//
Help2HTML`oy$["Usage: FitPlot[data, fun, var, {par1,ini1}, .. , {parn, inin}, opt].\n\noptions        defaults\n------------------\
-----------------------\nFunctionLabel  Default     Shows the fit function within FrameLabel[[3]].\nResultLabel    Default     Sho\
ws the fit results within FrameLabel[[3]].\n"[p2$2376,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L360>Fit</A></PRE>
<LI>
<H3><A NAME=L418>
GeometryPlot</A></H3>
<PRE>If[{},
Help2HTML`oA$["Usage: GeometryPlot[options]\n\nplots a geometry of beam line.\n\noptions       defaults\n-------------------------\
----------------\nRegion        {1,LINE[\"LENGTH\"]}  {begin, end}, begin and end can be strings.\n                               \
   Both begin and end point of drawing region\n                                  could be given by \"S\" unit by using S[begin|end\
] form.\nNames         \"*\"                 A pattern of component names to be plotted."],
 p$2379=1+p$2379[[1,2]];p1$2379=StringPosition["Usage: GeometryPlot[options]\n\nplots a geometry of beam line.\n\noptions       de\
faults\n-----------------------------------------\nRegion        {1,LINE[\"LENGTH\"]}  {begin, end}, begin and end can be strings.\
\n                                  Both begin and end point of drawing region\n                                  could be given b\
y \"S\" unit by using S[begin|end] form.\nNames         \"*\"                 A pattern of component names to be plotted."[p$2379,
     -1],
    ">::",1];
   p1$2379=If[p1$2379==={},448,-2+p$2379+p1$2379[[1,1]]];
neq=Which["Usage: GeometryPlot[options]\n\nplots a geometry of beam line.\n\noptions       defaults\n-----------------------------\
------------\nRegion        {1,LINE[\"LENGTH\"]}  {begin, end}, begin and end can be strings.\n                                  B\
oth begin and end point of drawing region\n                                  could be given by \"S\" unit by using S[begin|end] fo\
rm.\nNames         \"*\"                 A pattern of component names to be plotted."[p$2379,4+p$2379]==="Text[",
    lx$2379:=Help2HTML`oa$;p$2379=5+p$2379;p1$2379-=1;p2$2379=5+p1$2379;p0$2379=-9+p$2379;
If[(pe$2379=StringPosition["Usage: GeometryPlot[options]\n\nplots a geometry of beam line.\n\noptions       defaults\n------------\
-----------------------------\nRegion        {1,LINE[\"LENGTH\"]}  {begin, end}, begin and end can be strings.\n                  \
                Both begin and end point of drawing region\n                                  could be given by \"S\" unit by usin\
g S[begin|end] form.\nNames         \"*\"                 A pattern of component names to be plotted."[p$2379,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Usage: GeometryPlot[options]\n\nplots a geometry of beam line.\n\noptions       defaults\n-----------------------\
------------------\nRegion        {1,LINE[\"LENGTH\"]}  {begin, end}, begin and end can be strings.\n                             \
     Both begin and end point of drawing region\n                                  could be given by \"S\" unit by using S[begin|e\
nd] form.\nNames         \"*\"                 A pattern of component names to be plotted."[p$2379+pe$2379[[1,2]],p1$2379]]],
        p1$2379=-2+p$2379+pe$2379[[1,1]]}[[
       1]],
      0],
    1,lx$2379:=Help2HTML`o9$;p2$2379=4+p1$2379;p0$2379=-4+p$2379;0];
  If[(equ$2379=
Help2HTML`o8$["Usage: GeometryPlot[options]\n\nplots a geometry of beam line.\n\noptions       defaults\n-------------------------\
----------------\nRegion        {1,LINE[\"LENGTH\"]}  {begin, end}, begin and end can be strings.\n                               \
   Both begin and end point of drawing region\n                                  could be given by \"S\" unit by using S[begin|end\
] form.\nNames         \"*\"                 A pattern of component names to be plotted."[p$2379,p1$2379]])===
    Undefined,
equ$2379="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Usage: GeometryPlot[options]\n\nplots a geom\
etry of beam line.\n\noptions       defaults\n-----------------------------------------\nRegion        {1,LINE[\"LENGTH\"]}  {begi\
n, end}, begin and end can be strings.\n                                  Both begin and end point of drawing region\n            \
                      could be given by \"S\" unit by using S[begin|end] form.\nNames         \"*\"                 A pattern of c\
omponent names to be plotted."[p$2379,p1$2379]]=
       equ$2379;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2379},out$2379=lx$2379@Typeset["Usage: GeometryPlot[options]\n\nplots a geometry of beam line.\n\noptions       defaults\\
n-----------------------------------------\nRegion        {1,LINE[\"LENGTH\"]}  {begin, end}, begin and end can be strings.\n     \
                             Both begin and end point of drawing region\n                                  could be given by \"S\"\
 unit by using S[begin|end] form.\nNames         \"*\"                 A pattern of component names to be plotted."[p$2379,p1$2379
           ],Format->Help2HTML`oB$];
        System["mv -f "//out$2379//" "//equ$2379]];
      Exit[]]];
   "Usage: GeometryPlot[options]\n\nplots a geometry of beam line.\n\noptions       defaults\n------------------------------------\
-----\nRegion        {1,LINE[\"LENGTH\"]}  {begin, end}, begin and end can be strings.\n                                  Both beg\
in and end point of drawing region\n                                  could be given by \"S\" unit by using S[begin|end] form.\nNa\
mes         \"*\"                 A pattern of component names to be plotted."[1,Max[p0$2379,0]]//"<img  class=\"eqs\" SRC=\""//
   equ$2379//"\" />"//
Help2HTML`oy$["Usage: GeometryPlot[options]\n\nplots a geometry of beam line.\n\noptions       defaults\n-------------------------\
----------------\nRegion        {1,LINE[\"LENGTH\"]}  {begin, end}, begin and end can be strings.\n                               \
   Both begin and end point of drawing region\n                                  could be given by \"S\" unit by using S[begin|end\
] form.\nNames         \"*\"                 A pattern of component names to be plotted."[p2$2379,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L414>Graphics</A> <A HREF=#L423>OpticsPlot</A></PRE>
<LI>
<H3><A NAME=L419>
HistoPlot</A></H3>
<PRE>If[{},
Help2HTML`oA$["Usage:  HistoPlot[data, options, ...]\n\nplots a histogram using ColumnPlot(default) or ListPlot.\nData can be a si\
ngle list, or list of lists, which results in a multi-column histogram on a common axis.\nBesides options common for all plotting \
functions and ColumnPlot, it has its own options:\n\nOption           Value          Default             Action\n-----------------\
----------------------------------------------------------\nBins            number          Automatic           number of bins\nBi\
nRange        {min,max}       Automatic           Range of bins\nPlotStyle       ColumnPlot      ColumnPlot          plot function\
\n                ListPlot\n                FitPlot\nOrientation     Vertical        Vertical            orientation of columns\n \
               Horizontal\nFitParameters   args for FitPlot in a list"],
p$2382=1+p$2382[[1,2]];p1$2382=StringPosition["Usage:  HistoPlot[data, options, ...]\n\nplots a histogram using ColumnPlot(default\
) or ListPlot.\nData can be a single list, or list of lists, which results in a multi-column histogram on a common axis.\nBesides \
options common for all plotting functions and ColumnPlot, it has its own options:\n\nOption           Value          Default      \
       Action\n---------------------------------------------------------------------------\nBins            number          Automa\
tic           number of bins\nBinRange        {min,max}       Automatic           Range of bins\nPlotStyle       ColumnPlot      C\
olumnPlot          plot function\n                ListPlot\n                FitPlot\nOrientation     Vertical        Vertical     \
       orientation of columns\n                Horizontal\nFitParameters   args for FitPlot in a list"[p$2382,-1],">::",1];
   p1$2382=If[p1$2382==={},819,-2+p$2382+p1$2382[[1,1]]];
neq=Which["Usage:  HistoPlot[data, options, ...]\n\nplots a histogram using ColumnPlot(default) or ListPlot.\nData can be a single\
 list, or list of lists, which results in a multi-column histogram on a common axis.\nBesides options common for all plotting func\
tions and ColumnPlot, it has its own options:\n\nOption           Value          Default             Action\n---------------------\
------------------------------------------------------\nBins            number          Automatic           number of bins\nBinRan\
ge        {min,max}       Automatic           Range of bins\nPlotStyle       ColumnPlot      ColumnPlot          plot function\n  \
              ListPlot\n                FitPlot\nOrientation     Vertical        Vertical            orientation of columns\n     \
           Horizontal\nFitParameters   args for FitPlot in a list"[p$2382,4+p$2382]==="Text[",
    lx$2382:=Help2HTML`oa$;p$2382=5+p$2382;p1$2382-=1;p2$2382=5+p1$2382;p0$2382=-9+p$2382;
If[(pe$2382=StringPosition["Usage:  HistoPlot[data, options, ...]\n\nplots a histogram using ColumnPlot(default) or ListPlot.\nDat\
a can be a single list, or list of lists, which results in a multi-column histogram on a common axis.\nBesides options common for \
all plotting functions and ColumnPlot, it has its own options:\n\nOption           Value          Default             Action\n----\
-----------------------------------------------------------------------\nBins            number          Automatic           numbe\
r of bins\nBinRange        {min,max}       Automatic           Range of bins\nPlotStyle       ColumnPlot      ColumnPlot          \
plot function\n                ListPlot\n                FitPlot\nOrientation     Vertical        Vertical            orientation \
of columns\n                Horizontal\nFitParameters   args for FitPlot in a list"[p$2382,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Usage:  HistoPlot[data, options, ...]\n\nplots a histogram using ColumnPlot(default) or ListPlot.\nData can be a \
single list, or list of lists, which results in a multi-column histogram on a common axis.\nBesides options common for all plottin\
g functions and ColumnPlot, it has its own options:\n\nOption           Value          Default             Action\n---------------\
------------------------------------------------------------\nBins            number          Automatic           number of bins\n\
BinRange        {min,max}       Automatic           Range of bins\nPlotStyle       ColumnPlot      ColumnPlot          plot functi\
on\n                ListPlot\n                FitPlot\nOrientation     Vertical        Vertical            orientation of columns\\
n                Horizontal\nFitParameters   args for FitPlot in a list"[p$2382+pe$2382[[1,2]],p1$2382]]],
        p1$2382=-2+p$2382+pe$2382[[1,1]]}[[
       1]],
      0],
    1,lx$2382:=Help2HTML`o9$;p2$2382=4+p1$2382;p0$2382=-4+p$2382;0];
  If[(equ$2382=
Help2HTML`o8$["Usage:  HistoPlot[data, options, ...]\n\nplots a histogram using ColumnPlot(default) or ListPlot.\nData can be a si\
ngle list, or list of lists, which results in a multi-column histogram on a common axis.\nBesides options common for all plotting \
functions and ColumnPlot, it has its own options:\n\nOption           Value          Default             Action\n-----------------\
----------------------------------------------------------\nBins            number          Automatic           number of bins\nBi\
nRange        {min,max}       Automatic           Range of bins\nPlotStyle       ColumnPlot      ColumnPlot          plot function\
\n                ListPlot\n                FitPlot\nOrientation     Vertical        Vertical            orientation of columns\n \
               Horizontal\nFitParameters   args for FitPlot in a list"[p$2382,p1$2382]])===
    Undefined,
equ$2382="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Usage:  HistoPlot[data, options, ...]\n\nplo\
ts a histogram using ColumnPlot(default) or ListPlot.\nData can be a single list, or list of lists, which results in a multi-colum\
n histogram on a common axis.\nBesides options common for all plotting functions and ColumnPlot, it has its own options:\n\nOption\
           Value          Default             Action\n---------------------------------------------------------------------------\\
nBins            number          Automatic           number of bins\nBinRange        {min,max}       Automatic           Range of \
bins\nPlotStyle       ColumnPlot      ColumnPlot          plot function\n                ListPlot\n                FitPlot\nOrient\
ation     Vertical        Vertical            orientation of columns\n                Horizontal\nFitParameters   args for FitPlot\
 in a list"[p$2382,p1$2382]]=
       equ$2382;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2382},out$2382=lx$2382@Typeset["Usage:  HistoPlot[data, options, ...]\n\nplots a histogram using ColumnPlot(default) or L\
istPlot.\nData can be a single list, or list of lists, which results in a multi-column histogram on a common axis.\nBesides option\
s common for all plotting functions and ColumnPlot, it has its own options:\n\nOption           Value          Default            \
 Action\n---------------------------------------------------------------------------\nBins            number          Automatic   \
        number of bins\nBinRange        {min,max}       Automatic           Range of bins\nPlotStyle       ColumnPlot      ColumnP\
lot          plot function\n                ListPlot\n                FitPlot\nOrientation     Vertical        Vertical           \
 orientation of columns\n                Horizontal\nFitParameters   args for FitPlot in a list"[p$2382,p1$2382],
          Format->Help2HTML`oB$];
        System["mv -f "//out$2382//" "//equ$2382]];
      Exit[]]];
   "Usage:  HistoPlot[data, options, ...]\n\nplots a histogram using ColumnPlot(default) or ListPlot.\nData can be a single list, \
or list of lists, which results in a multi-column histogram on a common axis.\nBesides options common for all plotting functions a\
nd ColumnPlot, it has its own options:\n\nOption           Value          Default             Action\n----------------------------\
-----------------------------------------------\nBins            number          Automatic           number of bins\nBinRange     \
   {min,max}       Automatic           Range of bins\nPlotStyle       ColumnPlot      ColumnPlot          plot function\n         \
       ListPlot\n                FitPlot\nOrientation     Vertical        Vertical            orientation of columns\n            \
    Horizontal\nFitParameters   args for FitPlot in a list"[1,Max[p0$2382,0]]//"<img  class=\"eqs\" SRC=\""//equ$2382//"\" />"//
   Help2HTML`oy$["Usage:  HistoPlot[data, options, ...]\n\nplots a histogram using ColumnPlot(default) or ListPlot.\nData can be a\
 single list, or list of lists, which results in a multi-column histogram on a common axis.\nBesides options common for all plotti\
ng functions and ColumnPlot, it has its own options:\n\nOption           Value          Default             Action\n--------------\
-------------------------------------------------------------\nBins            number          Automatic           number of bins\\
nBinRange        {min,max}       Automatic           Range of bins\nPlotStyle       ColumnPlot      ColumnPlot          plot funct\
ion\n                ListPlot\n                FitPlot\nOrientation     Vertical        Vertical            orientation of columns\
\n                Horizontal\nFitParameters   args for FitPlot in a list"[p2$2382,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L414>Graphics</A> <A HREF=#L416>ColumnPlot</A> <A HREF=#L422>ListPlot</A> <A HREF=#L417>FitPlot</A></PRE>
<LI>
<H3><A NAME=L420>
ListContourPlot</A></H3>
<PRE>If[{},
Help2HTML`oA$["Usage:  ListContourPlot[list, options, ...]\n\nplots a contour plot by list which is a 2D List of Real data.\n\nOpt\
ion           Value            Default         Action\n---------------------------------------------------------------------------\
\nContours         Real             10              number of contours\nPlotRange        {min,max}, {prxy, prz}, or {prx, pry, prz\
}\n                                  Automatic       depth of contours (prz) and PlotRange for x-y (prxy)\nAspectRatio      Real  \
           1\nMeshRange        ({x1,xn},{y1,yn}} or {{x1,..,xn},{y1,..,y1n}}\n                                  Automatic       Ra\
nge of x and y axes\nColorFunction    Color scheme (Blue, Purple, Pink, Yellow, Green, Cyan),Function, or String\n                \
                  Blue            Null or None means \"white\"\nContourColorFunction\n                 Function or String\n       \
                           Automatic       Null or None to hide\nColorScale       True or False    True            displays a colo\
r scale on the right\nSmoothing        integer >= 0     1               number of linear interpolations\n\nExample:\n xr0=0;xr=Tab\
le[xr0+=Sin[i*Pi/21],{i,20}];xr-=(xr[[1]]+xr[[-1]])/2;\n yr=xr;\n table=Outer[Cos[Sqrt[(#^2+#2^2)/2]]&,xr,yr];\n\n gc=Graphics[Map\
Thread[\n  Rectangle[#2,#3,\n    ListContourPlot[table, MeshRange->{xr, yr}, AspectRatio->1,\n      DisplayFunction->Identity, Col\
orFunction->#,\n      FrameLabel->{\"x\", \"y\", ToString[#]}]]&,\n   {{ Blue,        Pink,       Green,      Purple,      Yellow,\
     Cyan},\n     {{-0.15,0.65},{0.25,0.65},{0.65,0.65},{-0.15,0   },{0.25,0   },{0.65,0}},\n     {{ 0.2, 1.1 },{0.6, 1.1 },{1,   \
1.1 },{ 0.2, 0.45},{0.6 ,0.45},{1.0, 0.45}}}]];\n Show[gc];Update[];\n<ListContourPlot.png"],
 p$2385=1+p$2385[[1,2]];p1$2385=StringPosition["Usage:  ListContourPlot[list, options, ...]\n\nplots a contour plot by list which \
is a 2D List of Real data.\n\nOption           Value            Default         Action\n------------------------------------------\
---------------------------------\nContours         Real             10              number of contours\nPlotRange        {min,max\
}, {prxy, prz}, or {prx, pry, prz}\n                                  Automatic       depth of contours (prz) and PlotRange for x-\
y (prxy)\nAspectRatio      Real             1\nMeshRange        ({x1,xn},{y1,yn}} or {{x1,..,xn},{y1,..,y1n}}\n                   \
               Automatic       Range of x and y axes\nColorFunction    Color scheme (Blue, Purple, Pink, Yellow, Green, Cyan),Func\
tion, or String\n                                  Blue            Null or None means \"white\"\nContourColorFunction\n           \
      Function or String\n                                  Automatic       Null or None to hide\nColorScale       True or False  \
  True            displays a color scale on the right\nSmoothing        integer >= 0     1               number of linear interpol\
ations\n\nExample:\n xr0=0;xr=Table[xr0+=Sin[i*Pi/21],{i,20}];xr-=(xr[[1]]+xr[[-1]])/2;\n yr=xr;\n table=Outer[Cos[Sqrt[(#^2+#2^2)\
/2]]&,xr,yr];\n\n gc=Graphics[MapThread[\n  Rectangle[#2,#3,\n    ListContourPlot[table, MeshRange->{xr, yr}, AspectRatio->1,\n   \
   DisplayFunction->Identity, ColorFunction->#,\n      FrameLabel->{\"x\", \"y\", ToString[#]}]]&,\n   {{ Blue,        Pink,      \
 Green,      Purple,      Yellow,     Cyan},\n     {{-0.15,0.65},{0.25,0.65},{0.65,0.65},{-0.15,0   },{0.25,0   },{0.65,0}},\n    \
 {{ 0.2, 1.1 },{0.6, 1.1 },{1,   1.1 },{ 0.2, 0.45},{0.6 ,0.45},{1.0, 0.45}}}]];\n Show[gc];Update[];\n<ListContourPlot.png"[p$2385
     ,-1],
    ">::",1];
   p1$2385=If[p1$2385==={},1725,-2+p$2385+p1$2385[[1,1]]];
neq=Which["Usage:  ListContourPlot[list, options, ...]\n\nplots a contour plot by list which is a 2D List of Real data.\n\nOption \
          Value            Default         Action\n---------------------------------------------------------------------------\nCo\
ntours         Real             10              number of contours\nPlotRange        {min,max}, {prxy, prz}, or {prx, pry, prz}\n \
                                 Automatic       depth of contours (prz) and PlotRange for x-y (prxy)\nAspectRatio      Real      \
       1\nMeshRange        ({x1,xn},{y1,yn}} or {{x1,..,xn},{y1,..,y1n}}\n                                  Automatic       Range \
of x and y axes\nColorFunction    Color scheme (Blue, Purple, Pink, Yellow, Green, Cyan),Function, or String\n                    \
              Blue            Null or None means \"white\"\nContourColorFunction\n                 Function or String\n           \
                       Automatic       Null or None to hide\nColorScale       True or False    True            displays a color sc\
ale on the right\nSmoothing        integer >= 0     1               number of linear interpolations\n\nExample:\n xr0=0;xr=Table[x\
r0+=Sin[i*Pi/21],{i,20}];xr-=(xr[[1]]+xr[[-1]])/2;\n yr=xr;\n table=Outer[Cos[Sqrt[(#^2+#2^2)/2]]&,xr,yr];\n\n gc=Graphics[MapThre\
ad[\n  Rectangle[#2,#3,\n    ListContourPlot[table, MeshRange->{xr, yr}, AspectRatio->1,\n      DisplayFunction->Identity, ColorFu\
nction->#,\n      FrameLabel->{\"x\", \"y\", ToString[#]}]]&,\n   {{ Blue,        Pink,       Green,      Purple,      Yellow,    \
 Cyan},\n     {{-0.15,0.65},{0.25,0.65},{0.65,0.65},{-0.15,0   },{0.25,0   },{0.65,0}},\n     {{ 0.2, 1.1 },{0.6, 1.1 },{1,   1.1 \
},{ 0.2, 0.45},{0.6 ,0.45},{1.0, 0.45}}}]];\n Show[gc];Update[];\n<ListContourPlot.png"[p$2385,4+p$2385]==="Text[",
    lx$2385:=Help2HTML`oa$;p$2385=5+p$2385;p1$2385-=1;p2$2385=5+p1$2385;p0$2385=-9+p$2385;
If[(pe$2385=StringPosition["Usage:  ListContourPlot[list, options, ...]\n\nplots a contour plot by list which is a 2D List of Real\
 data.\n\nOption           Value            Default         Action\n--------------------------------------------------------------\
-------------\nContours         Real             10              number of contours\nPlotRange        {min,max}, {prxy, prz}, or {\
prx, pry, prz}\n                                  Automatic       depth of contours (prz) and PlotRange for x-y (prxy)\nAspectRati\
o      Real             1\nMeshRange        ({x1,xn},{y1,yn}} or {{x1,..,xn},{y1,..,y1n}}\n                                  Autom\
atic       Range of x and y axes\nColorFunction    Color scheme (Blue, Purple, Pink, Yellow, Green, Cyan),Function, or String\n   \
                               Blue            Null or None means \"white\"\nContourColorFunction\n                 Function or St\
ring\n                                  Automatic       Null or None to hide\nColorScale       True or False    True            di\
splays a color scale on the right\nSmoothing        integer >= 0     1               number of linear interpolations\n\nExample:\n\
 xr0=0;xr=Table[xr0+=Sin[i*Pi/21],{i,20}];xr-=(xr[[1]]+xr[[-1]])/2;\n yr=xr;\n table=Outer[Cos[Sqrt[(#^2+#2^2)/2]]&,xr,yr];\n\n gc\
=Graphics[MapThread[\n  Rectangle[#2,#3,\n    ListContourPlot[table, MeshRange->{xr, yr}, AspectRatio->1,\n      DisplayFunction->\
Identity, ColorFunction->#,\n      FrameLabel->{\"x\", \"y\", ToString[#]}]]&,\n   {{ Blue,        Pink,       Green,      Purple,\
      Yellow,     Cyan},\n     {{-0.15,0.65},{0.25,0.65},{0.65,0.65},{-0.15,0   },{0.25,0   },{0.65,0}},\n     {{ 0.2, 1.1 },{0.6,\
 1.1 },{1,   1.1 },{ 0.2, 0.45},{0.6 ,0.45},{1.0, 0.45}}}]];\n Show[gc];Update[];\n<ListContourPlot.png"[p$2385,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Usage:  ListContourPlot[list, options, ...]\n\nplots a contour plot by list which is a 2D List of Real data.\n\nO\
ption           Value            Default         Action\n-------------------------------------------------------------------------\
--\nContours         Real             10              number of contours\nPlotRange        {min,max}, {prxy, prz}, or {prx, pry, p\
rz}\n                                  Automatic       depth of contours (prz) and PlotRange for x-y (prxy)\nAspectRatio      Real\
             1\nMeshRange        ({x1,xn},{y1,yn}} or {{x1,..,xn},{y1,..,y1n}}\n                                  Automatic       \
Range of x and y axes\nColorFunction    Color scheme (Blue, Purple, Pink, Yellow, Green, Cyan),Function, or String\n              \
                    Blue            Null or None means \"white\"\nContourColorFunction\n                 Function or String\n     \
                             Automatic       Null or None to hide\nColorScale       True or False    True            displays a co\
lor scale on the right\nSmoothing        integer >= 0     1               number of linear interpolations\n\nExample:\n xr0=0;xr=T\
able[xr0+=Sin[i*Pi/21],{i,20}];xr-=(xr[[1]]+xr[[-1]])/2;\n yr=xr;\n table=Outer[Cos[Sqrt[(#^2+#2^2)/2]]&,xr,yr];\n\n gc=Graphics[M\
apThread[\n  Rectangle[#2,#3,\n    ListContourPlot[table, MeshRange->{xr, yr}, AspectRatio->1,\n      DisplayFunction->Identity, C\
olorFunction->#,\n      FrameLabel->{\"x\", \"y\", ToString[#]}]]&,\n   {{ Blue,        Pink,       Green,      Purple,      Yello\
w,     Cyan},\n     {{-0.15,0.65},{0.25,0.65},{0.65,0.65},{-0.15,0   },{0.25,0   },{0.65,0}},\n     {{ 0.2, 1.1 },{0.6, 1.1 },{1, \
  1.1 },{ 0.2, 0.45},{0.6 ,0.45},{1.0, 0.45}}}]];\n Show[gc];Update[];\n<ListContourPlot.png"[p$2385+pe$2385[[1,2]],p1$2385]]],
        p1$2385=-2+p$2385+pe$2385[[1,1]]}[[
       1]],
      0],
    1,lx$2385:=Help2HTML`o9$;p2$2385=4+p1$2385;p0$2385=-4+p$2385;0];
  If[(equ$2385=
Help2HTML`o8$["Usage:  ListContourPlot[list, options, ...]\n\nplots a contour plot by list which is a 2D List of Real data.\n\nOpt\
ion           Value            Default         Action\n---------------------------------------------------------------------------\
\nContours         Real             10              number of contours\nPlotRange        {min,max}, {prxy, prz}, or {prx, pry, prz\
}\n                                  Automatic       depth of contours (prz) and PlotRange for x-y (prxy)\nAspectRatio      Real  \
           1\nMeshRange        ({x1,xn},{y1,yn}} or {{x1,..,xn},{y1,..,y1n}}\n                                  Automatic       Ra\
nge of x and y axes\nColorFunction    Color scheme (Blue, Purple, Pink, Yellow, Green, Cyan),Function, or String\n                \
                  Blue            Null or None means \"white\"\nContourColorFunction\n                 Function or String\n       \
                           Automatic       Null or None to hide\nColorScale       True or False    True            displays a colo\
r scale on the right\nSmoothing        integer >= 0     1               number of linear interpolations\n\nExample:\n xr0=0;xr=Tab\
le[xr0+=Sin[i*Pi/21],{i,20}];xr-=(xr[[1]]+xr[[-1]])/2;\n yr=xr;\n table=Outer[Cos[Sqrt[(#^2+#2^2)/2]]&,xr,yr];\n\n gc=Graphics[Map\
Thread[\n  Rectangle[#2,#3,\n    ListContourPlot[table, MeshRange->{xr, yr}, AspectRatio->1,\n      DisplayFunction->Identity, Col\
orFunction->#,\n      FrameLabel->{\"x\", \"y\", ToString[#]}]]&,\n   {{ Blue,        Pink,       Green,      Purple,      Yellow,\
     Cyan},\n     {{-0.15,0.65},{0.25,0.65},{0.65,0.65},{-0.15,0   },{0.25,0   },{0.65,0}},\n     {{ 0.2, 1.1 },{0.6, 1.1 },{1,   \
1.1 },{ 0.2, 0.45},{0.6 ,0.45},{1.0, 0.45}}}]];\n Show[gc];Update[];\n<ListContourPlot.png"[p$2385,p1$2385]])===
    Undefined,
equ$2385="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Usage:  ListContourPlot[list, options, ...]\\
n\nplots a contour plot by list which is a 2D List of Real data.\n\nOption           Value            Default         Action\n----\
-----------------------------------------------------------------------\nContours         Real             10              number \
of contours\nPlotRange        {min,max}, {prxy, prz}, or {prx, pry, prz}\n                                  Automatic       depth \
of contours (prz) and PlotRange for x-y (prxy)\nAspectRatio      Real             1\nMeshRange        ({x1,xn},{y1,yn}} or {{x1,..\
,xn},{y1,..,y1n}}\n                                  Automatic       Range of x and y axes\nColorFunction    Color scheme (Blue, P\
urple, Pink, Yellow, Green, Cyan),Function, or String\n                                  Blue            Null or None means \"whit\
e\"\nContourColorFunction\n                 Function or String\n                                  Automatic       Null or None to \
hide\nColorScale       True or False    True            displays a color scale on the right\nSmoothing        integer >= 0     1  \
             number of linear interpolations\n\nExample:\n xr0=0;xr=Table[xr0+=Sin[i*Pi/21],{i,20}];xr-=(xr[[1]]+xr[[-1]])/2;\n yr\
=xr;\n table=Outer[Cos[Sqrt[(#^2+#2^2)/2]]&,xr,yr];\n\n gc=Graphics[MapThread[\n  Rectangle[#2,#3,\n    ListContourPlot[table, Mes\
hRange->{xr, yr}, AspectRatio->1,\n      DisplayFunction->Identity, ColorFunction->#,\n      FrameLabel->{\"x\", \"y\", ToString[#\
]}]]&,\n   {{ Blue,        Pink,       Green,      Purple,      Yellow,     Cyan},\n     {{-0.15,0.65},{0.25,0.65},{0.65,0.65},{-0\
.15,0   },{0.25,0   },{0.65,0}},\n     {{ 0.2, 1.1 },{0.6, 1.1 },{1,   1.1 },{ 0.2, 0.45},{0.6 ,0.45},{1.0, 0.45}}}]];\n Show[gc];\
Update[];\n<ListContourPlot.png"[p$2385,p1$2385]]=
       equ$2385;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2385},out$2385=lx$2385@Typeset["Usage:  ListContourPlot[list, options, ...]\n\nplots a contour plot by list which is a 2D\
 List of Real data.\n\nOption           Value            Default         Action\n-------------------------------------------------\
--------------------------\nContours         Real             10              number of contours\nPlotRange        {min,max}, {prx\
y, prz}, or {prx, pry, prz}\n                                  Automatic       depth of contours (prz) and PlotRange for x-y (prxy\
)\nAspectRatio      Real             1\nMeshRange        ({x1,xn},{y1,yn}} or {{x1,..,xn},{y1,..,y1n}}\n                          \
        Automatic       Range of x and y axes\nColorFunction    Color scheme (Blue, Purple, Pink, Yellow, Green, Cyan),Function, o\
r String\n                                  Blue            Null or None means \"white\"\nContourColorFunction\n                 F\
unction or String\n                                  Automatic       Null or None to hide\nColorScale       True or False    True \
           displays a color scale on the right\nSmoothing        integer >= 0     1               number of linear interpolations\\
n\nExample:\n xr0=0;xr=Table[xr0+=Sin[i*Pi/21],{i,20}];xr-=(xr[[1]]+xr[[-1]])/2;\n yr=xr;\n table=Outer[Cos[Sqrt[(#^2+#2^2)/2]]&,x\
r,yr];\n\n gc=Graphics[MapThread[\n  Rectangle[#2,#3,\n    ListContourPlot[table, MeshRange->{xr, yr}, AspectRatio->1,\n      Disp\
layFunction->Identity, ColorFunction->#,\n      FrameLabel->{\"x\", \"y\", ToString[#]}]]&,\n   {{ Blue,        Pink,       Green,\
      Purple,      Yellow,     Cyan},\n     {{-0.15,0.65},{0.25,0.65},{0.65,0.65},{-0.15,0   },{0.25,0   },{0.65,0}},\n     {{ 0.2\
, 1.1 },{0.6, 1.1 },{1,   1.1 },{ 0.2, 0.45},{0.6 ,0.45},{1.0, 0.45}}}]];\n Show[gc];Update[];\n<ListContourPlot.png"[p$2385,
           p1$2385],Format->Help2HTML`oB$];
        System["mv -f "//out$2385//" "//equ$2385]];
      Exit[]]];
   "Usage:  ListContourPlot[list, options, ...]\n\nplots a contour plot by list which is a 2D List of Real data.\n\nOption        \
   Value            Default         Action\n---------------------------------------------------------------------------\nContours \
        Real             10              number of contours\nPlotRange        {min,max}, {prxy, prz}, or {prx, pry, prz}\n        \
                          Automatic       depth of contours (prz) and PlotRange for x-y (prxy)\nAspectRatio      Real             \
1\nMeshRange        ({x1,xn},{y1,yn}} or {{x1,..,xn},{y1,..,y1n}}\n                                  Automatic       Range of x an\
d y axes\nColorFunction    Color scheme (Blue, Purple, Pink, Yellow, Green, Cyan),Function, or String\n                           \
       Blue            Null or None means \"white\"\nContourColorFunction\n                 Function or String\n                  \
                Automatic       Null or None to hide\nColorScale       True or False    True            displays a color scale on \
the right\nSmoothing        integer >= 0     1               number of linear interpolations\n\nExample:\n xr0=0;xr=Table[xr0+=Sin\
[i*Pi/21],{i,20}];xr-=(xr[[1]]+xr[[-1]])/2;\n yr=xr;\n table=Outer[Cos[Sqrt[(#^2+#2^2)/2]]&,xr,yr];\n\n gc=Graphics[MapThread[\n  \
Rectangle[#2,#3,\n    ListContourPlot[table, MeshRange->{xr, yr}, AspectRatio->1,\n      DisplayFunction->Identity, ColorFunction-\
>#,\n      FrameLabel->{\"x\", \"y\", ToString[#]}]]&,\n   {{ Blue,        Pink,       Green,      Purple,      Yellow,     Cyan},\
\n     {{-0.15,0.65},{0.25,0.65},{0.65,0.65},{-0.15,0   },{0.25,0   },{0.65,0}},\n     {{ 0.2, 1.1 },{0.6, 1.1 },{1,   1.1 },{ 0.2\
, 0.45},{0.6 ,0.45},{1.0, 0.45}}}]];\n Show[gc];Update[];\n<ListContourPlot.png"[1,Max[p0$2385,0]]//"<img  class=\"eqs\" SRC=\""//
   equ$2385//"\" />"//
Help2HTML`oy$["Usage:  ListContourPlot[list, options, ...]\n\nplots a contour plot by list which is a 2D List of Real data.\n\nOpt\
ion           Value            Default         Action\n---------------------------------------------------------------------------\
\nContours         Real             10              number of contours\nPlotRange        {min,max}, {prxy, prz}, or {prx, pry, prz\
}\n                                  Automatic       depth of contours (prz) and PlotRange for x-y (prxy)\nAspectRatio      Real  \
           1\nMeshRange        ({x1,xn},{y1,yn}} or {{x1,..,xn},{y1,..,y1n}}\n                                  Automatic       Ra\
nge of x and y axes\nColorFunction    Color scheme (Blue, Purple, Pink, Yellow, Green, Cyan),Function, or String\n                \
                  Blue            Null or None means \"white\"\nContourColorFunction\n                 Function or String\n       \
                           Automatic       Null or None to hide\nColorScale       True or False    True            displays a colo\
r scale on the right\nSmoothing        integer >= 0     1               number of linear interpolations\n\nExample:\n xr0=0;xr=Tab\
le[xr0+=Sin[i*Pi/21],{i,20}];xr-=(xr[[1]]+xr[[-1]])/2;\n yr=xr;\n table=Outer[Cos[Sqrt[(#^2+#2^2)/2]]&,xr,yr];\n\n gc=Graphics[Map\
Thread[\n  Rectangle[#2,#3,\n    ListContourPlot[table, MeshRange->{xr, yr}, AspectRatio->1,\n      DisplayFunction->Identity, Col\
orFunction->#,\n      FrameLabel->{\"x\", \"y\", ToString[#]}]]&,\n   {{ Blue,        Pink,       Green,      Purple,      Yellow,\
     Cyan},\n     {{-0.15,0.65},{0.25,0.65},{0.65,0.65},{-0.15,0   },{0.25,0   },{0.65,0}},\n     {{ 0.2, 1.1 },{0.6, 1.1 },{1,   \
1.1 },{ 0.2, 0.45},{0.6 ,0.45},{1.0, 0.45}}}]];\n Show[gc];Update[];\n<ListContourPlot.png"[p2$2385,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L414>Graphics</A> <A HREF=#L422>ListPlot</A> <A HREF=#L421>ListDensityPlot</A></PRE>
<LI>
<H3><A NAME=L421>
ListDensityPlot</A></H3>
<PRE>If[{},
Help2HTML`oA$["Usage:  ListDensityPlot[list, options, ...]\n\nplots a density plot by list which is a 2D List of Real data.\n\nOpt\
ion           Value            Default         Action\n---------------------------------------------------------------------------\
\nPlotRange        {min,max}, {prxy, prz}, or {prx, pry, prz}\n                                  Automatic       depth of contours\
 (prz) and PlotRange for x-y (prxy)\nAspectRatio      Real             1\nMeshRange        ({x1,xn},{y1,yn}} or {{x1,..,xn},{y1,..\
,y1n}}\n                                  Automatic       Range of x and y axes\nColorFunction    Color scheme (Blue, Purple, Pink\
, Yellow, Green, Cyan),Function, or String\n                                  Blue            Null or None means \"white\"\nMesh  \
           True or False    False           True to draw mesh\nMeshColor        Function or String\n                              \
    Automatic       Null or None to hide\nColorScale       True or False    True            displays a color scale on the right\nS\
moothing        integer >= 0     1               number of linear interpolations\n\nExample:\n   data = Table[Sin[x]/Cos[x^2 + y^2\
], {x, -2, 2, 0.1}, {y, -2, 2, 0.1}];\n   ListDensityPlot[data,PlotRange->{-5,5}, MeshRange->{{-2,2},{-2,2}}, FrameLabel->{\"x\",\\
"y\"}];\n   Update[];\n\n<ListDensityPlot.png"],
p$2388=1+p$2388[[1,2]];p1$2388=StringPosition["Usage:  ListDensityPlot[list, options, ...]\n\nplots a density plot by list which i\
s a 2D List of Real data.\n\nOption           Value            Default         Action\n-------------------------------------------\
--------------------------------\nPlotRange        {min,max}, {prxy, prz}, or {prx, pry, prz}\n                                  A\
utomatic       depth of contours (prz) and PlotRange for x-y (prxy)\nAspectRatio      Real             1\nMeshRange        ({x1,xn\
},{y1,yn}} or {{x1,..,xn},{y1,..,y1n}}\n                                  Automatic       Range of x and y axes\nColorFunction    \
Color scheme (Blue, Purple, Pink, Yellow, Green, Cyan),Function, or String\n                                  Blue            Null\
 or None means \"white\"\nMesh             True or False    False           True to draw mesh\nMeshColor        Function or String\
\n                                  Automatic       Null or None to hide\nColorScale       True or False    True            displa\
ys a color scale on the right\nSmoothing        integer >= 0     1               number of linear interpolations\n\nExample:\n   d\
ata = Table[Sin[x]/Cos[x^2 + y^2], {x, -2, 2, 0.1}, {y, -2, 2, 0.1}];\n   ListDensityPlot[data,PlotRange->{-5,5}, MeshRange->{{-2,\
2},{-2,2}}, FrameLabel->{\"x\",\"y\"}];\n   Update[];\n\n<ListDensityPlot.png"[p$2388,-1],">::",1];
   p1$2388=If[p1$2388==={},1300,-2+p$2388+p1$2388[[1,1]]];
neq=Which["Usage:  ListDensityPlot[list, options, ...]\n\nplots a density plot by list which is a 2D List of Real data.\n\nOption \
          Value            Default         Action\n---------------------------------------------------------------------------\nPl\
otRange        {min,max}, {prxy, prz}, or {prx, pry, prz}\n                                  Automatic       depth of contours (pr\
z) and PlotRange for x-y (prxy)\nAspectRatio      Real             1\nMeshRange        ({x1,xn},{y1,yn}} or {{x1,..,xn},{y1,..,y1n\
}}\n                                  Automatic       Range of x and y axes\nColorFunction    Color scheme (Blue, Purple, Pink, Ye\
llow, Green, Cyan),Function, or String\n                                  Blue            Null or None means \"white\"\nMesh      \
       True or False    False           True to draw mesh\nMeshColor        Function or String\n                                  \
Automatic       Null or None to hide\nColorScale       True or False    True            displays a color scale on the right\nSmoot\
hing        integer >= 0     1               number of linear interpolations\n\nExample:\n   data = Table[Sin[x]/Cos[x^2 + y^2], {\
x, -2, 2, 0.1}, {y, -2, 2, 0.1}];\n   ListDensityPlot[data,PlotRange->{-5,5}, MeshRange->{{-2,2},{-2,2}}, FrameLabel->{\"x\",\"y\"\
}];\n   Update[];\n\n<ListDensityPlot.png"[p$2388,4+p$2388]==="Text[",
    lx$2388:=Help2HTML`oa$;p$2388=5+p$2388;p1$2388-=1;p2$2388=5+p1$2388;p0$2388=-9+p$2388;
If[(pe$2388=StringPosition["Usage:  ListDensityPlot[list, options, ...]\n\nplots a density plot by list which is a 2D List of Real\
 data.\n\nOption           Value            Default         Action\n--------------------------------------------------------------\
-------------\nPlotRange        {min,max}, {prxy, prz}, or {prx, pry, prz}\n                                  Automatic       dept\
h of contours (prz) and PlotRange for x-y (prxy)\nAspectRatio      Real             1\nMeshRange        ({x1,xn},{y1,yn}} or {{x1,\
..,xn},{y1,..,y1n}}\n                                  Automatic       Range of x and y axes\nColorFunction    Color scheme (Blue,\
 Purple, Pink, Yellow, Green, Cyan),Function, or String\n                                  Blue            Null or None means \"wh\
ite\"\nMesh             True or False    False           True to draw mesh\nMeshColor        Function or String\n                 \
                 Automatic       Null or None to hide\nColorScale       True or False    True            displays a color scale on\
 the right\nSmoothing        integer >= 0     1               number of linear interpolations\n\nExample:\n   data = Table[Sin[x]/\
Cos[x^2 + y^2], {x, -2, 2, 0.1}, {y, -2, 2, 0.1}];\n   ListDensityPlot[data,PlotRange->{-5,5}, MeshRange->{{-2,2},{-2,2}}, FrameLa\
bel->{\"x\",\"y\"}];\n   Update[];\n\n<ListDensityPlot.png"[p$2388,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Usage:  ListDensityPlot[list, options, ...]\n\nplots a density plot by list which is a 2D List of Real data.\n\nO\
ption           Value            Default         Action\n-------------------------------------------------------------------------\
--\nPlotRange        {min,max}, {prxy, prz}, or {prx, pry, prz}\n                                  Automatic       depth of contou\
rs (prz) and PlotRange for x-y (prxy)\nAspectRatio      Real             1\nMeshRange        ({x1,xn},{y1,yn}} or {{x1,..,xn},{y1,\
..,y1n}}\n                                  Automatic       Range of x and y axes\nColorFunction    Color scheme (Blue, Purple, Pi\
nk, Yellow, Green, Cyan),Function, or String\n                                  Blue            Null or None means \"white\"\nMesh\
             True or False    False           True to draw mesh\nMeshColor        Function or String\n                            \
      Automatic       Null or None to hide\nColorScale       True or False    True            displays a color scale on the right\\
nSmoothing        integer >= 0     1               number of linear interpolations\n\nExample:\n   data = Table[Sin[x]/Cos[x^2 + y\
^2], {x, -2, 2, 0.1}, {y, -2, 2, 0.1}];\n   ListDensityPlot[data,PlotRange->{-5,5}, MeshRange->{{-2,2},{-2,2}}, FrameLabel->{\"x\"\
,\"y\"}];\n   Update[];\n\n<ListDensityPlot.png"[p$2388+pe$2388[[1,2]],p1$2388]]],
        p1$2388=-2+p$2388+pe$2388[[1,1]]}[[
       1]],
      0],
    1,lx$2388:=Help2HTML`o9$;p2$2388=4+p1$2388;p0$2388=-4+p$2388;0];
  If[(equ$2388=
Help2HTML`o8$["Usage:  ListDensityPlot[list, options, ...]\n\nplots a density plot by list which is a 2D List of Real data.\n\nOpt\
ion           Value            Default         Action\n---------------------------------------------------------------------------\
\nPlotRange        {min,max}, {prxy, prz}, or {prx, pry, prz}\n                                  Automatic       depth of contours\
 (prz) and PlotRange for x-y (prxy)\nAspectRatio      Real             1\nMeshRange        ({x1,xn},{y1,yn}} or {{x1,..,xn},{y1,..\
,y1n}}\n                                  Automatic       Range of x and y axes\nColorFunction    Color scheme (Blue, Purple, Pink\
, Yellow, Green, Cyan),Function, or String\n                                  Blue            Null or None means \"white\"\nMesh  \
           True or False    False           True to draw mesh\nMeshColor        Function or String\n                              \
    Automatic       Null or None to hide\nColorScale       True or False    True            displays a color scale on the right\nS\
moothing        integer >= 0     1               number of linear interpolations\n\nExample:\n   data = Table[Sin[x]/Cos[x^2 + y^2\
], {x, -2, 2, 0.1}, {y, -2, 2, 0.1}];\n   ListDensityPlot[data,PlotRange->{-5,5}, MeshRange->{{-2,2},{-2,2}}, FrameLabel->{\"x\",\\
"y\"}];\n   Update[];\n\n<ListDensityPlot.png"[p$2388,p1$2388]])===
    Undefined,
equ$2388="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Usage:  ListDensityPlot[list, options, ...]\\
n\nplots a density plot by list which is a 2D List of Real data.\n\nOption           Value            Default         Action\n----\
-----------------------------------------------------------------------\nPlotRange        {min,max}, {prxy, prz}, or {prx, pry, pr\
z}\n                                  Automatic       depth of contours (prz) and PlotRange for x-y (prxy)\nAspectRatio      Real \
            1\nMeshRange        ({x1,xn},{y1,yn}} or {{x1,..,xn},{y1,..,y1n}}\n                                  Automatic       R\
ange of x and y axes\nColorFunction    Color scheme (Blue, Purple, Pink, Yellow, Green, Cyan),Function, or String\n               \
                   Blue            Null or None means \"white\"\nMesh             True or False    False           True to draw me\
sh\nMeshColor        Function or String\n                                  Automatic       Null or None to hide\nColorScale       \
True or False    True            displays a color scale on the right\nSmoothing        integer >= 0     1               number of \
linear interpolations\n\nExample:\n   data = Table[Sin[x]/Cos[x^2 + y^2], {x, -2, 2, 0.1}, {y, -2, 2, 0.1}];\n   ListDensityPlot[d\
ata,PlotRange->{-5,5}, MeshRange->{{-2,2},{-2,2}}, FrameLabel->{\"x\",\"y\"}];\n   Update[];\n\n<ListDensityPlot.png"[p$2388,
         p1$2388]]=
       equ$2388;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2388},out$2388=lx$2388@Typeset["Usage:  ListDensityPlot[list, options, ...]\n\nplots a density plot by list which is a 2D\
 List of Real data.\n\nOption           Value            Default         Action\n-------------------------------------------------\
--------------------------\nPlotRange        {min,max}, {prxy, prz}, or {prx, pry, prz}\n                                  Automat\
ic       depth of contours (prz) and PlotRange for x-y (prxy)\nAspectRatio      Real             1\nMeshRange        ({x1,xn},{y1,\
yn}} or {{x1,..,xn},{y1,..,y1n}}\n                                  Automatic       Range of x and y axes\nColorFunction    Color \
scheme (Blue, Purple, Pink, Yellow, Green, Cyan),Function, or String\n                                  Blue            Null or No\
ne means \"white\"\nMesh             True or False    False           True to draw mesh\nMeshColor        Function or String\n    \
                              Automatic       Null or None to hide\nColorScale       True or False    True            displays a c\
olor scale on the right\nSmoothing        integer >= 0     1               number of linear interpolations\n\nExample:\n   data = \
Table[Sin[x]/Cos[x^2 + y^2], {x, -2, 2, 0.1}, {y, -2, 2, 0.1}];\n   ListDensityPlot[data,PlotRange->{-5,5}, MeshRange->{{-2,2},{-2\
,2}}, FrameLabel->{\"x\",\"y\"}];\n   Update[];\n\n<ListDensityPlot.png"[p$2388,p1$2388],Format->Help2HTML`oB$];
        System["mv -f "//out$2388//" "//equ$2388]];
      Exit[]]];
   "Usage:  ListDensityPlot[list, options, ...]\n\nplots a density plot by list which is a 2D List of Real data.\n\nOption        \
   Value            Default         Action\n---------------------------------------------------------------------------\nPlotRange\
        {min,max}, {prxy, prz}, or {prx, pry, prz}\n                                  Automatic       depth of contours (prz) and \
PlotRange for x-y (prxy)\nAspectRatio      Real             1\nMeshRange        ({x1,xn},{y1,yn}} or {{x1,..,xn},{y1,..,y1n}}\n   \
                               Automatic       Range of x and y axes\nColorFunction    Color scheme (Blue, Purple, Pink, Yellow, G\
reen, Cyan),Function, or String\n                                  Blue            Null or None means \"white\"\nMesh             \
True or False    False           True to draw mesh\nMeshColor        Function or String\n                                  Automat\
ic       Null or None to hide\nColorScale       True or False    True            displays a color scale on the right\nSmoothing   \
     integer >= 0     1               number of linear interpolations\n\nExample:\n   data = Table[Sin[x]/Cos[x^2 + y^2], {x, -2, \
2, 0.1}, {y, -2, 2, 0.1}];\n   ListDensityPlot[data,PlotRange->{-5,5}, MeshRange->{{-2,2},{-2,2}}, FrameLabel->{\"x\",\"y\"}];\n  \
 Update[];\n\n<ListDensityPlot.png"[1,Max[p0$2388,0]]//"<img  class=\"eqs\" SRC=\""//equ$2388//"\" />"//
Help2HTML`oy$["Usage:  ListDensityPlot[list, options, ...]\n\nplots a density plot by list which is a 2D List of Real data.\n\nOpt\
ion           Value            Default         Action\n---------------------------------------------------------------------------\
\nPlotRange        {min,max}, {prxy, prz}, or {prx, pry, prz}\n                                  Automatic       depth of contours\
 (prz) and PlotRange for x-y (prxy)\nAspectRatio      Real             1\nMeshRange        ({x1,xn},{y1,yn}} or {{x1,..,xn},{y1,..\
,y1n}}\n                                  Automatic       Range of x and y axes\nColorFunction    Color scheme (Blue, Purple, Pink\
, Yellow, Green, Cyan),Function, or String\n                                  Blue            Null or None means \"white\"\nMesh  \
           True or False    False           True to draw mesh\nMeshColor        Function or String\n                              \
    Automatic       Null or None to hide\nColorScale       True or False    True            displays a color scale on the right\nS\
moothing        integer >= 0     1               number of linear interpolations\n\nExample:\n   data = Table[Sin[x]/Cos[x^2 + y^2\
], {x, -2, 2, 0.1}, {y, -2, 2, 0.1}];\n   ListDensityPlot[data,PlotRange->{-5,5}, MeshRange->{{-2,2},{-2,2}}, FrameLabel->{\"x\",\\
"y\"}];\n   Update[];\n\n<ListDensityPlot.png"[p2$2388,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L414>Graphics</A> <A HREF=#L422>ListPlot</A> <A HREF=#L420>ListContourPlot</A></PRE>
<LI>
<H3><A NAME=L422>
ListPlot</A></H3>
<PRE>If[{},
Help2HTML`oA$["Usage: ListPlot[{{x1,y1},..,{xn,yn}}, options]\n\nmakes a graphic with points.\nListPlot[{y1,..,yn}, options] assum\
es 1,..n for the x-xoordinate.\nListPlot[{{x,y,dy}, ..}, options ] plots error bars of length dy in y.\nListPlot[{{x,y,dx,dy}, ..}\
, options ] plots error bars in x and y.\n\noption           default         optional values\n------------------------------------\
------------\nPlotJoined       False           True\n                                 Step\nStepRatio        1               ratio\
 of stepping position\n                                 between two data points\n\nType ? to see other options for Graphics.\n\nEx\
ample:\n  data1={{1,2},{3,5},{4,-1}};\n  data2={{1,4},{2,-2},{3.5,3},{5,3}};\n  g1=ListPlot[data1, PointColor->\"dark slate blue\"\
,PlotJoined->True, Thickness->2, PlotColor->\"dark slate blue\", FrameLabel->{\"x\",\"y\"}, Legend->\"data1\", DisplayFunction->Id\
entity];\n  g2=ListPlot[data2, PointColor->\"tomato\", Legend->\"data2\", DisplayFunction->Identity];\n  Show[g1,g2];\n  Update[];\
\n\n<ListPlot.png"],
p$2391=1+p$2391[[1,2]];p1$2391=StringPosition["Usage: ListPlot[{{x1,y1},..,{xn,yn}}, options]\n\nmakes a graphic with points.\nLis\
tPlot[{y1,..,yn}, options] assumes 1,..n for the x-xoordinate.\nListPlot[{{x,y,dy}, ..}, options ] plots error bars of length dy i\
n y.\nListPlot[{{x,y,dx,dy}, ..}, options ] plots error bars in x and y.\n\noption           default         optional values\n----\
--------------------------------------------\nPlotJoined       False           True\n                                 Step\nStepRa\
tio        1               ratio of stepping position\n                                 between two data points\n\nType ? to see o\
ther options for Graphics.\n\nExample:\n  data1={{1,2},{3,5},{4,-1}};\n  data2={{1,4},{2,-2},{3.5,3},{5,3}};\n  g1=ListPlot[data1,\
 PointColor->\"dark slate blue\",PlotJoined->True, Thickness->2, PlotColor->\"dark slate blue\", FrameLabel->{\"x\",\"y\"}, Legend\
->\"data1\", DisplayFunction->Identity];\n  g2=ListPlot[data2, PointColor->\"tomato\", Legend->\"data2\", DisplayFunction->Identit\
y];\n  Show[g1,g2];\n  Update[];\n\n<ListPlot.png"[p$2391,-1],">::",1];
   p1$2391=If[p1$2391==={},1004,-2+p$2391+p1$2391[[1,1]]];
neq=Which["Usage: ListPlot[{{x1,y1},..,{xn,yn}}, options]\n\nmakes a graphic with points.\nListPlot[{y1,..,yn}, options] assumes 1\
,..n for the x-xoordinate.\nListPlot[{{x,y,dy}, ..}, options ] plots error bars of length dy in y.\nListPlot[{{x,y,dx,dy}, ..}, op\
tions ] plots error bars in x and y.\n\noption           default         optional values\n----------------------------------------\
--------\nPlotJoined       False           True\n                                 Step\nStepRatio        1               ratio of \
stepping position\n                                 between two data points\n\nType ? to see other options for Graphics.\n\nExampl\
e:\n  data1={{1,2},{3,5},{4,-1}};\n  data2={{1,4},{2,-2},{3.5,3},{5,3}};\n  g1=ListPlot[data1, PointColor->\"dark slate blue\",Plo\
tJoined->True, Thickness->2, PlotColor->\"dark slate blue\", FrameLabel->{\"x\",\"y\"}, Legend->\"data1\", DisplayFunction->Identi\
ty];\n  g2=ListPlot[data2, PointColor->\"tomato\", Legend->\"data2\", DisplayFunction->Identity];\n  Show[g1,g2];\n  Update[];\n\n\
<ListPlot.png"[p$2391,4+p$2391]==="Text[",
    lx$2391:=Help2HTML`oa$;p$2391=5+p$2391;p1$2391-=1;p2$2391=5+p1$2391;p0$2391=-9+p$2391;If[(pe$2391=
StringPosition["Usage: ListPlot[{{x1,y1},..,{xn,yn}}, options]\n\nmakes a graphic with points.\nListPlot[{y1,..,yn}, options] assu\
mes 1,..n for the x-xoordinate.\nListPlot[{{x,y,dy}, ..}, options ] plots error bars of length dy in y.\nListPlot[{{x,y,dx,dy}, ..\
}, options ] plots error bars in x and y.\n\noption           default         optional values\n-----------------------------------\
-------------\nPlotJoined       False           True\n                                 Step\nStepRatio        1               rati\
o of stepping position\n                                 between two data points\n\nType ? to see other options for Graphics.\n\nE\
xample:\n  data1={{1,2},{3,5},{4,-1}};\n  data2={{1,4},{2,-2},{3.5,3},{5,3}};\n  g1=ListPlot[data1, PointColor->\"dark slate blue\\
",PlotJoined->True, Thickness->2, PlotColor->\"dark slate blue\", FrameLabel->{\"x\",\"y\"}, Legend->\"data1\", DisplayFunction->I\
dentity];\n  g2=ListPlot[data2, PointColor->\"tomato\", Legend->\"data2\", DisplayFunction->Identity];\n  Show[g1,g2];\n  Update[]\
;\n\n<ListPlot.png"[p$2391,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Usage: ListPlot[{{x1,y1},..,{xn,yn}}, options]\n\nmakes a graphic with points.\nListPlot[{y1,..,yn}, options] ass\
umes 1,..n for the x-xoordinate.\nListPlot[{{x,y,dy}, ..}, options ] plots error bars of length dy in y.\nListPlot[{{x,y,dx,dy}, .\
.}, options ] plots error bars in x and y.\n\noption           default         optional values\n----------------------------------\
--------------\nPlotJoined       False           True\n                                 Step\nStepRatio        1               rat\
io of stepping position\n                                 between two data points\n\nType ? to see other options for Graphics.\n\n\
Example:\n  data1={{1,2},{3,5},{4,-1}};\n  data2={{1,4},{2,-2},{3.5,3},{5,3}};\n  g1=ListPlot[data1, PointColor->\"dark slate blue\
\",PlotJoined->True, Thickness->2, PlotColor->\"dark slate blue\", FrameLabel->{\"x\",\"y\"}, Legend->\"data1\", DisplayFunction->\
Identity];\n  g2=ListPlot[data2, PointColor->\"tomato\", Legend->\"data2\", DisplayFunction->Identity];\n  Show[g1,g2];\n  Update[\
];\n\n<ListPlot.png"[p$2391+pe$2391[[1,2]],p1$2391]]],
        p1$2391=-2+p$2391+pe$2391[[1,1]]}[[
       1]],
      0],
    1,lx$2391:=Help2HTML`o9$;p2$2391=4+p1$2391;p0$2391=-4+p$2391;0];
  If[(equ$2391=
Help2HTML`o8$["Usage: ListPlot[{{x1,y1},..,{xn,yn}}, options]\n\nmakes a graphic with points.\nListPlot[{y1,..,yn}, options] assum\
es 1,..n for the x-xoordinate.\nListPlot[{{x,y,dy}, ..}, options ] plots error bars of length dy in y.\nListPlot[{{x,y,dx,dy}, ..}\
, options ] plots error bars in x and y.\n\noption           default         optional values\n------------------------------------\
------------\nPlotJoined       False           True\n                                 Step\nStepRatio        1               ratio\
 of stepping position\n                                 between two data points\n\nType ? to see other options for Graphics.\n\nEx\
ample:\n  data1={{1,2},{3,5},{4,-1}};\n  data2={{1,4},{2,-2},{3.5,3},{5,3}};\n  g1=ListPlot[data1, PointColor->\"dark slate blue\"\
,PlotJoined->True, Thickness->2, PlotColor->\"dark slate blue\", FrameLabel->{\"x\",\"y\"}, Legend->\"data1\", DisplayFunction->Id\
entity];\n  g2=ListPlot[data2, PointColor->\"tomato\", Legend->\"data2\", DisplayFunction->Identity];\n  Show[g1,g2];\n  Update[];\
\n\n<ListPlot.png"[p$2391,p1$2391]])===
    Undefined,
equ$2391="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Usage: ListPlot[{{x1,y1},..,{xn,yn}}, option\
s]\n\nmakes a graphic with points.\nListPlot[{y1,..,yn}, options] assumes 1,..n for the x-xoordinate.\nListPlot[{{x,y,dy}, ..}, op\
tions ] plots error bars of length dy in y.\nListPlot[{{x,y,dx,dy}, ..}, options ] plots error bars in x and y.\n\noption         \
  default         optional values\n------------------------------------------------\nPlotJoined       False           True\n      \
                           Step\nStepRatio        1               ratio of stepping position\n                                 bet\
ween two data points\n\nType ? to see other options for Graphics.\n\nExample:\n  data1={{1,2},{3,5},{4,-1}};\n  data2={{1,4},{2,-2\
},{3.5,3},{5,3}};\n  g1=ListPlot[data1, PointColor->\"dark slate blue\",PlotJoined->True, Thickness->2, PlotColor->\"dark slate bl\
ue\", FrameLabel->{\"x\",\"y\"}, Legend->\"data1\", DisplayFunction->Identity];\n  g2=ListPlot[data2, PointColor->\"tomato\", Lege\
nd->\"data2\", DisplayFunction->Identity];\n  Show[g1,g2];\n  Update[];\n\n<ListPlot.png"[p$2391,p1$2391]]=
       equ$2391;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2391},out$2391=lx$2391@Typeset["Usage: ListPlot[{{x1,y1},..,{xn,yn}}, options]\n\nmakes a graphic with points.\nListPlot[\
{y1,..,yn}, options] assumes 1,..n for the x-xoordinate.\nListPlot[{{x,y,dy}, ..}, options ] plots error bars of length dy in y.\n\
ListPlot[{{x,y,dx,dy}, ..}, options ] plots error bars in x and y.\n\noption           default         optional values\n----------\
--------------------------------------\nPlotJoined       False           True\n                                 Step\nStepRatio   \
     1               ratio of stepping position\n                                 between two data points\n\nType ? to see other o\
ptions for Graphics.\n\nExample:\n  data1={{1,2},{3,5},{4,-1}};\n  data2={{1,4},{2,-2},{3.5,3},{5,3}};\n  g1=ListPlot[data1, Point\
Color->\"dark slate blue\",PlotJoined->True, Thickness->2, PlotColor->\"dark slate blue\", FrameLabel->{\"x\",\"y\"}, Legend->\"da\
ta1\", DisplayFunction->Identity];\n  g2=ListPlot[data2, PointColor->\"tomato\", Legend->\"data2\", DisplayFunction->Identity];\n \
 Show[g1,g2];\n  Update[];\n\n<ListPlot.png"[p$2391,p1$2391],Format->Help2HTML`oB$];
        System["mv -f "//out$2391//" "//equ$2391]];
      Exit[]]];
   "Usage: ListPlot[{{x1,y1},..,{xn,yn}}, options]\n\nmakes a graphic with points.\nListPlot[{y1,..,yn}, options] assumes 1,..n fo\
r the x-xoordinate.\nListPlot[{{x,y,dy}, ..}, options ] plots error bars of length dy in y.\nListPlot[{{x,y,dx,dy}, ..}, options ]\
 plots error bars in x and y.\n\noption           default         optional values\n-----------------------------------------------\
-\nPlotJoined       False           True\n                                 Step\nStepRatio        1               ratio of steppin\
g position\n                                 between two data points\n\nType ? to see other options for Graphics.\n\nExample:\n  d\
ata1={{1,2},{3,5},{4,-1}};\n  data2={{1,4},{2,-2},{3.5,3},{5,3}};\n  g1=ListPlot[data1, PointColor->\"dark slate blue\",PlotJoined\
->True, Thickness->2, PlotColor->\"dark slate blue\", FrameLabel->{\"x\",\"y\"}, Legend->\"data1\", DisplayFunction->Identity];\n \
 g2=ListPlot[data2, PointColor->\"tomato\", Legend->\"data2\", DisplayFunction->Identity];\n  Show[g1,g2];\n  Update[];\n\n<ListPl\
ot.png"[1,Max[p0$2391,0]]//"<img  class=\"eqs\" SRC=\""//equ$2391//"\" />"//
Help2HTML`oy$["Usage: ListPlot[{{x1,y1},..,{xn,yn}}, options]\n\nmakes a graphic with points.\nListPlot[{y1,..,yn}, options] assum\
es 1,..n for the x-xoordinate.\nListPlot[{{x,y,dy}, ..}, options ] plots error bars of length dy in y.\nListPlot[{{x,y,dx,dy}, ..}\
, options ] plots error bars in x and y.\n\noption           default         optional values\n------------------------------------\
------------\nPlotJoined       False           True\n                                 Step\nStepRatio        1               ratio\
 of stepping position\n                                 between two data points\n\nType ? to see other options for Graphics.\n\nEx\
ample:\n  data1={{1,2},{3,5},{4,-1}};\n  data2={{1,4},{2,-2},{3.5,3},{5,3}};\n  g1=ListPlot[data1, PointColor->\"dark slate blue\"\
,PlotJoined->True, Thickness->2, PlotColor->\"dark slate blue\", FrameLabel->{\"x\",\"y\"}, Legend->\"data1\", DisplayFunction->Id\
entity];\n  g2=ListPlot[data2, PointColor->\"tomato\", Legend->\"data2\", DisplayFunction->Identity];\n  Show[g1,g2];\n  Update[];\
\n\n<ListPlot.png"[p2$2391,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L414>Graphics</A> <A HREF=#L424>Plot</A></PRE>
<LI>
<H3><A NAME=L423>
OpticsPlot</A></H3>
<PRE>If[{},
Help2HTML`oA$["Usage: OpticsPlot[fun_list, options]\n\nmakes a plot of built-in optical functions, user-defined functions, or\nlis\
t of data at components on the beam line.   The parameters are:\t\n\nfun_list: a list of objects to be plotted in a window. The nu\
mber of windows in a plot is the length of fun_list object plotted in a window MUST have same dimensions. An element of fun_list i\
s one of fun_label, fun, list_data or a list as {object, options}, where\nfun_label: one of \"AX\", \"BX\", \"GMX\", \"NX\", \"EX\\
", \"EPX\", \"DX\", \"DPX\", \"AY\", \"BY\", \"GMY\", \"NY\", \"EY\", \"EPY\", \"DY\", \"DPY\", \"R1\", \"R2\", \"R3\", \"R4\", \"\
DETR\", \"AZ\", \"BZ\", \"GMZ\", \"NZ\", \"ZX\", \"ZPX\", \"ZY\", \"ZPY\", \"DZ\",\"DDP\",\"PEX\", \"PEPX\", \"PEY\", \"PEPY\", \"\
GAMMA\", \"GAMMABETA\",\"SIGab\", where a and b in \"SIGab\" are one of X, PX, Y, PY, Z, DP. \"R\"//fun_label refers the reference\
 optics. \"D\"//fun_label refers the difference between the current and reference optics.\n            fun: Any function of the co\
mponent number.   A fractional number may be used to obtain the intermediate value.\n            list_data: a list of {{pos1, val1\
}..{posn,valn}}.\t\n\noptions       defaults\n-----------------------------------------\nRegion        {1,LINE[\"LENGTH\"]}  {begi\
n, end}, begin and end can be strings.\n                                  Both begin and end point of drawing region\n            \
                      could be given by \"S\" unit by using S[begin|end] form.\nLattice       True                False to turn of\
 drawing lattice\nLatticeRegion Automatic           {low,high}, the region where lattice is drawn\nFrameHeight   Automatic        \
   List of relative heights of each frame\nInfoLabel     False               If True, pressing Button shows Twiss, etc.\nNames    \
     \"*\"                 A pattern of component names to be plotted.\nRemoveOverlap \"L$NAME\"            If not \"L$NAME\", ove\
rlapping of lattice names\n                                  remain untouched.\nTags          False               True to attach t\
ags \"C$\"//(component name)\n                                  to each rectangle for the lattice, and\n                          \
        \"L$\"//(component name) to the component \n                                  label (CanvasDrawer only).\nLegend        Fa\
lse               If Automatic, Legend is composed from FrameLabel\n                                  Automatically.\n\noptions in\
 a fun_list element:\noptions       defaults\n-----------------------------------------\nUnit          1                  Unit of \
the object. \"Meter\", \"InvMeter\",etc.\nFrameLabel    \"\"                 Left frame label.\nLegend        False               \
If Automatic, Legend is composed from FrameLabel\n                                  Automatically.\n\nExample:\n   p2=OpticsPlot[{\
{\"BX\",\"BY\"}, {\"DX\",{{{10,0.001},{20,0.002}}, FrameLabel->\"DX meas.\", Unit->Meter, Thickness->2, Names->\"Q*\"}}}];\n   Upd\
ate[];\n\n<OpticsPlot.png"],
p$2394=1+p$2394[[1,2]];p1$2394=StringPosition["Usage: OpticsPlot[fun_list, options]\n\nmakes a plot of built-in optical functions,\
 user-defined functions, or\nlist of data at components on the beam line.   The parameters are:\t\n\nfun_list: a list of objects t\
o be plotted in a window. The number of windows in a plot is the length of fun_list object plotted in a window MUST have same dime\
nsions. An element of fun_list is one of fun_label, fun, list_data or a list as {object, options}, where\nfun_label: one of \"AX\"\
, \"BX\", \"GMX\", \"NX\", \"EX\", \"EPX\", \"DX\", \"DPX\", \"AY\", \"BY\", \"GMY\", \"NY\", \"EY\", \"EPY\", \"DY\", \"DPY\", \"\
R1\", \"R2\", \"R3\", \"R4\", \"DETR\", \"AZ\", \"BZ\", \"GMZ\", \"NZ\", \"ZX\", \"ZPX\", \"ZY\", \"ZPY\", \"DZ\",\"DDP\",\"PEX\",\
 \"PEPX\", \"PEY\", \"PEPY\", \"GAMMA\", \"GAMMABETA\",\"SIGab\", where a and b in \"SIGab\" are one of X, PX, Y, PY, Z, DP. \"R\"\
//fun_label refers the reference optics. \"D\"//fun_label refers the difference between the current and reference optics.\n       \
     fun: Any function of the component number.   A fractional number may be used to obtain the intermediate value.\n            l\
ist_data: a list of {{pos1, val1}..{posn,valn}}.\t\n\noptions       defaults\n-----------------------------------------\nRegion   \
     {1,LINE[\"LENGTH\"]}  {begin, end}, begin and end can be strings.\n                                  Both begin and end point\
 of drawing region\n                                  could be given by \"S\" unit by using S[begin|end] form.\nLattice       True\
                False to turn of drawing lattice\nLatticeRegion Automatic           {low,high}, the region where lattice is drawn\\
nFrameHeight   Automatic           List of relative heights of each frame\nInfoLabel     False               If True, pressing But\
ton shows Twiss, etc.\nNames         \"*\"                 A pattern of component names to be plotted.\nRemoveOverlap \"L$NAME\"  \
          If not \"L$NAME\", overlapping of lattice names\n                                  remain untouched.\nTags          Fals\
e               True to attach tags \"C$\"//(component name)\n                                  to each rectangle for the lattice,\
 and\n                                  \"L$\"//(component name) to the component \n                                  label (Canva\
sDrawer only).\nLegend        False               If Automatic, Legend is composed from FrameLabel\n                              \
    Automatically.\n\noptions in a fun_list element:\noptions       defaults\n-----------------------------------------\nUnit     \
     1                  Unit of the object. \"Meter\", \"InvMeter\",etc.\nFrameLabel    \"\"                 Left frame label.\nLe\
gend        False               If Automatic, Legend is composed from FrameLabel\n                                  Automatically.\
\n\nExample:\n   p2=OpticsPlot[{{\"BX\",\"BY\"}, {\"DX\",{{{10,0.001},{20,0.002}}, FrameLabel->\"DX meas.\", Unit->Meter, Thicknes\
s->2, Names->\"Q*\"}}}];\n   Update[];\n\n<OpticsPlot.png"[p$2394,-1],">::",1];
   p1$2394=If[p1$2394==={},2845,-2+p$2394+p1$2394[[1,1]]];
neq=Which["Usage: OpticsPlot[fun_list, options]\n\nmakes a plot of built-in optical functions, user-defined functions, or\nlist of\
 data at components on the beam line.   The parameters are:\t\n\nfun_list: a list of objects to be plotted in a window. The number\
 of windows in a plot is the length of fun_list object plotted in a window MUST have same dimensions. An element of fun_list is on\
e of fun_label, fun, list_data or a list as {object, options}, where\nfun_label: one of \"AX\", \"BX\", \"GMX\", \"NX\", \"EX\", \\
"EPX\", \"DX\", \"DPX\", \"AY\", \"BY\", \"GMY\", \"NY\", \"EY\", \"EPY\", \"DY\", \"DPY\", \"R1\", \"R2\", \"R3\", \"R4\", \"DETR\
\", \"AZ\", \"BZ\", \"GMZ\", \"NZ\", \"ZX\", \"ZPX\", \"ZY\", \"ZPY\", \"DZ\",\"DDP\",\"PEX\", \"PEPX\", \"PEY\", \"PEPY\", \"GAMM\
A\", \"GAMMABETA\",\"SIGab\", where a and b in \"SIGab\" are one of X, PX, Y, PY, Z, DP. \"R\"//fun_label refers the reference opt\
ics. \"D\"//fun_label refers the difference between the current and reference optics.\n            fun: Any function of the compon\
ent number.   A fractional number may be used to obtain the intermediate value.\n            list_data: a list of {{pos1, val1}..{\
posn,valn}}.\t\n\noptions       defaults\n-----------------------------------------\nRegion        {1,LINE[\"LENGTH\"]}  {begin, e\
nd}, begin and end can be strings.\n                                  Both begin and end point of drawing region\n                \
                  could be given by \"S\" unit by using S[begin|end] form.\nLattice       True                False to turn of dra\
wing lattice\nLatticeRegion Automatic           {low,high}, the region where lattice is drawn\nFrameHeight   Automatic           L\
ist of relative heights of each frame\nInfoLabel     False               If True, pressing Button shows Twiss, etc.\nNames        \
 \"*\"                 A pattern of component names to be plotted.\nRemoveOverlap \"L$NAME\"            If not \"L$NAME\", overlap\
ping of lattice names\n                                  remain untouched.\nTags          False               True to attach tags \
\"C$\"//(component name)\n                                  to each rectangle for the lattice, and\n                              \
    \"L$\"//(component name) to the component \n                                  label (CanvasDrawer only).\nLegend        False \
              If Automatic, Legend is composed from FrameLabel\n                                  Automatically.\n\noptions in a f\
un_list element:\noptions       defaults\n-----------------------------------------\nUnit          1                  Unit of the \
object. \"Meter\", \"InvMeter\",etc.\nFrameLabel    \"\"                 Left frame label.\nLegend        False               If A\
utomatic, Legend is composed from FrameLabel\n                                  Automatically.\n\nExample:\n   p2=OpticsPlot[{{\"B\
X\",\"BY\"}, {\"DX\",{{{10,0.001},{20,0.002}}, FrameLabel->\"DX meas.\", Unit->Meter, Thickness->2, Names->\"Q*\"}}}];\n   Update[\
];\n\n<OpticsPlot.png"[p$2394,4+p$2394]==="Text[",
    lx$2394:=Help2HTML`oa$;p$2394=5+p$2394;p1$2394-=1;p2$2394=5+p1$2394;p0$2394=-9+p$2394;
If[(pe$2394=StringPosition["Usage: OpticsPlot[fun_list, options]\n\nmakes a plot of built-in optical functions, user-defined funct\
ions, or\nlist of data at components on the beam line.   The parameters are:\t\n\nfun_list: a list of objects to be plotted in a w\
indow. The number of windows in a plot is the length of fun_list object plotted in a window MUST have same dimensions. An element \
of fun_list is one of fun_label, fun, list_data or a list as {object, options}, where\nfun_label: one of \"AX\", \"BX\", \"GMX\", \
\"NX\", \"EX\", \"EPX\", \"DX\", \"DPX\", \"AY\", \"BY\", \"GMY\", \"NY\", \"EY\", \"EPY\", \"DY\", \"DPY\", \"R1\", \"R2\", \"R3\\
", \"R4\", \"DETR\", \"AZ\", \"BZ\", \"GMZ\", \"NZ\", \"ZX\", \"ZPX\", \"ZY\", \"ZPY\", \"DZ\",\"DDP\",\"PEX\", \"PEPX\", \"PEY\",\
 \"PEPY\", \"GAMMA\", \"GAMMABETA\",\"SIGab\", where a and b in \"SIGab\" are one of X, PX, Y, PY, Z, DP. \"R\"//fun_label refers \
the reference optics. \"D\"//fun_label refers the difference between the current and reference optics.\n            fun: Any funct\
ion of the component number.   A fractional number may be used to obtain the intermediate value.\n            list_data: a list of\
 {{pos1, val1}..{posn,valn}}.\t\n\noptions       defaults\n-----------------------------------------\nRegion        {1,LINE[\"LENG\
TH\"]}  {begin, end}, begin and end can be strings.\n                                  Both begin and end point of drawing region\\
n                                  could be given by \"S\" unit by using S[begin|end] form.\nLattice       True                Fal\
se to turn of drawing lattice\nLatticeRegion Automatic           {low,high}, the region where lattice is drawn\nFrameHeight   Auto\
matic           List of relative heights of each frame\nInfoLabel     False               If True, pressing Button shows Twiss, et\
c.\nNames         \"*\"                 A pattern of component names to be plotted.\nRemoveOverlap \"L$NAME\"            If not \"\
L$NAME\", overlapping of lattice names\n                                  remain untouched.\nTags          False               Tru\
e to attach tags \"C$\"//(component name)\n                                  to each rectangle for the lattice, and\n             \
                     \"L$\"//(component name) to the component \n                                  label (CanvasDrawer only).\nLeg\
end        False               If Automatic, Legend is composed from FrameLabel\n                                  Automatically.\\
n\noptions in a fun_list element:\noptions       defaults\n-----------------------------------------\nUnit          1             \
     Unit of the object. \"Meter\", \"InvMeter\",etc.\nFrameLabel    \"\"                 Left frame label.\nLegend        False  \
             If Automatic, Legend is composed from FrameLabel\n                                  Automatically.\n\nExample:\n   p2\
=OpticsPlot[{{\"BX\",\"BY\"}, {\"DX\",{{{10,0.001},{20,0.002}}, FrameLabel->\"DX meas.\", Unit->Meter, Thickness->2, Names->\"Q*\"\
}}}];\n   Update[];\n\n<OpticsPlot.png"[p$2394,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Usage: OpticsPlot[fun_list, options]\n\nmakes a plot of built-in optical functions, user-defined functions, or\nl\
ist of data at components on the beam line.   The parameters are:\t\n\nfun_list: a list of objects to be plotted in a window. The \
number of windows in a plot is the length of fun_list object plotted in a window MUST have same dimensions. An element of fun_list\
 is one of fun_label, fun, list_data or a list as {object, options}, where\nfun_label: one of \"AX\", \"BX\", \"GMX\", \"NX\", \"E\
X\", \"EPX\", \"DX\", \"DPX\", \"AY\", \"BY\", \"GMY\", \"NY\", \"EY\", \"EPY\", \"DY\", \"DPY\", \"R1\", \"R2\", \"R3\", \"R4\", \
\"DETR\", \"AZ\", \"BZ\", \"GMZ\", \"NZ\", \"ZX\", \"ZPX\", \"ZY\", \"ZPY\", \"DZ\",\"DDP\",\"PEX\", \"PEPX\", \"PEY\", \"PEPY\", \
\"GAMMA\", \"GAMMABETA\",\"SIGab\", where a and b in \"SIGab\" are one of X, PX, Y, PY, Z, DP. \"R\"//fun_label refers the referen\
ce optics. \"D\"//fun_label refers the difference between the current and reference optics.\n            fun: Any function of the \
component number.   A fractional number may be used to obtain the intermediate value.\n            list_data: a list of {{pos1, va\
l1}..{posn,valn}}.\t\n\noptions       defaults\n-----------------------------------------\nRegion        {1,LINE[\"LENGTH\"]}  {be\
gin, end}, begin and end can be strings.\n                                  Both begin and end point of drawing region\n          \
                        could be given by \"S\" unit by using S[begin|end] form.\nLattice       True                False to turn \
of drawing lattice\nLatticeRegion Automatic           {low,high}, the region where lattice is drawn\nFrameHeight   Automatic      \
     List of relative heights of each frame\nInfoLabel     False               If True, pressing Button shows Twiss, etc.\nNames  \
       \"*\"                 A pattern of component names to be plotted.\nRemoveOverlap \"L$NAME\"            If not \"L$NAME\", o\
verlapping of lattice names\n                                  remain untouched.\nTags          False               True to attach\
 tags \"C$\"//(component name)\n                                  to each rectangle for the lattice, and\n                        \
          \"L$\"//(component name) to the component \n                                  label (CanvasDrawer only).\nLegend        \
False               If Automatic, Legend is composed from FrameLabel\n                                  Automatically.\n\noptions \
in a fun_list element:\noptions       defaults\n-----------------------------------------\nUnit          1                  Unit o\
f the object. \"Meter\", \"InvMeter\",etc.\nFrameLabel    \"\"                 Left frame label.\nLegend        False             \
  If Automatic, Legend is composed from FrameLabel\n                                  Automatically.\n\nExample:\n   p2=OpticsPlot\
[{{\"BX\",\"BY\"}, {\"DX\",{{{10,0.001},{20,0.002}}, FrameLabel->\"DX meas.\", Unit->Meter, Thickness->2, Names->\"Q*\"}}}];\n   U\
pdate[];\n\n<OpticsPlot.png"[p$2394+pe$2394[[1,2]],p1$2394]]],
        p1$2394=-2+p$2394+pe$2394[[1,1]]}[[
       1]],
      0],
    1,lx$2394:=Help2HTML`o9$;p2$2394=4+p1$2394;p0$2394=-4+p$2394;0];
  If[(equ$2394=
Help2HTML`o8$["Usage: OpticsPlot[fun_list, options]\n\nmakes a plot of built-in optical functions, user-defined functions, or\nlis\
t of data at components on the beam line.   The parameters are:\t\n\nfun_list: a list of objects to be plotted in a window. The nu\
mber of windows in a plot is the length of fun_list object plotted in a window MUST have same dimensions. An element of fun_list i\
s one of fun_label, fun, list_data or a list as {object, options}, where\nfun_label: one of \"AX\", \"BX\", \"GMX\", \"NX\", \"EX\\
", \"EPX\", \"DX\", \"DPX\", \"AY\", \"BY\", \"GMY\", \"NY\", \"EY\", \"EPY\", \"DY\", \"DPY\", \"R1\", \"R2\", \"R3\", \"R4\", \"\
DETR\", \"AZ\", \"BZ\", \"GMZ\", \"NZ\", \"ZX\", \"ZPX\", \"ZY\", \"ZPY\", \"DZ\",\"DDP\",\"PEX\", \"PEPX\", \"PEY\", \"PEPY\", \"\
GAMMA\", \"GAMMABETA\",\"SIGab\", where a and b in \"SIGab\" are one of X, PX, Y, PY, Z, DP. \"R\"//fun_label refers the reference\
 optics. \"D\"//fun_label refers the difference between the current and reference optics.\n            fun: Any function of the co\
mponent number.   A fractional number may be used to obtain the intermediate value.\n            list_data: a list of {{pos1, val1\
}..{posn,valn}}.\t\n\noptions       defaults\n-----------------------------------------\nRegion        {1,LINE[\"LENGTH\"]}  {begi\
n, end}, begin and end can be strings.\n                                  Both begin and end point of drawing region\n            \
                      could be given by \"S\" unit by using S[begin|end] form.\nLattice       True                False to turn of\
 drawing lattice\nLatticeRegion Automatic           {low,high}, the region where lattice is drawn\nFrameHeight   Automatic        \
   List of relative heights of each frame\nInfoLabel     False               If True, pressing Button shows Twiss, etc.\nNames    \
     \"*\"                 A pattern of component names to be plotted.\nRemoveOverlap \"L$NAME\"            If not \"L$NAME\", ove\
rlapping of lattice names\n                                  remain untouched.\nTags          False               True to attach t\
ags \"C$\"//(component name)\n                                  to each rectangle for the lattice, and\n                          \
        \"L$\"//(component name) to the component \n                                  label (CanvasDrawer only).\nLegend        Fa\
lse               If Automatic, Legend is composed from FrameLabel\n                                  Automatically.\n\noptions in\
 a fun_list element:\noptions       defaults\n-----------------------------------------\nUnit          1                  Unit of \
the object. \"Meter\", \"InvMeter\",etc.\nFrameLabel    \"\"                 Left frame label.\nLegend        False               \
If Automatic, Legend is composed from FrameLabel\n                                  Automatically.\n\nExample:\n   p2=OpticsPlot[{\
{\"BX\",\"BY\"}, {\"DX\",{{{10,0.001},{20,0.002}}, FrameLabel->\"DX meas.\", Unit->Meter, Thickness->2, Names->\"Q*\"}}}];\n   Upd\
ate[];\n\n<OpticsPlot.png"[p$2394,p1$2394]])===
    Undefined,
equ$2394="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Usage: OpticsPlot[fun_list, options]\n\nmake\
s a plot of built-in optical functions, user-defined functions, or\nlist of data at components on the beam line.   The parameters \
are:\t\n\nfun_list: a list of objects to be plotted in a window. The number of windows in a plot is the length of fun_list object \
plotted in a window MUST have same dimensions. An element of fun_list is one of fun_label, fun, list_data or a list as {object, op\
tions}, where\nfun_label: one of \"AX\", \"BX\", \"GMX\", \"NX\", \"EX\", \"EPX\", \"DX\", \"DPX\", \"AY\", \"BY\", \"GMY\", \"NY\\
", \"EY\", \"EPY\", \"DY\", \"DPY\", \"R1\", \"R2\", \"R3\", \"R4\", \"DETR\", \"AZ\", \"BZ\", \"GMZ\", \"NZ\", \"ZX\", \"ZPX\", \\
"ZY\", \"ZPY\", \"DZ\",\"DDP\",\"PEX\", \"PEPX\", \"PEY\", \"PEPY\", \"GAMMA\", \"GAMMABETA\",\"SIGab\", where a and b in \"SIGab\\
" are one of X, PX, Y, PY, Z, DP. \"R\"//fun_label refers the reference optics. \"D\"//fun_label refers the difference between the\
 current and reference optics.\n            fun: Any function of the component number.   A fractional number may be used to obtain\
 the intermediate value.\n            list_data: a list of {{pos1, val1}..{posn,valn}}.\t\n\noptions       defaults\n-------------\
----------------------------\nRegion        {1,LINE[\"LENGTH\"]}  {begin, end}, begin and end can be strings.\n                   \
               Both begin and end point of drawing region\n                                  could be given by \"S\" unit by using\
 S[begin|end] form.\nLattice       True                False to turn of drawing lattice\nLatticeRegion Automatic           {low,hi\
gh}, the region where lattice is drawn\nFrameHeight   Automatic           List of relative heights of each frame\nInfoLabel     Fa\
lse               If True, pressing Button shows Twiss, etc.\nNames         \"*\"                 A pattern of component names to \
be plotted.\nRemoveOverlap \"L$NAME\"            If not \"L$NAME\", overlapping of lattice names\n                                \
  remain untouched.\nTags          False               True to attach tags \"C$\"//(component name)\n                             \
     to each rectangle for the lattice, and\n                                  \"L$\"//(component name) to the component \n       \
                           label (CanvasDrawer only).\nLegend        False               If Automatic, Legend is composed from Fra\
meLabel\n                                  Automatically.\n\noptions in a fun_list element:\noptions       defaults\n-------------\
----------------------------\nUnit          1                  Unit of the object. \"Meter\", \"InvMeter\",etc.\nFrameLabel    \"\\
"                 Left frame label.\nLegend        False               If Automatic, Legend is composed from FrameLabel\n         \
                         Automatically.\n\nExample:\n   p2=OpticsPlot[{{\"BX\",\"BY\"}, {\"DX\",{{{10,0.001},{20,0.002}}, FrameLab\
el->\"DX meas.\", Unit->Meter, Thickness->2, Names->\"Q*\"}}}];\n   Update[];\n\n<OpticsPlot.png"[p$2394,p1$2394]]=
       equ$2394;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2394},out$2394=lx$2394@Typeset["Usage: OpticsPlot[fun_list, options]\n\nmakes a plot of built-in optical functions, user-\
defined functions, or\nlist of data at components on the beam line.   The parameters are:\t\n\nfun_list: a list of objects to be p\
lotted in a window. The number of windows in a plot is the length of fun_list object plotted in a window MUST have same dimensions\
. An element of fun_list is one of fun_label, fun, list_data or a list as {object, options}, where\nfun_label: one of \"AX\", \"BX\
\", \"GMX\", \"NX\", \"EX\", \"EPX\", \"DX\", \"DPX\", \"AY\", \"BY\", \"GMY\", \"NY\", \"EY\", \"EPY\", \"DY\", \"DPY\", \"R1\", \
\"R2\", \"R3\", \"R4\", \"DETR\", \"AZ\", \"BZ\", \"GMZ\", \"NZ\", \"ZX\", \"ZPX\", \"ZY\", \"ZPY\", \"DZ\",\"DDP\",\"PEX\", \"PEP\
X\", \"PEY\", \"PEPY\", \"GAMMA\", \"GAMMABETA\",\"SIGab\", where a and b in \"SIGab\" are one of X, PX, Y, PY, Z, DP. \"R\"//fun_\
label refers the reference optics. \"D\"//fun_label refers the difference between the current and reference optics.\n            f\
un: Any function of the component number.   A fractional number may be used to obtain the intermediate value.\n            list_da\
ta: a list of {{pos1, val1}..{posn,valn}}.\t\n\noptions       defaults\n-----------------------------------------\nRegion        {\
1,LINE[\"LENGTH\"]}  {begin, end}, begin and end can be strings.\n                                  Both begin and end point of dr\
awing region\n                                  could be given by \"S\" unit by using S[begin|end] form.\nLattice       True      \
          False to turn of drawing lattice\nLatticeRegion Automatic           {low,high}, the region where lattice is drawn\nFrame\
Height   Automatic           List of relative heights of each frame\nInfoLabel     False               If True, pressing Button sh\
ows Twiss, etc.\nNames         \"*\"                 A pattern of component names to be plotted.\nRemoveOverlap \"L$NAME\"        \
    If not \"L$NAME\", overlapping of lattice names\n                                  remain untouched.\nTags          False     \
          True to attach tags \"C$\"//(component name)\n                                  to each rectangle for the lattice, and\n\
                                  \"L$\"//(component name) to the component \n                                  label (CanvasDrawe\
r only).\nLegend        False               If Automatic, Legend is composed from FrameLabel\n                                  Au\
tomatically.\n\noptions in a fun_list element:\noptions       defaults\n-----------------------------------------\nUnit          1\
                  Unit of the object. \"Meter\", \"InvMeter\",etc.\nFrameLabel    \"\"                 Left frame label.\nLegend  \
      False               If Automatic, Legend is composed from FrameLabel\n                                  Automatically.\n\nEx\
ample:\n   p2=OpticsPlot[{{\"BX\",\"BY\"}, {\"DX\",{{{10,0.001},{20,0.002}}, FrameLabel->\"DX meas.\", Unit->Meter, Thickness->2, \
Names->\"Q*\"}}}];\n   Update[];\n\n<OpticsPlot.png"[p$2394,p1$2394],Format->Help2HTML`oB$];
        System["mv -f "//out$2394//" "//equ$2394]];
      Exit[]]];
   "Usage: OpticsPlot[fun_list, options]\n\nmakes a plot of built-in optical functions, user-defined functions, or\nlist of data a\
t components on the beam line.   The parameters are:\t\n\nfun_list: a list of objects to be plotted in a window. The number of win\
dows in a plot is the length of fun_list object plotted in a window MUST have same dimensions. An element of fun_list is one of fu\
n_label, fun, list_data or a list as {object, options}, where\nfun_label: one of \"AX\", \"BX\", \"GMX\", \"NX\", \"EX\", \"EPX\",\
 \"DX\", \"DPX\", \"AY\", \"BY\", \"GMY\", \"NY\", \"EY\", \"EPY\", \"DY\", \"DPY\", \"R1\", \"R2\", \"R3\", \"R4\", \"DETR\", \"A\
Z\", \"BZ\", \"GMZ\", \"NZ\", \"ZX\", \"ZPX\", \"ZY\", \"ZPY\", \"DZ\",\"DDP\",\"PEX\", \"PEPX\", \"PEY\", \"PEPY\", \"GAMMA\", \"\
GAMMABETA\",\"SIGab\", where a and b in \"SIGab\" are one of X, PX, Y, PY, Z, DP. \"R\"//fun_label refers the reference optics. \"\
D\"//fun_label refers the difference between the current and reference optics.\n            fun: Any function of the component num\
ber.   A fractional number may be used to obtain the intermediate value.\n            list_data: a list of {{pos1, val1}..{posn,va\
ln}}.\t\n\noptions       defaults\n-----------------------------------------\nRegion        {1,LINE[\"LENGTH\"]}  {begin, end}, be\
gin and end can be strings.\n                                  Both begin and end point of drawing region\n                       \
           could be given by \"S\" unit by using S[begin|end] form.\nLattice       True                False to turn of drawing la\
ttice\nLatticeRegion Automatic           {low,high}, the region where lattice is drawn\nFrameHeight   Automatic           List of \
relative heights of each frame\nInfoLabel     False               If True, pressing Button shows Twiss, etc.\nNames         \"*\" \
                A pattern of component names to be plotted.\nRemoveOverlap \"L$NAME\"            If not \"L$NAME\", overlapping of\
 lattice names\n                                  remain untouched.\nTags          False               True to attach tags \"C$\"/\
/(component name)\n                                  to each rectangle for the lattice, and\n                                  \"L\
$\"//(component name) to the component \n                                  label (CanvasDrawer only).\nLegend        False        \
       If Automatic, Legend is composed from FrameLabel\n                                  Automatically.\n\noptions in a fun_list\
 element:\noptions       defaults\n-----------------------------------------\nUnit          1                  Unit of the object.\
 \"Meter\", \"InvMeter\",etc.\nFrameLabel    \"\"                 Left frame label.\nLegend        False               If Automati\
c, Legend is composed from FrameLabel\n                                  Automatically.\n\nExample:\n   p2=OpticsPlot[{{\"BX\",\"B\
Y\"}, {\"DX\",{{{10,0.001},{20,0.002}}, FrameLabel->\"DX meas.\", Unit->Meter, Thickness->2, Names->\"Q*\"}}}];\n   Update[];\n\n<\
OpticsPlot.png"[1,Max[p0$2394,0]]//"<img  class=\"eqs\" SRC=\""//equ$2394//"\" />"//
Help2HTML`oy$["Usage: OpticsPlot[fun_list, options]\n\nmakes a plot of built-in optical functions, user-defined functions, or\nlis\
t of data at components on the beam line.   The parameters are:\t\n\nfun_list: a list of objects to be plotted in a window. The nu\
mber of windows in a plot is the length of fun_list object plotted in a window MUST have same dimensions. An element of fun_list i\
s one of fun_label, fun, list_data or a list as {object, options}, where\nfun_label: one of \"AX\", \"BX\", \"GMX\", \"NX\", \"EX\\
", \"EPX\", \"DX\", \"DPX\", \"AY\", \"BY\", \"GMY\", \"NY\", \"EY\", \"EPY\", \"DY\", \"DPY\", \"R1\", \"R2\", \"R3\", \"R4\", \"\
DETR\", \"AZ\", \"BZ\", \"GMZ\", \"NZ\", \"ZX\", \"ZPX\", \"ZY\", \"ZPY\", \"DZ\",\"DDP\",\"PEX\", \"PEPX\", \"PEY\", \"PEPY\", \"\
GAMMA\", \"GAMMABETA\",\"SIGab\", where a and b in \"SIGab\" are one of X, PX, Y, PY, Z, DP. \"R\"//fun_label refers the reference\
 optics. \"D\"//fun_label refers the difference between the current and reference optics.\n            fun: Any function of the co\
mponent number.   A fractional number may be used to obtain the intermediate value.\n            list_data: a list of {{pos1, val1\
}..{posn,valn}}.\t\n\noptions       defaults\n-----------------------------------------\nRegion        {1,LINE[\"LENGTH\"]}  {begi\
n, end}, begin and end can be strings.\n                                  Both begin and end point of drawing region\n            \
                      could be given by \"S\" unit by using S[begin|end] form.\nLattice       True                False to turn of\
 drawing lattice\nLatticeRegion Automatic           {low,high}, the region where lattice is drawn\nFrameHeight   Automatic        \
   List of relative heights of each frame\nInfoLabel     False               If True, pressing Button shows Twiss, etc.\nNames    \
     \"*\"                 A pattern of component names to be plotted.\nRemoveOverlap \"L$NAME\"            If not \"L$NAME\", ove\
rlapping of lattice names\n                                  remain untouched.\nTags          False               True to attach t\
ags \"C$\"//(component name)\n                                  to each rectangle for the lattice, and\n                          \
        \"L$\"//(component name) to the component \n                                  label (CanvasDrawer only).\nLegend        Fa\
lse               If Automatic, Legend is composed from FrameLabel\n                                  Automatically.\n\noptions in\
 a fun_list element:\noptions       defaults\n-----------------------------------------\nUnit          1                  Unit of \
the object. \"Meter\", \"InvMeter\",etc.\nFrameLabel    \"\"                 Left frame label.\nLegend        False               \
If Automatic, Legend is composed from FrameLabel\n                                  Automatically.\n\nExample:\n   p2=OpticsPlot[{\
{\"BX\",\"BY\"}, {\"DX\",{{{10,0.001},{20,0.002}}, FrameLabel->\"DX meas.\", Unit->Meter, Thickness->2, Names->\"Q*\"}}}];\n   Upd\
ate[];\n\n<OpticsPlot.png"[p2$2394,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L414>Graphics</A> <A HREF=#L422>ListPlot</A> <A HREF=#L410>Twiss</A> <A HREF=#L490>reference-optics</A></PRE>
<LI>
<H3><A NAME=L424>
Plot</A></H3>
<PRE>If[{},
Help2HTML`oA$["Usage: Plot[fun, range, options] or Plot[{fun1, .. }, range, options],\n\nwhere fun is a function and range is a li\
st given as {x, xmin, xmax}.\n\noptions        defaults\n-----------------------------------------\nMaxBend        0.04\nPlotPoint\
s     25\nPlotDivision   250\nDashing        {\"1\",\"0.8 0.24\",\"0.4 0.12\",\"0.2 0.08\",\"0.1 0.08\",\n                  \"0.8 \
0.08 0.08 0.08\",\"0.4 0.08 0.08 0.08\"}\nOptions for ListPlot and Graphics are also available\n\nThe independent variable should \
have been cleared (i.e., no value should\nnot be set) when Plot is called. \n\nExample:\n  ff[x_]:=Sin[x]/x;\n  ff[0]=1;\n  Plot[{\
Cos[x],ff[x]}, {x,0,10}, Thickness->2];\n  Update[];\n\n<Plot.png"],
p$2397=1+p$2397[[1,2]];p1$2397=StringPosition["Usage: Plot[fun, range, options] or Plot[{fun1, .. }, range, options],\n\nwhere fun\
 is a function and range is a list given as {x, xmin, xmax}.\n\noptions        defaults\n-----------------------------------------\
\nMaxBend        0.04\nPlotPoints     25\nPlotDivision   250\nDashing        {\"1\",\"0.8 0.24\",\"0.4 0.12\",\"0.2 0.08\",\"0.1 0\
.08\",\n                  \"0.8 0.08 0.08 0.08\",\"0.4 0.08 0.08 0.08\"}\nOptions for ListPlot and Graphics are also available\n\n\
The independent variable should have been cleared (i.e., no value should\nnot be set) when Plot is called. \n\nExample:\n  ff[x_]:\
=Sin[x]/x;\n  ff[0]=1;\n  Plot[{Cos[x],ff[x]}, {x,0,10}, Thickness->2];\n  Update[];\n\n<Plot.png"[p$2397,-1],">::",1];
   p1$2397=If[p1$2397==={},664,-2+p$2397+p1$2397[[1,1]]];
neq=Which["Usage: Plot[fun, range, options] or Plot[{fun1, .. }, range, options],\n\nwhere fun is a function and range is a list g\
iven as {x, xmin, xmax}.\n\noptions        defaults\n-----------------------------------------\nMaxBend        0.04\nPlotPoints   \
  25\nPlotDivision   250\nDashing        {\"1\",\"0.8 0.24\",\"0.4 0.12\",\"0.2 0.08\",\"0.1 0.08\",\n                  \"0.8 0.08\
 0.08 0.08\",\"0.4 0.08 0.08 0.08\"}\nOptions for ListPlot and Graphics are also available\n\nThe independent variable should have\
 been cleared (i.e., no value should\nnot be set) when Plot is called. \n\nExample:\n  ff[x_]:=Sin[x]/x;\n  ff[0]=1;\n  Plot[{Cos[\
x],ff[x]}, {x,0,10}, Thickness->2];\n  Update[];\n\n<Plot.png"[p$2397,4+p$2397]==="Text[",
    lx$2397:=Help2HTML`oa$;p$2397=5+p$2397;p1$2397-=1;p2$2397=5+p1$2397;p0$2397=-9+p$2397;
If[(pe$2397=StringPosition["Usage: Plot[fun, range, options] or Plot[{fun1, .. }, range, options],\n\nwhere fun is a function and \
range is a list given as {x, xmin, xmax}.\n\noptions        defaults\n-----------------------------------------\nMaxBend        0.\
04\nPlotPoints     25\nPlotDivision   250\nDashing        {\"1\",\"0.8 0.24\",\"0.4 0.12\",\"0.2 0.08\",\"0.1 0.08\",\n           \
       \"0.8 0.08 0.08 0.08\",\"0.4 0.08 0.08 0.08\"}\nOptions for ListPlot and Graphics are also available\n\nThe independent var\
iable should have been cleared (i.e., no value should\nnot be set) when Plot is called. \n\nExample:\n  ff[x_]:=Sin[x]/x;\n  ff[0]\
=1;\n  Plot[{Cos[x],ff[x]}, {x,0,10}, Thickness->2];\n  Update[];\n\n<Plot.png"[p$2397,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Usage: Plot[fun, range, options] or Plot[{fun1, .. }, range, options],\n\nwhere fun is a function and range is a \
list given as {x, xmin, xmax}.\n\noptions        defaults\n-----------------------------------------\nMaxBend        0.04\nPlotPoi\
nts     25\nPlotDivision   250\nDashing        {\"1\",\"0.8 0.24\",\"0.4 0.12\",\"0.2 0.08\",\"0.1 0.08\",\n                  \"0.\
8 0.08 0.08 0.08\",\"0.4 0.08 0.08 0.08\"}\nOptions for ListPlot and Graphics are also available\n\nThe independent variable shoul\
d have been cleared (i.e., no value should\nnot be set) when Plot is called. \n\nExample:\n  ff[x_]:=Sin[x]/x;\n  ff[0]=1;\n  Plot\
[{Cos[x],ff[x]}, {x,0,10}, Thickness->2];\n  Update[];\n\n<Plot.png"[p$2397+pe$2397[[1,2]],p1$2397]]],
        p1$2397=-2+p$2397+pe$2397[[1,1]]}[[
       1]],
      0],
    1,lx$2397:=Help2HTML`o9$;p2$2397=4+p1$2397;p0$2397=-4+p$2397;0];
  If[(equ$2397=
Help2HTML`o8$["Usage: Plot[fun, range, options] or Plot[{fun1, .. }, range, options],\n\nwhere fun is a function and range is a li\
st given as {x, xmin, xmax}.\n\noptions        defaults\n-----------------------------------------\nMaxBend        0.04\nPlotPoint\
s     25\nPlotDivision   250\nDashing        {\"1\",\"0.8 0.24\",\"0.4 0.12\",\"0.2 0.08\",\"0.1 0.08\",\n                  \"0.8 \
0.08 0.08 0.08\",\"0.4 0.08 0.08 0.08\"}\nOptions for ListPlot and Graphics are also available\n\nThe independent variable should \
have been cleared (i.e., no value should\nnot be set) when Plot is called. \n\nExample:\n  ff[x_]:=Sin[x]/x;\n  ff[0]=1;\n  Plot[{\
Cos[x],ff[x]}, {x,0,10}, Thickness->2];\n  Update[];\n\n<Plot.png"[p$2397,p1$2397]])===
    Undefined,
equ$2397="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Usage: Plot[fun, range, options] or Plot[{fu\
n1, .. }, range, options],\n\nwhere fun is a function and range is a list given as {x, xmin, xmax}.\n\noptions        defaults\n--\
---------------------------------------\nMaxBend        0.04\nPlotPoints     25\nPlotDivision   250\nDashing        {\"1\",\"0.8 0\
.24\",\"0.4 0.12\",\"0.2 0.08\",\"0.1 0.08\",\n                  \"0.8 0.08 0.08 0.08\",\"0.4 0.08 0.08 0.08\"}\nOptions for ListP\
lot and Graphics are also available\n\nThe independent variable should have been cleared (i.e., no value should\nnot be set) when \
Plot is called. \n\nExample:\n  ff[x_]:=Sin[x]/x;\n  ff[0]=1;\n  Plot[{Cos[x],ff[x]}, {x,0,10}, Thickness->2];\n  Update[];\n\n<Pl\
ot.png"[p$2397,p1$2397]]=
       equ$2397;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2397},out$2397=lx$2397@Typeset["Usage: Plot[fun, range, options] or Plot[{fun1, .. }, range, options],\n\nwhere fun is a \
function and range is a list given as {x, xmin, xmax}.\n\noptions        defaults\n-----------------------------------------\nMaxB\
end        0.04\nPlotPoints     25\nPlotDivision   250\nDashing        {\"1\",\"0.8 0.24\",\"0.4 0.12\",\"0.2 0.08\",\"0.1 0.08\",\
\n                  \"0.8 0.08 0.08 0.08\",\"0.4 0.08 0.08 0.08\"}\nOptions for ListPlot and Graphics are also available\n\nThe in\
dependent variable should have been cleared (i.e., no value should\nnot be set) when Plot is called. \n\nExample:\n  ff[x_]:=Sin[x\
]/x;\n  ff[0]=1;\n  Plot[{Cos[x],ff[x]}, {x,0,10}, Thickness->2];\n  Update[];\n\n<Plot.png"[p$2397,p1$2397],
          Format->Help2HTML`oB$];
        System["mv -f "//out$2397//" "//equ$2397]];
      Exit[]]];
   "Usage: Plot[fun, range, options] or Plot[{fun1, .. }, range, options],\n\nwhere fun is a function and range is a list given as\
 {x, xmin, xmax}.\n\noptions        defaults\n-----------------------------------------\nMaxBend        0.04\nPlotPoints     25\nP\
lotDivision   250\nDashing        {\"1\",\"0.8 0.24\",\"0.4 0.12\",\"0.2 0.08\",\"0.1 0.08\",\n                  \"0.8 0.08 0.08 0\
.08\",\"0.4 0.08 0.08 0.08\"}\nOptions for ListPlot and Graphics are also available\n\nThe independent variable should have been c\
leared (i.e., no value should\nnot be set) when Plot is called. \n\nExample:\n  ff[x_]:=Sin[x]/x;\n  ff[0]=1;\n  Plot[{Cos[x],ff[x\
]}, {x,0,10}, Thickness->2];\n  Update[];\n\n<Plot.png"[1,Max[p0$2397,0]]//"<img  class=\"eqs\" SRC=\""//equ$2397//"\" />"//
   Help2HTML`oy$["Usage: Plot[fun, range, options] or Plot[{fun1, .. }, range, options],\n\nwhere fun is a function and range is a\
 list given as {x, xmin, xmax}.\n\noptions        defaults\n-----------------------------------------\nMaxBend        0.04\nPlotPo\
ints     25\nPlotDivision   250\nDashing        {\"1\",\"0.8 0.24\",\"0.4 0.12\",\"0.2 0.08\",\"0.1 0.08\",\n                  \"0\
.8 0.08 0.08 0.08\",\"0.4 0.08 0.08 0.08\"}\nOptions for ListPlot and Graphics are also available\n\nThe independent variable shou\
ld have been cleared (i.e., no value should\nnot be set) when Plot is called. \n\nExample:\n  ff[x_]:=Sin[x]/x;\n  ff[0]=1;\n  Plo\
t[{Cos[x],ff[x]}, {x,0,10}, Thickness->2];\n  Update[];\n\n<Plot.png"[p2$2397,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L414>Graphics</A> <A HREF=#L422>ListPlot</A></PRE>
</UL>
<LI>
<H3><A NAME=L425>
Input/Output</A></H3>
<PRE>
</PRE>
<UL>
<LI>
<H3><A NAME=L426>
$FORM</A></H3>
<PRE>If[{},
Help2HTML`oA$["$FORM is a character-string to specify the format of the output of a real number.\n\nUsage: $FORM=\"w.f\"\n       $\
FORM=\"Sw.f\"\n       $FORM=\"Fw.f\"\n       $FORM=\"Mw.f\"\n\nwhere w is the width of the output, and f is the length of the frac\
tions. If S is attached, trailing zeroes are omitted. If F is attached, it becomes same as FORTRAN's F-format. If M is attached, t\
he exponent is expressed as 10^n. If w and f are omitted, 17.15 is assumed.\n   The default is S17.15 ."],
 p$2401=1+p$2401[[1,2]];p1$2401=
StringPosition["$FORM is a character-string to specify the format of the output of a real number.\n\nUsage: $FORM=\"w.f\"\n       \
$FORM=\"Sw.f\"\n       $FORM=\"Fw.f\"\n       $FORM=\"Mw.f\"\n\nwhere w is the width of the output, and f is the length of the fra\
ctions. If S is attached, trailing zeroes are omitted. If F is attached, it becomes same as FORTRAN's F-format. If M is attached, \
the exponent is expressed as 10^n. If w and f are omitted, 17.15 is assumed.\n   The default is S17.15 ."[p$2401,-1],">::",1];
   p1$2401=If[p1$2401==={},462,-2+p$2401+p1$2401[[1,1]]];
neq=Which["$FORM is a character-string to specify the format of the output of a real number.\n\nUsage: $FORM=\"w.f\"\n       $FORM\
=\"Sw.f\"\n       $FORM=\"Fw.f\"\n       $FORM=\"Mw.f\"\n\nwhere w is the width of the output, and f is the length of the fraction\
s. If S is attached, trailing zeroes are omitted. If F is attached, it becomes same as FORTRAN's F-format. If M is attached, the e\
xponent is expressed as 10^n. If w and f are omitted, 17.15 is assumed.\n   The default is S17.15 ."[p$2401,4+p$2401]==="Text[",
    lx$2401:=Help2HTML`oa$;p$2401=5+p$2401;p1$2401-=1;p2$2401=5+p1$2401;p0$2401=-9+p$2401;
If[(pe$2401=StringPosition["$FORM is a character-string to specify the format of the output of a real number.\n\nUsage: $FORM=\"w.\
f\"\n       $FORM=\"Sw.f\"\n       $FORM=\"Fw.f\"\n       $FORM=\"Mw.f\"\n\nwhere w is the width of the output, and f is the lengt\
h of the fractions. If S is attached, trailing zeroes are omitted. If F is attached, it becomes same as FORTRAN's F-format. If M i\
s attached, the exponent is expressed as 10^n. If w and f are omitted, 17.15 is assumed.\n   The default is S17.15 ."[p$2401,-2],
         ";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["$FORM is a character-string to specify the format of the output of a real number.\n\nUsage: $FORM=\"w.f\"\n      \
 $FORM=\"Sw.f\"\n       $FORM=\"Fw.f\"\n       $FORM=\"Mw.f\"\n\nwhere w is the width of the output, and f is the length of the fr\
actions. If S is attached, trailing zeroes are omitted. If F is attached, it becomes same as FORTRAN's F-format. If M is attached,\
 the exponent is expressed as 10^n. If w and f are omitted, 17.15 is assumed.\n   The default is S17.15 ."[p$2401+pe$2401[[1,2]],
           p1$2401]]],
        p1$2401=-2+p$2401+pe$2401[[1,1]]}[[
       1]],
      0],
    1,lx$2401:=Help2HTML`o9$;p2$2401=4+p1$2401;p0$2401=-4+p$2401;0];
  If[(equ$2401=
Help2HTML`o8$["$FORM is a character-string to specify the format of the output of a real number.\n\nUsage: $FORM=\"w.f\"\n       $\
FORM=\"Sw.f\"\n       $FORM=\"Fw.f\"\n       $FORM=\"Mw.f\"\n\nwhere w is the width of the output, and f is the length of the frac\
tions. If S is attached, trailing zeroes are omitted. If F is attached, it becomes same as FORTRAN's F-format. If M is attached, t\
he exponent is expressed as 10^n. If w and f are omitted, 17.15 is assumed.\n   The default is S17.15 ."[p$2401,p1$2401]])===
    Undefined,
equ$2401="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["$FORM is a character-string to specify the f\
ormat of the output of a real number.\n\nUsage: $FORM=\"w.f\"\n       $FORM=\"Sw.f\"\n       $FORM=\"Fw.f\"\n       $FORM=\"Mw.f\"\
\n\nwhere w is the width of the output, and f is the length of the fractions. If S is attached, trailing zeroes are omitted. If F \
is attached, it becomes same as FORTRAN's F-format. If M is attached, the exponent is expressed as 10^n. If w and f are omitted, 1\
7.15 is assumed.\n   The default is S17.15 ."[p$2401,p1$2401]]=
       equ$2401;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2401},out$2401=lx$2401@Typeset["$FORM is a character-string to specify the format of the output of a real number.\n\nUsag\
e: $FORM=\"w.f\"\n       $FORM=\"Sw.f\"\n       $FORM=\"Fw.f\"\n       $FORM=\"Mw.f\"\n\nwhere w is the width of the output, and f\
 is the length of the fractions. If S is attached, trailing zeroes are omitted. If F is attached, it becomes same as FORTRAN's F-f\
ormat. If M is attached, the exponent is expressed as 10^n. If w and f are omitted, 17.15 is assumed.\n   The default is S17.15 ."[
           p$2401,p1$2401],Format->Help2HTML`oB$];
        System["mv -f "//out$2401//" "//equ$2401]];
      Exit[]]];
   "$FORM is a character-string to specify the format of the output of a real number.\n\nUsage: $FORM=\"w.f\"\n       $FORM=\"Sw.f\
\"\n       $FORM=\"Fw.f\"\n       $FORM=\"Mw.f\"\n\nwhere w is the width of the output, and f is the length of the fractions. If S\
 is attached, trailing zeroes are omitted. If F is attached, it becomes same as FORTRAN's F-format. If M is attached, the exponent\
 is expressed as 10^n. If w and f are omitted, 17.15 is assumed.\n   The default is S17.15 ."[1,Max[p0$2401,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2401//"\" />"//
Help2HTML`oy$["$FORM is a character-string to specify the format of the output of a real number.\n\nUsage: $FORM=\"w.f\"\n       $\
FORM=\"Sw.f\"\n       $FORM=\"Fw.f\"\n       $FORM=\"Mw.f\"\n\nwhere w is the width of the output, and f is the length of the frac\
tions. If S is attached, trailing zeroes are omitted. If F is attached, it becomes same as FORTRAN's F-format. If M is attached, t\
he exponent is expressed as 10^n. If w and f are omitted, 17.15 is assumed.\n   The default is S17.15 ."[p2$2401,-1]]
]</PRE>
<LI>
<H3><A NAME=L427>
$Input</A></H3>
<PRE>If[{},Help2HTML`oA$["$Input holds the file number for console input stream. The default is -1."],
 p$2403=1+p$2403[[1,2]];p1$2403=
   StringPosition["$Input holds the file number for console input stream. The default is -1."[p$2403,-1],">::",1];
  p1$2403=If[p1$2403==={},73,-2+p$2403+p1$2403[[1,1]]];
  neq=Which["$Input holds the file number for console input stream. The default is -1."[p$2403,4+p$2403]==="Text[",
    lx$2403:=Help2HTML`oa$;p$2403=5+p$2403;p1$2403-=1;p2$2403=5+p1$2403;p0$2403=-9+p$2403;
     If[(pe$2403=StringPosition["$Input holds the file number for console input stream. The default is -1."[p$2403,-2],";;;"])<=>{}
       ,
      {Max[0,
        -1+ToExpression["$Input holds the file number for console input stream. The default is -1."[p$2403+pe$2403[[1,2]],p1$2403]]
        ],p1$2403=-2+p$2403+pe$2403[[1,1]]}[[
       1]],
      0],
    1,lx$2403:=Help2HTML`o9$;p2$2403=4+p1$2403;p0$2403=-4+p$2403;0];
  If[(equ$2403=Help2HTML`o8$["$Input holds the file number for console input stream. The default is -1."[p$2403,p1$2403]])===
    Undefined,
   equ$2403="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "$Input holds the file number for console input stream. The default is -1."[p$2403,p1$2403]]=
       equ$2403;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$2403},out$2403=lx$2403@Typeset["$Input holds the file number for console input stream. The default is -1."[p$2403,
           p1$2403],Format->Help2HTML`oB$];
        System["mv -f "//out$2403//" "//equ$2403]];
      Exit[]]];
   "$Input holds the file number for console input stream. The default is -1."[1,Max[p0$2403,0]]//"<img  class=\"eqs\" SRC=\""//
   equ$2403//"\" />"//Help2HTML`oy$["$Input holds the file number for console input stream. The default is -1."[p2$2403,-1]]
 ]
</PRE>
<PRE>See also:
 <A HREF=#L428>$Output</A></PRE>
<LI>
<H3><A NAME=L428>
$Output</A></H3>
<PRE>If[{},Help2HTML`oA$["$Output holds the file number for console output. The default is -1."],
 p$2406=1+p$2406[[1,2]];p1$2406=StringPosition["$Output holds the file number for console output. The default is -1."[p$2406,-1],
    ">::",1];
   p1$2406=If[p1$2406==={},68,-2+p$2406+p1$2406[[1,1]]];
  neq=Which["$Output holds the file number for console output. The default is -1."[p$2406,4+p$2406]==="Text[",
    lx$2406:=Help2HTML`oa$;p$2406=5+p$2406;p1$2406-=1;p2$2406=5+p1$2406;p0$2406=-9+p$2406;
     If[(pe$2406=StringPosition["$Output holds the file number for console output. The default is -1."[p$2406,-2],";;;"])<=>{},
      {Max[0,-1+ToExpression["$Output holds the file number for console output. The default is -1."[p$2406+pe$2406[[1,2]],p1$2406]]
        ],p1$2406=-2+p$2406+pe$2406[[1,1]]}[[
       1]],
      0],
    1,lx$2406:=Help2HTML`o9$;p2$2406=4+p1$2406;p0$2406=-4+p$2406;0];
  If[(equ$2406=Help2HTML`o8$["$Output holds the file number for console output. The default is -1."[p$2406,p1$2406]])===Undefined,
   equ$2406="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["$Output holds the file number for console output. The default is -1."[p$2406,p1$2406]]=equ$2406;
      LaTeX`ob$+=neq,
     --LaTeX`ob$;With[{lx$2406},out$2406=lx$2406@Typeset["$Output holds the file number for console output. The default is -1."[p
           $2406,p1$2406],Format->Help2HTML`oB$];
        System["mv -f "//out$2406//" "//equ$2406]];
      Exit[]]];
   "$Output holds the file number for console output. The default is -1."[1,Max[p0$2406,0]]//"<img  class=\"eqs\" SRC=\""//
   equ$2406//"\" />"//Help2HTML`oy$["$Output holds the file number for console output. The default is -1."[p2$2406,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L427>$Input</A></PRE>
<LI>
<H3><A NAME=L429>
Close</A></H3>
<PRE>If[{},
Help2HTML`oA$[" Close[f] closes file number [f]. It is necessary to complete the output to an external file.\n Close[f1, ...] and \
Close[{f1, ...}] close all files f1, ..."],
p$2409=1+p$2409[[1,2]];p1$2409=StringPosition[" Close[f] closes file number [f]. It is necessary to complete the output to an exte\
rnal file.\n Close[f1, ...] and Close[{f1, ...}] close all files f1, ..."[p$2409,-1],">::",1];
   p1$2409=If[p1$2409==={},154,-2+p$2409+p1$2409[[1,1]]];
neq=Which[" Close[f] closes file number [f]. It is necessary to complete the output to an external file.\n Close[f1, ...] and Clos\
e[{f1, ...}] close all files f1, ..."[p$2409,4+p$2409]==="Text[",
    lx$2409:=Help2HTML`oa$;p$2409=5+p$2409;p1$2409-=1;p2$2409=5+p1$2409;p0$2409=-9+p$2409;
If[(pe$2409=StringPosition[" Close[f] closes file number [f]. It is necessary to complete the output to an external file.\n Close[\
f1, ...] and Close[{f1, ...}] close all files f1, ..."[p$2409,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression[" Close[f] closes file number [f]. It is necessary to complete the output to an external file.\n Close[f1, ...] an\
d Close[{f1, ...}] close all files f1, ..."[p$2409+pe$2409[[1,2]],p1$2409]]],
        p1$2409=-2+p$2409+pe$2409[[1,1]]}[[
       1]],
      0],
    1,lx$2409:=Help2HTML`o9$;p2$2409=4+p1$2409;p0$2409=-4+p$2409;0];
  If[(equ$2409=
Help2HTML`o8$[" Close[f] closes file number [f]. It is necessary to complete the output to an external file.\n Close[f1, ...] and \
Close[{f1, ...}] close all files f1, ..."[p$2409,p1$2409]])===
    Undefined,
equ$2409="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[" Close[f] closes file number [f]. It is nece\
ssary to complete the output to an external file.\n Close[f1, ...] and Close[{f1, ...}] close all files f1, ..."[p$2409,p1$2409]]=
       equ$2409;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2409},out$2409=lx$2409@Typeset[" Close[f] closes file number [f]. It is necessary to complete the output to an external f\
ile.\n Close[f1, ...] and Close[{f1, ...}] close all files f1, ..."[p$2409,p1$2409],Format->Help2HTML`oB$];
        System["mv -f "//out$2409//" "//equ$2409]];
      Exit[]]];
   " Close[f] closes file number [f]. It is necessary to complete the output to an external file.\n Close[f1, ...] and Close[{f1, \
...}] close all files f1, ..."[1,Max[p0$2409,0]]//"<img  class=\"eqs\" SRC=\""//equ$2409//"\" />"//
Help2HTML`oy$[" Close[f] closes file number [f]. It is necessary to complete the output to an external file.\n Close[f1, ...] and \
Close[{f1, ...}] close all files f1, ..."[p2$2409,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L431>OpenRead</A> <A HREF=#L432>OpenWrite</A> <A HREF=#L430>OpenAppend</A> <A HREF=#L443>OpenShared</A> <A HREF=#L438>StringToStream</A></PRE>
<LI>
<H3><A NAME=L430>
OpenAppend</A></H3>
<PRE>If[{},Help2HTML`oA$["f = OpenAppend[file]\n\nopens file (_String) for write and returns the file number (_Real)"],
 p$2412=1+p$2412[[1,2]];
  p1$2412=StringPosition["f = OpenAppend[file]\n\nopens file (_String) for write and returns the file number (_Real)"[p$2412,-1],
    ">::",1];
   p1$2412=If[p1$2412==={},88,-2+p$2412+p1$2412[[1,1]]];
  neq=Which["f = OpenAppend[file]\n\nopens file (_String) for write and returns the file number (_Real)"[p$2412,4+p$2412]==="Text["
     ,
    lx$2412:=Help2HTML`oa$;p$2412=5+p$2412;p1$2412-=1;p2$2412=5+p1$2412;p0$2412=-9+p$2412;If[(pe$2412=StringPosition[
         "f = OpenAppend[file]\n\nopens file (_String) for write and returns the file number (_Real)"[p$2412,-2],";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression["f = OpenAppend[file]\n\nopens file (_String) for write and returns the file number (_Real)"[p$2412+pe$2412
            [[1,2]],
           p1$2412]]],
        p1$2412=-2+p$2412+pe$2412[[1,1]]}[[
       1]],
      0],
    1,lx$2412:=Help2HTML`o9$;p2$2412=4+p1$2412;p0$2412=-4+p$2412;0];
  If[(equ$2412=
     Help2HTML`o8$["f = OpenAppend[file]\n\nopens file (_String) for write and returns the file number (_Real)"[p$2412,p1$2412]]
     )===
    Undefined,
   equ$2412="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "f = OpenAppend[file]\n\nopens file (_String) for write and returns the file number (_Real)"[p$2412,p1$2412]]=
       equ$2412;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$2412},out$2412=lx$2412@Typeset[
          "f = OpenAppend[file]\n\nopens file (_String) for write and returns the file number (_Real)"[p$2412,p1$2412],
          Format->Help2HTML`oB$];
        System["mv -f "//out$2412//" "//equ$2412]];
      Exit[]]];
   "f = OpenAppend[file]\n\nopens file (_String) for write and returns the file number (_Real)"[1,Max[p0$2412,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2412//"\" />"//
   Help2HTML`oy$["f = OpenAppend[file]\n\nopens file (_String) for write and returns the file number (_Real)"[p2$2412,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L429>Close</A> <A HREF=#L431>OpenRead</A> <A HREF=#L432>OpenWrite</A></PRE>
<LI>
<H3><A NAME=L431>
OpenRead</A></H3>
<PRE>If[{},Help2HTML`oA$["f = OpenRead[file]\n\nopens file (_String) for read and returns the file number (_Real)"],
 p$2415=1+p$2415[[1,2]];
  p1$2415=StringPosition["f = OpenRead[file]\n\nopens file (_String) for read and returns the file number (_Real)"[p$2415,-1],
    ">::",1];
   p1$2415=If[p1$2415==={},85,-2+p$2415+p1$2415[[1,1]]];
  neq=Which["f = OpenRead[file]\n\nopens file (_String) for read and returns the file number (_Real)"[p$2415,4+p$2415]==="Text[",
    lx$2415:=Help2HTML`oa$;p$2415=5+p$2415;p1$2415-=1;p2$2415=5+p1$2415;p0$2415=-9+p$2415;
     If[(pe$2415=StringPosition["f = OpenRead[file]\n\nopens file (_String) for read and returns the file number (_Real)"[p$2415,-2
          ],
         ";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression["f = OpenRead[file]\n\nopens file (_String) for read and returns the file number (_Real)"[p$2415+pe$2415[[
             1,2]],
           p1$2415]]],
        p1$2415=-2+p$2415+pe$2415[[1,1]]}[[
       1]],
      0],
    1,lx$2415:=Help2HTML`o9$;p2$2415=4+p1$2415;p0$2415=-4+p$2415;0];
  If[(equ$2415=
     Help2HTML`o8$["f = OpenRead[file]\n\nopens file (_String) for read and returns the file number (_Real)"[p$2415,p1$2415]])===
    Undefined,
   equ$2415="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "f = OpenRead[file]\n\nopens file (_String) for read and returns the file number (_Real)"[p$2415,p1$2415]]=
       equ$2415;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$2415},out$2415=lx$2415@Typeset[
          "f = OpenRead[file]\n\nopens file (_String) for read and returns the file number (_Real)"[p$2415,p1$2415],
          Format->Help2HTML`oB$];
        System["mv -f "//out$2415//" "//equ$2415]];
      Exit[]]];
   "f = OpenRead[file]\n\nopens file (_String) for read and returns the file number (_Real)"[1,Max[p0$2415,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2415//"\" />"//
   Help2HTML`oy$["f = OpenRead[file]\n\nopens file (_String) for read and returns the file number (_Real)"[p2$2415,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L429>Close</A> <A HREF=#L432>OpenWrite</A> <A HREF=#L430>OpenAppend</A></PRE>
<LI>
<H3><A NAME=L432>
OpenWrite</A></H3>
<PRE>If[{},Help2HTML`oA$["f = OpenWrite[file]\n\nopens file (_String) for write and returns the file number (_Real)"],
 p$2418=1+p$2418[[1,2]];
  p1$2418=StringPosition["f = OpenWrite[file]\n\nopens file (_String) for write and returns the file number (_Real)"[p$2418,-1],
    ">::",1];
   p1$2418=If[p1$2418==={},87,-2+p$2418+p1$2418[[1,1]]];
  neq=Which["f = OpenWrite[file]\n\nopens file (_String) for write and returns the file number (_Real)"[p$2418,4+p$2418]==="Text[",
    lx$2418:=Help2HTML`oa$;p$2418=5+p$2418;p1$2418-=1;p2$2418=5+p1$2418;p0$2418=-9+p$2418;
     If[(pe$2418=StringPosition["f = OpenWrite[file]\n\nopens file (_String) for write and returns the file number (_Real)"[p$2418,
          -2],
         ";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression["f = OpenWrite[file]\n\nopens file (_String) for write and returns the file number (_Real)"[p$2418+pe$2418
            [[1,2]],
           p1$2418]]],
        p1$2418=-2+p$2418+pe$2418[[1,1]]}[[
       1]],
      0],
    1,lx$2418:=Help2HTML`o9$;p2$2418=4+p1$2418;p0$2418=-4+p$2418;0];
  If[(equ$2418=
     Help2HTML`o8$["f = OpenWrite[file]\n\nopens file (_String) for write and returns the file number (_Real)"[p$2418,p1$2418]])===
    Undefined,
   equ$2418="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "f = OpenWrite[file]\n\nopens file (_String) for write and returns the file number (_Real)"[p$2418,p1$2418]]=
       equ$2418;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$2418},out$2418=lx$2418@Typeset[
          "f = OpenWrite[file]\n\nopens file (_String) for write and returns the file number (_Real)"[p$2418,p1$2418],
          Format->Help2HTML`oB$];
        System["mv -f "//out$2418//" "//equ$2418]];
      Exit[]]];
   "f = OpenWrite[file]\n\nopens file (_String) for write and returns the file number (_Real)"[1,Max[p0$2418,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2418//"\" />"//
   Help2HTML`oy$["f = OpenWrite[file]\n\nopens file (_String) for write and returns the file number (_Real)"[p2$2418,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L429>Close</A> <A HREF=#L431>OpenRead</A> <A HREF=#L430>OpenAppend</A></PRE>
<LI>
<H3><A NAME=L433>
PageWidth</A></H3>
<PRE>If[{},Help2HTML`oA$["PageWidth is the number of columns of the output. The default is set from GetEnv[\"WIDTH\"]."],
 p$2421=1+p$2421[[1,2]];
  p1$2421=StringPosition["PageWidth is the number of columns of the output. The default is set from GetEnv[\"WIDTH\"]."[p$2421,-1],
    ">::",1];
   p1$2421=If[p1$2421==={},90,-2+p$2421+p1$2421[[1,1]]];
  neq=Which["PageWidth is the number of columns of the output. The default is set from GetEnv[\"WIDTH\"]."[p$2421,4+p$2421]===
     "Text[",
    lx$2421:=Help2HTML`oa$;p$2421=5+p$2421;p1$2421-=1;p2$2421=5+p1$2421;p0$2421=-9+p$2421;If[(pe$2421=StringPosition[
         "PageWidth is the number of columns of the output. The default is set from GetEnv[\"WIDTH\"]."[p$2421,-2],";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression["PageWidth is the number of columns of the output. The default is set from GetEnv[\"WIDTH\"]."[p$2421+pe
            $2421[[1,2]],
           p1$2421]]],
        p1$2421=-2+p$2421+pe$2421[[1,1]]}[[
       1]],
      0],
    1,lx$2421:=Help2HTML`o9$;p2$2421=4+p1$2421;p0$2421=-4+p$2421;0];
  If[(equ$2421=
     Help2HTML`o8$["PageWidth is the number of columns of the output. The default is set from GetEnv[\"WIDTH\"]."[p$2421,p1$2421]]
     )===
    Undefined,
   equ$2421="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "PageWidth is the number of columns of the output. The default is set from GetEnv[\"WIDTH\"]."[p$2421,p1$2421]]=
       equ$2421;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$2421},out$2421=lx$2421@Typeset[
          "PageWidth is the number of columns of the output. The default is set from GetEnv[\"WIDTH\"]."[p$2421,p1$2421],
          Format->Help2HTML`oB$];
        System["mv -f "//out$2421//" "//equ$2421]];
      Exit[]]];
   "PageWidth is the number of columns of the output. The default is set from GetEnv[\"WIDTH\"]."[1,Max[p0$2421,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2421//"\" />"//
   Help2HTML`oy$["PageWidth is the number of columns of the output. The default is set from GetEnv[\"WIDTH\"]."[p2$2421,-1]]
 ]
</PRE>
<LI>
<H3><A NAME=L434>
Print</A></H3>
<PRE>If[{},
Help2HTML`oA$["   Print[expr1 [,expr2 ...]]\n\nconverts expr1... to _String then write them to $Output. A newline character is app\
ended at the end."],
p$2423=1+p$2423[[1,2]];p1$2423=StringPosition["   Print[expr1 [,expr2 ...]]\n\nconverts expr1... to _String then write them to $Ou\
tput. A newline character is appended at the end."[p$2423,-1],">::",1];
   p1$2423=If[p1$2423==={},130,-2+p$2423+p1$2423[[1,1]]];
neq=Which["   Print[expr1 [,expr2 ...]]\n\nconverts expr1... to _String then write them to $Output. A newline character is appende\
d at the end."[p$2423,4+p$2423]==="Text[",
    lx$2423:=Help2HTML`oa$;p$2423=5+p$2423;p1$2423-=1;p2$2423=5+p1$2423;p0$2423=-9+p$2423;If[(pe$2423=
StringPosition["   Print[expr1 [,expr2 ...]]\n\nconverts expr1... to _String then write them to $Output. A newline character is ap\
pended at the end."[p$2423,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["   Print[expr1 [,expr2 ...]]\n\nconverts expr1... to _String then write them to $Output. A newline character is a\
ppended at the end."[p$2423+pe$2423[[1,2]],p1$2423]]],
        p1$2423=-2+p$2423+pe$2423[[1,1]]}[[
       1]],
      0],
    1,lx$2423:=Help2HTML`o9$;p2$2423=4+p1$2423;p0$2423=-4+p$2423;0];
  If[(equ$2423=
Help2HTML`o8$["   Print[expr1 [,expr2 ...]]\n\nconverts expr1... to _String then write them to $Output. A newline character is app\
ended at the end."[p$2423,p1$2423]])===
    Undefined,
equ$2423="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["   Print[expr1 [,expr2 ...]]\n\nconverts exp\
r1... to _String then write them to $Output. A newline character is appended at the end."[p$2423,p1$2423]]=
       equ$2423;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2423},out$2423=lx$2423@Typeset["   Print[expr1 [,expr2 ...]]\n\nconverts expr1... to _String then write them to $Output. \
A newline character is appended at the end."[p$2423,p1$2423],Format->Help2HTML`oB$];
        System["mv -f "//out$2423//" "//equ$2423]];
      Exit[]]];
   "   Print[expr1 [,expr2 ...]]\n\nconverts expr1... to _String then write them to $Output. A newline character is appended at th\
e end."[1,Max[p0$2423,0]]//"<img  class=\"eqs\" SRC=\""//equ$2423//"\" />"//
Help2HTML`oy$["   Print[expr1 [,expr2 ...]]\n\nconverts expr1... to _String then write them to $Output. A newline character is app\
ended at the end."[p2$2423,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L439>Write</A> <A HREF=#L440>WriteString</A></PRE>
<LI>
<H3><A NAME=L435>
Read</A></H3>
<PRE>If[{},
Help2HTML`oA$["Read[f, item [, item1...] [, opts..]]\n\nreads item from file number f. If f is $Input, it reads from the current i\
nput stream. item can be one of or a list of:\nWord        a word, delimited by WordSeparators\nReal        a real expression\nExp\
ression  an expression\nCharacter   a single character\n\n A format n*item is possible with a positive integer n.\n A list {item1,\
.., itemn} is possible. The result is also a list.\n\n opts are options given by a Rule:\nOption         Value       Default    Ef\
fect\nWordSeparator  _String     \" ,\\t\"     the delimiters for Word\nReadNewRecord  True/False  True       If true, read the ne\
xt record of the file beyond the end of line\nNullWords      True/False  False      If True, \"\" is returned when the input conta\
ins adjavent word separators"],
p$2426=1+p$2426[[1,2]];p1$2426=StringPosition["Read[f, item [, item1...] [, opts..]]\n\nreads item from file number f. If f is $In\
put, it reads from the current input stream. item can be one of or a list of:\nWord        a word, delimited by WordSeparators\nRe\
al        a real expression\nExpression  an expression\nCharacter   a single character\n\n A format n*item is possible with a posi\
tive integer n.\n A list {item1,.., itemn} is possible. The result is also a list.\n\n opts are options given by a Rule:\nOption  \
       Value       Default    Effect\nWordSeparator  _String     \" ,\\t\"     the delimiters for Word\nReadNewRecord  True/False \
 True       If true, read the next record of the file beyond the end of line\nNullWords      True/False  False      If True, \"\" \
is returned when the input contains adjavent word separators"[p$2426,-1],">::",1];
   p1$2426=If[p1$2426==={},773,-2+p$2426+p1$2426[[1,1]]];
neq=Which["Read[f, item [, item1...] [, opts..]]\n\nreads item from file number f. If f is $Input, it reads from the current input\
 stream. item can be one of or a list of:\nWord        a word, delimited by WordSeparators\nReal        a real expression\nExpress\
ion  an expression\nCharacter   a single character\n\n A format n*item is possible with a positive integer n.\n A list {item1,.., \
itemn} is possible. The result is also a list.\n\n opts are options given by a Rule:\nOption         Value       Default    Effect\
\nWordSeparator  _String     \" ,\\t\"     the delimiters for Word\nReadNewRecord  True/False  True       If true, read the next r\
ecord of the file beyond the end of line\nNullWords      True/False  False      If True, \"\" is returned when the input contains \
adjavent word separators"[p$2426,4+p$2426]==="Text[",
    lx$2426:=Help2HTML`oa$;p$2426=5+p$2426;p1$2426-=1;p2$2426=5+p1$2426;p0$2426=-9+p$2426;
If[(pe$2426=StringPosition["Read[f, item [, item1...] [, opts..]]\n\nreads item from file number f. If f is $Input, it reads from \
the current input stream. item can be one of or a list of:\nWord        a word, delimited by WordSeparators\nReal        a real ex\
pression\nExpression  an expression\nCharacter   a single character\n\n A format n*item is possible with a positive integer n.\n A\
 list {item1,.., itemn} is possible. The result is also a list.\n\n opts are options given by a Rule:\nOption         Value       \
Default    Effect\nWordSeparator  _String     \" ,\\t\"     the delimiters for Word\nReadNewRecord  True/False  True       If true\
, read the next record of the file beyond the end of line\nNullWords      True/False  False      If True, \"\" is returned when th\
e input contains adjavent word separators"[p$2426,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Read[f, item [, item1...] [, opts..]]\n\nreads item from file number f. If f is $Input, it reads from the current\
 input stream. item can be one of or a list of:\nWord        a word, delimited by WordSeparators\nReal        a real expression\nE\
xpression  an expression\nCharacter   a single character\n\n A format n*item is possible with a positive integer n.\n A list {item\
1,.., itemn} is possible. The result is also a list.\n\n opts are options given by a Rule:\nOption         Value       Default    \
Effect\nWordSeparator  _String     \" ,\\t\"     the delimiters for Word\nReadNewRecord  True/False  True       If true, read the \
next record of the file beyond the end of line\nNullWords      True/False  False      If True, \"\" is returned when the input con\
tains adjavent word separators"[p$2426+pe$2426[[1,2]],p1$2426]]],
        p1$2426=-2+p$2426+pe$2426[[1,1]]}[[
       1]],
      0],
    1,lx$2426:=Help2HTML`o9$;p2$2426=4+p1$2426;p0$2426=-4+p$2426;0];
  If[(equ$2426=
Help2HTML`o8$["Read[f, item [, item1...] [, opts..]]\n\nreads item from file number f. If f is $Input, it reads from the current i\
nput stream. item can be one of or a list of:\nWord        a word, delimited by WordSeparators\nReal        a real expression\nExp\
ression  an expression\nCharacter   a single character\n\n A format n*item is possible with a positive integer n.\n A list {item1,\
.., itemn} is possible. The result is also a list.\n\n opts are options given by a Rule:\nOption         Value       Default    Ef\
fect\nWordSeparator  _String     \" ,\\t\"     the delimiters for Word\nReadNewRecord  True/False  True       If true, read the ne\
xt record of the file beyond the end of line\nNullWords      True/False  False      If True, \"\" is returned when the input conta\
ins adjavent word separators"[p$2426,p1$2426]])===
    Undefined,
equ$2426="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Read[f, item [, item1...] [, opts..]]\n\nrea\
ds item from file number f. If f is $Input, it reads from the current input stream. item can be one of or a list of:\nWord        \
a word, delimited by WordSeparators\nReal        a real expression\nExpression  an expression\nCharacter   a single character\n\n \
A format n*item is possible with a positive integer n.\n A list {item1,.., itemn} is possible. The result is also a list.\n\n opts\
 are options given by a Rule:\nOption         Value       Default    Effect\nWordSeparator  _String     \" ,\\t\"     the delimite\
rs for Word\nReadNewRecord  True/False  True       If true, read the next record of the file beyond the end of line\nNullWords    \
  True/False  False      If True, \"\" is returned when the input contains adjavent word separators"[p$2426,p1$2426]]=
       equ$2426;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2426},out$2426=lx$2426@Typeset["Read[f, item [, item1...] [, opts..]]\n\nreads item from file number f. If f is $Input, i\
t reads from the current input stream. item can be one of or a list of:\nWord        a word, delimited by WordSeparators\nReal    \
    a real expression\nExpression  an expression\nCharacter   a single character\n\n A format n*item is possible with a positive i\
nteger n.\n A list {item1,.., itemn} is possible. The result is also a list.\n\n opts are options given by a Rule:\nOption        \
 Value       Default    Effect\nWordSeparator  _String     \" ,\\t\"     the delimiters for Word\nReadNewRecord  True/False  True \
      If true, read the next record of the file beyond the end of line\nNullWords      True/False  False      If True, \"\" is ret\
urned when the input contains adjavent word separators"[p$2426,p1$2426],Format->Help2HTML`oB$];
        System["mv -f "//out$2426//" "//equ$2426]];
      Exit[]]];
   "Read[f, item [, item1...] [, opts..]]\n\nreads item from file number f. If f is $Input, it reads from the current input stream\
. item can be one of or a list of:\nWord        a word, delimited by WordSeparators\nReal        a real expression\nExpression  an\
 expression\nCharacter   a single character\n\n A format n*item is possible with a positive integer n.\n A list {item1,.., itemn} \
is possible. The result is also a list.\n\n opts are options given by a Rule:\nOption         Value       Default    Effect\nWordS\
eparator  _String     \" ,\\t\"     the delimiters for Word\nReadNewRecord  True/False  True       If true, read the next record o\
f the file beyond the end of line\nNullWords      True/False  False      If True, \"\" is returned when the input contains adjaven\
t word separators"[1,Max[p0$2426,0]]//"<img  class=\"eqs\" SRC=\""//equ$2426//"\" />"//
Help2HTML`oy$["Read[f, item [, item1...] [, opts..]]\n\nreads item from file number f. If f is $Input, it reads from the current i\
nput stream. item can be one of or a list of:\nWord        a word, delimited by WordSeparators\nReal        a real expression\nExp\
ression  an expression\nCharacter   a single character\n\n A format n*item is possible with a positive integer n.\n A list {item1,\
.., itemn} is possible. The result is also a list.\n\n opts are options given by a Rule:\nOption         Value       Default    Ef\
fect\nWordSeparator  _String     \" ,\\t\"     the delimiters for Word\nReadNewRecord  True/False  True       If true, read the ne\
xt record of the file beyond the end of line\nNullWords      True/False  False      If True, \"\" is returned when the input conta\
ins adjavent word separators"[p2$2426,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L431>OpenRead</A> <A HREF=#L429>Close</A></PRE>
<LI>
<H3><A NAME=L436>
ReadString</A></H3>
<PRE>If[{},Help2HTML`oA$["ReadString[f]\n\nreads the next record from file number f, and returns it as a _String."],
 p$2429=1+p$2429[[1,2]];
  p1$2429=StringPosition["ReadString[f]\n\nreads the next record from file number f, and returns it as a _String."[p$2429,-1],
    ">::",1];
   p1$2429=If[p1$2429==={},85,-2+p$2429+p1$2429[[1,1]]];
  neq=Which["ReadString[f]\n\nreads the next record from file number f, and returns it as a _String."[p$2429,4+p$2429]==="Text[",
    lx$2429:=Help2HTML`oa$;p$2429=5+p$2429;p1$2429-=1;p2$2429=5+p1$2429;p0$2429=-9+p$2429;
     If[(pe$2429=StringPosition["ReadString[f]\n\nreads the next record from file number f, and returns it as a _String."[p$2429,-2
          ],
         ";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression["ReadString[f]\n\nreads the next record from file number f, and returns it as a _String."[p$2429+pe$2429[[
             1,2]],
           p1$2429]]],
        p1$2429=-2+p$2429+pe$2429[[1,1]]}[[
       1]],
      0],
    1,lx$2429:=Help2HTML`o9$;p2$2429=4+p1$2429;p0$2429=-4+p$2429;0];
  If[(equ$2429=
     Help2HTML`o8$["ReadString[f]\n\nreads the next record from file number f, and returns it as a _String."[p$2429,p1$2429]])===
    Undefined,
   equ$2429="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "ReadString[f]\n\nreads the next record from file number f, and returns it as a _String."[p$2429,p1$2429]]=
       equ$2429;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$2429},out$2429=lx$2429@Typeset[
          "ReadString[f]\n\nreads the next record from file number f, and returns it as a _String."[p$2429,p1$2429],
          Format->Help2HTML`oB$];
        System["mv -f "//out$2429//" "//equ$2429]];
      Exit[]]];
   "ReadString[f]\n\nreads the next record from file number f, and returns it as a _String."[1,Max[p0$2429,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2429//"\" />"//
   Help2HTML`oy$["ReadString[f]\n\nreads the next record from file number f, and returns it as a _String."[p2$2429,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L435>Read</A> <A HREF=#L431>OpenRead</A> <A HREF=#L429>Close</A></PRE>
<LI>
<H3><A NAME=L437>
StandardForm</A></H3>
<PRE>If[{},
Help2HTML`oA$["StandardForm[expr]\n\nresets $FORM and PageWidth to their defaults, then evaluate expr, returns the result, and res\
ets $FORM and PageWidth to those at the beginning of StandardForm."],
p$2432=1+p$2432[[1,2]];p1$2432=StringPosition["StandardForm[expr]\n\nresets $FORM and PageWidth to their defaults, then evaluate e\
xpr, returns the result, and resets $FORM and PageWidth to those at the beginning of StandardForm."[p$2432,-1],">::",1];
   p1$2432=If[p1$2432==={},179,-2+p$2432+p1$2432[[1,1]]];
neq=Which["StandardForm[expr]\n\nresets $FORM and PageWidth to their defaults, then evaluate expr, returns the result, and resets \
$FORM and PageWidth to those at the beginning of StandardForm."[p$2432,4+p$2432]==="Text[",
    lx$2432:=Help2HTML`oa$;p$2432=5+p$2432;p1$2432-=1;p2$2432=5+p1$2432;p0$2432=-9+p$2432;
If[(pe$2432=StringPosition["StandardForm[expr]\n\nresets $FORM and PageWidth to their defaults, then evaluate expr, returns the re\
sult, and resets $FORM and PageWidth to those at the beginning of StandardForm."[p$2432,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["StandardForm[expr]\n\nresets $FORM and PageWidth to their defaults, then evaluate expr, returns the result, and r\
esets $FORM and PageWidth to those at the beginning of StandardForm."[p$2432+pe$2432[[1,2]],p1$2432]]],
        p1$2432=-2+p$2432+pe$2432[[1,1]]}[[
       1]],
      0],
    1,lx$2432:=Help2HTML`o9$;p2$2432=4+p1$2432;p0$2432=-4+p$2432;0];
  If[(equ$2432=
Help2HTML`o8$["StandardForm[expr]\n\nresets $FORM and PageWidth to their defaults, then evaluate expr, returns the result, and res\
ets $FORM and PageWidth to those at the beginning of StandardForm."[p$2432,p1$2432]])===
    Undefined,
equ$2432="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["StandardForm[expr]\n\nresets $FORM and PageW\
idth to their defaults, then evaluate expr, returns the result, and resets $FORM and PageWidth to those at the beginning of Standa\
rdForm."[p$2432,p1$2432]]=
       equ$2432;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2432},out$2432=lx$2432@Typeset["StandardForm[expr]\n\nresets $FORM and PageWidth to their defaults, then evaluate expr, r\
eturns the result, and resets $FORM and PageWidth to those at the beginning of StandardForm."[p$2432,p1$2432],
          Format->Help2HTML`oB$];
        System["mv -f "//out$2432//" "//equ$2432]];
      Exit[]]];
   "StandardForm[expr]\n\nresets $FORM and PageWidth to their defaults, then evaluate expr, returns the result, and resets $FORM a\
nd PageWidth to those at the beginning of StandardForm."[1,Max[p0$2432,0]]//"<img  class=\"eqs\" SRC=\""//equ$2432//"\" />"//
   Help2HTML`oy$["StandardForm[expr]\n\nresets $FORM and PageWidth to their defaults, then evaluate expr, returns the result, and \
resets $FORM and PageWidth to those at the beginning of StandardForm."[p2$2432,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L426>$FORM</A> <A HREF=#L433>PageWidth</A></PRE>
<LI>
<H3><A NAME=L438>
StringToStream</A></H3>
<PRE>If[{},Help2HTML`oA$["f = StringToStream[string]\n\nopens a character string for read and returns the file number (_Real)"],
 p$2435=1+p$2435[[1,2]];
  p1$2435=StringPosition["f = StringToStream[string]\n\nopens a character string for read and returns the file number (_Real)"[p
     $2435,-1],
    ">::",1];
   p1$2435=If[p1$2435==={},97,-2+p$2435+p1$2435[[1,1]]];
  neq=Which["f = StringToStream[string]\n\nopens a character string for read and returns the file number (_Real)"[p$2435,4+p$2435
      ]===
     "Text[",
    lx$2435:=Help2HTML`oa$;p$2435=5+p$2435;p1$2435-=1;p2$2435=5+p1$2435;p0$2435=-9+p$2435;If[(pe$2435=StringPosition[
         "f = StringToStream[string]\n\nopens a character string for read and returns the file number (_Real)"[p$2435,-2],";;;"]
        )<=>
       {},
      {Max[0,
        -1+ToExpression["f = StringToStream[string]\n\nopens a character string for read and returns the file number (_Real)"[p
            $2435+pe$2435[[1,2]],
           p1$2435]]],
        p1$2435=-2+p$2435+pe$2435[[1,1]]}[[
       1]],
      0],
    1,lx$2435:=Help2HTML`o9$;p2$2435=4+p1$2435;p0$2435=-4+p$2435;0];
  If[(equ$2435=
     Help2HTML`o8$["f = StringToStream[string]\n\nopens a character string for read and returns the file number (_Real)"[p$2435,
       p1$2435]])===
    Undefined,
   equ$2435="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "f = StringToStream[string]\n\nopens a character string for read and returns the file number (_Real)"[p$2435,p1$2435]]=
       equ$2435;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$2435},out$2435=lx$2435@Typeset[
          "f = StringToStream[string]\n\nopens a character string for read and returns the file number (_Real)"[p$2435,p1$2435],
          Format->Help2HTML`oB$];
        System["mv -f "//out$2435//" "//equ$2435]];
      Exit[]]];
   "f = StringToStream[string]\n\nopens a character string for read and returns the file number (_Real)"[1,Max[p0$2435,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2435//"\" />"//
   Help2HTML`oy$["f = StringToStream[string]\n\nopens a character string for read and returns the file number (_Real)"[p2$2435,-1]]
 ]
</PRE>
<PRE>See also:
 <A HREF=#L429>Close</A></PRE>
<LI>
<H3><A NAME=L439>
Write</A></H3>
<PRE>If[{},
Help2HTML`oA$["   Write[f, expr1 [,expr2 ...]]\n\nconverts expr1... to _String then write them to file number f. A newline charact\
er is appended at the end."],
p$2438=1+p$2438[[1,2]];p1$2438=StringPosition["   Write[f, expr1 [,expr2 ...]]\n\nconverts expr1... to _String then write them to \
file number f. A newline character is appended at the end."[p$2438,-1],">::",1];
   p1$2438=If[p1$2438==={},139,-2+p$2438+p1$2438[[1,1]]];
neq=Which["   Write[f, expr1 [,expr2 ...]]\n\nconverts expr1... to _String then write them to file number f. A newline character i\
s appended at the end."[p$2438,4+p$2438]==="Text[",
    lx$2438:=Help2HTML`oa$;p$2438=5+p$2438;p1$2438-=1;p2$2438=5+p1$2438;p0$2438=-9+p$2438;
If[(pe$2438=StringPosition["   Write[f, expr1 [,expr2 ...]]\n\nconverts expr1... to _String then write them to file number f. A ne\
wline character is appended at the end."[p$2438,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["   Write[f, expr1 [,expr2 ...]]\n\nconverts expr1... to _String then write them to file number f. A newline chara\
cter is appended at the end."[p$2438+pe$2438[[1,2]],p1$2438]]],
        p1$2438=-2+p$2438+pe$2438[[1,1]]}[[
       1]],
      0],
    1,lx$2438:=Help2HTML`o9$;p2$2438=4+p1$2438;p0$2438=-4+p$2438;0];
  If[(equ$2438=
Help2HTML`o8$["   Write[f, expr1 [,expr2 ...]]\n\nconverts expr1... to _String then write them to file number f. A newline charact\
er is appended at the end."[p$2438,p1$2438]])===
    Undefined,
equ$2438="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["   Write[f, expr1 [,expr2 ...]]\n\nconverts \
expr1... to _String then write them to file number f. A newline character is appended at the end."[p$2438,p1$2438]]=
       equ$2438;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2438},out$2438=lx$2438@Typeset["   Write[f, expr1 [,expr2 ...]]\n\nconverts expr1... to _String then write them to file n\
umber f. A newline character is appended at the end."[p$2438,p1$2438],Format->Help2HTML`oB$];
        System["mv -f "//out$2438//" "//equ$2438]];
      Exit[]]];
   "   Write[f, expr1 [,expr2 ...]]\n\nconverts expr1... to _String then write them to file number f. A newline character is appen\
ded at the end."[1,Max[p0$2438,0]]//"<img  class=\"eqs\" SRC=\""//equ$2438//"\" />"//
Help2HTML`oy$["   Write[f, expr1 [,expr2 ...]]\n\nconverts expr1... to _String then write them to file number f. A newline charact\
er is appended at the end."[p2$2438,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L440>WriteString</A> <A HREF=#L434>Print</A> <A HREF=#L432>OpenWrite</A> <A HREF=#L430>OpenAppend</A> <A HREF=#L429>Close</A> <A HREF=#L426>$FORM</A> <A HREF=#L433>PageWidth</A> <A HREF=#L437>StandardForm</A></PRE>
<LI>
<H3><A NAME=L440>
WriteString</A></H3>
<PRE>If[{},
Help2HTML`oA$["WriteString[f, expr1 [,expr2 ...]]\n\nconverts expr1... to _String then write them to file number f. No newline cha\
racter is appended."],
p$2441=1+p$2441[[1,2]];p1$2441=StringPosition["WriteString[f, expr1 [,expr2 ...]]\n\nconverts expr1... to _String then write them \
to file number f. No newline character is appended."[p$2441,-1],">::",1];
   p1$2441=If[p1$2441==={},132,-2+p$2441+p1$2441[[1,1]]];
neq=Which["WriteString[f, expr1 [,expr2 ...]]\n\nconverts expr1... to _String then write them to file number f. No newline charact\
er is appended."[p$2441,4+p$2441]==="Text[",
    lx$2441:=Help2HTML`oa$;p$2441=5+p$2441;p1$2441-=1;p2$2441=5+p1$2441;p0$2441=-9+p$2441;If[(pe$2441=
StringPosition["WriteString[f, expr1 [,expr2 ...]]\n\nconverts expr1... to _String then write them to file number f. No newline ch\
aracter is appended."[p$2441,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["WriteString[f, expr1 [,expr2 ...]]\n\nconverts expr1... to _String then write them to file number f. No newline c\
haracter is appended."[p$2441+pe$2441[[1,2]],p1$2441]]],
        p1$2441=-2+p$2441+pe$2441[[1,1]]}[[
       1]],
      0],
    1,lx$2441:=Help2HTML`o9$;p2$2441=4+p1$2441;p0$2441=-4+p$2441;0];
  If[(equ$2441=
Help2HTML`o8$["WriteString[f, expr1 [,expr2 ...]]\n\nconverts expr1... to _String then write them to file number f. No newline cha\
racter is appended."[p$2441,p1$2441]])===
    Undefined,
equ$2441="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["WriteString[f, expr1 [,expr2 ...]]\n\nconver\
ts expr1... to _String then write them to file number f. No newline character is appended."[p$2441,p1$2441]]=
       equ$2441;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2441},out$2441=lx$2441@Typeset["WriteString[f, expr1 [,expr2 ...]]\n\nconverts expr1... to _String then write them to fil\
e number f. No newline character is appended."[p$2441,p1$2441],Format->Help2HTML`oB$];
        System["mv -f "//out$2441//" "//equ$2441]];
      Exit[]]];
   "WriteString[f, expr1 [,expr2 ...]]\n\nconverts expr1... to _String then write them to file number f. No newline character is a\
ppended."[1,Max[p0$2441,0]]//"<img  class=\"eqs\" SRC=\""//equ$2441//"\" />"//
Help2HTML`oy$["WriteString[f, expr1 [,expr2 ...]]\n\nconverts expr1... to _String then write them to file number f. No newline cha\
racter is appended."[p2$2441,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L439>Write</A> <A HREF=#L432>OpenWrite</A> <A HREF=#L430>OpenAppend</A> <A HREF=#L429>Close</A> <A HREF=#L426>$FORM</A> <A HREF=#L433>PageWidth</A> <A HREF=#L437>StandardForm</A></PRE>
</UL>
<LI>
<H3><A NAME=L441>
Multiprocessing</A></H3>
<PRE>
</PRE>
<UL>
<LI>
<H3><A NAME=L442>
Fork</A></H3>
<PRE>If[{},
Help2HTML`oA$["Forks the process into a parent and a child processes.\n\n   Fork[]\n\nreturns 0 and the child's pid for the child \
and the parent, respectively."],
p$2445=1+p$2445[[1,2]];p1$2445=StringPosition["Forks the process into a parent and a child processes.\n\n   Fork[]\n\nreturns 0 an\
d the child's pid for the child and the parent, respectively."[p$2445,-1],">::",1];
   p1$2445=If[p1$2445==={},140,-2+p$2445+p1$2445[[1,1]]];
neq=Which["Forks the process into a parent and a child processes.\n\n   Fork[]\n\nreturns 0 and the child's pid for the child and \
the parent, respectively."[p$2445,4+p$2445]==="Text[",
    lx$2445:=Help2HTML`oa$;p$2445=5+p$2445;p1$2445-=1;p2$2445=5+p1$2445;p0$2445=-9+p$2445;
If[(pe$2445=StringPosition["Forks the process into a parent and a child processes.\n\n   Fork[]\n\nreturns 0 and the child's pid f\
or the child and the parent, respectively."[p$2445,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Forks the process into a parent and a child processes.\n\n   Fork[]\n\nreturns 0 and the child's pid for the chil\
d and the parent, respectively."[p$2445+pe$2445[[1,2]],p1$2445]]],
        p1$2445=-2+p$2445+pe$2445[[1,1]]}[[
       1]],
      0],
    1,lx$2445:=Help2HTML`o9$;p2$2445=4+p1$2445;p0$2445=-4+p$2445;0];
  If[(equ$2445=
Help2HTML`o8$["Forks the process into a parent and a child processes.\n\n   Fork[]\n\nreturns 0 and the child's pid for the child \
and the parent, respectively."[p$2445,p1$2445]])===
    Undefined,
equ$2445="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Forks the process into a parent and a child \
processes.\n\n   Fork[]\n\nreturns 0 and the child's pid for the child and the parent, respectively."[p$2445,p1$2445]]=
       equ$2445;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2445},out$2445=lx$2445@Typeset["Forks the process into a parent and a child processes.\n\n   Fork[]\n\nreturns 0 and the \
child's pid for the child and the parent, respectively."[p$2445,p1$2445],Format->Help2HTML`oB$];
        System["mv -f "//out$2445//" "//equ$2445]];
      Exit[]]];
   "Forks the process into a parent and a child processes.\n\n   Fork[]\n\nreturns 0 and the child's pid for the child and the par\
ent, respectively."[1,Max[p0$2445,0]]//"<img  class=\"eqs\" SRC=\""//equ$2445//"\" />"//
Help2HTML`oy$["Forks the process into a parent and a child processes.\n\n   Fork[]\n\nreturns 0 and the child's pid for the child \
and the parent, respectively."[p2$2445,-1]]
]</PRE>
<LI>
<H3><A NAME=L443>
OpenShared</A></H3>
<PRE>If[{},
Help2HTML`oA$["Allocated shared memory of n bytes.\n\n   s = OpenShared[n] ,\n\nwhere s is a file number to be used by Shared func\
tion. The allocated memory can be released by Close[s]."],
p$2447=1+p$2447[[1,2]];p1$2447=StringPosition["Allocated shared memory of n bytes.\n\n   s = OpenShared[n] ,\n\nwhere s is a file \
number to be used by Shared function. The allocated memory can be released by Close[s]."[p$2447,-1],">::",1];
   p1$2447=If[p1$2447==={},166,-2+p$2447+p1$2447[[1,1]]];
neq=Which["Allocated shared memory of n bytes.\n\n   s = OpenShared[n] ,\n\nwhere s is a file number to be used by Shared function\
. The allocated memory can be released by Close[s]."[p$2447,4+p$2447]==="Text[",
    lx$2447:=Help2HTML`oa$;p$2447=5+p$2447;p1$2447-=1;p2$2447=5+p1$2447;p0$2447=-9+p$2447;
If[(pe$2447=StringPosition["Allocated shared memory of n bytes.\n\n   s = OpenShared[n] ,\n\nwhere s is a file number to be used b\
y Shared function. The allocated memory can be released by Close[s]."[p$2447,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Allocated shared memory of n bytes.\n\n   s = OpenShared[n] ,\n\nwhere s is a file number to be used by Shared fu\
nction. The allocated memory can be released by Close[s]."[p$2447+pe$2447[[1,2]],p1$2447]]],
        p1$2447=-2+p$2447+pe$2447[[1,1]]}[[
       1]],
      0],
    1,lx$2447:=Help2HTML`o9$;p2$2447=4+p1$2447;p0$2447=-4+p$2447;0];
  If[(equ$2447=
Help2HTML`o8$["Allocated shared memory of n bytes.\n\n   s = OpenShared[n] ,\n\nwhere s is a file number to be used by Shared func\
tion. The allocated memory can be released by Close[s]."[p$2447,p1$2447]])===
    Undefined,
equ$2447="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Allocated shared memory of n bytes.\n\n   s \
= OpenShared[n] ,\n\nwhere s is a file number to be used by Shared function. The allocated memory can be released by Close[s]."[p
         $2447,p1$2447]]=
       equ$2447;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2447},out$2447=lx$2447@Typeset["Allocated shared memory of n bytes.\n\n   s = OpenShared[n] ,\n\nwhere s is a file number\
 to be used by Shared function. The allocated memory can be released by Close[s]."[p$2447,p1$2447],Format->Help2HTML`oB$];
        System["mv -f "//out$2447//" "//equ$2447]];
      Exit[]]];
   "Allocated shared memory of n bytes.\n\n   s = OpenShared[n] ,\n\nwhere s is a file number to be used by Shared function. The a\
llocated memory can be released by Close[s]."[1,Max[p0$2447,0]]//"<img  class=\"eqs\" SRC=\""//equ$2447//"\" />"//
Help2HTML`oy$["Allocated shared memory of n bytes.\n\n   s = OpenShared[n] ,\n\nwhere s is a file number to be used by Shared func\
tion. The allocated memory can be released by Close[s]."[p2$2447,-1]]
]</PRE>
<LI>
<H3><A NAME=L444>
Shared</A></H3>
<PRE>If[{},
Help2HTML`oA$["Read/Write to the shared memory.\n\n   Shared[s]\n   Shared[s] = x\n   Shared[s] := x\n\nwhere s is given by OpenSh\
ared, and x is Real, built-in function, String, defined symbol, or list of them."],
p$2449=1+p$2449[[1,2]];p1$2449=StringPosition["Read/Write to the shared memory.\n\n   Shared[s]\n   Shared[s] = x\n   Shared[s] :=\
 x\n\nwhere s is given by OpenShared, and x is Real, built-in function, String, defined symbol, or list of them."[p$2449,-1],">::",
    1];
   p1$2449=If[p1$2449==={},189,-2+p$2449+p1$2449[[1,1]]];
neq=Which["Read/Write to the shared memory.\n\n   Shared[s]\n   Shared[s] = x\n   Shared[s] := x\n\nwhere s is given by OpenShared\
, and x is Real, built-in function, String, defined symbol, or list of them."[p$2449,4+p$2449]==="Text[",
    lx$2449:=Help2HTML`oa$;p$2449=5+p$2449;p1$2449-=1;p2$2449=5+p1$2449;p0$2449=-9+p$2449;
If[(pe$2449=StringPosition["Read/Write to the shared memory.\n\n   Shared[s]\n   Shared[s] = x\n   Shared[s] := x\n\nwhere s is gi\
ven by OpenShared, and x is Real, built-in function, String, defined symbol, or list of them."[p$2449,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Read/Write to the shared memory.\n\n   Shared[s]\n   Shared[s] = x\n   Shared[s] := x\n\nwhere s is given by Open\
Shared, and x is Real, built-in function, String, defined symbol, or list of them."[p$2449+pe$2449[[1,2]],p1$2449]]],
        p1$2449=-2+p$2449+pe$2449[[1,1]]}[[
       1]],
      0],
    1,lx$2449:=Help2HTML`o9$;p2$2449=4+p1$2449;p0$2449=-4+p$2449;0];
  If[(equ$2449=
Help2HTML`o8$["Read/Write to the shared memory.\n\n   Shared[s]\n   Shared[s] = x\n   Shared[s] := x\n\nwhere s is given by OpenSh\
ared, and x is Real, built-in function, String, defined symbol, or list of them."[p$2449,p1$2449]])===
    Undefined,
equ$2449="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Read/Write to the shared memory.\n\n   Share\
d[s]\n   Shared[s] = x\n   Shared[s] := x\n\nwhere s is given by OpenShared, and x is Real, built-in function, String, defined sym\
bol, or list of them."[p$2449,p1$2449]]=
       equ$2449;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2449},out$2449=lx$2449@Typeset["Read/Write to the shared memory.\n\n   Shared[s]\n   Shared[s] = x\n   Shared[s] := x\n\n\
where s is given by OpenShared, and x is Real, built-in function, String, defined symbol, or list of them."[p$2449,p1$2449],
          Format->Help2HTML`oB$];
        System["mv -f "//out$2449//" "//equ$2449]];
      Exit[]]];
   "Read/Write to the shared memory.\n\n   Shared[s]\n   Shared[s] = x\n   Shared[s] := x\n\nwhere s is given by OpenShared, and x\
 is Real, built-in function, String, defined symbol, or list of them."[1,Max[p0$2449,0]]//"<img  class=\"eqs\" SRC=\""//equ$2449//
   "\" />"//
Help2HTML`oy$["Read/Write to the shared memory.\n\n   Shared[s]\n   Shared[s] = x\n   Shared[s] := x\n\nwhere s is given by OpenSh\
ared, and x is Real, built-in function, String, defined symbol, or list of them."[p2$2449,-1]]
]</PRE>
<LI>
<H3><A NAME=L445>
SharedSize</A></H3>
<PRE>If[{},Help2HTML`oA$["Returns the size of an object for OpenShared.\n\n   n = SharedSize[x] "],
 p$2451=1+p$2451[[1,2]];p1$2451=StringPosition["Returns the size of an object for OpenShared.\n\n   n = SharedSize[x] "[p$2451,-1],
    ">::",1];
   p1$2451=If[p1$2451==={},68,-2+p$2451+p1$2451[[1,1]]];
  neq=Which["Returns the size of an object for OpenShared.\n\n   n = SharedSize[x] "[p$2451,4+p$2451]==="Text[",
    lx$2451:=Help2HTML`oa$;p$2451=5+p$2451;p1$2451-=1;p2$2451=5+p1$2451;p0$2451=-9+p$2451;
     If[(pe$2451=StringPosition["Returns the size of an object for OpenShared.\n\n   n = SharedSize[x] "[p$2451,-2],";;;"])<=>{},
      {Max[0,
        -1+ToExpression["Returns the size of an object for OpenShared.\n\n   n = SharedSize[x] "[p$2451+pe$2451[[1,2]],p1$2451]]],
       p1$2451=-2+p$2451+pe$2451[[1,1]]}[[1]],
      0],
    1,lx$2451:=Help2HTML`o9$;p2$2451=4+p1$2451;p0$2451=-4+p$2451;0];
  If[(equ$2451=Help2HTML`o8$["Returns the size of an object for OpenShared.\n\n   n = SharedSize[x] "[p$2451,p1$2451]])===
    Undefined,
   equ$2451="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "Returns the size of an object for OpenShared.\n\n   n = SharedSize[x] "[p$2451,p1$2451]]=
       equ$2451;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$2451},out$2451=lx$2451@Typeset["Returns the size of an object for OpenShared.\n\n   n = SharedSize[x] "[p$2451,
           p1$2451],Format->Help2HTML`oB$];
        System["mv -f "//out$2451//" "//equ$2451]];
      Exit[]]];
   "Returns the size of an object for OpenShared.\n\n   n = SharedSize[x] "[1,Max[p0$2451,0]]//"<img  class=\"eqs\" SRC=\""//
   equ$2451//"\" />"//Help2HTML`oy$["Returns the size of an object for OpenShared.\n\n   n = SharedSize[x] "[p2$2451,-1]]
]</PRE>
</UL>
<LI>
<H3><A NAME=L446>
Object-oriented-programing</A></H3>
<PRE>If[{},
Help2HTML`oA$["Environment for an object-oriented-programming is supplied by:\n\nClass:          The function to define a class.\n\
context:        A class defines a context to define its all symbols for\n                the variables and methods within the cont\
ext.\n                This automatically avoids conflicts of symbols between \n                classes, Global, and System. When c\
 = Class[ ... ] is\n                done, a context c` is defined.\n\nmembers:        The set of Members of a class is a union of \
class variables,\n                instance variables, and class methods of the class.\n\noperator @:     A special operator to acc\
ess class member. In a notation \n                f@g, g's context defaults the class of the class of f. \n                f@g@h[x\
] is recognized as ((f@g)@h)[x] , thus the context of\n                h defaults the class of f.\n\nsuperclasses:   A class inher\
its all class variables, instance variables,\n                class methods from its superclasses which are give by the\n         \
       first argument of Class. If a null list is given, Object` \n                is set as the default superclass. Multiple inhe\
ritance is\n                allowed.\n\nclass variable: Class variables are given by the second argument of Class\n               \
 as a list of symbols. They are unique in the class.\n                They can be initialized by declaring in a way such as \n    \
            {a=1, {b, c} = {2, 3}} like Module. A form like\n                {a = b = c =1} is allowed.\n\ninstance variable: \n  \
              Instance variables are given by the third argument of Class\n                as a list of symbols. An instance has t\
hose symbols\n                separately. They can be initialized by declaring in a way\n                such as {a=1, {b, c} = {2\
, 3}} like as Module. A form like as\n                {a = b = c =1} is allowed. Also they\n                are initialized at the\
 creation of instance by rules as\n                x = c[ a->1, b:>Print[d]], etc.\n\nclass methods:  Class methods are given by t\
he fourth(last) argument of\n                Class. They must be in the form of either one of\n\n                f_[arg___] := g_;\
\n                With[_, f_[arg___] := g_];\n                With[_, f_[arg___] := g_; .. ];\n                If[_,\n            \
      ft_[argt___] := gt_; ..,\n                  ft_[argf___] := gf_; ..,];\n                h_[f_[arg___], b___] ^:= g_; .\n\n  \
              where f is the symbol for the method to be defined.\n                Set may be used instead of SetDelayed if necess\
ary.\n\nThis:           A symbol This in the definition of the method, it is \n                translated to the object (the insta\
nce or the class) which \n                refers the member.\n\ndefault reference:\n                In the definition of the class\
 methods, whenever a member of\n                the class is appeared, it is recognized as This@member.\n                When a sy\
mbol of the member conflicts the symbol in System`,\n                the system symbol should be wrapped by Literal.\n\nreference \
of member of superclasses:\n                Members of the superclasses (denote cc) are referred by \n                cc`member in\
 the definition of the method.\n\ncopying an instance:\n                An instance c of a class can be copied to another symbol\n\
                by c1 = c. After the copying, c1 and c refer the identical\n                instance. Destructing one of them by s\
uch as c1=. clears\n                the instance and also all the assigned symbols.\n\nConstructor:    When an instance is defined\
, by x = c[arg], a method\n                x@Constructor[arg] is always invoked.\n                In evaluation of instance defini\
tion under class scope,\n                class member symbol appeared 1st slot of Rule or RuleDelayed\n                argument is\
 sent to Constructor of new class instance\n                without evaluation. (In other term, class member symbol on\n          \
      1st slot of Rule or RuleDelayed argument behaves like\n                evaluating with implicit Literal[]) One can configure\
\n                Constructor[] in the definition of the class.\n                x = c[arg] returns the returned value of Construc\
tor[arg].\n                The rules in the argument work in two ways: (1) A rule for an\n                instance variable or a c\
lass variable sets the initial value\n                of the variable, (2) Other rules are stored in an instance\n                \
variable Options as a list.\n\nDestructor:     An instance x is cleared by (x=.), which invokes \n                x@Destructor[]. \
The default Destructor is Object`Destructor,\n                but one can reconfigure it in the definition of the class.\n\nShort:\
          When an instance x is returned as the result of expression\n                for Out[], x@Short[] is invoked to show the \
result. The \n                default Short is Object`Short, but one can reconfigure it\n                in the definition of the \
class.\n\nother methods:  Class[] gives the class of the instance.\n                Parents[] gives the immediate superclasses.\n \
               AllParents[] gives the all superclasses.\n                Members[] gives a list of class variables, class methods,\
\n                and instance variables of the class.\n                AllMembers[] gives a list of class variables, class method\
s,\n                and instance variables of the class and its all parents."],
p$2453=1+p$2453[[1,2]];p1$2453=StringPosition["Environment for an object-oriented-programming is supplied by:\n\nClass:          T\
he function to define a class.\ncontext:        A class defines a context to define its all symbols for\n                the varia\
bles and methods within the context.\n                This automatically avoids conflicts of symbols between \n                cla\
sses, Global, and System. When c = Class[ ... ] is\n                done, a context c` is defined.\n\nmembers:        The set of M\
embers of a class is a union of class variables,\n                instance variables, and class methods of the class.\n\noperator \
@:     A special operator to access class member. In a notation \n                f@g, g's context defaults the class of the class\
 of f. \n                f@g@h[x] is recognized as ((f@g)@h)[x] , thus the context of\n                h defaults the class of f.\\
n\nsuperclasses:   A class inherits all class variables, instance variables,\n                class methods from its superclasses \
which are give by the\n                first argument of Class. If a null list is given, Object` \n                is set as the d\
efault superclass. Multiple inheritance is\n                allowed.\n\nclass variable: Class variables are given by the second ar\
gument of Class\n                as a list of symbols. They are unique in the class.\n                They can be initialized by d\
eclaring in a way such as \n                {a=1, {b, c} = {2, 3}} like Module. A form like\n                {a = b = c =1} is all\
owed.\n\ninstance variable: \n                Instance variables are given by the third argument of Class\n                as a li\
st of symbols. An instance has those symbols\n                separately. They can be initialized by declaring in a way\n         \
       such as {a=1, {b, c} = {2, 3}} like as Module. A form like as\n                {a = b = c =1} is allowed. Also they\n      \
          are initialized at the creation of instance by rules as\n                x = c[ a->1, b:>Print[d]], etc.\n\nclass method\
s:  Class methods are given by the fourth(last) argument of\n                Class. They must be in the form of either one of\n\n \
               f_[arg___] := g_;\n                With[_, f_[arg___] := g_];\n                With[_, f_[arg___] := g_; .. ];\n   \
             If[_,\n                  ft_[argt___] := gt_; ..,\n                  ft_[argf___] := gf_; ..,];\n                h_[f\
_[arg___], b___] ^:= g_; .\n\n                where f is the symbol for the method to be defined.\n                Set may be used\
 instead of SetDelayed if necessary.\n\nThis:           A symbol This in the definition of the method, it is \n                tra\
nslated to the object (the instance or the class) which \n                refers the member.\n\ndefault reference:\n              \
  In the definition of the class methods, whenever a member of\n                the class is appeared, it is recognized as This@me\
mber.\n                When a symbol of the member conflicts the symbol in System`,\n                the system symbol should be w\
rapped by Literal.\n\nreference of member of superclasses:\n                Members of the superclasses (denote cc) are referred b\
y \n                cc`member in the definition of the method.\n\ncopying an instance:\n                An instance c of a class c\
an be copied to another symbol\n                by c1 = c. After the copying, c1 and c refer the identical\n                instan\
ce. Destructing one of them by such as c1=. clears\n                the instance and also all the assigned symbols.\n\nConstructor\
:    When an instance is defined, by x = c[arg], a method\n                x@Constructor[arg] is always invoked.\n                \
In evaluation of instance definition under class scope,\n                class member symbol appeared 1st slot of Rule or RuleDela\
yed\n                argument is sent to Constructor of new class instance\n                without evaluation. (In other term, cl\
ass member symbol on\n                1st slot of Rule or RuleDelayed argument behaves like\n                evaluating with impli\
cit Literal[]) One can configure\n                Constructor[] in the definition of the class.\n                x = c[arg] return\
s the returned value of Constructor[arg].\n                The rules in the argument work in two ways: (1) A rule for an\n        \
        instance variable or a class variable sets the initial value\n                of the variable, (2) Other rules are stored \
in an instance\n                variable Options as a list.\n\nDestructor:     An instance x is cleared by (x=.), which invokes \n\
                x@Destructor[]. The default Destructor is Object`Destructor,\n                but one can reconfigure it in the de\
finition of the class.\n\nShort:          When an instance x is returned as the result of expression\n                for Out[], x\
@Short[] is invoked to show the result. The \n                default Short is Object`Short, but one can reconfigure it\n         \
       in the definition of the class.\n\nother methods:  Class[] gives the class of the instance.\n                Parents[] give\
s the immediate superclasses.\n                AllParents[] gives the all superclasses.\n                Members[] gives a list of\
 class variables, class methods,\n                and instance variables of the class.\n                AllMembers[] gives a list \
of class variables, class methods,\n                and instance variables of the class and its all parents."[p$2453,-1],">::",1];
  p1$2453=If[p1$2453==={},5419,-2+p$2453+p1$2453[[1,1]]];
neq=Which["Environment for an object-oriented-programming is supplied by:\n\nClass:          The function to define a class.\ncont\
ext:        A class defines a context to define its all symbols for\n                the variables and methods within the context.\
\n                This automatically avoids conflicts of symbols between \n                classes, Global, and System. When c = C\
lass[ ... ] is\n                done, a context c` is defined.\n\nmembers:        The set of Members of a class is a union of clas\
s variables,\n                instance variables, and class methods of the class.\n\noperator @:     A special operator to access \
class member. In a notation \n                f@g, g's context defaults the class of the class of f. \n                f@g@h[x] is\
 recognized as ((f@g)@h)[x] , thus the context of\n                h defaults the class of f.\n\nsuperclasses:   A class inherits \
all class variables, instance variables,\n                class methods from its superclasses which are give by the\n             \
   first argument of Class. If a null list is given, Object` \n                is set as the default superclass. Multiple inherita\
nce is\n                allowed.\n\nclass variable: Class variables are given by the second argument of Class\n                as \
a list of symbols. They are unique in the class.\n                They can be initialized by declaring in a way such as \n        \
        {a=1, {b, c} = {2, 3}} like Module. A form like\n                {a = b = c =1} is allowed.\n\ninstance variable: \n      \
          Instance variables are given by the third argument of Class\n                as a list of symbols. An instance has those\
 symbols\n                separately. They can be initialized by declaring in a way\n                such as {a=1, {b, c} = {2, 3}\
} like as Module. A form like as\n                {a = b = c =1} is allowed. Also they\n                are initialized at the cre\
ation of instance by rules as\n                x = c[ a->1, b:>Print[d]], etc.\n\nclass methods:  Class methods are given by the f\
ourth(last) argument of\n                Class. They must be in the form of either one of\n\n                f_[arg___] := g_;\n  \
              With[_, f_[arg___] := g_];\n                With[_, f_[arg___] := g_; .. ];\n                If[_,\n                \
  ft_[argt___] := gt_; ..,\n                  ft_[argf___] := gf_; ..,];\n                h_[f_[arg___], b___] ^:= g_; .\n\n      \
          where f is the symbol for the method to be defined.\n                Set may be used instead of SetDelayed if necessary.\
\n\nThis:           A symbol This in the definition of the method, it is \n                translated to the object (the instance \
or the class) which \n                refers the member.\n\ndefault reference:\n                In the definition of the class met\
hods, whenever a member of\n                the class is appeared, it is recognized as This@member.\n                When a symbol\
 of the member conflicts the symbol in System`,\n                the system symbol should be wrapped by Literal.\n\nreference of m\
ember of superclasses:\n                Members of the superclasses (denote cc) are referred by \n                cc`member in the\
 definition of the method.\n\ncopying an instance:\n                An instance c of a class can be copied to another symbol\n    \
            by c1 = c. After the copying, c1 and c refer the identical\n                instance. Destructing one of them by such \
as c1=. clears\n                the instance and also all the assigned symbols.\n\nConstructor:    When an instance is defined, by\
 x = c[arg], a method\n                x@Constructor[arg] is always invoked.\n                In evaluation of instance definition\
 under class scope,\n                class member symbol appeared 1st slot of Rule or RuleDelayed\n                argument is sen\
t to Constructor of new class instance\n                without evaluation. (In other term, class member symbol on\n              \
  1st slot of Rule or RuleDelayed argument behaves like\n                evaluating with implicit Literal[]) One can configure\n  \
              Constructor[] in the definition of the class.\n                x = c[arg] returns the returned value of Constructor[\
arg].\n                The rules in the argument work in two ways: (1) A rule for an\n                instance variable or a class\
 variable sets the initial value\n                of the variable, (2) Other rules are stored in an instance\n                vari\
able Options as a list.\n\nDestructor:     An instance x is cleared by (x=.), which invokes \n                x@Destructor[]. The \
default Destructor is Object`Destructor,\n                but one can reconfigure it in the definition of the class.\n\nShort:    \
      When an instance x is returned as the result of expression\n                for Out[], x@Short[] is invoked to show the resu\
lt. The \n                default Short is Object`Short, but one can reconfigure it\n                in the definition of the clas\
s.\n\nother methods:  Class[] gives the class of the instance.\n                Parents[] gives the immediate superclasses.\n     \
           AllParents[] gives the all superclasses.\n                Members[] gives a list of class variables, class methods,\n  \
              and instance variables of the class.\n                AllMembers[] gives a list of class variables, class methods,\n\
                and instance variables of the class and its all parents."[p$2453,4+p$2453]==="Text[",
    lx$2453:=Help2HTML`oa$;p$2453=5+p$2453;p1$2453-=1;p2$2453=5+p1$2453;p0$2453=-9+p$2453;
If[(pe$2453=StringPosition["Environment for an object-oriented-programming is supplied by:\n\nClass:          The function to defi\
ne a class.\ncontext:        A class defines a context to define its all symbols for\n                the variables and methods wi\
thin the context.\n                This automatically avoids conflicts of symbols between \n                classes, Global, and S\
ystem. When c = Class[ ... ] is\n                done, a context c` is defined.\n\nmembers:        The set of Members of a class i\
s a union of class variables,\n                instance variables, and class methods of the class.\n\noperator @:     A special op\
erator to access class member. In a notation \n                f@g, g's context defaults the class of the class of f. \n          \
      f@g@h[x] is recognized as ((f@g)@h)[x] , thus the context of\n                h defaults the class of f.\n\nsuperclasses:   \
A class inherits all class variables, instance variables,\n                class methods from its superclasses which are give by t\
he\n                first argument of Class. If a null list is given, Object` \n                is set as the default superclass. \
Multiple inheritance is\n                allowed.\n\nclass variable: Class variables are given by the second argument of Class\n  \
              as a list of symbols. They are unique in the class.\n                They can be initialized by declaring in a way s\
uch as \n                {a=1, {b, c} = {2, 3}} like Module. A form like\n                {a = b = c =1} is allowed.\n\ninstance v\
ariable: \n                Instance variables are given by the third argument of Class\n                as a list of symbols. An i\
nstance has those symbols\n                separately. They can be initialized by declaring in a way\n                such as {a=1\
, {b, c} = {2, 3}} like as Module. A form like as\n                {a = b = c =1} is allowed. Also they\n                are initi\
alized at the creation of instance by rules as\n                x = c[ a->1, b:>Print[d]], etc.\n\nclass methods:  Class methods a\
re given by the fourth(last) argument of\n                Class. They must be in the form of either one of\n\n                f_[a\
rg___] := g_;\n                With[_, f_[arg___] := g_];\n                With[_, f_[arg___] := g_; .. ];\n                If[_,\\
n                  ft_[argt___] := gt_; ..,\n                  ft_[argf___] := gf_; ..,];\n                h_[f_[arg___], b___] ^:\
= g_; .\n\n                where f is the symbol for the method to be defined.\n                Set may be used instead of SetDela\
yed if necessary.\n\nThis:           A symbol This in the definition of the method, it is \n                translated to the obje\
ct (the instance or the class) which \n                refers the member.\n\ndefault reference:\n                In the definition\
 of the class methods, whenever a member of\n                the class is appeared, it is recognized as This@member.\n            \
    When a symbol of the member conflicts the symbol in System`,\n                the system symbol should be wrapped by Literal.\\
n\nreference of member of superclasses:\n                Members of the superclasses (denote cc) are referred by \n               \
 cc`member in the definition of the method.\n\ncopying an instance:\n                An instance c of a class can be copied to ano\
ther symbol\n                by c1 = c. After the copying, c1 and c refer the identical\n                instance. Destructing one\
 of them by such as c1=. clears\n                the instance and also all the assigned symbols.\n\nConstructor:    When an instan\
ce is defined, by x = c[arg], a method\n                x@Constructor[arg] is always invoked.\n                In evaluation of in\
stance definition under class scope,\n                class member symbol appeared 1st slot of Rule or RuleDelayed\n              \
  argument is sent to Constructor of new class instance\n                without evaluation. (In other term, class member symbol o\
n\n                1st slot of Rule or RuleDelayed argument behaves like\n                evaluating with implicit Literal[]) One \
can configure\n                Constructor[] in the definition of the class.\n                x = c[arg] returns the returned valu\
e of Constructor[arg].\n                The rules in the argument work in two ways: (1) A rule for an\n                instance va\
riable or a class variable sets the initial value\n                of the variable, (2) Other rules are stored in an instance\n   \
             variable Options as a list.\n\nDestructor:     An instance x is cleared by (x=.), which invokes \n                x@D\
estructor[]. The default Destructor is Object`Destructor,\n                but one can reconfigure it in the definition of the cla\
ss.\n\nShort:          When an instance x is returned as the result of expression\n                for Out[], x@Short[] is invoked\
 to show the result. The \n                default Short is Object`Short, but one can reconfigure it\n                in the defin\
ition of the class.\n\nother methods:  Class[] gives the class of the instance.\n                Parents[] gives the immediate sup\
erclasses.\n                AllParents[] gives the all superclasses.\n                Members[] gives a list of class variables, c\
lass methods,\n                and instance variables of the class.\n                AllMembers[] gives a list of class variables,\
 class methods,\n                and instance variables of the class and its all parents."[p$2453,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Environment for an object-oriented-programming is supplied by:\n\nClass:          The function to define a class.\
\ncontext:        A class defines a context to define its all symbols for\n                the variables and methods within the co\
ntext.\n                This automatically avoids conflicts of symbols between \n                classes, Global, and System. When\
 c = Class[ ... ] is\n                done, a context c` is defined.\n\nmembers:        The set of Members of a class is a union o\
f class variables,\n                instance variables, and class methods of the class.\n\noperator @:     A special operator to a\
ccess class member. In a notation \n                f@g, g's context defaults the class of the class of f. \n                f@g@h\
[x] is recognized as ((f@g)@h)[x] , thus the context of\n                h defaults the class of f.\n\nsuperclasses:   A class inh\
erits all class variables, instance variables,\n                class methods from its superclasses which are give by the\n       \
         first argument of Class. If a null list is given, Object` \n                is set as the default superclass. Multiple in\
heritance is\n                allowed.\n\nclass variable: Class variables are given by the second argument of Class\n             \
   as a list of symbols. They are unique in the class.\n                They can be initialized by declaring in a way such as \n  \
              {a=1, {b, c} = {2, 3}} like Module. A form like\n                {a = b = c =1} is allowed.\n\ninstance variable: \n\
                Instance variables are given by the third argument of Class\n                as a list of symbols. An instance has\
 those symbols\n                separately. They can be initialized by declaring in a way\n                such as {a=1, {b, c} = \
{2, 3}} like as Module. A form like as\n                {a = b = c =1} is allowed. Also they\n                are initialized at t\
he creation of instance by rules as\n                x = c[ a->1, b:>Print[d]], etc.\n\nclass methods:  Class methods are given by\
 the fourth(last) argument of\n                Class. They must be in the form of either one of\n\n                f_[arg___] := g\
_;\n                With[_, f_[arg___] := g_];\n                With[_, f_[arg___] := g_; .. ];\n                If[_,\n          \
        ft_[argt___] := gt_; ..,\n                  ft_[argf___] := gf_; ..,];\n                h_[f_[arg___], b___] ^:= g_; .\n\n\
                where f is the symbol for the method to be defined.\n                Set may be used instead of SetDelayed if nece\
ssary.\n\nThis:           A symbol This in the definition of the method, it is \n                translated to the object (the ins\
tance or the class) which \n                refers the member.\n\ndefault reference:\n                In the definition of the cla\
ss methods, whenever a member of\n                the class is appeared, it is recognized as This@member.\n                When a \
symbol of the member conflicts the symbol in System`,\n                the system symbol should be wrapped by Literal.\n\nreferenc\
e of member of superclasses:\n                Members of the superclasses (denote cc) are referred by \n                cc`member \
in the definition of the method.\n\ncopying an instance:\n                An instance c of a class can be copied to another symbol\
\n                by c1 = c. After the copying, c1 and c refer the identical\n                instance. Destructing one of them by\
 such as c1=. clears\n                the instance and also all the assigned symbols.\n\nConstructor:    When an instance is defin\
ed, by x = c[arg], a method\n                x@Constructor[arg] is always invoked.\n                In evaluation of instance defi\
nition under class scope,\n                class member symbol appeared 1st slot of Rule or RuleDelayed\n                argument \
is sent to Constructor of new class instance\n                without evaluation. (In other term, class member symbol on\n        \
        1st slot of Rule or RuleDelayed argument behaves like\n                evaluating with implicit Literal[]) One can configu\
re\n                Constructor[] in the definition of the class.\n                x = c[arg] returns the returned value of Constr\
uctor[arg].\n                The rules in the argument work in two ways: (1) A rule for an\n                instance variable or a\
 class variable sets the initial value\n                of the variable, (2) Other rules are stored in an instance\n              \
  variable Options as a list.\n\nDestructor:     An instance x is cleared by (x=.), which invokes \n                x@Destructor[]\
. The default Destructor is Object`Destructor,\n                but one can reconfigure it in the definition of the class.\n\nShor\
t:          When an instance x is returned as the result of expression\n                for Out[], x@Short[] is invoked to show th\
e result. The \n                default Short is Object`Short, but one can reconfigure it\n                in the definition of th\
e class.\n\nother methods:  Class[] gives the class of the instance.\n                Parents[] gives the immediate superclasses.\\
n                AllParents[] gives the all superclasses.\n                Members[] gives a list of class variables, class method\
s,\n                and instance variables of the class.\n                AllMembers[] gives a list of class variables, class meth\
ods,\n                and instance variables of the class and its all parents."[p$2453+pe$2453[[1,2]],p1$2453]]],
        p1$2453=-2+p$2453+pe$2453[[1,1]]}[[
       1]],
      0],
    1,lx$2453:=Help2HTML`o9$;p2$2453=4+p1$2453;p0$2453=-4+p$2453;0];
  If[(equ$2453=
Help2HTML`o8$["Environment for an object-oriented-programming is supplied by:\n\nClass:          The function to define a class.\n\
context:        A class defines a context to define its all symbols for\n                the variables and methods within the cont\
ext.\n                This automatically avoids conflicts of symbols between \n                classes, Global, and System. When c\
 = Class[ ... ] is\n                done, a context c` is defined.\n\nmembers:        The set of Members of a class is a union of \
class variables,\n                instance variables, and class methods of the class.\n\noperator @:     A special operator to acc\
ess class member. In a notation \n                f@g, g's context defaults the class of the class of f. \n                f@g@h[x\
] is recognized as ((f@g)@h)[x] , thus the context of\n                h defaults the class of f.\n\nsuperclasses:   A class inher\
its all class variables, instance variables,\n                class methods from its superclasses which are give by the\n         \
       first argument of Class. If a null list is given, Object` \n                is set as the default superclass. Multiple inhe\
ritance is\n                allowed.\n\nclass variable: Class variables are given by the second argument of Class\n               \
 as a list of symbols. They are unique in the class.\n                They can be initialized by declaring in a way such as \n    \
            {a=1, {b, c} = {2, 3}} like Module. A form like\n                {a = b = c =1} is allowed.\n\ninstance variable: \n  \
              Instance variables are given by the third argument of Class\n                as a list of symbols. An instance has t\
hose symbols\n                separately. They can be initialized by declaring in a way\n                such as {a=1, {b, c} = {2\
, 3}} like as Module. A form like as\n                {a = b = c =1} is allowed. Also they\n                are initialized at the\
 creation of instance by rules as\n                x = c[ a->1, b:>Print[d]], etc.\n\nclass methods:  Class methods are given by t\
he fourth(last) argument of\n                Class. They must be in the form of either one of\n\n                f_[arg___] := g_;\
\n                With[_, f_[arg___] := g_];\n                With[_, f_[arg___] := g_; .. ];\n                If[_,\n            \
      ft_[argt___] := gt_; ..,\n                  ft_[argf___] := gf_; ..,];\n                h_[f_[arg___], b___] ^:= g_; .\n\n  \
              where f is the symbol for the method to be defined.\n                Set may be used instead of SetDelayed if necess\
ary.\n\nThis:           A symbol This in the definition of the method, it is \n                translated to the object (the insta\
nce or the class) which \n                refers the member.\n\ndefault reference:\n                In the definition of the class\
 methods, whenever a member of\n                the class is appeared, it is recognized as This@member.\n                When a sy\
mbol of the member conflicts the symbol in System`,\n                the system symbol should be wrapped by Literal.\n\nreference \
of member of superclasses:\n                Members of the superclasses (denote cc) are referred by \n                cc`member in\
 the definition of the method.\n\ncopying an instance:\n                An instance c of a class can be copied to another symbol\n\
                by c1 = c. After the copying, c1 and c refer the identical\n                instance. Destructing one of them by s\
uch as c1=. clears\n                the instance and also all the assigned symbols.\n\nConstructor:    When an instance is defined\
, by x = c[arg], a method\n                x@Constructor[arg] is always invoked.\n                In evaluation of instance defini\
tion under class scope,\n                class member symbol appeared 1st slot of Rule or RuleDelayed\n                argument is\
 sent to Constructor of new class instance\n                without evaluation. (In other term, class member symbol on\n          \
      1st slot of Rule or RuleDelayed argument behaves like\n                evaluating with implicit Literal[]) One can configure\
\n                Constructor[] in the definition of the class.\n                x = c[arg] returns the returned value of Construc\
tor[arg].\n                The rules in the argument work in two ways: (1) A rule for an\n                instance variable or a c\
lass variable sets the initial value\n                of the variable, (2) Other rules are stored in an instance\n                \
variable Options as a list.\n\nDestructor:     An instance x is cleared by (x=.), which invokes \n                x@Destructor[]. \
The default Destructor is Object`Destructor,\n                but one can reconfigure it in the definition of the class.\n\nShort:\
          When an instance x is returned as the result of expression\n                for Out[], x@Short[] is invoked to show the \
result. The \n                default Short is Object`Short, but one can reconfigure it\n                in the definition of the \
class.\n\nother methods:  Class[] gives the class of the instance.\n                Parents[] gives the immediate superclasses.\n \
               AllParents[] gives the all superclasses.\n                Members[] gives a list of class variables, class methods,\
\n                and instance variables of the class.\n                AllMembers[] gives a list of class variables, class method\
s,\n                and instance variables of the class and its all parents."[p$2453,p1$2453]])===
    Undefined,
equ$2453="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Environment for an object-oriented-programmi\
ng is supplied by:\n\nClass:          The function to define a class.\ncontext:        A class defines a context to define its all\
 symbols for\n                the variables and methods within the context.\n                This automatically avoids conflicts o\
f symbols between \n                classes, Global, and System. When c = Class[ ... ] is\n                done, a context c` is d\
efined.\n\nmembers:        The set of Members of a class is a union of class variables,\n                instance variables, and c\
lass methods of the class.\n\noperator @:     A special operator to access class member. In a notation \n                f@g, g's \
context defaults the class of the class of f. \n                f@g@h[x] is recognized as ((f@g)@h)[x] , thus the context of\n    \
            h defaults the class of f.\n\nsuperclasses:   A class inherits all class variables, instance variables,\n             \
   class methods from its superclasses which are give by the\n                first argument of Class. If a null list is given, Ob\
ject` \n                is set as the default superclass. Multiple inheritance is\n                allowed.\n\nclass variable: Cla\
ss variables are given by the second argument of Class\n                as a list of symbols. They are unique in the class.\n     \
           They can be initialized by declaring in a way such as \n                {a=1, {b, c} = {2, 3}} like Module. A form like\
\n                {a = b = c =1} is allowed.\n\ninstance variable: \n                Instance variables are given by the third arg\
ument of Class\n                as a list of symbols. An instance has those symbols\n                separately. They can be initi\
alized by declaring in a way\n                such as {a=1, {b, c} = {2, 3}} like as Module. A form like as\n                {a = \
b = c =1} is allowed. Also they\n                are initialized at the creation of instance by rules as\n                x = c[ a\
->1, b:>Print[d]], etc.\n\nclass methods:  Class methods are given by the fourth(last) argument of\n                Class. They mu\
st be in the form of either one of\n\n                f_[arg___] := g_;\n                With[_, f_[arg___] := g_];\n             \
   With[_, f_[arg___] := g_; .. ];\n                If[_,\n                  ft_[argt___] := gt_; ..,\n                  ft_[argf_\
__] := gf_; ..,];\n                h_[f_[arg___], b___] ^:= g_; .\n\n                where f is the symbol for the method to be de\
fined.\n                Set may be used instead of SetDelayed if necessary.\n\nThis:           A symbol This in the definition of \
the method, it is \n                translated to the object (the instance or the class) which \n                refers the member\
.\n\ndefault reference:\n                In the definition of the class methods, whenever a member of\n                the class i\
s appeared, it is recognized as This@member.\n                When a symbol of the member conflicts the symbol in System`,\n      \
          the system symbol should be wrapped by Literal.\n\nreference of member of superclasses:\n                Members of the \
superclasses (denote cc) are referred by \n                cc`member in the definition of the method.\n\ncopying an instance:\n   \
             An instance c of a class can be copied to another symbol\n                by c1 = c. After the copying, c1 and c refe\
r the identical\n                instance. Destructing one of them by such as c1=. clears\n                the instance and also a\
ll the assigned symbols.\n\nConstructor:    When an instance is defined, by x = c[arg], a method\n                x@Constructor[ar\
g] is always invoked.\n                In evaluation of instance definition under class scope,\n                class member symbo\
l appeared 1st slot of Rule or RuleDelayed\n                argument is sent to Constructor of new class instance\n               \
 without evaluation. (In other term, class member symbol on\n                1st slot of Rule or RuleDelayed argument behaves like\
\n                evaluating with implicit Literal[]) One can configure\n                Constructor[] in the definition of the cl\
ass.\n                x = c[arg] returns the returned value of Constructor[arg].\n                The rules in the argument work i\
n two ways: (1) A rule for an\n                instance variable or a class variable sets the initial value\n                of th\
e variable, (2) Other rules are stored in an instance\n                variable Options as a list.\n\nDestructor:     An instance \
x is cleared by (x=.), which invokes \n                x@Destructor[]. The default Destructor is Object`Destructor,\n             \
   but one can reconfigure it in the definition of the class.\n\nShort:          When an instance x is returned as the result of e\
xpression\n                for Out[], x@Short[] is invoked to show the result. The \n                default Short is Object`Short\
, but one can reconfigure it\n                in the definition of the class.\n\nother methods:  Class[] gives the class of the in\
stance.\n                Parents[] gives the immediate superclasses.\n                AllParents[] gives the all superclasses.\n  \
              Members[] gives a list of class variables, class methods,\n                and instance variables of the class.\n   \
             AllMembers[] gives a list of class variables, class methods,\n                and instance variables of the class and\
 its all parents."[p$2453,p1$2453]]=
       equ$2453;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2453},out$2453=lx$2453@Typeset["Environment for an object-oriented-programming is supplied by:\n\nClass:          The fun\
ction to define a class.\ncontext:        A class defines a context to define its all symbols for\n                the variables a\
nd methods within the context.\n                This automatically avoids conflicts of symbols between \n                classes, \
Global, and System. When c = Class[ ... ] is\n                done, a context c` is defined.\n\nmembers:        The set of Members\
 of a class is a union of class variables,\n                instance variables, and class methods of the class.\n\noperator @:    \
 A special operator to access class member. In a notation \n                f@g, g's context defaults the class of the class of f.\
 \n                f@g@h[x] is recognized as ((f@g)@h)[x] , thus the context of\n                h defaults the class of f.\n\nsup\
erclasses:   A class inherits all class variables, instance variables,\n                class methods from its superclasses which \
are give by the\n                first argument of Class. If a null list is given, Object` \n                is set as the default\
 superclass. Multiple inheritance is\n                allowed.\n\nclass variable: Class variables are given by the second argument\
 of Class\n                as a list of symbols. They are unique in the class.\n                They can be initialized by declari\
ng in a way such as \n                {a=1, {b, c} = {2, 3}} like Module. A form like\n                {a = b = c =1} is allowed.\\
n\ninstance variable: \n                Instance variables are given by the third argument of Class\n                as a list of \
symbols. An instance has those symbols\n                separately. They can be initialized by declaring in a way\n               \
 such as {a=1, {b, c} = {2, 3}} like as Module. A form like as\n                {a = b = c =1} is allowed. Also they\n            \
    are initialized at the creation of instance by rules as\n                x = c[ a->1, b:>Print[d]], etc.\n\nclass methods:  Cl\
ass methods are given by the fourth(last) argument of\n                Class. They must be in the form of either one of\n\n       \
         f_[arg___] := g_;\n                With[_, f_[arg___] := g_];\n                With[_, f_[arg___] := g_; .. ];\n         \
       If[_,\n                  ft_[argt___] := gt_; ..,\n                  ft_[argf___] := gf_; ..,];\n                h_[f_[arg_\
__], b___] ^:= g_; .\n\n                where f is the symbol for the method to be defined.\n                Set may be used inste\
ad of SetDelayed if necessary.\n\nThis:           A symbol This in the definition of the method, it is \n                translate\
d to the object (the instance or the class) which \n                refers the member.\n\ndefault reference:\n                In t\
he definition of the class methods, whenever a member of\n                the class is appeared, it is recognized as This@member.\\
n                When a symbol of the member conflicts the symbol in System`,\n                the system symbol should be wrapped\
 by Literal.\n\nreference of member of superclasses:\n                Members of the superclasses (denote cc) are referred by \n  \
              cc`member in the definition of the method.\n\ncopying an instance:\n                An instance c of a class can be \
copied to another symbol\n                by c1 = c. After the copying, c1 and c refer the identical\n                instance. De\
structing one of them by such as c1=. clears\n                the instance and also all the assigned symbols.\n\nConstructor:    W\
hen an instance is defined, by x = c[arg], a method\n                x@Constructor[arg] is always invoked.\n                In eva\
luation of instance definition under class scope,\n                class member symbol appeared 1st slot of Rule or RuleDelayed\n \
               argument is sent to Constructor of new class instance\n                without evaluation. (In other term, class me\
mber symbol on\n                1st slot of Rule or RuleDelayed argument behaves like\n                evaluating with implicit Li\
teral[]) One can configure\n                Constructor[] in the definition of the class.\n                x = c[arg] returns the \
returned value of Constructor[arg].\n                The rules in the argument work in two ways: (1) A rule for an\n              \
  instance variable or a class variable sets the initial value\n                of the variable, (2) Other rules are stored in an \
instance\n                variable Options as a list.\n\nDestructor:     An instance x is cleared by (x=.), which invokes \n      \
          x@Destructor[]. The default Destructor is Object`Destructor,\n                but one can reconfigure it in the definiti\
on of the class.\n\nShort:          When an instance x is returned as the result of expression\n                for Out[], x@Short\
[] is invoked to show the result. The \n                default Short is Object`Short, but one can reconfigure it\n               \
 in the definition of the class.\n\nother methods:  Class[] gives the class of the instance.\n                Parents[] gives the \
immediate superclasses.\n                AllParents[] gives the all superclasses.\n                Members[] gives a list of class\
 variables, class methods,\n                and instance variables of the class.\n                AllMembers[] gives a list of cla\
ss variables, class methods,\n                and instance variables of the class and its all parents."[p$2453,p1$2453],
          Format->Help2HTML`oB$];
        System["mv -f "//out$2453//" "//equ$2453]];
      Exit[]]];
   "Environment for an object-oriented-programming is supplied by:\n\nClass:          The function to define a class.\ncontext:   \
     A class defines a context to define its all symbols for\n                the variables and methods within the context.\n     \
           This automatically avoids conflicts of symbols between \n                classes, Global, and System. When c = Class[ .\
.. ] is\n                done, a context c` is defined.\n\nmembers:        The set of Members of a class is a union of class varia\
bles,\n                instance variables, and class methods of the class.\n\noperator @:     A special operator to access class m\
ember. In a notation \n                f@g, g's context defaults the class of the class of f. \n                f@g@h[x] is recogn\
ized as ((f@g)@h)[x] , thus the context of\n                h defaults the class of f.\n\nsuperclasses:   A class inherits all cla\
ss variables, instance variables,\n                class methods from its superclasses which are give by the\n                firs\
t argument of Class. If a null list is given, Object` \n                is set as the default superclass. Multiple inheritance is\\
n                allowed.\n\nclass variable: Class variables are given by the second argument of Class\n                as a list \
of symbols. They are unique in the class.\n                They can be initialized by declaring in a way such as \n               \
 {a=1, {b, c} = {2, 3}} like Module. A form like\n                {a = b = c =1} is allowed.\n\ninstance variable: \n             \
   Instance variables are given by the third argument of Class\n                as a list of symbols. An instance has those symbol\
s\n                separately. They can be initialized by declaring in a way\n                such as {a=1, {b, c} = {2, 3}} like \
as Module. A form like as\n                {a = b = c =1} is allowed. Also they\n                are initialized at the creation o\
f instance by rules as\n                x = c[ a->1, b:>Print[d]], etc.\n\nclass methods:  Class methods are given by the fourth(l\
ast) argument of\n                Class. They must be in the form of either one of\n\n                f_[arg___] := g_;\n         \
       With[_, f_[arg___] := g_];\n                With[_, f_[arg___] := g_; .. ];\n                If[_,\n                  ft_[a\
rgt___] := gt_; ..,\n                  ft_[argf___] := gf_; ..,];\n                h_[f_[arg___], b___] ^:= g_; .\n\n             \
   where f is the symbol for the method to be defined.\n                Set may be used instead of SetDelayed if necessary.\n\nThi\
s:           A symbol This in the definition of the method, it is \n                translated to the object (the instance or the \
class) which \n                refers the member.\n\ndefault reference:\n                In the definition of the class methods, w\
henever a member of\n                the class is appeared, it is recognized as This@member.\n                When a symbol of the\
 member conflicts the symbol in System`,\n                the system symbol should be wrapped by Literal.\n\nreference of member o\
f superclasses:\n                Members of the superclasses (denote cc) are referred by \n                cc`member in the defini\
tion of the method.\n\ncopying an instance:\n                An instance c of a class can be copied to another symbol\n           \
     by c1 = c. After the copying, c1 and c refer the identical\n                instance. Destructing one of them by such as c1=.\
 clears\n                the instance and also all the assigned symbols.\n\nConstructor:    When an instance is defined, by x = c[\
arg], a method\n                x@Constructor[arg] is always invoked.\n                In evaluation of instance definition under \
class scope,\n                class member symbol appeared 1st slot of Rule or RuleDelayed\n                argument is sent to Co\
nstructor of new class instance\n                without evaluation. (In other term, class member symbol on\n                1st s\
lot of Rule or RuleDelayed argument behaves like\n                evaluating with implicit Literal[]) One can configure\n         \
       Constructor[] in the definition of the class.\n                x = c[arg] returns the returned value of Constructor[arg].\n\
                The rules in the argument work in two ways: (1) A rule for an\n                instance variable or a class variab\
le sets the initial value\n                of the variable, (2) Other rules are stored in an instance\n                variable Op\
tions as a list.\n\nDestructor:     An instance x is cleared by (x=.), which invokes \n                x@Destructor[]. The default\
 Destructor is Object`Destructor,\n                but one can reconfigure it in the definition of the class.\n\nShort:          W\
hen an instance x is returned as the result of expression\n                for Out[], x@Short[] is invoked to show the result. The\
 \n                default Short is Object`Short, but one can reconfigure it\n                in the definition of the class.\n\no\
ther methods:  Class[] gives the class of the instance.\n                Parents[] gives the immediate superclasses.\n            \
    AllParents[] gives the all superclasses.\n                Members[] gives a list of class variables, class methods,\n         \
       and instance variables of the class.\n                AllMembers[] gives a list of class variables, class methods,\n       \
         and instance variables of the class and its all parents."[1,Max[p0$2453,0]]//"<img  class=\"eqs\" SRC=\""//equ$2453//
   "\" />"//
Help2HTML`oy$["Environment for an object-oriented-programming is supplied by:\n\nClass:          The function to define a class.\n\
context:        A class defines a context to define its all symbols for\n                the variables and methods within the cont\
ext.\n                This automatically avoids conflicts of symbols between \n                classes, Global, and System. When c\
 = Class[ ... ] is\n                done, a context c` is defined.\n\nmembers:        The set of Members of a class is a union of \
class variables,\n                instance variables, and class methods of the class.\n\noperator @:     A special operator to acc\
ess class member. In a notation \n                f@g, g's context defaults the class of the class of f. \n                f@g@h[x\
] is recognized as ((f@g)@h)[x] , thus the context of\n                h defaults the class of f.\n\nsuperclasses:   A class inher\
its all class variables, instance variables,\n                class methods from its superclasses which are give by the\n         \
       first argument of Class. If a null list is given, Object` \n                is set as the default superclass. Multiple inhe\
ritance is\n                allowed.\n\nclass variable: Class variables are given by the second argument of Class\n               \
 as a list of symbols. They are unique in the class.\n                They can be initialized by declaring in a way such as \n    \
            {a=1, {b, c} = {2, 3}} like Module. A form like\n                {a = b = c =1} is allowed.\n\ninstance variable: \n  \
              Instance variables are given by the third argument of Class\n                as a list of symbols. An instance has t\
hose symbols\n                separately. They can be initialized by declaring in a way\n                such as {a=1, {b, c} = {2\
, 3}} like as Module. A form like as\n                {a = b = c =1} is allowed. Also they\n                are initialized at the\
 creation of instance by rules as\n                x = c[ a->1, b:>Print[d]], etc.\n\nclass methods:  Class methods are given by t\
he fourth(last) argument of\n                Class. They must be in the form of either one of\n\n                f_[arg___] := g_;\
\n                With[_, f_[arg___] := g_];\n                With[_, f_[arg___] := g_; .. ];\n                If[_,\n            \
      ft_[argt___] := gt_; ..,\n                  ft_[argf___] := gf_; ..,];\n                h_[f_[arg___], b___] ^:= g_; .\n\n  \
              where f is the symbol for the method to be defined.\n                Set may be used instead of SetDelayed if necess\
ary.\n\nThis:           A symbol This in the definition of the method, it is \n                translated to the object (the insta\
nce or the class) which \n                refers the member.\n\ndefault reference:\n                In the definition of the class\
 methods, whenever a member of\n                the class is appeared, it is recognized as This@member.\n                When a sy\
mbol of the member conflicts the symbol in System`,\n                the system symbol should be wrapped by Literal.\n\nreference \
of member of superclasses:\n                Members of the superclasses (denote cc) are referred by \n                cc`member in\
 the definition of the method.\n\ncopying an instance:\n                An instance c of a class can be copied to another symbol\n\
                by c1 = c. After the copying, c1 and c refer the identical\n                instance. Destructing one of them by s\
uch as c1=. clears\n                the instance and also all the assigned symbols.\n\nConstructor:    When an instance is defined\
, by x = c[arg], a method\n                x@Constructor[arg] is always invoked.\n                In evaluation of instance defini\
tion under class scope,\n                class member symbol appeared 1st slot of Rule or RuleDelayed\n                argument is\
 sent to Constructor of new class instance\n                without evaluation. (In other term, class member symbol on\n          \
      1st slot of Rule or RuleDelayed argument behaves like\n                evaluating with implicit Literal[]) One can configure\
\n                Constructor[] in the definition of the class.\n                x = c[arg] returns the returned value of Construc\
tor[arg].\n                The rules in the argument work in two ways: (1) A rule for an\n                instance variable or a c\
lass variable sets the initial value\n                of the variable, (2) Other rules are stored in an instance\n                \
variable Options as a list.\n\nDestructor:     An instance x is cleared by (x=.), which invokes \n                x@Destructor[]. \
The default Destructor is Object`Destructor,\n                but one can reconfigure it in the definition of the class.\n\nShort:\
          When an instance x is returned as the result of expression\n                for Out[], x@Short[] is invoked to show the \
result. The \n                default Short is Object`Short, but one can reconfigure it\n                in the definition of the \
class.\n\nother methods:  Class[] gives the class of the instance.\n                Parents[] gives the immediate superclasses.\n \
               AllParents[] gives the all superclasses.\n                Members[] gives a list of class variables, class methods,\
\n                and instance variables of the class.\n                AllMembers[] gives a list of class variables, class method\
s,\n                and instance variables of the class and its all parents."[p2$2453,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L267>Member(@)</A></PRE>
<UL>
<LI>
<H3><A NAME=L447>
Class</A></H3>
<PRE>If[{},
Help2HTML`oA$["Class sets up a class of objects.\n\nUsage:   a = Class[\n               list of superclasses,\n               list\
 of class-variables,\n               list of instance-variables,\n               class-methods];\n\nExample: a = Class[\n         \
      {aa, bb},      (* aa and bb are superclasses *)\n               {a1, a2},      (* class-variables *)\n               {v1, v2\
},      (* instance-variables *)\n               Constructor[arg__] := (Print[{arg}]; v1 = Plus[arg]);\n               sum[] := v1\
 + v2 (* defining Constructor and method \"sum\"*)\n             ];\n\n         a1 = a[1, 2]          (* creating an instance of a\
 *)\n         a1@v1                 (* accessing an instance variable *)\n         a1@v2 = 3             (* setting an instance va\
riable *)\n         a1@sum[]              (* calling a method \"sum\" *)\n         a1=.                  (* delete an instance *)"
  ],
p$2456=1+p$2456[[1,2]];p1$2456=StringPosition["Class sets up a class of objects.\n\nUsage:   a = Class[\n               list of su\
perclasses,\n               list of class-variables,\n               list of instance-variables,\n               class-methods];\n\
\nExample: a = Class[\n               {aa, bb},      (* aa and bb are superclasses *)\n               {a1, a2},      (* class-vari\
ables *)\n               {v1, v2},      (* instance-variables *)\n               Constructor[arg__] := (Print[{arg}]; v1 = Plus[ar\
g]);\n               sum[] := v1 + v2 (* defining Constructor and method \"sum\"*)\n             ];\n\n         a1 = a[1, 2]      \
    (* creating an instance of a *)\n         a1@v1                 (* accessing an instance variable *)\n         a1@v2 = 3      \
       (* setting an instance variable *)\n         a1@sum[]              (* calling a method \"sum\" *)\n         a1=.           \
       (* delete an instance *)"[p$2456,-1],">::",1];
   p1$2456=If[p1$2456==={},870,-2+p$2456+p1$2456[[1,1]]];
neq=Which["Class sets up a class of objects.\n\nUsage:   a = Class[\n               list of superclasses,\n               list of \
class-variables,\n               list of instance-variables,\n               class-methods];\n\nExample: a = Class[\n             \
  {aa, bb},      (* aa and bb are superclasses *)\n               {a1, a2},      (* class-variables *)\n               {v1, v2},  \
    (* instance-variables *)\n               Constructor[arg__] := (Print[{arg}]; v1 = Plus[arg]);\n               sum[] := v1 + v\
2 (* defining Constructor and method \"sum\"*)\n             ];\n\n         a1 = a[1, 2]          (* creating an instance of a *)\\
n         a1@v1                 (* accessing an instance variable *)\n         a1@v2 = 3             (* setting an instance variab\
le *)\n         a1@sum[]              (* calling a method \"sum\" *)\n         a1=.                  (* delete an instance *)"[p
      $2456,4+p$2456]===
     "Text[",
lx$2456:=Help2HTML`oa$;p$2456=5+p$2456;p1$2456-=1;p2$2456=5+p1$2456;p0$2456=-9+p$2456;If[(pe$2456=StringPosition["Class sets up a \
class of objects.\n\nUsage:   a = Class[\n               list of superclasses,\n               list of class-variables,\n         \
      list of instance-variables,\n               class-methods];\n\nExample: a = Class[\n               {aa, bb},      (* aa and \
bb are superclasses *)\n               {a1, a2},      (* class-variables *)\n               {v1, v2},      (* instance-variables *\
)\n               Constructor[arg__] := (Print[{arg}]; v1 = Plus[arg]);\n               sum[] := v1 + v2 (* defining Constructor a\
nd method \"sum\"*)\n             ];\n\n         a1 = a[1, 2]          (* creating an instance of a *)\n         a1@v1            \
     (* accessing an instance variable *)\n         a1@v2 = 3             (* setting an instance variable *)\n         a1@sum[]   \
           (* calling a method \"sum\" *)\n         a1=.                  (* delete an instance *)"[p$2456,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Class sets up a class of objects.\n\nUsage:   a = Class[\n               list of superclasses,\n               li\
st of class-variables,\n               list of instance-variables,\n               class-methods];\n\nExample: a = Class[\n       \
        {aa, bb},      (* aa and bb are superclasses *)\n               {a1, a2},      (* class-variables *)\n               {v1, \
v2},      (* instance-variables *)\n               Constructor[arg__] := (Print[{arg}]; v1 = Plus[arg]);\n               sum[] := \
v1 + v2 (* defining Constructor and method \"sum\"*)\n             ];\n\n         a1 = a[1, 2]          (* creating an instance of\
 a *)\n         a1@v1                 (* accessing an instance variable *)\n         a1@v2 = 3             (* setting an instance \
variable *)\n         a1@sum[]              (* calling a method \"sum\" *)\n         a1=.                  (* delete an instance *\
)"[p$2456+pe$2456[[1,2]],p1$2456]]],
        p1$2456=-2+p$2456+pe$2456[[1,1]]}[[
       1]],
      0],
    1,lx$2456:=Help2HTML`o9$;p2$2456=4+p1$2456;p0$2456=-4+p$2456;0];
  If[(equ$2456=
Help2HTML`o8$["Class sets up a class of objects.\n\nUsage:   a = Class[\n               list of superclasses,\n               list\
 of class-variables,\n               list of instance-variables,\n               class-methods];\n\nExample: a = Class[\n         \
      {aa, bb},      (* aa and bb are superclasses *)\n               {a1, a2},      (* class-variables *)\n               {v1, v2\
},      (* instance-variables *)\n               Constructor[arg__] := (Print[{arg}]; v1 = Plus[arg]);\n               sum[] := v1\
 + v2 (* defining Constructor and method \"sum\"*)\n             ];\n\n         a1 = a[1, 2]          (* creating an instance of a\
 *)\n         a1@v1                 (* accessing an instance variable *)\n         a1@v2 = 3             (* setting an instance va\
riable *)\n         a1@sum[]              (* calling a method \"sum\" *)\n         a1=.                  (* delete an instance *)"[
       p$2456,p1$2456]])===
    Undefined,
equ$2456="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Class sets up a class of objects.\n\nUsage: \
  a = Class[\n               list of superclasses,\n               list of class-variables,\n               list of instance-varia\
bles,\n               class-methods];\n\nExample: a = Class[\n               {aa, bb},      (* aa and bb are superclasses *)\n    \
           {a1, a2},      (* class-variables *)\n               {v1, v2},      (* instance-variables *)\n               Constructo\
r[arg__] := (Print[{arg}]; v1 = Plus[arg]);\n               sum[] := v1 + v2 (* defining Constructor and method \"sum\"*)\n       \
      ];\n\n         a1 = a[1, 2]          (* creating an instance of a *)\n         a1@v1                 (* accessing an instanc\
e variable *)\n         a1@v2 = 3             (* setting an instance variable *)\n         a1@sum[]              (* calling a meth\
od \"sum\" *)\n         a1=.                  (* delete an instance *)"[p$2456,p1$2456]]=
       equ$2456;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2456},out$2456=lx$2456@Typeset["Class sets up a class of objects.\n\nUsage:   a = Class[\n               list of supercla\
sses,\n               list of class-variables,\n               list of instance-variables,\n               class-methods];\n\nExam\
ple: a = Class[\n               {aa, bb},      (* aa and bb are superclasses *)\n               {a1, a2},      (* class-variables \
*)\n               {v1, v2},      (* instance-variables *)\n               Constructor[arg__] := (Print[{arg}]; v1 = Plus[arg]);\n\
               sum[] := v1 + v2 (* defining Constructor and method \"sum\"*)\n             ];\n\n         a1 = a[1, 2]          (*\
 creating an instance of a *)\n         a1@v1                 (* accessing an instance variable *)\n         a1@v2 = 3            \
 (* setting an instance variable *)\n         a1@sum[]              (* calling a method \"sum\" *)\n         a1=.                 \
 (* delete an instance *)"[p$2456,p1$2456],Format->Help2HTML`oB$];
        System["mv -f "//out$2456//" "//equ$2456]];
      Exit[]]];
   "Class sets up a class of objects.\n\nUsage:   a = Class[\n               list of superclasses,\n               list of class-v\
ariables,\n               list of instance-variables,\n               class-methods];\n\nExample: a = Class[\n               {aa, \
bb},      (* aa and bb are superclasses *)\n               {a1, a2},      (* class-variables *)\n               {v1, v2},      (* \
instance-variables *)\n               Constructor[arg__] := (Print[{arg}]; v1 = Plus[arg]);\n               sum[] := v1 + v2 (* de\
fining Constructor and method \"sum\"*)\n             ];\n\n         a1 = a[1, 2]          (* creating an instance of a *)\n      \
   a1@v1                 (* accessing an instance variable *)\n         a1@v2 = 3             (* setting an instance variable *)\n\
         a1@sum[]              (* calling a method \"sum\" *)\n         a1=.                  (* delete an instance *)"[1,
    Max[p0$2456,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2456//"\" />"//
Help2HTML`oy$["Class sets up a class of objects.\n\nUsage:   a = Class[\n               list of superclasses,\n               list\
 of class-variables,\n               list of instance-variables,\n               class-methods];\n\nExample: a = Class[\n         \
      {aa, bb},      (* aa and bb are superclasses *)\n               {a1, a2},      (* class-variables *)\n               {v1, v2\
},      (* instance-variables *)\n               Constructor[arg__] := (Print[{arg}]; v1 = Plus[arg]);\n               sum[] := v1\
 + v2 (* defining Constructor and method \"sum\"*)\n             ];\n\n         a1 = a[1, 2]          (* creating an instance of a\
 *)\n         a1@v1                 (* accessing an instance variable *)\n         a1@v2 = 3             (* setting an instance va\
riable *)\n         a1@sum[]              (* calling a method \"sum\" *)\n         a1=.                  (* delete an instance *)"[
     p2$2456,-1]]
]</PRE>
</UL>
<LI>
<H3><A NAME=L448>
Random-number-functions</A></H3>
<PRE>If[{},
Help2HTML`oA$["The random number functions use common seed given by SEED command or SeedRandom function. It has an initial value 1\
7 at the beginning of FFS. The cut-off value of GaussRandom[] is given by variable GCUT."],
 p$2458=1+p$2458[[1,2]];p1$2458=StringPosition["The random number functions use common seed given by SEED command or SeedRandom fu\
nction. It has an initial value 17 at the beginning of FFS. The cut-off value of GaussRandom[] is given by variable GCUT."[p$2458,
     -1],
    ">::",1];
   p1$2458=If[p1$2458==={},203,-2+p$2458+p1$2458[[1,1]]];
neq=Which["The random number functions use common seed given by SEED command or SeedRandom function. It has an initial value 17 at\
 the beginning of FFS. The cut-off value of GaussRandom[] is given by variable GCUT."[p$2458,4+p$2458]==="Text[",
    lx$2458:=Help2HTML`oa$;p$2458=5+p$2458;p1$2458-=1;p2$2458=5+p1$2458;p0$2458=-9+p$2458;
If[(pe$2458=StringPosition["The random number functions use common seed given by SEED command or SeedRandom function. It has an in\
itial value 17 at the beginning of FFS. The cut-off value of GaussRandom[] is given by variable GCUT."[p$2458,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["The random number functions use common seed given by SEED command or SeedRandom function. It has an initial value\
 17 at the beginning of FFS. The cut-off value of GaussRandom[] is given by variable GCUT."[p$2458+pe$2458[[1,2]],p1$2458]]],
        p1$2458=-2+p$2458+pe$2458[[1,1]]}[[
       1]],
      0],
    1,lx$2458:=Help2HTML`o9$;p2$2458=4+p1$2458;p0$2458=-4+p$2458;0];
  If[(equ$2458=
Help2HTML`o8$["The random number functions use common seed given by SEED command or SeedRandom function. It has an initial value 1\
7 at the beginning of FFS. The cut-off value of GaussRandom[] is given by variable GCUT."[p$2458,p1$2458]])===
    Undefined,
equ$2458="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["The random number functions use common seed \
given by SEED command or SeedRandom function. It has an initial value 17 at the beginning of FFS. The cut-off value of GaussRandom\
[] is given by variable GCUT."[p$2458,p1$2458]]=
       equ$2458;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2458},out$2458=lx$2458@Typeset["The random number functions use common seed given by SEED command or SeedRandom function.\
 It has an initial value 17 at the beginning of FFS. The cut-off value of GaussRandom[] is given by variable GCUT."[p$2458,p1$2458
           ],Format->Help2HTML`oB$];
        System["mv -f "//out$2458//" "//equ$2458]];
      Exit[]]];
   "The random number functions use common seed given by SEED command or SeedRandom function. It has an initial value 17 at the be\
ginning of FFS. The cut-off value of GaussRandom[] is given by variable GCUT."[1,Max[p0$2458,0]]//"<img  class=\"eqs\" SRC=\""//
   equ$2458//"\" />"//
Help2HTML`oy$["The random number functions use common seed given by SEED command or SeedRandom function. It has an initial value 1\
7 at the beginning of FFS. The cut-off value of GaussRandom[] is given by variable GCUT."[p2$2458,-1]]
]</PRE>
<PRE>See also:
 special-variables: <A HREF=#L523>GCUT</A></PRE>
<UL>
<LI>
<H3><A NAME=L449>
Random</A></H3>
<PRE>If[{},
Help2HTML`oA$["Random[]           gives a uniform random number between 0 and 1.\nRandom[n]          gives a list of n uniform ran\
dom numbers.\nRandom[n1, n2, ..] gives a (n1 * n2 * .. ) tensor of uniform random numbers."],
 p$2461=1+p$2461[[1,2]];p1$2461=StringPosition["Random[]           gives a uniform random number between 0 and 1.\nRandom[n]      \
    gives a list of n uniform random numbers.\nRandom[n1, n2, ..] gives a (n1 * n2 * .. ) tensor of uniform random numbers."[p$2461
     ,-1],
    ">::",1];
   p1$2461=If[p1$2461==={},203,-2+p$2461+p1$2461[[1,1]]];
neq=Which["Random[]           gives a uniform random number between 0 and 1.\nRandom[n]          gives a list of n uniform random \
numbers.\nRandom[n1, n2, ..] gives a (n1 * n2 * .. ) tensor of uniform random numbers."[p$2461,4+p$2461]==="Text[",
    lx$2461:=Help2HTML`oa$;p$2461=5+p$2461;p1$2461-=1;p2$2461=5+p1$2461;p0$2461=-9+p$2461;
If[(pe$2461=StringPosition["Random[]           gives a uniform random number between 0 and 1.\nRandom[n]          gives a list of \
n uniform random numbers.\nRandom[n1, n2, ..] gives a (n1 * n2 * .. ) tensor of uniform random numbers."[p$2461,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Random[]           gives a uniform random number between 0 and 1.\nRandom[n]          gives a list of n uniform r\
andom numbers.\nRandom[n1, n2, ..] gives a (n1 * n2 * .. ) tensor of uniform random numbers."[p$2461+pe$2461[[1,2]],p1$2461]]],
        p1$2461=-2+p$2461+pe$2461[[1,1]]}[[
       1]],
      0],
    1,lx$2461:=Help2HTML`o9$;p2$2461=4+p1$2461;p0$2461=-4+p$2461;0];
  If[(equ$2461=
Help2HTML`o8$["Random[]           gives a uniform random number between 0 and 1.\nRandom[n]          gives a list of n uniform ran\
dom numbers.\nRandom[n1, n2, ..] gives a (n1 * n2 * .. ) tensor of uniform random numbers."[p$2461,p1$2461]])===
    Undefined,
equ$2461="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Random[]           gives a uniform random nu\
mber between 0 and 1.\nRandom[n]          gives a list of n uniform random numbers.\nRandom[n1, n2, ..] gives a (n1 * n2 * .. ) te\
nsor of uniform random numbers."[p$2461,p1$2461]]=
       equ$2461;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2461},out$2461=lx$2461@Typeset["Random[]           gives a uniform random number between 0 and 1.\nRandom[n]          giv\
es a list of n uniform random numbers.\nRandom[n1, n2, ..] gives a (n1 * n2 * .. ) tensor of uniform random numbers."[p$2461,
           p1$2461],Format->Help2HTML`oB$];
        System["mv -f "//out$2461//" "//equ$2461]];
      Exit[]]];
   "Random[]           gives a uniform random number between 0 and 1.\nRandom[n]          gives a list of n uniform random numbers\
.\nRandom[n1, n2, ..] gives a (n1 * n2 * .. ) tensor of uniform random numbers."[1,Max[p0$2461,0]]//"<img  class=\"eqs\" SRC=\""//
   equ$2461//"\" />"//
Help2HTML`oy$["Random[]           gives a uniform random number between 0 and 1.\nRandom[n]          gives a list of n uniform ran\
dom numbers.\nRandom[n1, n2, ..] gives a (n1 * n2 * .. ) tensor of uniform random numbers."[p2$2461,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L450>GaussRandom</A> <A HREF=#L451>ParabolaRandom</A> <A HREF=#L452>SeedRandom</A></PRE>
<LI>
<H3><A NAME=L450>
GaussRandom</A></H3>
<PRE>If[{},
Help2HTML`oA$["GaussRandom[]           gives a Gaussian random number with average 0, \n                        standard deviation\
 1, cutoff at GCUT.\nGaussRandom[n]          gives a list of n Gaussian random numbers.\nGaussRandom[n1, n2, ..] gives a (n1 * n2 \
* .. ) tensor of Gaussian random\n                        numbers."],
p$2464=1+p$2464[[1,2]];p1$2464=StringPosition["GaussRandom[]           gives a Gaussian random number with average 0, \n          \
              standard deviation 1, cutoff at GCUT.\nGaussRandom[n]          gives a list of n Gaussian random numbers.\nGaussRand\
om[n1, n2, ..] gives a (n1 * n2 * .. ) tensor of Gaussian random\n                        numbers."[p$2464,-1],">::",1];
   p1$2464=If[p1$2464==={},307,-2+p$2464+p1$2464[[1,1]]];
neq=Which["GaussRandom[]           gives a Gaussian random number with average 0, \n                        standard deviation 1, \
cutoff at GCUT.\nGaussRandom[n]          gives a list of n Gaussian random numbers.\nGaussRandom[n1, n2, ..] gives a (n1 * n2 * ..\
 ) tensor of Gaussian random\n                        numbers."[p$2464,4+p$2464]==="Text[",
    lx$2464:=Help2HTML`oa$;p$2464=5+p$2464;p1$2464-=1;p2$2464=5+p1$2464;p0$2464=-9+p$2464;
If[(pe$2464=StringPosition["GaussRandom[]           gives a Gaussian random number with average 0, \n                        stand\
ard deviation 1, cutoff at GCUT.\nGaussRandom[n]          gives a list of n Gaussian random numbers.\nGaussRandom[n1, n2, ..] give\
s a (n1 * n2 * .. ) tensor of Gaussian random\n                        numbers."[p$2464,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["GaussRandom[]           gives a Gaussian random number with average 0, \n                        standard deviati\
on 1, cutoff at GCUT.\nGaussRandom[n]          gives a list of n Gaussian random numbers.\nGaussRandom[n1, n2, ..] gives a (n1 * n\
2 * .. ) tensor of Gaussian random\n                        numbers."[p$2464+pe$2464[[1,2]],p1$2464]]],
        p1$2464=-2+p$2464+pe$2464[[1,1]]}[[
       1]],
      0],
    1,lx$2464:=Help2HTML`o9$;p2$2464=4+p1$2464;p0$2464=-4+p$2464;0];
  If[(equ$2464=
Help2HTML`o8$["GaussRandom[]           gives a Gaussian random number with average 0, \n                        standard deviation\
 1, cutoff at GCUT.\nGaussRandom[n]          gives a list of n Gaussian random numbers.\nGaussRandom[n1, n2, ..] gives a (n1 * n2 \
* .. ) tensor of Gaussian random\n                        numbers."[p$2464,p1$2464]])===
    Undefined,
equ$2464="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["GaussRandom[]           gives a Gaussian ran\
dom number with average 0, \n                        standard deviation 1, cutoff at GCUT.\nGaussRandom[n]          gives a list o\
f n Gaussian random numbers.\nGaussRandom[n1, n2, ..] gives a (n1 * n2 * .. ) tensor of Gaussian random\n                        n\
umbers."[p$2464,p1$2464]]=
       equ$2464;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2464},out$2464=lx$2464@Typeset["GaussRandom[]           gives a Gaussian random number with average 0, \n                \
        standard deviation 1, cutoff at GCUT.\nGaussRandom[n]          gives a list of n Gaussian random numbers.\nGaussRandom[n1,\
 n2, ..] gives a (n1 * n2 * .. ) tensor of Gaussian random\n                        numbers."[p$2464,p1$2464],
          Format->Help2HTML`oB$];
        System["mv -f "//out$2464//" "//equ$2464]];
      Exit[]]];
   "GaussRandom[]           gives a Gaussian random number with average 0, \n                        standard deviation 1, cutoff \
at GCUT.\nGaussRandom[n]          gives a list of n Gaussian random numbers.\nGaussRandom[n1, n2, ..] gives a (n1 * n2 * .. ) tens\
or of Gaussian random\n                        numbers."[1,Max[p0$2464,0]]//"<img  class=\"eqs\" SRC=\""//equ$2464//"\" />"//
   Help2HTML`oy$["GaussRandom[]           gives a Gaussian random number with average 0, \n                        standard deviat\
ion 1, cutoff at GCUT.\nGaussRandom[n]          gives a list of n Gaussian random numbers.\nGaussRandom[n1, n2, ..] gives a (n1 * \
n2 * .. ) tensor of Gaussian random\n                        numbers."[p2$2464,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L449>Random</A> <A HREF=#L451>ParabolaRandom</A> <A HREF=#L452>SeedRandom</A></PRE>
<LI>
<H3><A NAME=L451>
ParabolaRandom</A></H3>
<PRE>If[{},
Help2HTML`oA$["ParabolaRandom[]           gives a parabola random number between -1 and 1. \nParabolaRandom[n]          gives a li\
st of n parabola random numbers.\nParabolaRandom[n1, n2, ..] gives a (n1 * n2 * .. ) tensor of parabola random\n                  \
         numbers."],
p$2467=1+p$2467[[1,2]];p1$2467=StringPosition["ParabolaRandom[]           gives a parabola random number between -1 and 1. \nParab\
olaRandom[n]          gives a list of n parabola random numbers.\nParabolaRandom[n1, n2, ..] gives a (n1 * n2 * .. ) tensor of par\
abola random\n                           numbers."[p$2467,-1],">::",1];
   p1$2467=If[p1$2467==={},259,-2+p$2467+p1$2467[[1,1]]];
neq=Which["ParabolaRandom[]           gives a parabola random number between -1 and 1. \nParabolaRandom[n]          gives a list o\
f n parabola random numbers.\nParabolaRandom[n1, n2, ..] gives a (n1 * n2 * .. ) tensor of parabola random\n                      \
     numbers."[p$2467,4+p$2467]==="Text[",
    lx$2467:=Help2HTML`oa$;p$2467=5+p$2467;p1$2467-=1;p2$2467=5+p1$2467;p0$2467=-9+p$2467;If[(pe$2467=
StringPosition["ParabolaRandom[]           gives a parabola random number between -1 and 1. \nParabolaRandom[n]          gives a l\
ist of n parabola random numbers.\nParabolaRandom[n1, n2, ..] gives a (n1 * n2 * .. ) tensor of parabola random\n                 \
          numbers."[p$2467,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["ParabolaRandom[]           gives a parabola random number between -1 and 1. \nParabolaRandom[n]          gives a \
list of n parabola random numbers.\nParabolaRandom[n1, n2, ..] gives a (n1 * n2 * .. ) tensor of parabola random\n                \
           numbers."[p$2467+pe$2467[[1,2]],p1$2467]]],
        p1$2467=-2+p$2467+pe$2467[[1,1]]}[[
       1]],
      0],
    1,lx$2467:=Help2HTML`o9$;p2$2467=4+p1$2467;p0$2467=-4+p$2467;0];
  If[(equ$2467=
Help2HTML`o8$["ParabolaRandom[]           gives a parabola random number between -1 and 1. \nParabolaRandom[n]          gives a li\
st of n parabola random numbers.\nParabolaRandom[n1, n2, ..] gives a (n1 * n2 * .. ) tensor of parabola random\n                  \
         numbers."[p$2467,p1$2467]])===
    Undefined,
equ$2467="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["ParabolaRandom[]           gives a parabola \
random number between -1 and 1. \nParabolaRandom[n]          gives a list of n parabola random numbers.\nParabolaRandom[n1, n2, ..\
] gives a (n1 * n2 * .. ) tensor of parabola random\n                           numbers."[p$2467,p1$2467]]=
       equ$2467;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2467},out$2467=lx$2467@Typeset["ParabolaRandom[]           gives a parabola random number between -1 and 1. \nParabolaRan\
dom[n]          gives a list of n parabola random numbers.\nParabolaRandom[n1, n2, ..] gives a (n1 * n2 * .. ) tensor of parabola \
random\n                           numbers."[p$2467,p1$2467],Format->Help2HTML`oB$];
        System["mv -f "//out$2467//" "//equ$2467]];
      Exit[]]];
   "ParabolaRandom[]           gives a parabola random number between -1 and 1. \nParabolaRandom[n]          gives a list of n par\
abola random numbers.\nParabolaRandom[n1, n2, ..] gives a (n1 * n2 * .. ) tensor of parabola random\n                           nu\
mbers."[1,Max[p0$2467,0]]//"<img  class=\"eqs\" SRC=\""//equ$2467//"\" />"//
Help2HTML`oy$["ParabolaRandom[]           gives a parabola random number between -1 and 1. \nParabolaRandom[n]          gives a li\
st of n parabola random numbers.\nParabolaRandom[n1, n2, ..] gives a (n1 * n2 * .. ) tensor of parabola random\n                  \
         numbers."[p2$2467,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L449>Random</A> <A HREF=#L450>GaussRandom</A> <A HREF=#L452>SeedRandom</A></PRE>
<LI>
<H3><A NAME=L452>
SeedRandom</A></H3>
<PRE>If[{},
Help2HTML`oA$["SeedRandom[plugin_String] selects new pseudo random-number generator\n                          plugin named as plu\
gin.\nSeedRandom[seed_Real]     initializes the internal state of the current\n                          pseudo random-number gene\
rator plugin by seed.\nSeedRandom[{seeds__Real}] initializes the internal state of the current\n                          pseudo r\
andom-number generator plugin by {seeds}.\nSeedRadnom[state_List]    restores both the selection of the pseudo random-number\n    \
                      generator plugin and the internal state of the selected\n                          plugin by using state dum\
ped by SeedRandom[].\nSeedRandom[]              returns List containing both the current selected pseudo\n                        \
  random-number generator plugin name and its internal state."],
p$2470=1+p$2470[[1,2]];p1$2470=StringPosition["SeedRandom[plugin_String] selects new pseudo random-number generator\n             \
             plugin named as plugin.\nSeedRandom[seed_Real]     initializes the internal state of the current\n                   \
       pseudo random-number generator plugin by seed.\nSeedRandom[{seeds__Real}] initializes the internal state of the current\n  \
                        pseudo random-number generator plugin by {seeds}.\nSeedRadnom[state_List]    restores both the selection o\
f the pseudo random-number\n                          generator plugin and the internal state of the selected\n                   \
       plugin by using state dumped by SeedRandom[].\nSeedRandom[]              returns List containing both the current selected \
pseudo\n                          random-number generator plugin name and its internal state."[p$2470,-1],">::",1];
   p1$2470=If[p1$2470==={},816,-2+p$2470+p1$2470[[1,1]]];
neq=Which["SeedRandom[plugin_String] selects new pseudo random-number generator\n                          plugin named as plugin.\
\nSeedRandom[seed_Real]     initializes the internal state of the current\n                          pseudo random-number generato\
r plugin by seed.\nSeedRandom[{seeds__Real}] initializes the internal state of the current\n                          pseudo rando\
m-number generator plugin by {seeds}.\nSeedRadnom[state_List]    restores both the selection of the pseudo random-number\n        \
                  generator plugin and the internal state of the selected\n                          plugin by using state dumped \
by SeedRandom[].\nSeedRandom[]              returns List containing both the current selected pseudo\n                          ra\
ndom-number generator plugin name and its internal state."[p$2470,4+p$2470]==="Text[",
    lx$2470:=Help2HTML`oa$;p$2470=5+p$2470;p1$2470-=1;p2$2470=5+p1$2470;p0$2470=-9+p$2470;
If[(pe$2470=StringPosition["SeedRandom[plugin_String] selects new pseudo random-number generator\n                          plugin\
 named as plugin.\nSeedRandom[seed_Real]     initializes the internal state of the current\n                          pseudo rando\
m-number generator plugin by seed.\nSeedRandom[{seeds__Real}] initializes the internal state of the current\n                     \
     pseudo random-number generator plugin by {seeds}.\nSeedRadnom[state_List]    restores both the selection of the pseudo random\
-number\n                          generator plugin and the internal state of the selected\n                          plugin by us\
ing state dumped by SeedRandom[].\nSeedRandom[]              returns List containing both the current selected pseudo\n           \
               random-number generator plugin name and its internal state."[p$2470,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["SeedRandom[plugin_String] selects new pseudo random-number generator\n                          plugin named as p\
lugin.\nSeedRandom[seed_Real]     initializes the internal state of the current\n                          pseudo random-number ge\
nerator plugin by seed.\nSeedRandom[{seeds__Real}] initializes the internal state of the current\n                          pseudo\
 random-number generator plugin by {seeds}.\nSeedRadnom[state_List]    restores both the selection of the pseudo random-number\n  \
                        generator plugin and the internal state of the selected\n                          plugin by using state d\
umped by SeedRandom[].\nSeedRandom[]              returns List containing both the current selected pseudo\n                      \
    random-number generator plugin name and its internal state."[p$2470+pe$2470[[1,2]],p1$2470]]],
        p1$2470=-2+p$2470+pe$2470[[1,1]]}[[
       1]],
      0],
    1,lx$2470:=Help2HTML`o9$;p2$2470=4+p1$2470;p0$2470=-4+p$2470;0];
  If[(equ$2470=
Help2HTML`o8$["SeedRandom[plugin_String] selects new pseudo random-number generator\n                          plugin named as plu\
gin.\nSeedRandom[seed_Real]     initializes the internal state of the current\n                          pseudo random-number gene\
rator plugin by seed.\nSeedRandom[{seeds__Real}] initializes the internal state of the current\n                          pseudo r\
andom-number generator plugin by {seeds}.\nSeedRadnom[state_List]    restores both the selection of the pseudo random-number\n    \
                      generator plugin and the internal state of the selected\n                          plugin by using state dum\
ped by SeedRandom[].\nSeedRandom[]              returns List containing both the current selected pseudo\n                        \
  random-number generator plugin name and its internal state."[p$2470,p1$2470]])===
    Undefined,
equ$2470="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["SeedRandom[plugin_String] selects new pseudo\
 random-number generator\n                          plugin named as plugin.\nSeedRandom[seed_Real]     initializes the internal st\
ate of the current\n                          pseudo random-number generator plugin by seed.\nSeedRandom[{seeds__Real}] initialize\
s the internal state of the current\n                          pseudo random-number generator plugin by {seeds}.\nSeedRadnom[state\
_List]    restores both the selection of the pseudo random-number\n                          generator plugin and the internal sta\
te of the selected\n                          plugin by using state dumped by SeedRandom[].\nSeedRandom[]              returns Lis\
t containing both the current selected pseudo\n                          random-number generator plugin name and its internal stat\
e."[p$2470,p1$2470]]=
       equ$2470;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2470},out$2470=lx$2470@Typeset["SeedRandom[plugin_String] selects new pseudo random-number generator\n                   \
       plugin named as plugin.\nSeedRandom[seed_Real]     initializes the internal state of the current\n                         \
 pseudo random-number generator plugin by seed.\nSeedRandom[{seeds__Real}] initializes the internal state of the current\n        \
                  pseudo random-number generator plugin by {seeds}.\nSeedRadnom[state_List]    restores both the selection of the \
pseudo random-number\n                          generator plugin and the internal state of the selected\n                         \
 plugin by using state dumped by SeedRandom[].\nSeedRandom[]              returns List containing both the current selected pseudo\
\n                          random-number generator plugin name and its internal state."[p$2470,p1$2470],Format->Help2HTML`oB$];
        System["mv -f "//out$2470//" "//equ$2470]];
      Exit[]]];
   "SeedRandom[plugin_String] selects new pseudo random-number generator\n                          plugin named as plugin.\nSeedR\
andom[seed_Real]     initializes the internal state of the current\n                          pseudo random-number generator plugi\
n by seed.\nSeedRandom[{seeds__Real}] initializes the internal state of the current\n                          pseudo random-numbe\
r generator plugin by {seeds}.\nSeedRadnom[state_List]    restores both the selection of the pseudo random-number\n               \
           generator plugin and the internal state of the selected\n                          plugin by using state dumped by Seed\
Random[].\nSeedRandom[]              returns List containing both the current selected pseudo\n                          random-nu\
mber generator plugin name and its internal state."[1,Max[p0$2470,0]]//"<img  class=\"eqs\" SRC=\""//equ$2470//"\" />"//
   Help2HTML`oy$["SeedRandom[plugin_String] selects new pseudo random-number generator\n                          plugin named as \
plugin.\nSeedRandom[seed_Real]     initializes the internal state of the current\n                          pseudo random-number g\
enerator plugin by seed.\nSeedRandom[{seeds__Real}] initializes the internal state of the current\n                          pseud\
o random-number generator plugin by {seeds}.\nSeedRadnom[state_List]    restores both the selection of the pseudo random-number\n \
                         generator plugin and the internal state of the selected\n                          plugin by using state \
dumped by SeedRandom[].\nSeedRandom[]              returns List containing both the current selected pseudo\n                     \
     random-number generator plugin name and its internal state."[p2$2470,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L453>ListRandom</A> <A HREF=#L449>Random</A> <A HREF=#L450>GaussRandom</A> <A HREF=#L451>ParabolaRandom</A></PRE>
<LI>
<H3><A NAME=L453>
ListRandom</A></H3>
<PRE>If[{},Help2HTML`oA$["ListRandom[] returns List of available pseudo random-number generator plugins."],
 p$2473=1+p$2473[[1,2]];p1$2473=
   StringPosition["ListRandom[] returns List of available pseudo random-number generator plugins."[p$2473,-1],">::",1];
  p1$2473=If[p1$2473==={},78,-2+p$2473+p1$2473[[1,1]]];
  neq=Which["ListRandom[] returns List of available pseudo random-number generator plugins."[p$2473,4+p$2473]==="Text[",
    lx$2473:=Help2HTML`oa$;p$2473=5+p$2473;p1$2473-=1;p2$2473=5+p1$2473;p0$2473=-9+p$2473;
     If[(pe$2473=StringPosition["ListRandom[] returns List of available pseudo random-number generator plugins."[p$2473,-2],";;;"]
        )<=>
       {},
      {Max[0,
        -1+ToExpression["ListRandom[] returns List of available pseudo random-number generator plugins."[p$2473+pe$2473[[1,2]],
           p1$2473]]],
        p1$2473=-2+p$2473+pe$2473[[1,1]]}[[
       1]],
      0],
    1,lx$2473:=Help2HTML`o9$;p2$2473=4+p1$2473;p0$2473=-4+p$2473;0];
  If[(equ$2473=Help2HTML`o8$["ListRandom[] returns List of available pseudo random-number generator plugins."[p$2473,p1$2473]])===
    Undefined,
   equ$2473="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "ListRandom[] returns List of available pseudo random-number generator plugins."[p$2473,p1$2473]]=
       equ$2473;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$2473},out$2473=lx$2473@Typeset["ListRandom[] returns List of available pseudo random-number generator plugins."[p
           $2473,p1$2473],Format->Help2HTML`oB$];
        System["mv -f "//out$2473//" "//equ$2473]];
      Exit[]]];
   "ListRandom[] returns List of available pseudo random-number generator plugins."[1,Max[p0$2473,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2473//"\" />"//
   Help2HTML`oy$["ListRandom[] returns List of available pseudo random-number generator plugins."[p2$2473,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L452>SeedRandom</A></PRE>
</UL>
<LI>
<H3><A NAME=L454>
System-interface</A></H3>
<PRE>
</PRE>
<UL>
<LI>
<H3><A NAME=L455>
System</A></H3>
<PRE>If[{},Help2HTML`oA$["System[string] executes string as a shell command. It returns the system return code."],
 p$2477=1+p$2477[[1,2]];
  p1$2477=StringPosition["System[string] executes string as a shell command. It returns the system return code."[p$2477,-1],">::",
    1];
   p1$2477=If[p1$2477==={},85,-2+p$2477+p1$2477[[1,1]]];
  neq=Which["System[string] executes string as a shell command. It returns the system return code."[p$2477,4+p$2477]==="Text[",
    lx$2477:=Help2HTML`oa$;p$2477=5+p$2477;p1$2477-=1;p2$2477=5+p1$2477;p0$2477=-9+p$2477;
     If[(pe$2477=StringPosition["System[string] executes string as a shell command. It returns the system return code."[p$2477,-2],
         ";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression["System[string] executes string as a shell command. It returns the system return code."[p$2477+pe$2477[[1,
             2]],
           p1$2477]]],
        p1$2477=-2+p$2477+pe$2477[[1,1]]}[[
       1]],
      0],
    1,lx$2477:=Help2HTML`o9$;p2$2477=4+p1$2477;p0$2477=-4+p$2477;0];
  If[(equ$2477=
     Help2HTML`o8$["System[string] executes string as a shell command. It returns the system return code."[p$2477,p1$2477]])===
    Undefined,
   equ$2477="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "System[string] executes string as a shell command. It returns the system return code."[p$2477,p1$2477]]=
       equ$2477;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$2477},out$2477=lx$2477@Typeset[
          "System[string] executes string as a shell command. It returns the system return code."[p$2477,p1$2477],
          Format->Help2HTML`oB$];
        System["mv -f "//out$2477//" "//equ$2477]];
      Exit[]]];
   "System[string] executes string as a shell command. It returns the system return code."[1,Max[p0$2477,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2477//"\" />"//
   Help2HTML`oy$["System[string] executes string as a shell command. It returns the system return code."[p2$2477,-1]]
]</PRE>
<LI>
<H3><A NAME=L456>
TemporaryName</A></H3>
<PRE>If[{},Help2HTML`oA$["TemporaryName[] returns a unique file name for a temporary use."],
 p$2479=1+p$2479[[1,2]];p1$2479=StringPosition["TemporaryName[] returns a unique file name for a temporary use."[p$2479,-1],">::",
    1];
   p1$2479=If[p1$2479==={},63,-2+p$2479+p1$2479[[1,1]]];
  neq=Which["TemporaryName[] returns a unique file name for a temporary use."[p$2479,4+p$2479]==="Text[",
    lx$2479:=Help2HTML`oa$;p$2479=5+p$2479;p1$2479-=1;p2$2479=5+p1$2479;p0$2479=-9+p$2479;
     If[(pe$2479=StringPosition["TemporaryName[] returns a unique file name for a temporary use."[p$2479,-2],";;;"])<=>{},
      {Max[0,-1+ToExpression["TemporaryName[] returns a unique file name for a temporary use."[p$2479+pe$2479[[1,2]],p1$2479]]],
       p1$2479=-2+p$2479+pe$2479[[1,1]]}[[1]],
      0],
    1,lx$2479:=Help2HTML`o9$;p2$2479=4+p1$2479;p0$2479=-4+p$2479;0];
  If[(equ$2479=Help2HTML`o8$["TemporaryName[] returns a unique file name for a temporary use."[p$2479,p1$2479]])===Undefined,
   equ$2479="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["TemporaryName[] returns a unique file name for a temporary use."[p$2479,p1$2479]]=equ$2479;
      LaTeX`ob$+=neq,
     --LaTeX`ob$;With[{lx$2479},out$2479=lx$2479@Typeset["TemporaryName[] returns a unique file name for a temporary use."[p$2479,
           p1$2479],Format->Help2HTML`oB$];
        System["mv -f "//out$2479//" "//equ$2479]];
      Exit[]]];
   "TemporaryName[] returns a unique file name for a temporary use."[1,Max[p0$2479,0]]//"<img  class=\"eqs\" SRC=\""//equ$2479//
   "\" />"//Help2HTML`oy$["TemporaryName[] returns a unique file name for a temporary use."[p2$2479,-1]]
]</PRE>
</UL>
<LI>
<H3><A NAME=L457>
Utilities</A></H3>
<PRE>
</PRE>
<UL>
<LI>
<H3><A NAME=L458>
DateString</A></H3>
<PRE>If[{},
Help2HTML`oA$[" DateString[] returns the current date and time as string  \"mm/dd/CCYY HH:MM:SS\".\n DateString[date] converts dat\
e to string as above. The date can be either a real number (in second, date=0 is 1/1/1900 0:0:0) or a list of 6 reals {Y,m,d,H,M,S\
}."],
p$2482=1+p$2482[[1,2]];p1$2482=StringPosition[" DateString[] returns the current date and time as string  \"mm/dd/CCYY HH:MM:SS\".\
\n DateString[date] converts date to string as above. The date can be either a real number (in second, date=0 is 1/1/1900 0:0:0) o\
r a list of 6 reals {Y,m,d,H,M,S}."[p$2482,-1],">::",1];
   p1$2482=If[p1$2482==={},244,-2+p$2482+p1$2482[[1,1]]];
neq=Which[" DateString[] returns the current date and time as string  \"mm/dd/CCYY HH:MM:SS\".\n DateString[date] converts date to\
 string as above. The date can be either a real number (in second, date=0 is 1/1/1900 0:0:0) or a list of 6 reals {Y,m,d,H,M,S}."[
      p$2482,4+p$2482]===
     "Text[",
lx$2482:=Help2HTML`oa$;p$2482=5+p$2482;p1$2482-=1;p2$2482=5+p1$2482;p0$2482=-9+p$2482;If[(pe$2482=StringPosition[" DateString[] re\
turns the current date and time as string  \"mm/dd/CCYY HH:MM:SS\".\n DateString[date] converts date to string as above. The date \
can be either a real number (in second, date=0 is 1/1/1900 0:0:0) or a list of 6 reals {Y,m,d,H,M,S}."[p$2482,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression[" DateString[] returns the current date and time as string  \"mm/dd/CCYY HH:MM:SS\".\n DateString[date] converts d\
ate to string as above. The date can be either a real number (in second, date=0 is 1/1/1900 0:0:0) or a list of 6 reals {Y,m,d,H,M\
,S}."[p$2482+pe$2482[[1,2]],p1$2482]]],
        p1$2482=-2+p$2482+pe$2482[[1,1]]}[[
       1]],
      0],
    1,lx$2482:=Help2HTML`o9$;p2$2482=4+p1$2482;p0$2482=-4+p$2482;0];
  If[(equ$2482=
Help2HTML`o8$[" DateString[] returns the current date and time as string  \"mm/dd/CCYY HH:MM:SS\".\n DateString[date] converts dat\
e to string as above. The date can be either a real number (in second, date=0 is 1/1/1900 0:0:0) or a list of 6 reals {Y,m,d,H,M,S\
}."[p$2482,p1$2482]])===
    Undefined,
equ$2482="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[" DateString[] returns the current date and t\
ime as string  \"mm/dd/CCYY HH:MM:SS\".\n DateString[date] converts date to string as above. The date can be either a real number \
(in second, date=0 is 1/1/1900 0:0:0) or a list of 6 reals {Y,m,d,H,M,S}."[p$2482,p1$2482]]=
       equ$2482;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2482},out$2482=lx$2482@Typeset[" DateString[] returns the current date and time as string  \"mm/dd/CCYY HH:MM:SS\".\n Dat\
eString[date] converts date to string as above. The date can be either a real number (in second, date=0 is 1/1/1900 0:0:0) or a li\
st of 6 reals {Y,m,d,H,M,S}."[p$2482,p1$2482],Format->Help2HTML`oB$];
        System["mv -f "//out$2482//" "//equ$2482]];
      Exit[]]];
   " DateString[] returns the current date and time as string  \"mm/dd/CCYY HH:MM:SS\".\n DateString[date] converts date to string\
 as above. The date can be either a real number (in second, date=0 is 1/1/1900 0:0:0) or a list of 6 reals {Y,m,d,H,M,S}."[1,
    Max[p0$2482,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2482//"\" />"//
Help2HTML`oy$[" DateString[] returns the current date and time as string  \"mm/dd/CCYY HH:MM:SS\".\n DateString[date] converts dat\
e to string as above. The date can be either a real number (in second, date=0 is 1/1/1900 0:0:0) or a list of 6 reals {Y,m,d,H,M,S\
}."[p2$2482,-1]]
]</PRE>
<LI>
<H3><A NAME=L459>
MemoryCheck</A></H3>
<PRE>If[{},
Help2HTML`oA$["MemoryCheck[n]\n\nchecks the consistency of the memory allocation by SAD. The range of the check and the output dep\
end on n:\t\n\nMemoryCheck[]  : checks the consistency of the free area and returns the allocation info,\nMemoryCheck[1] : checks \
the consistensy of the free and used areas. Returns the allocation info.\nMemoryCheck[2] : checks the consistensy of the free and \
used areas. Returns the allocation info. and a list of free segments.\t\n\n The returned value is {used, allocated from system, # \
of free segments, missing size[, list of free segments]} in units of word (= 8 bytes).\n If an inconsistency is found, messages ar\
e printed out."],
p$2484=1+p$2484[[1,2]];p1$2484=StringPosition["MemoryCheck[n]\n\nchecks the consistency of the memory allocation by SAD. The range\
 of the check and the output depend on n:\t\n\nMemoryCheck[]  : checks the consistency of the free area and returns the allocation\
 info,\nMemoryCheck[1] : checks the consistensy of the free and used areas. Returns the allocation info.\nMemoryCheck[2] : checks \
the consistensy of the free and used areas. Returns the allocation info. and a list of free segments.\t\n\n The returned value is \
{used, allocated from system, # of free segments, missing size[, list of free segments]} in units of word (= 8 bytes).\n If an inc\
onsistency is found, messages are printed out."[p$2484,-1],">::",1];
   p1$2484=If[p1$2484==={},638,-2+p$2484+p1$2484[[1,1]]];
neq=Which["MemoryCheck[n]\n\nchecks the consistency of the memory allocation by SAD. The range of the check and the output depend \
on n:\t\n\nMemoryCheck[]  : checks the consistency of the free area and returns the allocation info,\nMemoryCheck[1] : checks the \
consistensy of the free and used areas. Returns the allocation info.\nMemoryCheck[2] : checks the consistensy of the free and used\
 areas. Returns the allocation info. and a list of free segments.\t\n\n The returned value is {used, allocated from system, # of f\
ree segments, missing size[, list of free segments]} in units of word (= 8 bytes).\n If an inconsistency is found, messages are pr\
inted out."[p$2484,4+p$2484]==="Text[",
    lx$2484:=Help2HTML`oa$;p$2484=5+p$2484;p1$2484-=1;p2$2484=5+p1$2484;p0$2484=-9+p$2484;If[(pe$2484=
StringPosition["MemoryCheck[n]\n\nchecks the consistency of the memory allocation by SAD. The range of the check and the output de\
pend on n:\t\n\nMemoryCheck[]  : checks the consistency of the free area and returns the allocation info,\nMemoryCheck[1] : checks\
 the consistensy of the free and used areas. Returns the allocation info.\nMemoryCheck[2] : checks the consistensy of the free and\
 used areas. Returns the allocation info. and a list of free segments.\t\n\n The returned value is {used, allocated from system, #\
 of free segments, missing size[, list of free segments]} in units of word (= 8 bytes).\n If an inconsistency is found, messages a\
re printed out."[p$2484,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["MemoryCheck[n]\n\nchecks the consistency of the memory allocation by SAD. The range of the check and the output d\
epend on n:\t\n\nMemoryCheck[]  : checks the consistency of the free area and returns the allocation info,\nMemoryCheck[1] : check\
s the consistensy of the free and used areas. Returns the allocation info.\nMemoryCheck[2] : checks the consistensy of the free an\
d used areas. Returns the allocation info. and a list of free segments.\t\n\n The returned value is {used, allocated from system, \
# of free segments, missing size[, list of free segments]} in units of word (= 8 bytes).\n If an inconsistency is found, messages \
are printed out."[p$2484+pe$2484[[1,2]],p1$2484]]],
        p1$2484=-2+p$2484+pe$2484[[1,1]]}[[
       1]],
      0],
    1,lx$2484:=Help2HTML`o9$;p2$2484=4+p1$2484;p0$2484=-4+p$2484;0];
  If[(equ$2484=
Help2HTML`o8$["MemoryCheck[n]\n\nchecks the consistency of the memory allocation by SAD. The range of the check and the output dep\
end on n:\t\n\nMemoryCheck[]  : checks the consistency of the free area and returns the allocation info,\nMemoryCheck[1] : checks \
the consistensy of the free and used areas. Returns the allocation info.\nMemoryCheck[2] : checks the consistensy of the free and \
used areas. Returns the allocation info. and a list of free segments.\t\n\n The returned value is {used, allocated from system, # \
of free segments, missing size[, list of free segments]} in units of word (= 8 bytes).\n If an inconsistency is found, messages ar\
e printed out."[p$2484,p1$2484]])===
    Undefined,
equ$2484="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["MemoryCheck[n]\n\nchecks the consistency of \
the memory allocation by SAD. The range of the check and the output depend on n:\t\n\nMemoryCheck[]  : checks the consistency of t\
he free area and returns the allocation info,\nMemoryCheck[1] : checks the consistensy of the free and used areas. Returns the all\
ocation info.\nMemoryCheck[2] : checks the consistensy of the free and used areas. Returns the allocation info. and a list of free\
 segments.\t\n\n The returned value is {used, allocated from system, # of free segments, missing size[, list of free segments]} in\
 units of word (= 8 bytes).\n If an inconsistency is found, messages are printed out."[p$2484,p1$2484]]=
       equ$2484;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2484},out$2484=lx$2484@Typeset["MemoryCheck[n]\n\nchecks the consistency of the memory allocation by SAD. The range of th\
e check and the output depend on n:\t\n\nMemoryCheck[]  : checks the consistency of the free area and returns the allocation info,\
\nMemoryCheck[1] : checks the consistensy of the free and used areas. Returns the allocation info.\nMemoryCheck[2] : checks the co\
nsistensy of the free and used areas. Returns the allocation info. and a list of free segments.\t\n\n The returned value is {used,\
 allocated from system, # of free segments, missing size[, list of free segments]} in units of word (= 8 bytes).\n If an inconsist\
ency is found, messages are printed out."[p$2484,p1$2484],Format->Help2HTML`oB$];
        System["mv -f "//out$2484//" "//equ$2484]];
      Exit[]]];
   "MemoryCheck[n]\n\nchecks the consistency of the memory allocation by SAD. The range of the check and the output depend on n:\t\
\n\nMemoryCheck[]  : checks the consistency of the free area and returns the allocation info,\nMemoryCheck[1] : checks the consist\
ensy of the free and used areas. Returns the allocation info.\nMemoryCheck[2] : checks the consistensy of the free and used areas.\
 Returns the allocation info. and a list of free segments.\t\n\n The returned value is {used, allocated from system, # of free seg\
ments, missing size[, list of free segments]} in units of word (= 8 bytes).\n If an inconsistency is found, messages are printed o\
ut."[1,Max[p0$2484,0]]//"<img  class=\"eqs\" SRC=\""//equ$2484//"\" />"//
Help2HTML`oy$["MemoryCheck[n]\n\nchecks the consistency of the memory allocation by SAD. The range of the check and the output dep\
end on n:\t\n\nMemoryCheck[]  : checks the consistency of the free area and returns the allocation info,\nMemoryCheck[1] : checks \
the consistensy of the free and used areas. Returns the allocation info.\nMemoryCheck[2] : checks the consistensy of the free and \
used areas. Returns the allocation info. and a list of free segments.\t\n\n The returned value is {used, allocated from system, # \
of free segments, missing size[, list of free segments]} in units of word (= 8 bytes).\n If an inconsistency is found, messages ar\
e printed out."[p2$2484,-1]]
]</PRE>
<LI>
<H3><A NAME=L460>
TimeUsed</A></H3>
<PRE>If[{},Help2HTML`oA$["TimeUsed[] returns the cputime since the start of SAD in seconds."],
 p$2486=1+p$2486[[1,2]];p1$2486=StringPosition["TimeUsed[] returns the cputime since the start of SAD in seconds."[p$2486,-1],
    ">::",1];
   p1$2486=If[p1$2486==={},65,-2+p$2486+p1$2486[[1,1]]];
  neq=Which["TimeUsed[] returns the cputime since the start of SAD in seconds."[p$2486,4+p$2486]==="Text[",
    lx$2486:=Help2HTML`oa$;p$2486=5+p$2486;p1$2486-=1;p2$2486=5+p1$2486;p0$2486=-9+p$2486;
     If[(pe$2486=StringPosition["TimeUsed[] returns the cputime since the start of SAD in seconds."[p$2486,-2],";;;"])<=>{},
      {Max[0,-1+ToExpression["TimeUsed[] returns the cputime since the start of SAD in seconds."[p$2486+pe$2486[[1,2]],p1$2486]]],
       p1$2486=-2+p$2486+pe$2486[[1,1]]}[[1]],
      0],
    1,lx$2486:=Help2HTML`o9$;p2$2486=4+p1$2486;p0$2486=-4+p$2486;0];
  If[(equ$2486=Help2HTML`o8$["TimeUsed[] returns the cputime since the start of SAD in seconds."[p$2486,p1$2486]])===Undefined,
   equ$2486="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["TimeUsed[] returns the cputime since the start of SAD in seconds."[p$2486,p1$2486]]=equ$2486;
      LaTeX`ob$+=neq,
     --LaTeX`ob$;With[{lx$2486},out$2486=lx$2486@Typeset["TimeUsed[] returns the cputime since the start of SAD in seconds."[p$2486
           ,p1$2486],Format->Help2HTML`oB$];
        System["mv -f "//out$2486//" "//equ$2486]];
      Exit[]]];
   "TimeUsed[] returns the cputime since the start of SAD in seconds."[1,Max[p0$2486,0]]//"<img  class=\"eqs\" SRC=\""//equ$2486//
   "\" />"//Help2HTML`oy$["TimeUsed[] returns the cputime since the start of SAD in seconds."[p2$2486,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L461>Timing</A></PRE>
<LI>
<H3><A NAME=L461>
Timing</A></H3>
<PRE>If[{},Help2HTML`oA$["Timing[fun]\n\nevaluates fun and returns {cputime, result}. cputime is in seconds."],
 p$2489=1+p$2489[[1,2]];
  p1$2489=StringPosition["Timing[fun]\n\nevaluates fun and returns {cputime, result}. cputime is in seconds."[p$2489,-1],">::",1];
  p1$2489=If[p1$2489==={},80,-2+p$2489+p1$2489[[1,1]]];
  neq=Which["Timing[fun]\n\nevaluates fun and returns {cputime, result}. cputime is in seconds."[p$2489,4+p$2489]==="Text[",
    lx$2489:=Help2HTML`oa$;p$2489=5+p$2489;p1$2489-=1;p2$2489=5+p1$2489;p0$2489=-9+p$2489;
     If[(pe$2489=StringPosition["Timing[fun]\n\nevaluates fun and returns {cputime, result}. cputime is in seconds."[p$2489,-2],
         ";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression["Timing[fun]\n\nevaluates fun and returns {cputime, result}. cputime is in seconds."[p$2489+pe$2489[[1,2]],
           p1$2489]]],
        p1$2489=-2+p$2489+pe$2489[[1,1]]}[[
       1]],
      0],
    1,lx$2489:=Help2HTML`o9$;p2$2489=4+p1$2489;p0$2489=-4+p$2489;0];
  If[(equ$2489=Help2HTML`o8$["Timing[fun]\n\nevaluates fun and returns {cputime, result}. cputime is in seconds."[p$2489,p1$2489]]
     )===
    Undefined,
   equ$2489="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "Timing[fun]\n\nevaluates fun and returns {cputime, result}. cputime is in seconds."[p$2489,p1$2489]]=
       equ$2489;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$2489},out$2489=lx$2489@Typeset["Timing[fun]\n\nevaluates fun and returns {cputime, result}. cputime is in seconds."[
           p$2489,p1$2489],Format->Help2HTML`oB$];
        System["mv -f "//out$2489//" "//equ$2489]];
      Exit[]]];
   "Timing[fun]\n\nevaluates fun and returns {cputime, result}. cputime is in seconds."[1,Max[p0$2489,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2489//"\" />"//
   Help2HTML`oy$["Timing[fun]\n\nevaluates fun and returns {cputime, result}. cputime is in seconds."[p2$2489,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L460>TimeUsed</A></PRE>
<LI>
<H3><A NAME=L462>
TracePrint</A></H3>
<PRE>If[{},
 Help2HTML`oA$["TracePrint[fun]\n\nprints out all function calls and each expression compound in \";\" in the evaluation of fun."],
 p$2492=1+p$2492[[1,2]];
  p1$2492=StringPosition[
    "TracePrint[fun]\n\nprints out all function calls and each expression compound in \";\" in the evaluation of fun."[p$2492,-1],
    ">::",1];
   p1$2492=If[p1$2492==={},108,-2+p$2492+p1$2492[[1,1]]];
  neq=Which["TracePrint[fun]\n\nprints out all function calls and each expression compound in \";\" in the evaluation of fun."[p
      $2492,4+p$2492]===
     "Text[",
    lx$2492:=Help2HTML`oa$;p$2492=5+p$2492;p1$2492-=1;p2$2492=5+p1$2492;p0$2492=-9+p$2492;If[(pe$2492=StringPosition[
         "TracePrint[fun]\n\nprints out all function calls and each expression compound in \";\" in the evaluation of fun."[p$2492,
          -2],
         ";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression[
          "TracePrint[fun]\n\nprints out all function calls and each expression compound in \";\" in the evaluation of fun."[p$2492
            +pe$2492[[1,2]],
           p1$2492]]],
        p1$2492=-2+p$2492+pe$2492[[1,1]]}[[
       1]],
      0],
    1,lx$2492:=Help2HTML`o9$;p2$2492=4+p1$2492;p0$2492=-4+p$2492;0];
  If[(equ$2492=
     Help2HTML`o8$[
      "TracePrint[fun]\n\nprints out all function calls and each expression compound in \";\" in the evaluation of fun."[p$2492,
       p1$2492]])===
    Undefined,
   equ$2492="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "TracePrint[fun]\n\nprints out all function calls and each expression compound in \";\" in the evaluation of fun."[p$2492,
         p1$2492]]=
       equ$2492;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$2492},out$2492=lx$2492@Typeset[
          "TracePrint[fun]\n\nprints out all function calls and each expression compound in \";\" in the evaluation of fun."[p$2492
           ,p1$2492],Format->Help2HTML`oB$];
        System["mv -f "//out$2492//" "//equ$2492]];
      Exit[]]];
   "TracePrint[fun]\n\nprints out all function calls and each expression compound in \";\" in the evaluation of fun."[1,
    Max[p0$2492,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2492//"\" />"//
   Help2HTML`oy$["TracePrint[fun]\n\nprints out all function calls and each expression compound in \";\" in the evaluation of fun."
    [p2$2492,-1]]
]</PRE>
</UL>
</UL>
<H3><A NAME=L463>
FIT</A></H3>
<PRE>If[{},
Help2HTML`oA$["Usage: (1) FIT [component]\n       (2) FIT component1 component2\n\nsets the current location where the matching co\
ndition is applied. The component is given with the form name[.order][{+-}offset] (see components). If component is omitted, the e\
nd of the beam line is chosen.\n   If two components are given, it means a relative-fitting or zone-fitting. If the fitting condit\
ion is not maximum-fitting, the condition means to make values at two components equal (for AX, BX, GMX, AY, BY, GMY, EX, EPX, EY,\
 EPY, R1, R2, R3, R4, DX, DPX, DY, DPY, PEX, PEPX, PEY, PEPY, CHI1, CHI2, CHI3),  or have the specified difference (for NX, NY, LE\
NG, GX, GY, GZ). If the fitting condition is maximum-fitting, the condition means a zone-fitting (for AX, BX, GMX, AY, BY, GMY, EX\
, EPX, EY, EPY, R1, R2, R3, R4, DX, DPX, DY, DPY, PEX, PEPX, PEY, PEPY, CHI1, CHI2, CHI3), which suppress the maximum of the funct\
ion in the region between component1 and component2, or maximum-fitting for the difference of the function (for NX,  NY, LENG, GX,\
 GY, GZ). The fit region is shown in the first part of the prompt when FFSPRMPT is ON.\n\nExamples: (1) FIT QF.2-10\n\nsets the cu\
rrent fit point at  10 components upstream from the entrance of the second QF.\n\n          (2) FIT QF QD NX 0.5 BXM 10\n\nsets th\
e two-point fitting between QF and QD, then set the difference of NX between QF and QD to be 0.5, and the maximum of BX to be 10 i\
n the region between QF and QD."],
p$2494=1+p$2494[[1,2]];p1$2494=StringPosition["Usage: (1) FIT [component]\n       (2) FIT component1 component2\n\nsets the curren\
t location where the matching condition is applied. The component is given with the form name[.order][{+-}offset] (see components)\
. If component is omitted, the end of the beam line is chosen.\n   If two components are given, it means a relative-fitting or zon\
e-fitting. If the fitting condition is not maximum-fitting, the condition means to make values at two components equal (for AX, BX\
, GMX, AY, BY, GMY, EX, EPX, EY, EPY, R1, R2, R3, R4, DX, DPX, DY, DPY, PEX, PEPX, PEY, PEPY, CHI1, CHI2, CHI3),  or have the spec\
ified difference (for NX, NY, LENG, GX, GY, GZ). If the fitting condition is maximum-fitting, the condition means a zone-fitting (\
for AX, BX, GMX, AY, BY, GMY, EX, EPX, EY, EPY, R1, R2, R3, R4, DX, DPX, DY, DPY, PEX, PEPX, PEY, PEPY, CHI1, CHI2, CHI3), which s\
uppress the maximum of the function in the region between component1 and component2, or maximum-fitting for the difference of the \
function (for NX,  NY, LENG, GX, GY, GZ). The fit region is shown in the first part of the prompt when FFSPRMPT is ON.\n\nExamples\
: (1) FIT QF.2-10\n\nsets the current fit point at  10 components upstream from the entrance of the second QF.\n\n          (2) FI\
T QF QD NX 0.5 BXM 10\n\nsets the two-point fitting between QF and QD, then set the difference of NX between QF and QD to be 0.5, \
and the maximum of BX to be 10 in the region between QF and QD."[p$2494,-1],">::",1];
   p1$2494=If[p1$2494==={},1434,-2+p$2494+p1$2494[[1,1]]];
neq=Which["Usage: (1) FIT [component]\n       (2) FIT component1 component2\n\nsets the current location where the matching condit\
ion is applied. The component is given with the form name[.order][{+-}offset] (see components). If component is omitted, the end o\
f the beam line is chosen.\n   If two components are given, it means a relative-fitting or zone-fitting. If the fitting condition \
is not maximum-fitting, the condition means to make values at two components equal (for AX, BX, GMX, AY, BY, GMY, EX, EPX, EY, EPY\
, R1, R2, R3, R4, DX, DPX, DY, DPY, PEX, PEPX, PEY, PEPY, CHI1, CHI2, CHI3),  or have the specified difference (for NX, NY, LENG, \
GX, GY, GZ). If the fitting condition is maximum-fitting, the condition means a zone-fitting (for AX, BX, GMX, AY, BY, GMY, EX, EP\
X, EY, EPY, R1, R2, R3, R4, DX, DPX, DY, DPY, PEX, PEPX, PEY, PEPY, CHI1, CHI2, CHI3), which suppress the maximum of the function \
in the region between component1 and component2, or maximum-fitting for the difference of the function (for NX,  NY, LENG, GX, GY,\
 GZ). The fit region is shown in the first part of the prompt when FFSPRMPT is ON.\n\nExamples: (1) FIT QF.2-10\n\nsets the curren\
t fit point at  10 components upstream from the entrance of the second QF.\n\n          (2) FIT QF QD NX 0.5 BXM 10\n\nsets the tw\
o-point fitting between QF and QD, then set the difference of NX between QF and QD to be 0.5, and the maximum of BX to be 10 in th\
e region between QF and QD."[p$2494,4+p$2494]==="Text[",
    lx$2494:=Help2HTML`oa$;p$2494=5+p$2494;p1$2494-=1;p2$2494=5+p1$2494;p0$2494=-9+p$2494;
If[(pe$2494=StringPosition["Usage: (1) FIT [component]\n       (2) FIT component1 component2\n\nsets the current location where th\
e matching condition is applied. The component is given with the form name[.order][{+-}offset] (see components). If component is o\
mitted, the end of the beam line is chosen.\n   If two components are given, it means a relative-fitting or zone-fitting. If the f\
itting condition is not maximum-fitting, the condition means to make values at two components equal (for AX, BX, GMX, AY, BY, GMY,\
 EX, EPX, EY, EPY, R1, R2, R3, R4, DX, DPX, DY, DPY, PEX, PEPX, PEY, PEPY, CHI1, CHI2, CHI3),  or have the specified difference (f\
or NX, NY, LENG, GX, GY, GZ). If the fitting condition is maximum-fitting, the condition means a zone-fitting (for AX, BX, GMX, AY\
, BY, GMY, EX, EPX, EY, EPY, R1, R2, R3, R4, DX, DPX, DY, DPY, PEX, PEPX, PEY, PEPY, CHI1, CHI2, CHI3), which suppress the maximum\
 of the function in the region between component1 and component2, or maximum-fitting for the difference of the function (for NX,  \
NY, LENG, GX, GY, GZ). The fit region is shown in the first part of the prompt when FFSPRMPT is ON.\n\nExamples: (1) FIT QF.2-10\n\
\nsets the current fit point at  10 components upstream from the entrance of the second QF.\n\n          (2) FIT QF QD NX 0.5 BXM \
10\n\nsets the two-point fitting between QF and QD, then set the difference of NX between QF and QD to be 0.5, and the maximum of \
BX to be 10 in the region between QF and QD."[p$2494,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Usage: (1) FIT [component]\n       (2) FIT component1 component2\n\nsets the current location where the matching \
condition is applied. The component is given with the form name[.order][{+-}offset] (see components). If component is omitted, the\
 end of the beam line is chosen.\n   If two components are given, it means a relative-fitting or zone-fitting. If the fitting cond\
ition is not maximum-fitting, the condition means to make values at two components equal (for AX, BX, GMX, AY, BY, GMY, EX, EPX, E\
Y, EPY, R1, R2, R3, R4, DX, DPX, DY, DPY, PEX, PEPX, PEY, PEPY, CHI1, CHI2, CHI3),  or have the specified difference (for NX, NY, \
LENG, GX, GY, GZ). If the fitting condition is maximum-fitting, the condition means a zone-fitting (for AX, BX, GMX, AY, BY, GMY, \
EX, EPX, EY, EPY, R1, R2, R3, R4, DX, DPX, DY, DPY, PEX, PEPX, PEY, PEPY, CHI1, CHI2, CHI3), which suppress the maximum of the fun\
ction in the region between component1 and component2, or maximum-fitting for the difference of the function (for NX,  NY, LENG, G\
X, GY, GZ). The fit region is shown in the first part of the prompt when FFSPRMPT is ON.\n\nExamples: (1) FIT QF.2-10\n\nsets the \
current fit point at  10 components upstream from the entrance of the second QF.\n\n          (2) FIT QF QD NX 0.5 BXM 10\n\nsets \
the two-point fitting between QF and QD, then set the difference of NX between QF and QD to be 0.5, and the maximum of BX to be 10\
 in the region between QF and QD."[p$2494+pe$2494[[1,2]],p1$2494]]],
        p1$2494=-2+p$2494+pe$2494[[1,1]]}[[
       1]],
      0],
    1,lx$2494:=Help2HTML`o9$;p2$2494=4+p1$2494;p0$2494=-4+p$2494;0];
  If[(equ$2494=
Help2HTML`o8$["Usage: (1) FIT [component]\n       (2) FIT component1 component2\n\nsets the current location where the matching co\
ndition is applied. The component is given with the form name[.order][{+-}offset] (see components). If component is omitted, the e\
nd of the beam line is chosen.\n   If two components are given, it means a relative-fitting or zone-fitting. If the fitting condit\
ion is not maximum-fitting, the condition means to make values at two components equal (for AX, BX, GMX, AY, BY, GMY, EX, EPX, EY,\
 EPY, R1, R2, R3, R4, DX, DPX, DY, DPY, PEX, PEPX, PEY, PEPY, CHI1, CHI2, CHI3),  or have the specified difference (for NX, NY, LE\
NG, GX, GY, GZ). If the fitting condition is maximum-fitting, the condition means a zone-fitting (for AX, BX, GMX, AY, BY, GMY, EX\
, EPX, EY, EPY, R1, R2, R3, R4, DX, DPX, DY, DPY, PEX, PEPX, PEY, PEPY, CHI1, CHI2, CHI3), which suppress the maximum of the funct\
ion in the region between component1 and component2, or maximum-fitting for the difference of the function (for NX,  NY, LENG, GX,\
 GY, GZ). The fit region is shown in the first part of the prompt when FFSPRMPT is ON.\n\nExamples: (1) FIT QF.2-10\n\nsets the cu\
rrent fit point at  10 components upstream from the entrance of the second QF.\n\n          (2) FIT QF QD NX 0.5 BXM 10\n\nsets th\
e two-point fitting between QF and QD, then set the difference of NX between QF and QD to be 0.5, and the maximum of BX to be 10 i\
n the region between QF and QD."[p$2494,p1$2494]])===
    Undefined,
equ$2494="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Usage: (1) FIT [component]\n       (2) FIT c\
omponent1 component2\n\nsets the current location where the matching condition is applied. The component is given with the form na\
me[.order][{+-}offset] (see components). If component is omitted, the end of the beam line is chosen.\n   If two components are gi\
ven, it means a relative-fitting or zone-fitting. If the fitting condition is not maximum-fitting, the condition means to make val\
ues at two components equal (for AX, BX, GMX, AY, BY, GMY, EX, EPX, EY, EPY, R1, R2, R3, R4, DX, DPX, DY, DPY, PEX, PEPX, PEY, PEP\
Y, CHI1, CHI2, CHI3),  or have the specified difference (for NX, NY, LENG, GX, GY, GZ). If the fitting condition is maximum-fittin\
g, the condition means a zone-fitting (for AX, BX, GMX, AY, BY, GMY, EX, EPX, EY, EPY, R1, R2, R3, R4, DX, DPX, DY, DPY, PEX, PEPX\
, PEY, PEPY, CHI1, CHI2, CHI3), which suppress the maximum of the function in the region between component1 and component2, or max\
imum-fitting for the difference of the function (for NX,  NY, LENG, GX, GY, GZ). The fit region is shown in the first part of the \
prompt when FFSPRMPT is ON.\n\nExamples: (1) FIT QF.2-10\n\nsets the current fit point at  10 components upstream from the entranc\
e of the second QF.\n\n          (2) FIT QF QD NX 0.5 BXM 10\n\nsets the two-point fitting between QF and QD, then set the differe\
nce of NX between QF and QD to be 0.5, and the maximum of BX to be 10 in the region between QF and QD."[p$2494,p1$2494]]=
       equ$2494;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2494},out$2494=lx$2494@Typeset["Usage: (1) FIT [component]\n       (2) FIT component1 component2\n\nsets the current loca\
tion where the matching condition is applied. The component is given with the form name[.order][{+-}offset] (see components). If c\
omponent is omitted, the end of the beam line is chosen.\n   If two components are given, it means a relative-fitting or zone-fitt\
ing. If the fitting condition is not maximum-fitting, the condition means to make values at two components equal (for AX, BX, GMX,\
 AY, BY, GMY, EX, EPX, EY, EPY, R1, R2, R3, R4, DX, DPX, DY, DPY, PEX, PEPX, PEY, PEPY, CHI1, CHI2, CHI3),  or have the specified \
difference (for NX, NY, LENG, GX, GY, GZ). If the fitting condition is maximum-fitting, the condition means a zone-fitting (for AX\
, BX, GMX, AY, BY, GMY, EX, EPX, EY, EPY, R1, R2, R3, R4, DX, DPX, DY, DPY, PEX, PEPX, PEY, PEPY, CHI1, CHI2, CHI3), which suppres\
s the maximum of the function in the region between component1 and component2, or maximum-fitting for the difference of the functi\
on (for NX,  NY, LENG, GX, GY, GZ). The fit region is shown in the first part of the prompt when FFSPRMPT is ON.\n\nExamples: (1) \
FIT QF.2-10\n\nsets the current fit point at  10 components upstream from the entrance of the second QF.\n\n          (2) FIT QF Q\
D NX 0.5 BXM 10\n\nsets the two-point fitting between QF and QD, then set the difference of NX between QF and QD to be 0.5, and th\
e maximum of BX to be 10 in the region between QF and QD."[p$2494,p1$2494],Format->Help2HTML`oB$];
        System["mv -f "//out$2494//" "//equ$2494]];
      Exit[]]];
   "Usage: (1) FIT [component]\n       (2) FIT component1 component2\n\nsets the current location where the matching condition is \
applied. The component is given with the form name[.order][{+-}offset] (see components). If component is omitted, the end of the b\
eam line is chosen.\n   If two components are given, it means a relative-fitting or zone-fitting. If the fitting condition is not \
maximum-fitting, the condition means to make values at two components equal (for AX, BX, GMX, AY, BY, GMY, EX, EPX, EY, EPY, R1, R\
2, R3, R4, DX, DPX, DY, DPY, PEX, PEPX, PEY, PEPY, CHI1, CHI2, CHI3),  or have the specified difference (for NX, NY, LENG, GX, GY,\
 GZ). If the fitting condition is maximum-fitting, the condition means a zone-fitting (for AX, BX, GMX, AY, BY, GMY, EX, EPX, EY, \
EPY, R1, R2, R3, R4, DX, DPX, DY, DPY, PEX, PEPX, PEY, PEPY, CHI1, CHI2, CHI3), which suppress the maximum of the function in the \
region between component1 and component2, or maximum-fitting for the difference of the function (for NX,  NY, LENG, GX, GY, GZ). T\
he fit region is shown in the first part of the prompt when FFSPRMPT is ON.\n\nExamples: (1) FIT QF.2-10\n\nsets the current fit p\
oint at  10 components upstream from the entrance of the second QF.\n\n          (2) FIT QF QD NX 0.5 BXM 10\n\nsets the two-point\
 fitting between QF and QD, then set the difference of NX between QF and QD to be 0.5, and the maximum of BX to be 10 in the regio\
n between QF and QD."[1,Max[p0$2494,0]]//"<img  class=\"eqs\" SRC=\""//equ$2494//"\" />"//
Help2HTML`oy$["Usage: (1) FIT [component]\n       (2) FIT component1 component2\n\nsets the current location where the matching co\
ndition is applied. The component is given with the form name[.order][{+-}offset] (see components). If component is omitted, the e\
nd of the beam line is chosen.\n   If two components are given, it means a relative-fitting or zone-fitting. If the fitting condit\
ion is not maximum-fitting, the condition means to make values at two components equal (for AX, BX, GMX, AY, BY, GMY, EX, EPX, EY,\
 EPY, R1, R2, R3, R4, DX, DPX, DY, DPY, PEX, PEPX, PEY, PEPY, CHI1, CHI2, CHI3),  or have the specified difference (for NX, NY, LE\
NG, GX, GY, GZ). If the fitting condition is maximum-fitting, the condition means a zone-fitting (for AX, BX, GMX, AY, BY, GMY, EX\
, EPX, EY, EPY, R1, R2, R3, R4, DX, DPX, DY, DPY, PEX, PEPX, PEY, PEPY, CHI1, CHI2, CHI3), which suppress the maximum of the funct\
ion in the region between component1 and component2, or maximum-fitting for the difference of the function (for NX,  NY, LENG, GX,\
 GY, GZ). The fit region is shown in the first part of the prompt when FFSPRMPT is ON.\n\nExamples: (1) FIT QF.2-10\n\nsets the cu\
rrent fit point at  10 components upstream from the entrance of the second QF.\n\n          (2) FIT QF QD NX 0.5 BXM 10\n\nsets th\
e two-point fitting between QF and QD, then set the difference of NX between QF and QD to be 0.5, and the maximum of BX to be 10 i\
n the region between QF and QD."[p2$2494,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L473>matching-function-commands</A> <A HREF=#L30>components</A> <A HREF=#L550>SHOW</A> <A HREF=#L469>GO</A> <A HREF=#L32>CALCULATE(CAL)</A></PRE>
<H3><A NAME=L464>
FITPOINTS(FITP)</A></H3>
<PRE>If[{},
Help2HTML`oA$["Usage: FITP n\n\n sets n to the number of off-momentum points in the off-momentum matching. If the fitting conditio\
n is on-momentum only, it is not affected."],
p$2497=1+p$2497[[1,2]];p1$2497=StringPosition["Usage: FITP n\n\n sets n to the number of off-momentum points in the off-momentum m\
atching. If the fitting condition is on-momentum only, it is not affected."[p$2497,-1],">::",1];
   p1$2497=If[p1$2497==={},155,-2+p$2497+p1$2497[[1,1]]];
neq=Which["Usage: FITP n\n\n sets n to the number of off-momentum points in the off-momentum matching. If the fitting condition is\
 on-momentum only, it is not affected."[p$2497,4+p$2497]==="Text[",
    lx$2497:=Help2HTML`oa$;p$2497=5+p$2497;p1$2497-=1;p2$2497=5+p1$2497;p0$2497=-9+p$2497;
If[(pe$2497=StringPosition["Usage: FITP n\n\n sets n to the number of off-momentum points in the off-momentum matching. If the fit\
ting condition is on-momentum only, it is not affected."[p$2497,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Usage: FITP n\n\n sets n to the number of off-momentum points in the off-momentum matching. If the fitting condit\
ion is on-momentum only, it is not affected."[p$2497+pe$2497[[1,2]],p1$2497]]],
        p1$2497=-2+p$2497+pe$2497[[1,1]]}[[
       1]],
      0],
    1,lx$2497:=Help2HTML`o9$;p2$2497=4+p1$2497;p0$2497=-4+p$2497;0];
  If[(equ$2497=
Help2HTML`o8$["Usage: FITP n\n\n sets n to the number of off-momentum points in the off-momentum matching. If the fitting conditio\
n is on-momentum only, it is not affected."[p$2497,p1$2497]])===
    Undefined,
equ$2497="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Usage: FITP n\n\n sets n to the number of of\
f-momentum points in the off-momentum matching. If the fitting condition is on-momentum only, it is not affected."[p$2497,p1$2497]
        ]=
       equ$2497;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2497},out$2497=lx$2497@Typeset["Usage: FITP n\n\n sets n to the number of off-momentum points in the off-momentum matchin\
g. If the fitting condition is on-momentum only, it is not affected."[p$2497,p1$2497],Format->Help2HTML`oB$];
        System["mv -f "//out$2497//" "//equ$2497]];
      Exit[]]];
   "Usage: FITP n\n\n sets n to the number of off-momentum points in the off-momentum matching. If the fitting condition is on-mom\
entum only, it is not affected."[1,Max[p0$2497,0]]//"<img  class=\"eqs\" SRC=\""//equ$2497//"\" />"//
Help2HTML`oy$["Usage: FITP n\n\n sets n to the number of off-momentum points in the off-momentum matching. If the fitting conditio\
n is on-momentum only, it is not affected."[p2$2497,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L473>matching-function-commands</A></PRE>
<H3><A NAME=L465>
FIX</A></H3>
<PRE>If[{},
Help2HTML`oA$["Usage: (1) FIX element-pattern [keyword] [element-pattern1 [keyword1]..]\n\nremoves elements which match element-pa\
ttern from the matching variables. The optional keyword specifies the non-default variables. If the keyword is omitted, all keywor\
ds are removed.\n   For the MARK element at the beginning of the beam line, a special form can be used for the FIX command. That i\
s a form &lt matching-function>&gt I (appending \"I\" to a matching-function name).\n\nExample: FIX AXI BXI AYI BYI\n\nremoves inc\
oming AX, BX, AY, and BY from the matching variables.\n\nUsage: (2) FIX\n\nsets the standard optics for the orbit correction comma\
nds."],
p$2500=1+p$2500[[1,2]];p1$2500=StringPosition["Usage: (1) FIX element-pattern [keyword] [element-pattern1 [keyword1]..]\n\nremoves\
 elements which match element-pattern from the matching variables. The optional keyword specifies the non-default variables. If th\
e keyword is omitted, all keywords are removed.\n   For the MARK element at the beginning of the beam line, a special form can be \
used for the FIX command. That is a form &lt matching-function>&gt I (appending \"I\" to a matching-function name).\n\nExample: FI\
X AXI BXI AYI BYI\n\nremoves incoming AX, BX, AY, and BY from the matching variables.\n\nUsage: (2) FIX\n\nsets the standard optic\
s for the orbit correction commands."[p$2500,-1],">::",1];
   p1$2500=If[p1$2500==={},626,-2+p$2500+p1$2500[[1,1]]];
neq=Which["Usage: (1) FIX element-pattern [keyword] [element-pattern1 [keyword1]..]\n\nremoves elements which match element-patter\
n from the matching variables. The optional keyword specifies the non-default variables. If the keyword is omitted, all keywords a\
re removed.\n   For the MARK element at the beginning of the beam line, a special form can be used for the FIX command. That is a \
form &lt matching-function>&gt I (appending \"I\" to a matching-function name).\n\nExample: FIX AXI BXI AYI BYI\n\nremoves incomin\
g AX, BX, AY, and BY from the matching variables.\n\nUsage: (2) FIX\n\nsets the standard optics for the orbit correction commands."
     [p$2500,4+p$2500]==="Text[",
    lx$2500:=Help2HTML`oa$;p$2500=5+p$2500;p1$2500-=1;p2$2500=5+p1$2500;p0$2500=-9+p$2500;If[(pe$2500=StringPosition["Usage: (1) F\
IX element-pattern [keyword] [element-pattern1 [keyword1]..]\n\nremoves elements which match element-pattern from the matching var\
iables. The optional keyword specifies the non-default variables. If the keyword is omitted, all keywords are removed.\n   For the\
 MARK element at the beginning of the beam line, a special form can be used for the FIX command. That is a form &lt matching-funct\
ion>&gt I (appending \"I\" to a matching-function name).\n\nExample: FIX AXI BXI AYI BYI\n\nremoves incoming AX, BX, AY, and BY fr\
om the matching variables.\n\nUsage: (2) FIX\n\nsets the standard optics for the orbit correction commands."[p$2500,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Usage: (1) FIX element-pattern [keyword] [element-pattern1 [keyword1]..]\n\nremoves elements which match element-\
pattern from the matching variables. The optional keyword specifies the non-default variables. If the keyword is omitted, all keyw\
ords are removed.\n   For the MARK element at the beginning of the beam line, a special form can be used for the FIX command. That\
 is a form &lt matching-function>&gt I (appending \"I\" to a matching-function name).\n\nExample: FIX AXI BXI AYI BYI\n\nremoves i\
ncoming AX, BX, AY, and BY from the matching variables.\n\nUsage: (2) FIX\n\nsets the standard optics for the orbit correction com\
mands."[p$2500+pe$2500[[1,2]],p1$2500]]],
        p1$2500=-2+p$2500+pe$2500[[1,1]]}[[
       1]],
      0],
    1,lx$2500:=Help2HTML`o9$;p2$2500=4+p1$2500;p0$2500=-4+p$2500;0];
  If[(equ$2500=
Help2HTML`o8$["Usage: (1) FIX element-pattern [keyword] [element-pattern1 [keyword1]..]\n\nremoves elements which match element-pa\
ttern from the matching variables. The optional keyword specifies the non-default variables. If the keyword is omitted, all keywor\
ds are removed.\n   For the MARK element at the beginning of the beam line, a special form can be used for the FIX command. That i\
s a form &lt matching-function>&gt I (appending \"I\" to a matching-function name).\n\nExample: FIX AXI BXI AYI BYI\n\nremoves inc\
oming AX, BX, AY, and BY from the matching variables.\n\nUsage: (2) FIX\n\nsets the standard optics for the orbit correction comma\
nds."[p$2500,p1$2500]])===
    Undefined,
equ$2500="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Usage: (1) FIX element-pattern [keyword] [el\
ement-pattern1 [keyword1]..]\n\nremoves elements which match element-pattern from the matching variables. The optional keyword spe\
cifies the non-default variables. If the keyword is omitted, all keywords are removed.\n   For the MARK element at the beginning o\
f the beam line, a special form can be used for the FIX command. That is a form &lt matching-function>&gt I (appending \"I\" to a \
matching-function name).\n\nExample: FIX AXI BXI AYI BYI\n\nremoves incoming AX, BX, AY, and BY from the matching variables.\n\nUs\
age: (2) FIX\n\nsets the standard optics for the orbit correction commands."[p$2500,p1$2500]]=
       equ$2500;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2500},out$2500=lx$2500@Typeset["Usage: (1) FIX element-pattern [keyword] [element-pattern1 [keyword1]..]\n\nremoves eleme\
nts which match element-pattern from the matching variables. The optional keyword specifies the non-default variables. If the keyw\
ord is omitted, all keywords are removed.\n   For the MARK element at the beginning of the beam line, a special form can be used f\
or the FIX command. That is a form &lt matching-function>&gt I (appending \"I\" to a matching-function name).\n\nExample: FIX AXI \
BXI AYI BYI\n\nremoves incoming AX, BX, AY, and BY from the matching variables.\n\nUsage: (2) FIX\n\nsets the standard optics for \
the orbit correction commands."[p$2500,p1$2500],Format->Help2HTML`oB$];
        System["mv -f "//out$2500//" "//equ$2500]];
      Exit[]]];
   "Usage: (1) FIX element-pattern [keyword] [element-pattern1 [keyword1]..]\n\nremoves elements which match element-pattern from \
the matching variables. The optional keyword specifies the non-default variables. If the keyword is omitted, all keywords are remo\
ved.\n   For the MARK element at the beginning of the beam line, a special form can be used for the FIX command. That is a form &l\
t matching-function>&gt I (appending \"I\" to a matching-function name).\n\nExample: FIX AXI BXI AYI BYI\n\nremoves incoming AX, B\
X, AY, and BY from the matching variables.\n\nUsage: (2) FIX\n\nsets the standard optics for the orbit correction commands."[1,
    Max[p0$2500,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2500//"\" />"//
Help2HTML`oy$["Usage: (1) FIX element-pattern [keyword] [element-pattern1 [keyword1]..]\n\nremoves elements which match element-pa\
ttern from the matching variables. The optional keyword specifies the non-default variables. If the keyword is omitted, all keywor\
ds are removed.\n   For the MARK element at the beginning of the beam line, a special form can be used for the FIX command. That i\
s a form &lt matching-function>&gt I (appending \"I\" to a matching-function name).\n\nExample: FIX AXI BXI AYI BYI\n\nremoves inc\
oming AX, BX, AY, and BY from the matching variables.\n\nUsage: (2) FIX\n\nsets the standard optics for the orbit correction comma\
nds."[p2$2500,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L466>FREE</A> <A HREF=#L463>FIT</A> <A HREF=#L550>SHOW</A> <A HREF=#L469>GO</A> <A HREF=#L32>CALCULATE(CAL)</A> <A HREF=#L562>wildcards</A> <A HREF=#L75>elements</A></PRE>
<H3><A NAME=L466>
FREE</A></H3>
<PRE>If[{},
Help2HTML`oA$["Usage: FREE element-pattern [keyword] [element-pattern1 [keyword1]..]\n\nspecifies elements which match element-pat\
tern as the matching variables. The optional keyword specifies the non-default variables. See default-keyword. \n   For the MARK e\
lement at the beginning of the beam line, a special form can be used for the FREE command. That is a form &lt matching-function &g\
t I  (appending \"I\" to a matching-function name) which means the incoming condition of the matching-function is varied in the ma\
tching.\n\nExample: FREE AXI BXI AYI BYI\n\nchanges incoming AX, BX, AY, and BY to find the solution."],
 p$2503=1+p$2503[[1,2]];p1$2503=
StringPosition["Usage: FREE element-pattern [keyword] [element-pattern1 [keyword1]..]\n\nspecifies elements which match element-pa\
ttern as the matching variables. The optional keyword specifies the non-default variables. See default-keyword. \n   For the MARK \
element at the beginning of the beam line, a special form can be used for the FREE command. That is a form &lt matching-function &\
gt I  (appending \"I\" to a matching-function name) which means the incoming condition of the matching-function is varied in the m\
atching.\n\nExample: FREE AXI BXI AYI BYI\n\nchanges incoming AX, BX, AY, and BY to find the solution."[p$2503,-1],">::",1];
   p1$2503=If[p1$2503==={},597,-2+p$2503+p1$2503[[1,1]]];
neq=Which["Usage: FREE element-pattern [keyword] [element-pattern1 [keyword1]..]\n\nspecifies elements which match element-pattern\
 as the matching variables. The optional keyword specifies the non-default variables. See default-keyword. \n   For the MARK eleme\
nt at the beginning of the beam line, a special form can be used for the FREE command. That is a form &lt matching-function &gt I \
 (appending \"I\" to a matching-function name) which means the incoming condition of the matching-function is varied in the matchi\
ng.\n\nExample: FREE AXI BXI AYI BYI\n\nchanges incoming AX, BX, AY, and BY to find the solution."[p$2503,4+p$2503]==="Text[",
    lx$2503:=Help2HTML`oa$;p$2503=5+p$2503;p1$2503-=1;p2$2503=5+p1$2503;p0$2503=-9+p$2503;
If[(pe$2503=StringPosition["Usage: FREE element-pattern [keyword] [element-pattern1 [keyword1]..]\n\nspecifies elements which matc\
h element-pattern as the matching variables. The optional keyword specifies the non-default variables. See default-keyword. \n   F\
or the MARK element at the beginning of the beam line, a special form can be used for the FREE command. That is a form &lt matchin\
g-function &gt I  (appending \"I\" to a matching-function name) which means the incoming condition of the matching-function is var\
ied in the matching.\n\nExample: FREE AXI BXI AYI BYI\n\nchanges incoming AX, BX, AY, and BY to find the solution."[p$2503,-2],
         ";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Usage: FREE element-pattern [keyword] [element-pattern1 [keyword1]..]\n\nspecifies elements which match element-p\
attern as the matching variables. The optional keyword specifies the non-default variables. See default-keyword. \n   For the MARK\
 element at the beginning of the beam line, a special form can be used for the FREE command. That is a form &lt matching-function \
&gt I  (appending \"I\" to a matching-function name) which means the incoming condition of the matching-function is varied in the \
matching.\n\nExample: FREE AXI BXI AYI BYI\n\nchanges incoming AX, BX, AY, and BY to find the solution."[p$2503+pe$2503[[1,2]],
           p1$2503]]],
        p1$2503=-2+p$2503+pe$2503[[1,1]]}[[
       1]],
      0],
    1,lx$2503:=Help2HTML`o9$;p2$2503=4+p1$2503;p0$2503=-4+p$2503;0];
  If[(equ$2503=
Help2HTML`o8$["Usage: FREE element-pattern [keyword] [element-pattern1 [keyword1]..]\n\nspecifies elements which match element-pat\
tern as the matching variables. The optional keyword specifies the non-default variables. See default-keyword. \n   For the MARK e\
lement at the beginning of the beam line, a special form can be used for the FREE command. That is a form &lt matching-function &g\
t I  (appending \"I\" to a matching-function name) which means the incoming condition of the matching-function is varied in the ma\
tching.\n\nExample: FREE AXI BXI AYI BYI\n\nchanges incoming AX, BX, AY, and BY to find the solution."[p$2503,p1$2503]])===
    Undefined,
equ$2503="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Usage: FREE element-pattern [keyword] [eleme\
nt-pattern1 [keyword1]..]\n\nspecifies elements which match element-pattern as the matching variables. The optional keyword specif\
ies the non-default variables. See default-keyword. \n   For the MARK element at the beginning of the beam line, a special form ca\
n be used for the FREE command. That is a form &lt matching-function &gt I  (appending \"I\" to a matching-function name) which me\
ans the incoming condition of the matching-function is varied in the matching.\n\nExample: FREE AXI BXI AYI BYI\n\nchanges incomin\
g AX, BX, AY, and BY to find the solution."[p$2503,p1$2503]]=
       equ$2503;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2503},out$2503=lx$2503@Typeset["Usage: FREE element-pattern [keyword] [element-pattern1 [keyword1]..]\n\nspecifies elemen\
ts which match element-pattern as the matching variables. The optional keyword specifies the non-default variables. See default-ke\
yword. \n   For the MARK element at the beginning of the beam line, a special form can be used for the FREE command. That is a for\
m &lt matching-function &gt I  (appending \"I\" to a matching-function name) which means the incoming condition of the matching-fu\
nction is varied in the matching.\n\nExample: FREE AXI BXI AYI BYI\n\nchanges incoming AX, BX, AY, and BY to find the solution."[
           p$2503,p1$2503],Format->Help2HTML`oB$];
        System["mv -f "//out$2503//" "//equ$2503]];
      Exit[]]];
   "Usage: FREE element-pattern [keyword] [element-pattern1 [keyword1]..]\n\nspecifies elements which match element-pattern as the\
 matching variables. The optional keyword specifies the non-default variables. See default-keyword. \n   For the MARK element at t\
he beginning of the beam line, a special form can be used for the FREE command. That is a form &lt matching-function &gt I  (appen\
ding \"I\" to a matching-function name) which means the incoming condition of the matching-function is varied in the matching.\n\n\
Example: FREE AXI BXI AYI BYI\n\nchanges incoming AX, BX, AY, and BY to find the solution."[1,Max[p0$2503,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2503//"\" />"//
Help2HTML`oy$["Usage: FREE element-pattern [keyword] [element-pattern1 [keyword1]..]\n\nspecifies elements which match element-pat\
tern as the matching variables. The optional keyword specifies the non-default variables. See default-keyword. \n   For the MARK e\
lement at the beginning of the beam line, a special form can be used for the FREE command. That is a form &lt matching-function &g\
t I  (appending \"I\" to a matching-function name) which means the incoming condition of the matching-function is varied in the ma\
tching.\n\nExample: FREE AXI BXI AYI BYI\n\nchanges incoming AX, BX, AY, and BY to find the solution."[p2$2503,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L465>FIX</A> <A HREF=#L463>FIT</A> <A HREF=#L550>SHOW</A> <A HREF=#L469>GO</A> <A HREF=#L32>CALCULATE(CAL)</A> <A HREF=#L562>wildcards</A> <A HREF=#L75>elements</A></PRE>
<UL>
<LI>
<H3><A NAME=L467>
default-keyword</A></H3>
<PRE>If[{},
Help2HTML`oA$["The default and available non-default variable keywords are:\n\ntype    default-keyword  non-default variable keywo\
rd\nDRIFT   L                -\nBEND    ANGLE            K1,K0,E1,E2\nQUAD    K1               ROTATE\nSEXT    K2               RO\
TATE\nOCT     K3               ROTATE\nDECA    K4               ROTATE\nDODECA  K5               ROTATE\nMULT    K1               \
K0,K2..K21,SK0,SK1,SK2..SK21,ROTATE,ANGLE\nMARK    -                AX,BX,EX,EPX,AY,BY,EY,EPY,R1,R2,R3,R4,DETR,\n                 \
        DX,DPX,DY,DPY,DZ,DDP,AZ,BZ,ZX,ZPX,ZY,ZPY"],
p$2506=1+p$2506[[1,2]];p1$2506=StringPosition["The default and available non-default variable keywords are:\n\ntype    default-key\
word  non-default variable keyword\nDRIFT   L                -\nBEND    ANGLE            K1,K0,E1,E2\nQUAD    K1               ROT\
ATE\nSEXT    K2               ROTATE\nOCT     K3               ROTATE\nDECA    K4               ROTATE\nDODECA  K5               R\
OTATE\nMULT    K1               K0,K2..K21,SK0,SK1,SK2..SK21,ROTATE,ANGLE\nMARK    -                AX,BX,EX,EPX,AY,BY,EY,EPY,R1,R\
2,R3,R4,DETR,\n                         DX,DPX,DY,DPY,DZ,DDP,AZ,BZ,ZX,ZPX,ZY,ZPY"[p$2506,-1],">::",1];
   p1$2506=If[p1$2506==={},541,-2+p$2506+p1$2506[[1,1]]];
neq=Which["The default and available non-default variable keywords are:\n\ntype    default-keyword  non-default variable keyword\n\
DRIFT   L                -\nBEND    ANGLE            K1,K0,E1,E2\nQUAD    K1               ROTATE\nSEXT    K2               ROTATE\
\nOCT     K3               ROTATE\nDECA    K4               ROTATE\nDODECA  K5               ROTATE\nMULT    K1               K0,K\
2..K21,SK0,SK1,SK2..SK21,ROTATE,ANGLE\nMARK    -                AX,BX,EX,EPX,AY,BY,EY,EPY,R1,R2,R3,R4,DETR,\n                     \
    DX,DPX,DY,DPY,DZ,DDP,AZ,BZ,ZX,ZPX,ZY,ZPY"[p$2506,4+p$2506]==="Text[",
    lx$2506:=Help2HTML`oa$;p$2506=5+p$2506;p1$2506-=1;p2$2506=5+p1$2506;p0$2506=-9+p$2506;
If[(pe$2506=StringPosition["The default and available non-default variable keywords are:\n\ntype    default-keyword  non-default v\
ariable keyword\nDRIFT   L                -\nBEND    ANGLE            K1,K0,E1,E2\nQUAD    K1               ROTATE\nSEXT    K2    \
           ROTATE\nOCT     K3               ROTATE\nDECA    K4               ROTATE\nDODECA  K5               ROTATE\nMULT    K1  \
             K0,K2..K21,SK0,SK1,SK2..SK21,ROTATE,ANGLE\nMARK    -                AX,BX,EX,EPX,AY,BY,EY,EPY,R1,R2,R3,R4,DETR,\n    \
                     DX,DPX,DY,DPY,DZ,DDP,AZ,BZ,ZX,ZPX,ZY,ZPY"[p$2506,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["The default and available non-default variable keywords are:\n\ntype    default-keyword  non-default variable key\
word\nDRIFT   L                -\nBEND    ANGLE            K1,K0,E1,E2\nQUAD    K1               ROTATE\nSEXT    K2               \
ROTATE\nOCT     K3               ROTATE\nDECA    K4               ROTATE\nDODECA  K5               ROTATE\nMULT    K1             \
  K0,K2..K21,SK0,SK1,SK2..SK21,ROTATE,ANGLE\nMARK    -                AX,BX,EX,EPX,AY,BY,EY,EPY,R1,R2,R3,R4,DETR,\n               \
          DX,DPX,DY,DPY,DZ,DDP,AZ,BZ,ZX,ZPX,ZY,ZPY"[p$2506+pe$2506[[1,2]],p1$2506]]],
        p1$2506=-2+p$2506+pe$2506[[1,1]]}[[
       1]],
      0],
    1,lx$2506:=Help2HTML`o9$;p2$2506=4+p1$2506;p0$2506=-4+p$2506;0];
  If[(equ$2506=
Help2HTML`o8$["The default and available non-default variable keywords are:\n\ntype    default-keyword  non-default variable keywo\
rd\nDRIFT   L                -\nBEND    ANGLE            K1,K0,E1,E2\nQUAD    K1               ROTATE\nSEXT    K2               RO\
TATE\nOCT     K3               ROTATE\nDECA    K4               ROTATE\nDODECA  K5               ROTATE\nMULT    K1               \
K0,K2..K21,SK0,SK1,SK2..SK21,ROTATE,ANGLE\nMARK    -                AX,BX,EX,EPX,AY,BY,EY,EPY,R1,R2,R3,R4,DETR,\n                 \
        DX,DPX,DY,DPY,DZ,DDP,AZ,BZ,ZX,ZPX,ZY,ZPY"[p$2506,p1$2506]])===
    Undefined,
equ$2506="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["The default and available non-default variab\
le keywords are:\n\ntype    default-keyword  non-default variable keyword\nDRIFT   L                -\nBEND    ANGLE            K1\
,K0,E1,E2\nQUAD    K1               ROTATE\nSEXT    K2               ROTATE\nOCT     K3               ROTATE\nDECA    K4          \
     ROTATE\nDODECA  K5               ROTATE\nMULT    K1               K0,K2..K21,SK0,SK1,SK2..SK21,ROTATE,ANGLE\nMARK    -       \
         AX,BX,EX,EPX,AY,BY,EY,EPY,R1,R2,R3,R4,DETR,\n                         DX,DPX,DY,DPY,DZ,DDP,AZ,BZ,ZX,ZPX,ZY,ZPY"[p$2506,
         p1$2506]]=
       equ$2506;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2506},out$2506=lx$2506@Typeset["The default and available non-default variable keywords are:\n\ntype    default-keyword  \
non-default variable keyword\nDRIFT   L                -\nBEND    ANGLE            K1,K0,E1,E2\nQUAD    K1               ROTATE\nS\
EXT    K2               ROTATE\nOCT     K3               ROTATE\nDECA    K4               ROTATE\nDODECA  K5               ROTATE\\
nMULT    K1               K0,K2..K21,SK0,SK1,SK2..SK21,ROTATE,ANGLE\nMARK    -                AX,BX,EX,EPX,AY,BY,EY,EPY,R1,R2,R3,R\
4,DETR,\n                         DX,DPX,DY,DPY,DZ,DDP,AZ,BZ,ZX,ZPX,ZY,ZPY"[p$2506,p1$2506],Format->Help2HTML`oB$];
        System["mv -f "//out$2506//" "//equ$2506]];
      Exit[]]];
   "The default and available non-default variable keywords are:\n\ntype    default-keyword  non-default variable keyword\nDRIFT  \
 L                -\nBEND    ANGLE            K1,K0,E1,E2\nQUAD    K1               ROTATE\nSEXT    K2               ROTATE\nOCT  \
   K3               ROTATE\nDECA    K4               ROTATE\nDODECA  K5               ROTATE\nMULT    K1               K0,K2..K21,\
SK0,SK1,SK2..SK21,ROTATE,ANGLE\nMARK    -                AX,BX,EX,EPX,AY,BY,EY,EPY,R1,R2,R3,R4,DETR,\n                         DX,\
DPX,DY,DPY,DZ,DDP,AZ,BZ,ZX,ZPX,ZY,ZPY"[1,Max[p0$2506,0]]//"<img  class=\"eqs\" SRC=\""//equ$2506//"\" />"//
Help2HTML`oy$["The default and available non-default variable keywords are:\n\ntype    default-keyword  non-default variable keywo\
rd\nDRIFT   L                -\nBEND    ANGLE            K1,K0,E1,E2\nQUAD    K1               ROTATE\nSEXT    K2               RO\
TATE\nOCT     K3               ROTATE\nDECA    K4               ROTATE\nDODECA  K5               ROTATE\nMULT    K1               \
K0,K2..K21,SK0,SK1,SK2..SK21,ROTATE,ANGLE\nMARK    -                AX,BX,EX,EPX,AY,BY,EY,EPY,R1,R2,R3,R4,DETR,\n                 \
        DX,DPX,DY,DPY,DZ,DDP,AZ,BZ,ZX,ZPX,ZY,ZPY"[p2$2506,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L136>keywords</A></PRE>
</UL>
<H3><A NAME=L468>
geometric-functions</A></H3>
<PRE>If[{},
Help2HTML`oA$["Available geometric-functions are:\n\nGX      geometrical coordinate xi\nGY      geometrical coordinate eta\nGZ    \
  geometrical coordinate zeta\nCHI1    geometrical rotation angle ch1_1\nCHI2    geometrical rotation angle ch1_2\nCHI3    geometr\
ical rotation angle ch1_3\n\nThe geometrical coordinate {xi, eta, zeta} is set by the ORG command, and its default origin is at th\
e entrance of the beam line, and the default directions are xi in s-direction, eta in -(x-direction), and zeta in -(y-direction) a\
t the entrance. The set {xi, eta, zeta} forms a right-hand system.\n   The rotation angles are defined so as to give the local {x,\
y,s} is written\n\n    {x, y, s}_local\n   = rotate[s, chi3] rotate[x, chi2] rotate[y, -chi1]{x, y, s}_origin,\n\nwhere rotate[a, \
b] reads \"rotate around the new-a vector by b right-handedly.\n\ngeometric functions disignate the geometry of the coordinate. If\
 the geometry of orbit is needed, use LINE[\"OGEO\"], etc., or DISP OG."],
p$2509=1+p$2509[[1,2]];p1$2509=StringPosition["Available geometric-functions are:\n\nGX      geometrical coordinate xi\nGY      ge\
ometrical coordinate eta\nGZ      geometrical coordinate zeta\nCHI1    geometrical rotation angle ch1_1\nCHI2    geometrical rotat\
ion angle ch1_2\nCHI3    geometrical rotation angle ch1_3\n\nThe geometrical coordinate {xi, eta, zeta} is set by the ORG command,\
 and its default origin is at the entrance of the beam line, and the default directions are xi in s-direction, eta in -(x-directio\
n), and zeta in -(y-direction) at the entrance. The set {xi, eta, zeta} forms a right-hand system.\n   The rotation angles are def\
ined so as to give the local {x,y,s} is written\n\n    {x, y, s}_local\n   = rotate[s, chi3] rotate[x, chi2] rotate[y, -chi1]{x, y\
, s}_origin,\n\nwhere rotate[a, b] reads \"rotate around the new-a vector by b right-handedly.\n\ngeometric functions disignate th\
e geometry of the coordinate. If the geometry of orbit is needed, use LINE[\"OGEO\"], etc., or DISP OG."[p$2509,-1],">::",1];
   p1$2509=If[p1$2509==={},946,-2+p$2509+p1$2509[[1,1]]];
neq=Which["Available geometric-functions are:\n\nGX      geometrical coordinate xi\nGY      geometrical coordinate eta\nGZ      ge\
ometrical coordinate zeta\nCHI1    geometrical rotation angle ch1_1\nCHI2    geometrical rotation angle ch1_2\nCHI3    geometrical\
 rotation angle ch1_3\n\nThe geometrical coordinate {xi, eta, zeta} is set by the ORG command, and its default origin is at the en\
trance of the beam line, and the default directions are xi in s-direction, eta in -(x-direction), and zeta in -(y-direction) at th\
e entrance. The set {xi, eta, zeta} forms a right-hand system.\n   The rotation angles are defined so as to give the local {x,y,s}\
 is written\n\n    {x, y, s}_local\n   = rotate[s, chi3] rotate[x, chi2] rotate[y, -chi1]{x, y, s}_origin,\n\nwhere rotate[a, b] r\
eads \"rotate around the new-a vector by b right-handedly.\n\ngeometric functions disignate the geometry of the coordinate. If the\
 geometry of orbit is needed, use LINE[\"OGEO\"], etc., or DISP OG."[p$2509,4+p$2509]==="Text[",
    lx$2509:=Help2HTML`oa$;p$2509=5+p$2509;p1$2509-=1;p2$2509=5+p1$2509;p0$2509=-9+p$2509;
If[(pe$2509=StringPosition["Available geometric-functions are:\n\nGX      geometrical coordinate xi\nGY      geometrical coordinat\
e eta\nGZ      geometrical coordinate zeta\nCHI1    geometrical rotation angle ch1_1\nCHI2    geometrical rotation angle ch1_2\nCH\
I3    geometrical rotation angle ch1_3\n\nThe geometrical coordinate {xi, eta, zeta} is set by the ORG command, and its default or\
igin is at the entrance of the beam line, and the default directions are xi in s-direction, eta in -(x-direction), and zeta in -(y\
-direction) at the entrance. The set {xi, eta, zeta} forms a right-hand system.\n   The rotation angles are defined so as to give \
the local {x,y,s} is written\n\n    {x, y, s}_local\n   = rotate[s, chi3] rotate[x, chi2] rotate[y, -chi1]{x, y, s}_origin,\n\nwhe\
re rotate[a, b] reads \"rotate around the new-a vector by b right-handedly.\n\ngeometric functions disignate the geometry of the c\
oordinate. If the geometry of orbit is needed, use LINE[\"OGEO\"], etc., or DISP OG."[p$2509,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Available geometric-functions are:\n\nGX      geometrical coordinate xi\nGY      geometrical coordinate eta\nGZ  \
    geometrical coordinate zeta\nCHI1    geometrical rotation angle ch1_1\nCHI2    geometrical rotation angle ch1_2\nCHI3    geome\
trical rotation angle ch1_3\n\nThe geometrical coordinate {xi, eta, zeta} is set by the ORG command, and its default origin is at \
the entrance of the beam line, and the default directions are xi in s-direction, eta in -(x-direction), and zeta in -(y-direction)\
 at the entrance. The set {xi, eta, zeta} forms a right-hand system.\n   The rotation angles are defined so as to give the local {\
x,y,s} is written\n\n    {x, y, s}_local\n   = rotate[s, chi3] rotate[x, chi2] rotate[y, -chi1]{x, y, s}_origin,\n\nwhere rotate[a\
, b] reads \"rotate around the new-a vector by b right-handedly.\n\ngeometric functions disignate the geometry of the coordinate. \
If the geometry of orbit is needed, use LINE[\"OGEO\"], etc., or DISP OG."[p$2509+pe$2509[[1,2]],p1$2509]]],
        p1$2509=-2+p$2509+pe$2509[[1,1]]}[[
       1]],
      0],
    1,lx$2509:=Help2HTML`o9$;p2$2509=4+p1$2509;p0$2509=-4+p$2509;0];
  If[(equ$2509=
Help2HTML`o8$["Available geometric-functions are:\n\nGX      geometrical coordinate xi\nGY      geometrical coordinate eta\nGZ    \
  geometrical coordinate zeta\nCHI1    geometrical rotation angle ch1_1\nCHI2    geometrical rotation angle ch1_2\nCHI3    geometr\
ical rotation angle ch1_3\n\nThe geometrical coordinate {xi, eta, zeta} is set by the ORG command, and its default origin is at th\
e entrance of the beam line, and the default directions are xi in s-direction, eta in -(x-direction), and zeta in -(y-direction) a\
t the entrance. The set {xi, eta, zeta} forms a right-hand system.\n   The rotation angles are defined so as to give the local {x,\
y,s} is written\n\n    {x, y, s}_local\n   = rotate[s, chi3] rotate[x, chi2] rotate[y, -chi1]{x, y, s}_origin,\n\nwhere rotate[a, \
b] reads \"rotate around the new-a vector by b right-handedly.\n\ngeometric functions disignate the geometry of the coordinate. If\
 the geometry of orbit is needed, use LINE[\"OGEO\"], etc., or DISP OG."[p$2509,p1$2509]])===
    Undefined,
equ$2509="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Available geometric-functions are:\n\nGX    \
  geometrical coordinate xi\nGY      geometrical coordinate eta\nGZ      geometrical coordinate zeta\nCHI1    geometrical rotation\
 angle ch1_1\nCHI2    geometrical rotation angle ch1_2\nCHI3    geometrical rotation angle ch1_3\n\nThe geometrical coordinate {xi\
, eta, zeta} is set by the ORG command, and its default origin is at the entrance of the beam line, and the default directions are\
 xi in s-direction, eta in -(x-direction), and zeta in -(y-direction) at the entrance. The set {xi, eta, zeta} forms a right-hand \
system.\n   The rotation angles are defined so as to give the local {x,y,s} is written\n\n    {x, y, s}_local\n   = rotate[s, chi3\
] rotate[x, chi2] rotate[y, -chi1]{x, y, s}_origin,\n\nwhere rotate[a, b] reads \"rotate around the new-a vector by b right-handed\
ly.\n\ngeometric functions disignate the geometry of the coordinate. If the geometry of orbit is needed, use LINE[\"OGEO\"], etc.,\
 or DISP OG."[p$2509,p1$2509]]=
       equ$2509;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2509},out$2509=lx$2509@Typeset["Available geometric-functions are:\n\nGX      geometrical coordinate xi\nGY      geometri\
cal coordinate eta\nGZ      geometrical coordinate zeta\nCHI1    geometrical rotation angle ch1_1\nCHI2    geometrical rotation an\
gle ch1_2\nCHI3    geometrical rotation angle ch1_3\n\nThe geometrical coordinate {xi, eta, zeta} is set by the ORG command, and i\
ts default origin is at the entrance of the beam line, and the default directions are xi in s-direction, eta in -(x-direction), an\
d zeta in -(y-direction) at the entrance. The set {xi, eta, zeta} forms a right-hand system.\n   The rotation angles are defined s\
o as to give the local {x,y,s} is written\n\n    {x, y, s}_local\n   = rotate[s, chi3] rotate[x, chi2] rotate[y, -chi1]{x, y, s}_o\
rigin,\n\nwhere rotate[a, b] reads \"rotate around the new-a vector by b right-handedly.\n\ngeometric functions disignate the geom\
etry of the coordinate. If the geometry of orbit is needed, use LINE[\"OGEO\"], etc., or DISP OG."[p$2509,p1$2509],
          Format->Help2HTML`oB$];
        System["mv -f "//out$2509//" "//equ$2509]];
      Exit[]]];
   "Available geometric-functions are:\n\nGX      geometrical coordinate xi\nGY      geometrical coordinate eta\nGZ      geometric\
al coordinate zeta\nCHI1    geometrical rotation angle ch1_1\nCHI2    geometrical rotation angle ch1_2\nCHI3    geometrical rotati\
on angle ch1_3\n\nThe geometrical coordinate {xi, eta, zeta} is set by the ORG command, and its default origin is at the entrance \
of the beam line, and the default directions are xi in s-direction, eta in -(x-direction), and zeta in -(y-direction) at the entra\
nce. The set {xi, eta, zeta} forms a right-hand system.\n   The rotation angles are defined so as to give the local {x,y,s} is wri\
tten\n\n    {x, y, s}_local\n   = rotate[s, chi3] rotate[x, chi2] rotate[y, -chi1]{x, y, s}_origin,\n\nwhere rotate[a, b] reads \"\
rotate around the new-a vector by b right-handedly.\n\ngeometric functions disignate the geometry of the coordinate. If the geomet\
ry of orbit is needed, use LINE[\"OGEO\"], etc., or DISP OG."[1,Max[p0$2509,0]]//"<img  class=\"eqs\" SRC=\""//equ$2509//"\" />"//
   Help2HTML`oy$["Available geometric-functions are:\n\nGX      geometrical coordinate xi\nGY      geometrical coordinate eta\nGZ \
     geometrical coordinate zeta\nCHI1    geometrical rotation angle ch1_1\nCHI2    geometrical rotation angle ch1_2\nCHI3    geom\
etrical rotation angle ch1_3\n\nThe geometrical coordinate {xi, eta, zeta} is set by the ORG command, and its default origin is at\
 the entrance of the beam line, and the default directions are xi in s-direction, eta in -(x-direction), and zeta in -(y-direction\
) at the entrance. The set {xi, eta, zeta} forms a right-hand system.\n   The rotation angles are defined so as to give the local \
{x,y,s} is written\n\n    {x, y, s}_local\n   = rotate[s, chi3] rotate[x, chi2] rotate[y, -chi1]{x, y, s}_origin,\n\nwhere rotate[\
a, b] reads \"rotate around the new-a vector by b right-handedly.\n\ngeometric functions disignate the geometry of the coordinate.\
 If the geometry of orbit is needed, use LINE[\"OGEO\"], etc., or DISP OG."[p2$2509,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L478>optical-functions</A> <A HREF=#L473>matching-function-commands</A> <A HREF=#L56>DISPLAY(DISP)</A> <A HREF=#L320>GEOCAL</A> <A HREF=#L321>GEOFIX</A> <A HREF=#L479>ORG</A> <A HREF=#L398>LINE</A></PRE>
<H3><A NAME=L469>
GO</A></H3>
<PRE>If[{},
Help2HTML`oA$["Usage: GO [[NO]EXPAND]\n\nDoes matching for fitting conditions given by matching-function-commands with variables s\
pecified by FREE.\n\nIf an option EXPAND is given (default), it expands the beam line before the calculation. If NOEXPAND is given\
, it avoids any expansion.   FFS[\"CAL\"] and FFS[\"GO\"] returns the result as a list, whose format is\n\n   {dp, kind, reslist, \
function-values},\n\nwhere\t\n\ndp:        a list contains dp/p0 .\nkind:      a list of kind of the orbit (usually 0, but 1 to 6 \
for the finite amplitude matching, see MatchingAmplitude).\nreslist:   a list of {residual, xstab, ystab}, where\t\n       residua\
l: matching residual,\n       xstab:    True when the matrix is stable in X,\n       ystab:    True when the matrix is stable in Y\
, for each orbit.\n\nAbove are lists with length nf (== number of orbits).\n\nfunction-values: a list of length nc (== number of c\
alculated items). Each element has the form:\n\n       {component1, component2, function, list-of-values},\n\n       where\n\n    \
   component1, component2: fit locations (see FIT).\n       function: name of the function (see matching-function-commands).\n    \
   list-of-values: list of the value of the function for each orbit Length nf.\n       The central orbit comes at the Floor[(n+1)/\
2]-th element."],
p$2512=1+p$2512[[1,2]];p1$2512=StringPosition["Usage: GO [[NO]EXPAND]\n\nDoes matching for fitting conditions given by matching-fu\
nction-commands with variables specified by FREE.\n\nIf an option EXPAND is given (default), it expands the beam line before the c\
alculation. If NOEXPAND is given, it avoids any expansion.   FFS[\"CAL\"] and FFS[\"GO\"] returns the result as a list, whose form\
at is\n\n   {dp, kind, reslist, function-values},\n\nwhere\t\n\ndp:        a list contains dp/p0 .\nkind:      a list of kind of t\
he orbit (usually 0, but 1 to 6 for the finite amplitude matching, see MatchingAmplitude).\nreslist:   a list of {residual, xstab,\
 ystab}, where\t\n       residual: matching residual,\n       xstab:    True when the matrix is stable in X,\n       ystab:    Tru\
e when the matrix is stable in Y, for each orbit.\n\nAbove are lists with length nf (== number of orbits).\n\nfunction-values: a l\
ist of length nc (== number of calculated items). Each element has the form:\n\n       {component1, component2, function, list-of-\
values},\n\n       where\n\n       component1, component2: fit locations (see FIT).\n       function: name of the function (see ma\
tching-function-commands).\n       list-of-values: list of the value of the function for each orbit Length nf.\n       The central\
 orbit comes at the Floor[(n+1)/2]-th element."[p$2512,-1],">::",1];
   p1$2512=If[p1$2512==={},1265,-2+p$2512+p1$2512[[1,1]]];
neq=Which["Usage: GO [[NO]EXPAND]\n\nDoes matching for fitting conditions given by matching-function-commands with variables speci\
fied by FREE.\n\nIf an option EXPAND is given (default), it expands the beam line before the calculation. If NOEXPAND is given, it\
 avoids any expansion.   FFS[\"CAL\"] and FFS[\"GO\"] returns the result as a list, whose format is\n\n   {dp, kind, reslist, func\
tion-values},\n\nwhere\t\n\ndp:        a list contains dp/p0 .\nkind:      a list of kind of the orbit (usually 0, but 1 to 6 for \
the finite amplitude matching, see MatchingAmplitude).\nreslist:   a list of {residual, xstab, ystab}, where\t\n       residual: m\
atching residual,\n       xstab:    True when the matrix is stable in X,\n       ystab:    True when the matrix is stable in Y, fo\
r each orbit.\n\nAbove are lists with length nf (== number of orbits).\n\nfunction-values: a list of length nc (== number of calcu\
lated items). Each element has the form:\n\n       {component1, component2, function, list-of-values},\n\n       where\n\n       c\
omponent1, component2: fit locations (see FIT).\n       function: name of the function (see matching-function-commands).\n       l\
ist-of-values: list of the value of the function for each orbit Length nf.\n       The central orbit comes at the Floor[(n+1)/2]-t\
h element."[p$2512,4+p$2512]==="Text[",
    lx$2512:=Help2HTML`oa$;p$2512=5+p$2512;p1$2512-=1;p2$2512=5+p1$2512;p0$2512=-9+p$2512;If[(pe$2512=
StringPosition["Usage: GO [[NO]EXPAND]\n\nDoes matching for fitting conditions given by matching-function-commands with variables \
specified by FREE.\n\nIf an option EXPAND is given (default), it expands the beam line before the calculation. If NOEXPAND is give\
n, it avoids any expansion.   FFS[\"CAL\"] and FFS[\"GO\"] returns the result as a list, whose format is\n\n   {dp, kind, reslist,\
 function-values},\n\nwhere\t\n\ndp:        a list contains dp/p0 .\nkind:      a list of kind of the orbit (usually 0, but 1 to 6\
 for the finite amplitude matching, see MatchingAmplitude).\nreslist:   a list of {residual, xstab, ystab}, where\t\n       residu\
al: matching residual,\n       xstab:    True when the matrix is stable in X,\n       ystab:    True when the matrix is stable in \
Y, for each orbit.\n\nAbove are lists with length nf (== number of orbits).\n\nfunction-values: a list of length nc (== number of \
calculated items). Each element has the form:\n\n       {component1, component2, function, list-of-values},\n\n       where\n\n   \
    component1, component2: fit locations (see FIT).\n       function: name of the function (see matching-function-commands).\n   \
    list-of-values: list of the value of the function for each orbit Length nf.\n       The central orbit comes at the Floor[(n+1)\
/2]-th element."[p$2512,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Usage: GO [[NO]EXPAND]\n\nDoes matching for fitting conditions given by matching-function-commands with variables\
 specified by FREE.\n\nIf an option EXPAND is given (default), it expands the beam line before the calculation. If NOEXPAND is giv\
en, it avoids any expansion.   FFS[\"CAL\"] and FFS[\"GO\"] returns the result as a list, whose format is\n\n   {dp, kind, reslist\
, function-values},\n\nwhere\t\n\ndp:        a list contains dp/p0 .\nkind:      a list of kind of the orbit (usually 0, but 1 to \
6 for the finite amplitude matching, see MatchingAmplitude).\nreslist:   a list of {residual, xstab, ystab}, where\t\n       resid\
ual: matching residual,\n       xstab:    True when the matrix is stable in X,\n       ystab:    True when the matrix is stable in\
 Y, for each orbit.\n\nAbove are lists with length nf (== number of orbits).\n\nfunction-values: a list of length nc (== number of\
 calculated items). Each element has the form:\n\n       {component1, component2, function, list-of-values},\n\n       where\n\n  \
     component1, component2: fit locations (see FIT).\n       function: name of the function (see matching-function-commands).\n  \
     list-of-values: list of the value of the function for each orbit Length nf.\n       The central orbit comes at the Floor[(n+1\
)/2]-th element."[p$2512+pe$2512[[1,2]],p1$2512]]],
        p1$2512=-2+p$2512+pe$2512[[1,1]]}[[
       1]],
      0],
    1,lx$2512:=Help2HTML`o9$;p2$2512=4+p1$2512;p0$2512=-4+p$2512;0];
  If[(equ$2512=
Help2HTML`o8$["Usage: GO [[NO]EXPAND]\n\nDoes matching for fitting conditions given by matching-function-commands with variables s\
pecified by FREE.\n\nIf an option EXPAND is given (default), it expands the beam line before the calculation. If NOEXPAND is given\
, it avoids any expansion.   FFS[\"CAL\"] and FFS[\"GO\"] returns the result as a list, whose format is\n\n   {dp, kind, reslist, \
function-values},\n\nwhere\t\n\ndp:        a list contains dp/p0 .\nkind:      a list of kind of the orbit (usually 0, but 1 to 6 \
for the finite amplitude matching, see MatchingAmplitude).\nreslist:   a list of {residual, xstab, ystab}, where\t\n       residua\
l: matching residual,\n       xstab:    True when the matrix is stable in X,\n       ystab:    True when the matrix is stable in Y\
, for each orbit.\n\nAbove are lists with length nf (== number of orbits).\n\nfunction-values: a list of length nc (== number of c\
alculated items). Each element has the form:\n\n       {component1, component2, function, list-of-values},\n\n       where\n\n    \
   component1, component2: fit locations (see FIT).\n       function: name of the function (see matching-function-commands).\n    \
   list-of-values: list of the value of the function for each orbit Length nf.\n       The central orbit comes at the Floor[(n+1)/\
2]-th element."[p$2512,p1$2512]])===
    Undefined,
equ$2512="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Usage: GO [[NO]EXPAND]\n\nDoes matching for \
fitting conditions given by matching-function-commands with variables specified by FREE.\n\nIf an option EXPAND is given (default)\
, it expands the beam line before the calculation. If NOEXPAND is given, it avoids any expansion.   FFS[\"CAL\"] and FFS[\"GO\"] r\
eturns the result as a list, whose format is\n\n   {dp, kind, reslist, function-values},\n\nwhere\t\n\ndp:        a list contains \
dp/p0 .\nkind:      a list of kind of the orbit (usually 0, but 1 to 6 for the finite amplitude matching, see MatchingAmplitude).\\
nreslist:   a list of {residual, xstab, ystab}, where\t\n       residual: matching residual,\n       xstab:    True when the matri\
x is stable in X,\n       ystab:    True when the matrix is stable in Y, for each orbit.\n\nAbove are lists with length nf (== num\
ber of orbits).\n\nfunction-values: a list of length nc (== number of calculated items). Each element has the form:\n\n       {com\
ponent1, component2, function, list-of-values},\n\n       where\n\n       component1, component2: fit locations (see FIT).\n      \
 function: name of the function (see matching-function-commands).\n       list-of-values: list of the value of the function for ea\
ch orbit Length nf.\n       The central orbit comes at the Floor[(n+1)/2]-th element."[p$2512,p1$2512]]=
       equ$2512;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2512},out$2512=lx$2512@Typeset["Usage: GO [[NO]EXPAND]\n\nDoes matching for fitting conditions given by matching-function\
-commands with variables specified by FREE.\n\nIf an option EXPAND is given (default), it expands the beam line before the calcula\
tion. If NOEXPAND is given, it avoids any expansion.   FFS[\"CAL\"] and FFS[\"GO\"] returns the result as a list, whose format is\\
n\n   {dp, kind, reslist, function-values},\n\nwhere\t\n\ndp:        a list contains dp/p0 .\nkind:      a list of kind of the orb\
it (usually 0, but 1 to 6 for the finite amplitude matching, see MatchingAmplitude).\nreslist:   a list of {residual, xstab, ystab\
}, where\t\n       residual: matching residual,\n       xstab:    True when the matrix is stable in X,\n       ystab:    True when\
 the matrix is stable in Y, for each orbit.\n\nAbove are lists with length nf (== number of orbits).\n\nfunction-values: a list of\
 length nc (== number of calculated items). Each element has the form:\n\n       {component1, component2, function, list-of-values\
},\n\n       where\n\n       component1, component2: fit locations (see FIT).\n       function: name of the function (see matching\
-function-commands).\n       list-of-values: list of the value of the function for each orbit Length nf.\n       The central orbit\
 comes at the Floor[(n+1)/2]-th element."[p$2512,p1$2512],Format->Help2HTML`oB$];
        System["mv -f "//out$2512//" "//equ$2512]];
      Exit[]]];
   "Usage: GO [[NO]EXPAND]\n\nDoes matching for fitting conditions given by matching-function-commands with variables specified by\
 FREE.\n\nIf an option EXPAND is given (default), it expands the beam line before the calculation. If NOEXPAND is given, it avoids\
 any expansion.   FFS[\"CAL\"] and FFS[\"GO\"] returns the result as a list, whose format is\n\n   {dp, kind, reslist, function-va\
lues},\n\nwhere\t\n\ndp:        a list contains dp/p0 .\nkind:      a list of kind of the orbit (usually 0, but 1 to 6 for the fin\
ite amplitude matching, see MatchingAmplitude).\nreslist:   a list of {residual, xstab, ystab}, where\t\n       residual: matching\
 residual,\n       xstab:    True when the matrix is stable in X,\n       ystab:    True when the matrix is stable in Y, for each \
orbit.\n\nAbove are lists with length nf (== number of orbits).\n\nfunction-values: a list of length nc (== number of calculated i\
tems). Each element has the form:\n\n       {component1, component2, function, list-of-values},\n\n       where\n\n       componen\
t1, component2: fit locations (see FIT).\n       function: name of the function (see matching-function-commands).\n       list-of-\
values: list of the value of the function for each orbit Length nf.\n       The central orbit comes at the Floor[(n+1)/2]-th eleme\
nt."[1,Max[p0$2512,0]]//"<img  class=\"eqs\" SRC=\""//equ$2512//"\" />"//
Help2HTML`oy$["Usage: GO [[NO]EXPAND]\n\nDoes matching for fitting conditions given by matching-function-commands with variables s\
pecified by FREE.\n\nIf an option EXPAND is given (default), it expands the beam line before the calculation. If NOEXPAND is given\
, it avoids any expansion.   FFS[\"CAL\"] and FFS[\"GO\"] returns the result as a list, whose format is\n\n   {dp, kind, reslist, \
function-values},\n\nwhere\t\n\ndp:        a list contains dp/p0 .\nkind:      a list of kind of the orbit (usually 0, but 1 to 6 \
for the finite amplitude matching, see MatchingAmplitude).\nreslist:   a list of {residual, xstab, ystab}, where\t\n       residua\
l: matching residual,\n       xstab:    True when the matrix is stable in X,\n       ystab:    True when the matrix is stable in Y\
, for each orbit.\n\nAbove are lists with length nf (== number of orbits).\n\nfunction-values: a list of length nc (== number of c\
alculated items). Each element has the form:\n\n       {component1, component2, function, list-of-values},\n\n       where\n\n    \
   component1, component2: fit locations (see FIT).\n       function: name of the function (see matching-function-commands).\n    \
   list-of-values: list of the value of the function for each orbit Length nf.\n       The central orbit comes at the Floor[(n+1)/\
2]-th element."[p2$2512,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L463>FIT</A> <A HREF=#L550>SHOW</A> <A HREF=#L473>matching-function-commands</A> <A HREF=#L477>off-momentum-matching</A> <A HREF=#L466>FREE</A> <A HREF=#L465>FIX</A> <A HREF=#L559>VARIABLES(VAR)</A> <A HREF=#L35>COUPLE(COUP)</A>
 <A HREF=#L4>ATTRIBUTE(ATTR)</A> <A HREF=#L32>CALCULATE(CAL)</A> <A HREF=#L560>VARY</A> <A HREF=#L550>SHOW</A> <A HREF=#L309>CONV</A> <A HREF=#L504>CONVERGENCE</A> <A HREF=#L528>MatchingResidual</A> <A HREF=#L527>MatchingAmplitude</A>
 <A HREF=#L521>FitFunction</A> <A HREF=#L392>FFS</A> <A HREF=#L400>OptimizeOptics</A></PRE>
<H3><A NAME=L470>
IF</A></H3>
<PRE>If[{},
Help2HTML`oA$["Usage: IF expr1 body1 [ELSEIF expr2 body2 [ELSEIF ..]] [ELSE body3] ENDIF\n\nThis is a FORTRAN77 like IF-structure.\
 If the expression expr1 is True(==1) or nonzero, executes commands in body1. If it is False(==0), skip commands until ELSE, ELSEI\
F or ENDIF appears at the same level of the IF-structure, and executes commands after ELSE or ENDIF, or executes the ELSEIF comman\
d. If expr1 is not a real number, an error message is printed and ignores the command line."],
 p$2515=1+p$2515[[1,2]];p1$2515=StringPosition["Usage: IF expr1 body1 [ELSEIF expr2 body2 [ELSEIF ..]] [ELSE body3] ENDIF\n\nThis \
is a FORTRAN77 like IF-structure. If the expression expr1 is True(==1) or nonzero, executes commands in body1. If it is False(==0)\
, skip commands until ELSE, ELSEIF or ENDIF appears at the same level of the IF-structure, and executes commands after ELSE or END\
IF, or executes the ELSEIF command. If expr1 is not a real number, an error message is printed and ignores the command line."[p
     $2515,-1],
    ">::",1];
   p1$2515=If[p1$2515==={},464,-2+p$2515+p1$2515[[1,1]]];
neq=Which["Usage: IF expr1 body1 [ELSEIF expr2 body2 [ELSEIF ..]] [ELSE body3] ENDIF\n\nThis is a FORTRAN77 like IF-structure. If \
the expression expr1 is True(==1) or nonzero, executes commands in body1. If it is False(==0), skip commands until ELSE, ELSEIF or\
 ENDIF appears at the same level of the IF-structure, and executes commands after ELSE or ENDIF, or executes the ELSEIF command. I\
f expr1 is not a real number, an error message is printed and ignores the command line."[p$2515,4+p$2515]==="Text[",
    lx$2515:=Help2HTML`oa$;p$2515=5+p$2515;p1$2515-=1;p2$2515=5+p1$2515;p0$2515=-9+p$2515;
If[(pe$2515=StringPosition["Usage: IF expr1 body1 [ELSEIF expr2 body2 [ELSEIF ..]] [ELSE body3] ENDIF\n\nThis is a FORTRAN77 like \
IF-structure. If the expression expr1 is True(==1) or nonzero, executes commands in body1. If it is False(==0), skip commands unti\
l ELSE, ELSEIF or ENDIF appears at the same level of the IF-structure, and executes commands after ELSE or ENDIF, or executes the \
ELSEIF command. If expr1 is not a real number, an error message is printed and ignores the command line."[p$2515,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Usage: IF expr1 body1 [ELSEIF expr2 body2 [ELSEIF ..]] [ELSE body3] ENDIF\n\nThis is a FORTRAN77 like IF-structur\
e. If the expression expr1 is True(==1) or nonzero, executes commands in body1. If it is False(==0), skip commands until ELSE, ELS\
EIF or ENDIF appears at the same level of the IF-structure, and executes commands after ELSE or ENDIF, or executes the ELSEIF comm\
and. If expr1 is not a real number, an error message is printed and ignores the command line."[p$2515+pe$2515[[1,2]],p1$2515]]],
        p1$2515=-2+p$2515+pe$2515[[1,1]]}[[
       1]],
      0],
    1,lx$2515:=Help2HTML`o9$;p2$2515=4+p1$2515;p0$2515=-4+p$2515;0];
  If[(equ$2515=
Help2HTML`o8$["Usage: IF expr1 body1 [ELSEIF expr2 body2 [ELSEIF ..]] [ELSE body3] ENDIF\n\nThis is a FORTRAN77 like IF-structure.\
 If the expression expr1 is True(==1) or nonzero, executes commands in body1. If it is False(==0), skip commands until ELSE, ELSEI\
F or ENDIF appears at the same level of the IF-structure, and executes commands after ELSE or ENDIF, or executes the ELSEIF comman\
d. If expr1 is not a real number, an error message is printed and ignores the command line."[p$2515,p1$2515]])===
    Undefined,
equ$2515="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Usage: IF expr1 body1 [ELSEIF expr2 body2 [E\
LSEIF ..]] [ELSE body3] ENDIF\n\nThis is a FORTRAN77 like IF-structure. If the expression expr1 is True(==1) or nonzero, executes \
commands in body1. If it is False(==0), skip commands until ELSE, ELSEIF or ENDIF appears at the same level of the IF-structure, a\
nd executes commands after ELSE or ENDIF, or executes the ELSEIF command. If expr1 is not a real number, an error message is print\
ed and ignores the command line."[p$2515,p1$2515]]=
       equ$2515;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2515},out$2515=lx$2515@Typeset["Usage: IF expr1 body1 [ELSEIF expr2 body2 [ELSEIF ..]] [ELSE body3] ENDIF\n\nThis is a FO\
RTRAN77 like IF-structure. If the expression expr1 is True(==1) or nonzero, executes commands in body1. If it is False(==0), skip \
commands until ELSE, ELSEIF or ENDIF appears at the same level of the IF-structure, and executes commands after ELSE or ENDIF, or \
executes the ELSEIF command. If expr1 is not a real number, an error message is printed and ignores the command line."[p$2515,
           p1$2515],Format->Help2HTML`oB$];
        System["mv -f "//out$2515//" "//equ$2515]];
      Exit[]]];
   "Usage: IF expr1 body1 [ELSEIF expr2 body2 [ELSEIF ..]] [ELSE body3] ENDIF\n\nThis is a FORTRAN77 like IF-structure. If the exp\
ression expr1 is True(==1) or nonzero, executes commands in body1. If it is False(==0), skip commands until ELSE, ELSEIF or ENDIF \
appears at the same level of the IF-structure, and executes commands after ELSE or ENDIF, or executes the ELSEIF command. If expr1\
 is not a real number, an error message is printed and ignores the command line."[1,Max[p0$2515,0]]//"<img  class=\"eqs\" SRC=\""//
   equ$2515//"\" />"//
Help2HTML`oy$["Usage: IF expr1 body1 [ELSEIF expr2 body2 [ELSEIF ..]] [ELSE body3] ENDIF\n\nThis is a FORTRAN77 like IF-structure.\
 If the expression expr1 is True(==1) or nonzero, executes commands in body1. If it is False(==0), skip commands until ELSE, ELSEI\
F or ENDIF appears at the same level of the IF-structure, and executes commands after ELSE or ENDIF, or executes the ELSEIF comman\
d. If expr1 is not a real number, an error message is printed and ignores the command line."[p2$2515,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L293>ELSE</A> <A HREF=#L294>ELSEIF</A> <A HREF=#L297>ENDIF</A> <A HREF=#L246>expression</A> <A HREF=#L29>command-syntax</A> If</PRE>
<H3><A NAME=L471>
INPUT(IN)</A></H3>
<PRE>If[{},
Help2HTML`oA$["IN {filename | file-number} switches the input stream to the specified file or the file-number. The original stream\
 is kept and to be returned by TERMINATE(TERM). The input file is not rewound."],
p$2518=1+p$2518[[1,2]];p1$2518=StringPosition["IN {filename | file-number} switches the input stream to the specified file or the \
file-number. The original stream is kept and to be returned by TERMINATE(TERM). The input file is not rewound."[p$2518,-1],">::",
    1];
   p1$2518=If[p1$2518==={},193,-2+p$2518+p1$2518[[1,1]]];
neq=Which["IN {filename | file-number} switches the input stream to the specified file or the file-number. The original stream is \
kept and to be returned by TERMINATE(TERM). The input file is not rewound."[p$2518,4+p$2518]==="Text[",
    lx$2518:=Help2HTML`oa$;p$2518=5+p$2518;p1$2518-=1;p2$2518=5+p1$2518;p0$2518=-9+p$2518;
If[(pe$2518=StringPosition["IN {filename | file-number} switches the input stream to the specified file or the file-number. The or\
iginal stream is kept and to be returned by TERMINATE(TERM). The input file is not rewound."[p$2518,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["IN {filename | file-number} switches the input stream to the specified file or the file-number. The original stre\
am is kept and to be returned by TERMINATE(TERM). The input file is not rewound."[p$2518+pe$2518[[1,2]],p1$2518]]],
        p1$2518=-2+p$2518+pe$2518[[1,1]]}[[
       1]],
      0],
    1,lx$2518:=Help2HTML`o9$;p2$2518=4+p1$2518;p0$2518=-4+p$2518;0];
  If[(equ$2518=
Help2HTML`o8$["IN {filename | file-number} switches the input stream to the specified file or the file-number. The original stream\
 is kept and to be returned by TERMINATE(TERM). The input file is not rewound."[p$2518,p1$2518]])===
    Undefined,
equ$2518="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["IN {filename | file-number} switches the inp\
ut stream to the specified file or the file-number. The original stream is kept and to be returned by TERMINATE(TERM). The input f\
ile is not rewound."[p$2518,p1$2518]]=
       equ$2518;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2518},out$2518=lx$2518@Typeset["IN {filename | file-number} switches the input stream to the specified file or the file-n\
umber. The original stream is kept and to be returned by TERMINATE(TERM). The input file is not rewound."[p$2518,p1$2518],
          Format->Help2HTML`oB$];
        System["mv -f "//out$2518//" "//equ$2518]];
      Exit[]]];
   "IN {filename | file-number} switches the input stream to the specified file or the file-number. The original stream is kept an\
d to be returned by TERMINATE(TERM). The input file is not rewound."[1,Max[p0$2518,0]]//"<img  class=\"eqs\" SRC=\""//equ$2518//
   "\" />"//
Help2HTML`oy$["IN {filename | file-number} switches the input stream to the specified file or the file-number. The original stream\
 is kept and to be returned by TERMINATE(TERM). The input file is not rewound."[p2$2518,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L555>TERMINATE(TERM)</A> <A HREF=#L34>CLOSE(CLO)</A> <A HREF=#L487>READ</A> <A HREF=#L480>OUTPUT(OUT)</A> <A HREF=#L3>APPEND(APP)</A> <A HREF=#L296>END</A></PRE>
<H3><A NAME=L472>
machine-error-commands</A></H3>
<PRE>If[{},
Help2HTML`oA$["Usage: machine-error-command [options] amount component-pattern ..\n\nwhere machine-error-command is one of\n\ncomm\
and    keyword affected     applicable types\nDELX       DX                   BEND QUAD SEXT OCT DECA DODECA SOL CAV\nDELY       D\
Y                   BEND QUAD SEXT OCT DECA DODECA SOL CAV\nDL         L                    DRIFT SOL\nDTHETA     ROTATE          \
     QUAD SEXT OCT DECA DODECA CAV\nDTHETA     DROTATE              BEND\nDK         default-keyword      DRIFT BEND QUAD SEXT OCT\
 DECA DODECA MULT SOL CAV\nDDK        K0 or DBZ            BEND SOL\n\n   amount is the amount of the error,\n   component-pattern\
 is the pattern to specify the components to be applied.\n\n   Options are\t\n\nRANDOM(R)        Set amount*GaussRandom[] to the k\
eyword. \nUNIFORM(U)       Set the specified amount to the keyword without random number.\nINCOHERENT(INC)  GaussRandom[] is calle\
d for each component. Default.\nCOHERENT(C)      GaussRandom[] is called once for each component-pattern.\nPUT(P)           Set th\
e error to the keyword. Default.\nADD(A)           Add the error to the keyword.\t"],
 p$2521=1+p$2521[[1,2]];p1$2521=StringPosition["Usage: machine-error-command [options] amount component-pattern ..\n\nwhere machin\
e-error-command is one of\n\ncommand    keyword affected     applicable types\nDELX       DX                   BEND QUAD SEXT OCT \
DECA DODECA SOL CAV\nDELY       DY                   BEND QUAD SEXT OCT DECA DODECA SOL CAV\nDL         L                    DRIFT\
 SOL\nDTHETA     ROTATE               QUAD SEXT OCT DECA DODECA CAV\nDTHETA     DROTATE              BEND\nDK         default-keyw\
ord      DRIFT BEND QUAD SEXT OCT DECA DODECA MULT SOL CAV\nDDK        K0 or DBZ            BEND SOL\n\n   amount is the amount of\
 the error,\n   component-pattern is the pattern to specify the components to be applied.\n\n   Options are\t\n\nRANDOM(R)        \
Set amount*GaussRandom[] to the keyword. \nUNIFORM(U)       Set the specified amount to the keyword without random number.\nINCOHE\
RENT(INC)  GaussRandom[] is called for each component. Default.\nCOHERENT(C)      GaussRandom[] is called once for each component-\
pattern.\nPUT(P)           Set the error to the keyword. Default.\nADD(A)           Add the error to the keyword.\t"[p$2521,-1],
    ">::",1];
   p1$2521=If[p1$2521==={},1082,-2+p$2521+p1$2521[[1,1]]];
neq=Which["Usage: machine-error-command [options] amount component-pattern ..\n\nwhere machine-error-command is one of\n\ncommand \
   keyword affected     applicable types\nDELX       DX                   BEND QUAD SEXT OCT DECA DODECA SOL CAV\nDELY       DY   \
                BEND QUAD SEXT OCT DECA DODECA SOL CAV\nDL         L                    DRIFT SOL\nDTHETA     ROTATE              \
 QUAD SEXT OCT DECA DODECA CAV\nDTHETA     DROTATE              BEND\nDK         default-keyword      DRIFT BEND QUAD SEXT OCT DEC\
A DODECA MULT SOL CAV\nDDK        K0 or DBZ            BEND SOL\n\n   amount is the amount of the error,\n   component-pattern is \
the pattern to specify the components to be applied.\n\n   Options are\t\n\nRANDOM(R)        Set amount*GaussRandom[] to the keywo\
rd. \nUNIFORM(U)       Set the specified amount to the keyword without random number.\nINCOHERENT(INC)  GaussRandom[] is called fo\
r each component. Default.\nCOHERENT(C)      GaussRandom[] is called once for each component-pattern.\nPUT(P)           Set the er\
ror to the keyword. Default.\nADD(A)           Add the error to the keyword.\t"[p$2521,4+p$2521]==="Text[",
    lx$2521:=Help2HTML`oa$;p$2521=5+p$2521;p1$2521-=1;p2$2521=5+p1$2521;p0$2521=-9+p$2521;
If[(pe$2521=StringPosition["Usage: machine-error-command [options] amount component-pattern ..\n\nwhere machine-error-command is o\
ne of\n\ncommand    keyword affected     applicable types\nDELX       DX                   BEND QUAD SEXT OCT DECA DODECA SOL CAV\\
nDELY       DY                   BEND QUAD SEXT OCT DECA DODECA SOL CAV\nDL         L                    DRIFT SOL\nDTHETA     ROT\
ATE               QUAD SEXT OCT DECA DODECA CAV\nDTHETA     DROTATE              BEND\nDK         default-keyword      DRIFT BEND \
QUAD SEXT OCT DECA DODECA MULT SOL CAV\nDDK        K0 or DBZ            BEND SOL\n\n   amount is the amount of the error,\n   comp\
onent-pattern is the pattern to specify the components to be applied.\n\n   Options are\t\n\nRANDOM(R)        Set amount*GaussRand\
om[] to the keyword. \nUNIFORM(U)       Set the specified amount to the keyword without random number.\nINCOHERENT(INC)  GaussRand\
om[] is called for each component. Default.\nCOHERENT(C)      GaussRandom[] is called once for each component-pattern.\nPUT(P)    \
       Set the error to the keyword. Default.\nADD(A)           Add the error to the keyword.\t"[p$2521,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Usage: machine-error-command [options] amount component-pattern ..\n\nwhere machine-error-command is one of\n\nco\
mmand    keyword affected     applicable types\nDELX       DX                   BEND QUAD SEXT OCT DECA DODECA SOL CAV\nDELY      \
 DY                   BEND QUAD SEXT OCT DECA DODECA SOL CAV\nDL         L                    DRIFT SOL\nDTHETA     ROTATE        \
       QUAD SEXT OCT DECA DODECA CAV\nDTHETA     DROTATE              BEND\nDK         default-keyword      DRIFT BEND QUAD SEXT O\
CT DECA DODECA MULT SOL CAV\nDDK        K0 or DBZ            BEND SOL\n\n   amount is the amount of the error,\n   component-patte\
rn is the pattern to specify the components to be applied.\n\n   Options are\t\n\nRANDOM(R)        Set amount*GaussRandom[] to the\
 keyword. \nUNIFORM(U)       Set the specified amount to the keyword without random number.\nINCOHERENT(INC)  GaussRandom[] is cal\
led for each component. Default.\nCOHERENT(C)      GaussRandom[] is called once for each component-pattern.\nPUT(P)           Set \
the error to the keyword. Default.\nADD(A)           Add the error to the keyword.\t"[p$2521+pe$2521[[1,2]],p1$2521]]],
        p1$2521=-2+p$2521+pe$2521[[1,1]]}[[
       1]],
      0],
    1,lx$2521:=Help2HTML`o9$;p2$2521=4+p1$2521;p0$2521=-4+p$2521;0];
  If[(equ$2521=
Help2HTML`o8$["Usage: machine-error-command [options] amount component-pattern ..\n\nwhere machine-error-command is one of\n\ncomm\
and    keyword affected     applicable types\nDELX       DX                   BEND QUAD SEXT OCT DECA DODECA SOL CAV\nDELY       D\
Y                   BEND QUAD SEXT OCT DECA DODECA SOL CAV\nDL         L                    DRIFT SOL\nDTHETA     ROTATE          \
     QUAD SEXT OCT DECA DODECA CAV\nDTHETA     DROTATE              BEND\nDK         default-keyword      DRIFT BEND QUAD SEXT OCT\
 DECA DODECA MULT SOL CAV\nDDK        K0 or DBZ            BEND SOL\n\n   amount is the amount of the error,\n   component-pattern\
 is the pattern to specify the components to be applied.\n\n   Options are\t\n\nRANDOM(R)        Set amount*GaussRandom[] to the k\
eyword. \nUNIFORM(U)       Set the specified amount to the keyword without random number.\nINCOHERENT(INC)  GaussRandom[] is calle\
d for each component. Default.\nCOHERENT(C)      GaussRandom[] is called once for each component-pattern.\nPUT(P)           Set th\
e error to the keyword. Default.\nADD(A)           Add the error to the keyword.\t"[p$2521,p1$2521]])===
    Undefined,
equ$2521="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Usage: machine-error-command [options] amoun\
t component-pattern ..\n\nwhere machine-error-command is one of\n\ncommand    keyword affected     applicable types\nDELX       DX\
                   BEND QUAD SEXT OCT DECA DODECA SOL CAV\nDELY       DY                   BEND QUAD SEXT OCT DECA DODECA SOL CAV\\
nDL         L                    DRIFT SOL\nDTHETA     ROTATE               QUAD SEXT OCT DECA DODECA CAV\nDTHETA     DROTATE     \
         BEND\nDK         default-keyword      DRIFT BEND QUAD SEXT OCT DECA DODECA MULT SOL CAV\nDDK        K0 or DBZ            \
BEND SOL\n\n   amount is the amount of the error,\n   component-pattern is the pattern to specify the components to be applied.\n\\
n   Options are\t\n\nRANDOM(R)        Set amount*GaussRandom[] to the keyword. \nUNIFORM(U)       Set the specified amount to the \
keyword without random number.\nINCOHERENT(INC)  GaussRandom[] is called for each component. Default.\nCOHERENT(C)      GaussRando\
m[] is called once for each component-pattern.\nPUT(P)           Set the error to the keyword. Default.\nADD(A)           Add the \
error to the keyword.\t"[p$2521,p1$2521]]=
       equ$2521;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2521},out$2521=lx$2521@Typeset["Usage: machine-error-command [options] amount component-pattern ..\n\nwhere machine-error\
-command is one of\n\ncommand    keyword affected     applicable types\nDELX       DX                   BEND QUAD SEXT OCT DECA DO\
DECA SOL CAV\nDELY       DY                   BEND QUAD SEXT OCT DECA DODECA SOL CAV\nDL         L                    DRIFT SOL\nD\
THETA     ROTATE               QUAD SEXT OCT DECA DODECA CAV\nDTHETA     DROTATE              BEND\nDK         default-keyword    \
  DRIFT BEND QUAD SEXT OCT DECA DODECA MULT SOL CAV\nDDK        K0 or DBZ            BEND SOL\n\n   amount is the amount of the er\
ror,\n   component-pattern is the pattern to specify the components to be applied.\n\n   Options are\t\n\nRANDOM(R)        Set amo\
unt*GaussRandom[] to the keyword. \nUNIFORM(U)       Set the specified amount to the keyword without random number.\nINCOHERENT(IN\
C)  GaussRandom[] is called for each component. Default.\nCOHERENT(C)      GaussRandom[] is called once for each component-pattern\
.\nPUT(P)           Set the error to the keyword. Default.\nADD(A)           Add the error to the keyword.\t"[p$2521,p1$2521],
          Format->Help2HTML`oB$];
        System["mv -f "//out$2521//" "//equ$2521]];
      Exit[]]];
   "Usage: machine-error-command [options] amount component-pattern ..\n\nwhere machine-error-command is one of\n\ncommand    keyw\
ord affected     applicable types\nDELX       DX                   BEND QUAD SEXT OCT DECA DODECA SOL CAV\nDELY       DY          \
         BEND QUAD SEXT OCT DECA DODECA SOL CAV\nDL         L                    DRIFT SOL\nDTHETA     ROTATE               QUAD S\
EXT OCT DECA DODECA CAV\nDTHETA     DROTATE              BEND\nDK         default-keyword      DRIFT BEND QUAD SEXT OCT DECA DODEC\
A MULT SOL CAV\nDDK        K0 or DBZ            BEND SOL\n\n   amount is the amount of the error,\n   component-pattern is the pat\
tern to specify the components to be applied.\n\n   Options are\t\n\nRANDOM(R)        Set amount*GaussRandom[] to the keyword. \nU\
NIFORM(U)       Set the specified amount to the keyword without random number.\nINCOHERENT(INC)  GaussRandom[] is called for each \
component. Default.\nCOHERENT(C)      GaussRandom[] is called once for each component-pattern.\nPUT(P)           Set the error to \
the keyword. Default.\nADD(A)           Add the error to the keyword.\t"[1,Max[p0$2521,0]]//"<img  class=\"eqs\" SRC=\""//
   equ$2521//"\" />"//
Help2HTML`oy$["Usage: machine-error-command [options] amount component-pattern ..\n\nwhere machine-error-command is one of\n\ncomm\
and    keyword affected     applicable types\nDELX       DX                   BEND QUAD SEXT OCT DECA DODECA SOL CAV\nDELY       D\
Y                   BEND QUAD SEXT OCT DECA DODECA SOL CAV\nDL         L                    DRIFT SOL\nDTHETA     ROTATE          \
     QUAD SEXT OCT DECA DODECA CAV\nDTHETA     DROTATE              BEND\nDK         default-keyword      DRIFT BEND QUAD SEXT OCT\
 DECA DODECA MULT SOL CAV\nDDK        K0 or DBZ            BEND SOL\n\n   amount is the amount of the error,\n   component-pattern\
 is the pattern to specify the components to be applied.\n\n   Options are\t\n\nRANDOM(R)        Set amount*GaussRandom[] to the k\
eyword. \nUNIFORM(U)       Set the specified amount to the keyword without random number.\nINCOHERENT(INC)  GaussRandom[] is calle\
d for each component. Default.\nCOHERENT(C)      GaussRandom[] is called once for each component-pattern.\nPUT(P)           Set th\
e error to the keyword. Default.\nADD(A)           Add the error to the keyword.\t"[p2$2521,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L30>components</A> <A HREF=#L562>wildcards</A> <A HREF=#L136>keywords</A> <A HREF=#L113>default-keyword</A> <A HREF=#L74>DUMP</A> <A HREF=#L549>SEED</A></PRE>
<H3><A NAME=L473>
matching-function-commands</A></H3>
<PRE>If[{},
Help2HTML`oA$["Usage: (1) matching-function  goal-value [off-momentum-points]\n       (2) matching-functionM goal-value [off-momen\
tum-points]\n       (3) matching-functionI incoming-value\n       (4) matching-functionSCALE scale\n\n(1) sets the matching condit\
ion for matching-function at the current fitting point or region with the goal-value and the off-momentum-points (see off-momentum\
-matching).\n   If off-momentum-points is omitted, the previous value for this matching-function at this fitting-point is assumed.\
 If the previous value is not defined, 1 is assumed. If -1 is given for off-momentum-points, the matching-function is rejected fro\
m the matching (see REJECT(REJ)).\n   If \"*\" is given for goal-value, the previous value is used if exists.\n\nExample:   BX 10 \
3    (beta_x to be 10 at 3 momenta) \n           BX 20      (now beta_x to be 20 at 3 momenta (previous setting))\n           BX *\
  5    (now beta_x to be 20 (previous setting) at 5 momenta)\n\n(2) If the letter \"M\" is appended to matching-function, it means\
 the maximum-fitting for the function. The maximum of either the value (for positive-definite functions) or the absolute value (fo\
r bipolar functions) are to be limited in the matching.\n\n(3) If the letter \"I\" is appended to matching-function, it specifies \
the value of the incoming beam.\n\n(4) If SCALE is appended to matching-function, it sets the scale of the input/output of the fun\
ction to scale. This scale is used in the matching-function commands, DISPLAY(DISP), SHOW, etc.\n(5) If the current fit location i\
s at a MARK, @ for the goal value refers the save value at the MARK. @- refers -(save value). These are useful to match between tw\
o beam lines.\n\n   Available matching-functions are:\noptical-functions (see optical-functions):\nAX BX GMX NX AY BY GMY NY EX EP\
X EY EPY R1 R2 R3 R4 DETR DX DPX DY DPY DZ DDP PEX PEPX PEY PEPY TRX TRY LENG\ngeometric-functions (see geometric-functions):\nGX \
GY GZ CHI1 CHI2 CHI3"],
p$2524=1+p$2524[[1,2]];p1$2524=StringPosition["Usage: (1) matching-function  goal-value [off-momentum-points]\n       (2) matching\
-functionM goal-value [off-momentum-points]\n       (3) matching-functionI incoming-value\n       (4) matching-functionSCALE scale\
\n\n(1) sets the matching condition for matching-function at the current fitting point or region with the goal-value and the off-m\
omentum-points (see off-momentum-matching).\n   If off-momentum-points is omitted, the previous value for this matching-function a\
t this fitting-point is assumed. If the previous value is not defined, 1 is assumed. If -1 is given for off-momentum-points, the m\
atching-function is rejected from the matching (see REJECT(REJ)).\n   If \"*\" is given for goal-value, the previous value is used\
 if exists.\n\nExample:   BX 10 3    (beta_x to be 10 at 3 momenta) \n           BX 20      (now beta_x to be 20 at 3 momenta (pre\
vious setting))\n           BX *  5    (now beta_x to be 20 (previous setting) at 5 momenta)\n\n(2) If the letter \"M\" is appende\
d to matching-function, it means the maximum-fitting for the function. The maximum of either the value (for positive-definite func\
tions) or the absolute value (for bipolar functions) are to be limited in the matching.\n\n(3) If the letter \"I\" is appended to \
matching-function, it specifies the value of the incoming beam.\n\n(4) If SCALE is appended to matching-function, it sets the scal\
e of the input/output of the function to scale. This scale is used in the matching-function commands, DISPLAY(DISP), SHOW, etc.\n(\
5) If the current fit location is at a MARK, @ for the goal value refers the save value at the MARK. @- refers -(save value). Thes\
e are useful to match between two beam lines.\n\n   Available matching-functions are:\noptical-functions (see optical-functions):\\
nAX BX GMX NX AY BY GMY NY EX EPX EY EPY R1 R2 R3 R4 DETR DX DPX DY DPY DZ DDP PEX PEPX PEY PEPY TRX TRY LENG\ngeometric-functions\
 (see geometric-functions):\nGX GY GZ CHI1 CHI2 CHI3"[p$2524,-1],">::",1];
   p1$2524=If[p1$2524==={},1925,-2+p$2524+p1$2524[[1,1]]];
neq=Which["Usage: (1) matching-function  goal-value [off-momentum-points]\n       (2) matching-functionM goal-value [off-momentum-\
points]\n       (3) matching-functionI incoming-value\n       (4) matching-functionSCALE scale\n\n(1) sets the matching condition \
for matching-function at the current fitting point or region with the goal-value and the off-momentum-points (see off-momentum-mat\
ching).\n   If off-momentum-points is omitted, the previous value for this matching-function at this fitting-point is assumed. If \
the previous value is not defined, 1 is assumed. If -1 is given for off-momentum-points, the matching-function is rejected from th\
e matching (see REJECT(REJ)).\n   If \"*\" is given for goal-value, the previous value is used if exists.\n\nExample:   BX 10 3   \
 (beta_x to be 10 at 3 momenta) \n           BX 20      (now beta_x to be 20 at 3 momenta (previous setting))\n           BX *  5 \
   (now beta_x to be 20 (previous setting) at 5 momenta)\n\n(2) If the letter \"M\" is appended to matching-function, it means the\
 maximum-fitting for the function. The maximum of either the value (for positive-definite functions) or the absolute value (for bi\
polar functions) are to be limited in the matching.\n\n(3) If the letter \"I\" is appended to matching-function, it specifies the \
value of the incoming beam.\n\n(4) If SCALE is appended to matching-function, it sets the scale of the input/output of the functio\
n to scale. This scale is used in the matching-function commands, DISPLAY(DISP), SHOW, etc.\n(5) If the current fit location is at\
 a MARK, @ for the goal value refers the save value at the MARK. @- refers -(save value). These are useful to match between two be\
am lines.\n\n   Available matching-functions are:\noptical-functions (see optical-functions):\nAX BX GMX NX AY BY GMY NY EX EPX EY\
 EPY R1 R2 R3 R4 DETR DX DPX DY DPY DZ DDP PEX PEPX PEY PEPY TRX TRY LENG\ngeometric-functions (see geometric-functions):\nGX GY G\
Z CHI1 CHI2 CHI3"[p$2524,4+p$2524]==="Text[",
    lx$2524:=Help2HTML`oa$;p$2524=5+p$2524;p1$2524-=1;p2$2524=5+p1$2524;p0$2524=-9+p$2524;If[(pe$2524=
StringPosition["Usage: (1) matching-function  goal-value [off-momentum-points]\n       (2) matching-functionM goal-value [off-mome\
ntum-points]\n       (3) matching-functionI incoming-value\n       (4) matching-functionSCALE scale\n\n(1) sets the matching condi\
tion for matching-function at the current fitting point or region with the goal-value and the off-momentum-points (see off-momentu\
m-matching).\n   If off-momentum-points is omitted, the previous value for this matching-function at this fitting-point is assumed\
. If the previous value is not defined, 1 is assumed. If -1 is given for off-momentum-points, the matching-function is rejected fr\
om the matching (see REJECT(REJ)).\n   If \"*\" is given for goal-value, the previous value is used if exists.\n\nExample:   BX 10\
 3    (beta_x to be 10 at 3 momenta) \n           BX 20      (now beta_x to be 20 at 3 momenta (previous setting))\n           BX \
*  5    (now beta_x to be 20 (previous setting) at 5 momenta)\n\n(2) If the letter \"M\" is appended to matching-function, it mean\
s the maximum-fitting for the function. The maximum of either the value (for positive-definite functions) or the absolute value (f\
or bipolar functions) are to be limited in the matching.\n\n(3) If the letter \"I\" is appended to matching-function, it specifies\
 the value of the incoming beam.\n\n(4) If SCALE is appended to matching-function, it sets the scale of the input/output of the fu\
nction to scale. This scale is used in the matching-function commands, DISPLAY(DISP), SHOW, etc.\n(5) If the current fit location \
is at a MARK, @ for the goal value refers the save value at the MARK. @- refers -(save value). These are useful to match between t\
wo beam lines.\n\n   Available matching-functions are:\noptical-functions (see optical-functions):\nAX BX GMX NX AY BY GMY NY EX E\
PX EY EPY R1 R2 R3 R4 DETR DX DPX DY DPY DZ DDP PEX PEPX PEY PEPY TRX TRY LENG\ngeometric-functions (see geometric-functions):\nGX\
 GY GZ CHI1 CHI2 CHI3"[p$2524,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Usage: (1) matching-function  goal-value [off-momentum-points]\n       (2) matching-functionM goal-value [off-mom\
entum-points]\n       (3) matching-functionI incoming-value\n       (4) matching-functionSCALE scale\n\n(1) sets the matching cond\
ition for matching-function at the current fitting point or region with the goal-value and the off-momentum-points (see off-moment\
um-matching).\n   If off-momentum-points is omitted, the previous value for this matching-function at this fitting-point is assume\
d. If the previous value is not defined, 1 is assumed. If -1 is given for off-momentum-points, the matching-function is rejected f\
rom the matching (see REJECT(REJ)).\n   If \"*\" is given for goal-value, the previous value is used if exists.\n\nExample:   BX 1\
0 3    (beta_x to be 10 at 3 momenta) \n           BX 20      (now beta_x to be 20 at 3 momenta (previous setting))\n           BX\
 *  5    (now beta_x to be 20 (previous setting) at 5 momenta)\n\n(2) If the letter \"M\" is appended to matching-function, it mea\
ns the maximum-fitting for the function. The maximum of either the value (for positive-definite functions) or the absolute value (\
for bipolar functions) are to be limited in the matching.\n\n(3) If the letter \"I\" is appended to matching-function, it specifie\
s the value of the incoming beam.\n\n(4) If SCALE is appended to matching-function, it sets the scale of the input/output of the f\
unction to scale. This scale is used in the matching-function commands, DISPLAY(DISP), SHOW, etc.\n(5) If the current fit location\
 is at a MARK, @ for the goal value refers the save value at the MARK. @- refers -(save value). These are useful to match between \
two beam lines.\n\n   Available matching-functions are:\noptical-functions (see optical-functions):\nAX BX GMX NX AY BY GMY NY EX \
EPX EY EPY R1 R2 R3 R4 DETR DX DPX DY DPY DZ DDP PEX PEPX PEY PEPY TRX TRY LENG\ngeometric-functions (see geometric-functions):\nG\
X GY GZ CHI1 CHI2 CHI3"[p$2524+pe$2524[[1,2]],p1$2524]]],
        p1$2524=-2+p$2524+pe$2524[[1,1]]}[[
       1]],
      0],
    1,lx$2524:=Help2HTML`o9$;p2$2524=4+p1$2524;p0$2524=-4+p$2524;0];
  If[(equ$2524=
Help2HTML`o8$["Usage: (1) matching-function  goal-value [off-momentum-points]\n       (2) matching-functionM goal-value [off-momen\
tum-points]\n       (3) matching-functionI incoming-value\n       (4) matching-functionSCALE scale\n\n(1) sets the matching condit\
ion for matching-function at the current fitting point or region with the goal-value and the off-momentum-points (see off-momentum\
-matching).\n   If off-momentum-points is omitted, the previous value for this matching-function at this fitting-point is assumed.\
 If the previous value is not defined, 1 is assumed. If -1 is given for off-momentum-points, the matching-function is rejected fro\
m the matching (see REJECT(REJ)).\n   If \"*\" is given for goal-value, the previous value is used if exists.\n\nExample:   BX 10 \
3    (beta_x to be 10 at 3 momenta) \n           BX 20      (now beta_x to be 20 at 3 momenta (previous setting))\n           BX *\
  5    (now beta_x to be 20 (previous setting) at 5 momenta)\n\n(2) If the letter \"M\" is appended to matching-function, it means\
 the maximum-fitting for the function. The maximum of either the value (for positive-definite functions) or the absolute value (fo\
r bipolar functions) are to be limited in the matching.\n\n(3) If the letter \"I\" is appended to matching-function, it specifies \
the value of the incoming beam.\n\n(4) If SCALE is appended to matching-function, it sets the scale of the input/output of the fun\
ction to scale. This scale is used in the matching-function commands, DISPLAY(DISP), SHOW, etc.\n(5) If the current fit location i\
s at a MARK, @ for the goal value refers the save value at the MARK. @- refers -(save value). These are useful to match between tw\
o beam lines.\n\n   Available matching-functions are:\noptical-functions (see optical-functions):\nAX BX GMX NX AY BY GMY NY EX EP\
X EY EPY R1 R2 R3 R4 DETR DX DPX DY DPY DZ DDP PEX PEPX PEY PEPY TRX TRY LENG\ngeometric-functions (see geometric-functions):\nGX \
GY GZ CHI1 CHI2 CHI3"[p$2524,p1$2524]])===
    Undefined,
equ$2524="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Usage: (1) matching-function  goal-value [of\
f-momentum-points]\n       (2) matching-functionM goal-value [off-momentum-points]\n       (3) matching-functionI incoming-value\n\
       (4) matching-functionSCALE scale\n\n(1) sets the matching condition for matching-function at the current fitting point or r\
egion with the goal-value and the off-momentum-points (see off-momentum-matching).\n   If off-momentum-points is omitted, the prev\
ious value for this matching-function at this fitting-point is assumed. If the previous value is not defined, 1 is assumed. If -1 \
is given for off-momentum-points, the matching-function is rejected from the matching (see REJECT(REJ)).\n   If \"*\" is given for\
 goal-value, the previous value is used if exists.\n\nExample:   BX 10 3    (beta_x to be 10 at 3 momenta) \n           BX 20     \
 (now beta_x to be 20 at 3 momenta (previous setting))\n           BX *  5    (now beta_x to be 20 (previous setting) at 5 momenta\
)\n\n(2) If the letter \"M\" is appended to matching-function, it means the maximum-fitting for the function. The maximum of eithe\
r the value (for positive-definite functions) or the absolute value (for bipolar functions) are to be limited in the matching.\n\n\
(3) If the letter \"I\" is appended to matching-function, it specifies the value of the incoming beam.\n\n(4) If SCALE is appended\
 to matching-function, it sets the scale of the input/output of the function to scale. This scale is used in the matching-function\
 commands, DISPLAY(DISP), SHOW, etc.\n(5) If the current fit location is at a MARK, @ for the goal value refers the save value at \
the MARK. @- refers -(save value). These are useful to match between two beam lines.\n\n   Available matching-functions are:\nopti\
cal-functions (see optical-functions):\nAX BX GMX NX AY BY GMY NY EX EPX EY EPY R1 R2 R3 R4 DETR DX DPX DY DPY DZ DDP PEX PEPX PEY\
 PEPY TRX TRY LENG\ngeometric-functions (see geometric-functions):\nGX GY GZ CHI1 CHI2 CHI3"[p$2524,p1$2524]]=
       equ$2524;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2524},out$2524=lx$2524@Typeset["Usage: (1) matching-function  goal-value [off-momentum-points]\n       (2) matching-funct\
ionM goal-value [off-momentum-points]\n       (3) matching-functionI incoming-value\n       (4) matching-functionSCALE scale\n\n(1\
) sets the matching condition for matching-function at the current fitting point or region with the goal-value and the off-momentu\
m-points (see off-momentum-matching).\n   If off-momentum-points is omitted, the previous value for this matching-function at this\
 fitting-point is assumed. If the previous value is not defined, 1 is assumed. If -1 is given for off-momentum-points, the matchin\
g-function is rejected from the matching (see REJECT(REJ)).\n   If \"*\" is given for goal-value, the previous value is used if ex\
ists.\n\nExample:   BX 10 3    (beta_x to be 10 at 3 momenta) \n           BX 20      (now beta_x to be 20 at 3 momenta (previous \
setting))\n           BX *  5    (now beta_x to be 20 (previous setting) at 5 momenta)\n\n(2) If the letter \"M\" is appended to m\
atching-function, it means the maximum-fitting for the function. The maximum of either the value (for positive-definite functions)\
 or the absolute value (for bipolar functions) are to be limited in the matching.\n\n(3) If the letter \"I\" is appended to matchi\
ng-function, it specifies the value of the incoming beam.\n\n(4) If SCALE is appended to matching-function, it sets the scale of t\
he input/output of the function to scale. This scale is used in the matching-function commands, DISPLAY(DISP), SHOW, etc.\n(5) If \
the current fit location is at a MARK, @ for the goal value refers the save value at the MARK. @- refers -(save value). These are \
useful to match between two beam lines.\n\n   Available matching-functions are:\noptical-functions (see optical-functions):\nAX BX\
 GMX NX AY BY GMY NY EX EPX EY EPY R1 R2 R3 R4 DETR DX DPX DY DPY DZ DDP PEX PEPX PEY PEPY TRX TRY LENG\ngeometric-functions (see \
geometric-functions):\nGX GY GZ CHI1 CHI2 CHI3"[p$2524,p1$2524],Format->Help2HTML`oB$];
        System["mv -f "//out$2524//" "//equ$2524]];
      Exit[]]];
   "Usage: (1) matching-function  goal-value [off-momentum-points]\n       (2) matching-functionM goal-value [off-momentum-points]\
\n       (3) matching-functionI incoming-value\n       (4) matching-functionSCALE scale\n\n(1) sets the matching condition for mat\
ching-function at the current fitting point or region with the goal-value and the off-momentum-points (see off-momentum-matching).\
\n   If off-momentum-points is omitted, the previous value for this matching-function at this fitting-point is assumed. If the pre\
vious value is not defined, 1 is assumed. If -1 is given for off-momentum-points, the matching-function is rejected from the match\
ing (see REJECT(REJ)).\n   If \"*\" is given for goal-value, the previous value is used if exists.\n\nExample:   BX 10 3    (beta_\
x to be 10 at 3 momenta) \n           BX 20      (now beta_x to be 20 at 3 momenta (previous setting))\n           BX *  5    (now\
 beta_x to be 20 (previous setting) at 5 momenta)\n\n(2) If the letter \"M\" is appended to matching-function, it means the maximu\
m-fitting for the function. The maximum of either the value (for positive-definite functions) or the absolute value (for bipolar f\
unctions) are to be limited in the matching.\n\n(3) If the letter \"I\" is appended to matching-function, it specifies the value o\
f the incoming beam.\n\n(4) If SCALE is appended to matching-function, it sets the scale of the input/output of the function to sc\
ale. This scale is used in the matching-function commands, DISPLAY(DISP), SHOW, etc.\n(5) If the current fit location is at a MARK\
, @ for the goal value refers the save value at the MARK. @- refers -(save value). These are useful to match between two beam line\
s.\n\n   Available matching-functions are:\noptical-functions (see optical-functions):\nAX BX GMX NX AY BY GMY NY EX EPX EY EPY R1\
 R2 R3 R4 DETR DX DPX DY DPY DZ DDP PEX PEPX PEY PEPY TRX TRY LENG\ngeometric-functions (see geometric-functions):\nGX GY GZ CHI1 \
CHI2 CHI3"[1,Max[p0$2524,0]]//"<img  class=\"eqs\" SRC=\""//equ$2524//"\" />"//
Help2HTML`oy$["Usage: (1) matching-function  goal-value [off-momentum-points]\n       (2) matching-functionM goal-value [off-momen\
tum-points]\n       (3) matching-functionI incoming-value\n       (4) matching-functionSCALE scale\n\n(1) sets the matching condit\
ion for matching-function at the current fitting point or region with the goal-value and the off-momentum-points (see off-momentum\
-matching).\n   If off-momentum-points is omitted, the previous value for this matching-function at this fitting-point is assumed.\
 If the previous value is not defined, 1 is assumed. If -1 is given for off-momentum-points, the matching-function is rejected fro\
m the matching (see REJECT(REJ)).\n   If \"*\" is given for goal-value, the previous value is used if exists.\n\nExample:   BX 10 \
3    (beta_x to be 10 at 3 momenta) \n           BX 20      (now beta_x to be 20 at 3 momenta (previous setting))\n           BX *\
  5    (now beta_x to be 20 (previous setting) at 5 momenta)\n\n(2) If the letter \"M\" is appended to matching-function, it means\
 the maximum-fitting for the function. The maximum of either the value (for positive-definite functions) or the absolute value (fo\
r bipolar functions) are to be limited in the matching.\n\n(3) If the letter \"I\" is appended to matching-function, it specifies \
the value of the incoming beam.\n\n(4) If SCALE is appended to matching-function, it sets the scale of the input/output of the fun\
ction to scale. This scale is used in the matching-function commands, DISPLAY(DISP), SHOW, etc.\n(5) If the current fit location i\
s at a MARK, @ for the goal value refers the save value at the MARK. @- refers -(save value). These are useful to match between tw\
o beam lines.\n\n   Available matching-functions are:\noptical-functions (see optical-functions):\nAX BX GMX NX AY BY GMY NY EX EP\
X EY EPY R1 R2 R3 R4 DETR DX DPX DY DPY DZ DDP PEX PEPX PEY PEPY TRX TRY LENG\ngeometric-functions (see geometric-functions):\nGX \
GY GZ CHI1 CHI2 CHI3"[p2$2524,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L463>FIT</A> <A HREF=#L469>GO</A> <A HREF=#L550>SHOW</A> <A HREF=#L137>MARK</A> <A HREF=#L478>optical-functions</A> <A HREF=#L468>geometric-functions</A> <A HREF=#L477>off-momentum-matching</A> <A HREF=#L51>x-y-coupling</A>
 <A HREF=#L491>REJECT(REJ)</A> <A HREF=#L500>special-variables</A> <A HREF=#L506>DP</A> <A HREF=#L358>functions</A> <A HREF=#L394>FitValue</A> <A HREF=#L527>MatchingAmplitude</A></PRE>
<H3><A NAME=L474>
multi-turn-tracking</A></H3>
<PRE>If[{},
Help2HTML`oA$["The multi-turn tracking can be done by TrackParticles or DynamicApertureSurvey[] function in FFS.\n\nThe multi-turn\
 tracking uses the closed orbit, normal coordinate, and the equilibrium emittances. Therefore One of EMITTANCE(EMIT), the Emittanc\
e[] function, or the EMIT command in the MAIN level are necessary to be done once in prior to the multi-turn-tracking. The values \
of EMITX, EMITY, EMITZ, SIGE can be changed between EMITs and the multi-turn-tracking."],
 p$2527=1+p$2527[[1,2]];p1$2527=StringPosition["The multi-turn tracking can be done by TrackParticles or DynamicApertureSurvey[] f\
unction in FFS.\n\nThe multi-turn tracking uses the closed orbit, normal coordinate, and the equilibrium emittances. Therefore One\
 of EMITTANCE(EMIT), the Emittance[] function, or the EMIT command in the MAIN level are necessary to be done once in prior to the\
 multi-turn-tracking. The values of EMITX, EMITY, EMITZ, SIGE can be changed between EMITs and the multi-turn-tracking."[p$2527,-1
     ],
    ">::",1];
   p1$2527=If[p1$2527==={},459,-2+p$2527+p1$2527[[1,1]]];
neq=Which["The multi-turn tracking can be done by TrackParticles or DynamicApertureSurvey[] function in FFS.\n\nThe multi-turn tra\
cking uses the closed orbit, normal coordinate, and the equilibrium emittances. Therefore One of EMITTANCE(EMIT), the Emittance[] \
function, or the EMIT command in the MAIN level are necessary to be done once in prior to the multi-turn-tracking. The values of E\
MITX, EMITY, EMITZ, SIGE can be changed between EMITs and the multi-turn-tracking."[p$2527,4+p$2527]==="Text[",
    lx$2527:=Help2HTML`oa$;p$2527=5+p$2527;p1$2527-=1;p2$2527=5+p1$2527;p0$2527=-9+p$2527;
If[(pe$2527=StringPosition["The multi-turn tracking can be done by TrackParticles or DynamicApertureSurvey[] function in FFS.\n\nT\
he multi-turn tracking uses the closed orbit, normal coordinate, and the equilibrium emittances. Therefore One of EMITTANCE(EMIT),\
 the Emittance[] function, or the EMIT command in the MAIN level are necessary to be done once in prior to the multi-turn-tracking\
. The values of EMITX, EMITY, EMITZ, SIGE can be changed between EMITs and the multi-turn-tracking."[p$2527,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["The multi-turn tracking can be done by TrackParticles or DynamicApertureSurvey[] function in FFS.\n\nThe multi-tu\
rn tracking uses the closed orbit, normal coordinate, and the equilibrium emittances. Therefore One of EMITTANCE(EMIT), the Emitta\
nce[] function, or the EMIT command in the MAIN level are necessary to be done once in prior to the multi-turn-tracking. The value\
s of EMITX, EMITY, EMITZ, SIGE can be changed between EMITs and the multi-turn-tracking."[p$2527+pe$2527[[1,2]],p1$2527]]],
        p1$2527=-2+p$2527+pe$2527[[1,1]]}[[
       1]],
      0],
    1,lx$2527:=Help2HTML`o9$;p2$2527=4+p1$2527;p0$2527=-4+p$2527;0];
  If[(equ$2527=
Help2HTML`o8$["The multi-turn tracking can be done by TrackParticles or DynamicApertureSurvey[] function in FFS.\n\nThe multi-turn\
 tracking uses the closed orbit, normal coordinate, and the equilibrium emittances. Therefore One of EMITTANCE(EMIT), the Emittanc\
e[] function, or the EMIT command in the MAIN level are necessary to be done once in prior to the multi-turn-tracking. The values \
of EMITX, EMITY, EMITZ, SIGE can be changed between EMITs and the multi-turn-tracking."[p$2527,p1$2527]])===
    Undefined,
equ$2527="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["The multi-turn tracking can be done by Track\
Particles or DynamicApertureSurvey[] function in FFS.\n\nThe multi-turn tracking uses the closed orbit, normal coordinate, and the\
 equilibrium emittances. Therefore One of EMITTANCE(EMIT), the Emittance[] function, or the EMIT command in the MAIN level are nec\
essary to be done once in prior to the multi-turn-tracking. The values of EMITX, EMITY, EMITZ, SIGE can be changed between EMITs a\
nd the multi-turn-tracking."[p$2527,p1$2527]]=
       equ$2527;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2527},out$2527=lx$2527@Typeset["The multi-turn tracking can be done by TrackParticles or DynamicApertureSurvey[] function\
 in FFS.\n\nThe multi-turn tracking uses the closed orbit, normal coordinate, and the equilibrium emittances. Therefore One of EMI\
TTANCE(EMIT), the Emittance[] function, or the EMIT command in the MAIN level are necessary to be done once in prior to the multi-\
turn-tracking. The values of EMITX, EMITY, EMITZ, SIGE can be changed between EMITs and the multi-turn-tracking."[p$2527,p1$2527],
          Format->Help2HTML`oB$];
        System["mv -f "//out$2527//" "//equ$2527]];
      Exit[]]];
   "The multi-turn tracking can be done by TrackParticles or DynamicApertureSurvey[] function in FFS.\n\nThe multi-turn tracking u\
ses the closed orbit, normal coordinate, and the equilibrium emittances. Therefore One of EMITTANCE(EMIT), the Emittance[] functio\
n, or the EMIT command in the MAIN level are necessary to be done once in prior to the multi-turn-tracking. The values of EMITX, E\
MITY, EMITZ, SIGE can be changed between EMITs and the multi-turn-tracking."[1,Max[p0$2527,0]]//"<img  class=\"eqs\" SRC=\""//
   equ$2527//"\" />"//
Help2HTML`oy$["The multi-turn tracking can be done by TrackParticles or DynamicApertureSurvey[] function in FFS.\n\nThe multi-turn\
 tracking uses the closed orbit, normal coordinate, and the equilibrium emittances. Therefore One of EMITTANCE(EMIT), the Emittanc\
e[] function, or the EMIT command in the MAIN level are necessary to be done once in prior to the multi-turn-tracking. The values \
of EMITX, EMITY, EMITZ, SIGE can be changed between EMITs and the multi-turn-tracking."[p2$2527,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L409>TrackParticles</A> <A HREF=#L386>DynamicApertureSurvey</A> <A HREF=#L295>EMITTANCE(EMIT)</A> <A HREF=#L344>RFSW</A> <A HREF=#L337>RAD</A> <A HREF=#L318>FLUC</A> <A HREF=#L338>RADCOD</A> <A HREF=#L348>SPAC</A> <A HREF=#L357>WSPAC</A>
 <A HREF=#L500>special-variables</A> <A HREF=#L55>equilibrium-beam-envelope</A></PRE>
<H3><A NAME=L475>
MATRIX(MAT)</A></H3>
<PRE>If[{},
Help2HTML`oA$["Usage: MATRIX [{SYMPLECTIC(S) | PHYSICAL(P)}] [from to]\n\nprints out the 4 by 5 (w/CALC4D) or 6 by 6 (w/CALC6D) tr\
ansfer matrix from from-component to to-component. If SYMPLECTIC(S) is specified (default), the symplectic transfer matrix on {x,p\
x/p0,y,py/p0,dp/p0} where p0 is the nominal momentum at the entrance, is given. Otherwise, in the case of TRPT, the transfer matri\
x on {x,px/p0(s),y,py/p0(s),dp/p0(s)} is printed out.\n   If the from- and to- components are omitted, entire beam line is assumed\
.\nIf to-component is upstream the from-component, it gives the inverse matrix (TRPT) or one-turn-wrapped matrix (RING)."],
 p$2530=1+p$2530[[1,2]];
p1$2530=StringPosition["Usage: MATRIX [{SYMPLECTIC(S) | PHYSICAL(P)}] [from to]\n\nprints out the 4 by 5 (w/CALC4D) or 6 by 6 (w/C\
ALC6D) transfer matrix from from-component to to-component. If SYMPLECTIC(S) is specified (default), the symplectic transfer matri\
x on {x,px/p0,y,py/p0,dp/p0} where p0 is the nominal momentum at the entrance, is given. Otherwise, in the case of TRPT, the trans\
fer matrix on {x,px/p0(s),y,py/p0(s),dp/p0(s)} is printed out.\n   If the from- and to- components are omitted, entire beam line i\
s assumed.\nIf to-component is upstream the from-component, it gives the inverse matrix (TRPT) or one-turn-wrapped matrix (RING)."[
     p$2530,-1],
    ">::",1];
   p1$2530=If[p1$2530==={},621,-2+p$2530+p1$2530[[1,1]]];
neq=Which["Usage: MATRIX [{SYMPLECTIC(S) | PHYSICAL(P)}] [from to]\n\nprints out the 4 by 5 (w/CALC4D) or 6 by 6 (w/CALC6D) transf\
er matrix from from-component to to-component. If SYMPLECTIC(S) is specified (default), the symplectic transfer matrix on {x,px/p0\
,y,py/p0,dp/p0} where p0 is the nominal momentum at the entrance, is given. Otherwise, in the case of TRPT, the transfer matrix on\
 {x,px/p0(s),y,py/p0(s),dp/p0(s)} is printed out.\n   If the from- and to- components are omitted, entire beam line is assumed.\nI\
f to-component is upstream the from-component, it gives the inverse matrix (TRPT) or one-turn-wrapped matrix (RING)."[p$2530,
      4+p$2530]===
     "Text[",
lx$2530:=Help2HTML`oa$;p$2530=5+p$2530;p1$2530-=1;p2$2530=5+p1$2530;p0$2530=-9+p$2530;If[(pe$2530=StringPosition["Usage: MATRIX [{\
SYMPLECTIC(S) | PHYSICAL(P)}] [from to]\n\nprints out the 4 by 5 (w/CALC4D) or 6 by 6 (w/CALC6D) transfer matrix from from-compone\
nt to to-component. If SYMPLECTIC(S) is specified (default), the symplectic transfer matrix on {x,px/p0,y,py/p0,dp/p0} where p0 is\
 the nominal momentum at the entrance, is given. Otherwise, in the case of TRPT, the transfer matrix on {x,px/p0(s),y,py/p0(s),dp/\
p0(s)} is printed out.\n   If the from- and to- components are omitted, entire beam line is assumed.\nIf to-component is upstream \
the from-component, it gives the inverse matrix (TRPT) or one-turn-wrapped matrix (RING)."[p$2530,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Usage: MATRIX [{SYMPLECTIC(S) | PHYSICAL(P)}] [from to]\n\nprints out the 4 by 5 (w/CALC4D) or 6 by 6 (w/CALC6D) \
transfer matrix from from-component to to-component. If SYMPLECTIC(S) is specified (default), the symplectic transfer matrix on {x\
,px/p0,y,py/p0,dp/p0} where p0 is the nominal momentum at the entrance, is given. Otherwise, in the case of TRPT, the transfer mat\
rix on {x,px/p0(s),y,py/p0(s),dp/p0(s)} is printed out.\n   If the from- and to- components are omitted, entire beam line is assum\
ed.\nIf to-component is upstream the from-component, it gives the inverse matrix (TRPT) or one-turn-wrapped matrix (RING)."[p$2530+
            pe$2530[[1,2]],
           p1$2530]]],
        p1$2530=-2+p$2530+pe$2530[[1,1]]}[[
       1]],
      0],
    1,lx$2530:=Help2HTML`o9$;p2$2530=4+p1$2530;p0$2530=-4+p$2530;0];
  If[(equ$2530=
Help2HTML`o8$["Usage: MATRIX [{SYMPLECTIC(S) | PHYSICAL(P)}] [from to]\n\nprints out the 4 by 5 (w/CALC4D) or 6 by 6 (w/CALC6D) tr\
ansfer matrix from from-component to to-component. If SYMPLECTIC(S) is specified (default), the symplectic transfer matrix on {x,p\
x/p0,y,py/p0,dp/p0} where p0 is the nominal momentum at the entrance, is given. Otherwise, in the case of TRPT, the transfer matri\
x on {x,px/p0(s),y,py/p0(s),dp/p0(s)} is printed out.\n   If the from- and to- components are omitted, entire beam line is assumed\
.\nIf to-component is upstream the from-component, it gives the inverse matrix (TRPT) or one-turn-wrapped matrix (RING)."[p$2530,
       p1$2530]])===
    Undefined,
equ$2530="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Usage: MATRIX [{SYMPLECTIC(S) | PHYSICAL(P)}\
] [from to]\n\nprints out the 4 by 5 (w/CALC4D) or 6 by 6 (w/CALC6D) transfer matrix from from-component to to-component. If SYMPL\
ECTIC(S) is specified (default), the symplectic transfer matrix on {x,px/p0,y,py/p0,dp/p0} where p0 is the nominal momentum at the\
 entrance, is given. Otherwise, in the case of TRPT, the transfer matrix on {x,px/p0(s),y,py/p0(s),dp/p0(s)} is printed out.\n   I\
f the from- and to- components are omitted, entire beam line is assumed.\nIf to-component is upstream the from-component, it gives\
 the inverse matrix (TRPT) or one-turn-wrapped matrix (RING)."[p$2530,p1$2530]]=
       equ$2530;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2530},out$2530=lx$2530@Typeset["Usage: MATRIX [{SYMPLECTIC(S) | PHYSICAL(P)}] [from to]\n\nprints out the 4 by 5 (w/CALC4\
D) or 6 by 6 (w/CALC6D) transfer matrix from from-component to to-component. If SYMPLECTIC(S) is specified (default), the symplect\
ic transfer matrix on {x,px/p0,y,py/p0,dp/p0} where p0 is the nominal momentum at the entrance, is given. Otherwise, in the case o\
f TRPT, the transfer matrix on {x,px/p0(s),y,py/p0(s),dp/p0(s)} is printed out.\n   If the from- and to- components are omitted, e\
ntire beam line is assumed.\nIf to-component is upstream the from-component, it gives the inverse matrix (TRPT) or one-turn-wrappe\
d matrix (RING)."[p$2530,p1$2530],Format->Help2HTML`oB$];
        System["mv -f "//out$2530//" "//equ$2530]];
      Exit[]]];
   "Usage: MATRIX [{SYMPLECTIC(S) | PHYSICAL(P)}] [from to]\n\nprints out the 4 by 5 (w/CALC4D) or 6 by 6 (w/CALC6D) transfer matr\
ix from from-component to to-component. If SYMPLECTIC(S) is specified (default), the symplectic transfer matrix on {x,px/p0,y,py/p\
0,dp/p0} where p0 is the nominal momentum at the entrance, is given. Otherwise, in the case of TRPT, the transfer matrix on {x,px/\
p0(s),y,py/p0(s),dp/p0(s)} is printed out.\n   If the from- and to- components are omitted, entire beam line is assumed.\nIf to-co\
mponent is upstream the from-component, it gives the inverse matrix (TRPT) or one-turn-wrapped matrix (RING)."[1,Max[p0$2530,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2530//"\" />"//
Help2HTML`oy$["Usage: MATRIX [{SYMPLECTIC(S) | PHYSICAL(P)}] [from to]\n\nprints out the 4 by 5 (w/CALC4D) or 6 by 6 (w/CALC6D) tr\
ansfer matrix from from-component to to-component. If SYMPLECTIC(S) is specified (default), the symplectic transfer matrix on {x,p\
x/p0,y,py/p0,dp/p0} where p0 is the nominal momentum at the entrance, is given. Otherwise, in the case of TRPT, the transfer matri\
x on {x,px/p0(s),y,py/p0(s),dp/p0(s)} is printed out.\n   If the from- and to- components are omitted, entire beam line is assumed\
.\nIf to-component is upstream the from-component, it gives the inverse matrix (TRPT) or one-turn-wrapped matrix (RING)."[p2$2530,
     -1]]
]</PRE>
<PRE>See also:
 <A HREF=#L56>DISPLAY(DISP)</A> <A HREF=#L352>TRPT</A> <A HREF=#L345>RING</A> <A HREF=#L303>CALC4D</A> <A HREF=#L304>CALC6D</A> TransferMatrix</PRE>
<H3><A NAME=L476>
MEASURE(MEA)</A></H3>
<PRE>If[{},
Help2HTML`oA$["Usage: MEA [end-component] [OUT file plot-spaces]\n\ntracks particles from the entrance to end-component and prints\
 out the statistics at the end. If end-component is omitted, the component end used in the last MEASURE(MEA) (default: end of the \
beam line) is assumed.\n   If OUT file plot-spaces are attached, it plots phase space distribution on file. The phase-spaces are s\
pecified like as X-PX, \nor X-Y, etc., (up to any numbers).\n   Parameters for the tracking are specified by special-variables and\
 flags:\n\nseed for the random-number generator:\n     SeedRandom[seed_Real] or SeedRandom[{seeds__Real}]\n\nspecial-variables (ca\
n be set with =):\n     NP        number of particles \n     EMITX     horizontal emittance\n     EMITY     vertical emittance\n  \
   DP        relative momentum spread\n     DP0       relative momentum offset dp/p0\n     GCUT      cut-off value of the Gaussian\
 tail\nflags:\n     GAUSS/UNIFORM    Gaussian/uniform(default) momentum distribution\n     JITTER/NOJITTER  off(default)/on nullif\
ying the incoming centroid offset\n     RFSW/NORFSW      switch on(default)/off the rf-cavities\n     RAD/NORAD        synchrotron\
 radiation on/off\n     RADCOD/NORADCOD  off/on compensation of energy loss due to radiation\n     FIXSEED/MOVESEED keep(default)/\
unkeep the initial random-number seed\n\n   The initial transverse distribution is Gaussian."],
 p$2533=1+p$2533[[1,2]];p1$2533=StringPosition["Usage: MEA [end-component] [OUT file plot-spaces]\n\ntracks particles from the ent\
rance to end-component and prints out the statistics at the end. If end-component is omitted, the component end used in the last M\
EASURE(MEA) (default: end of the beam line) is assumed.\n   If OUT file plot-spaces are attached, it plots phase space distributio\
n on file. The phase-spaces are specified like as X-PX, \nor X-Y, etc., (up to any numbers).\n   Parameters for the tracking are s\
pecified by special-variables and flags:\n\nseed for the random-number generator:\n     SeedRandom[seed_Real] or SeedRandom[{seeds\
__Real}]\n\nspecial-variables (can be set with =):\n     NP        number of particles \n     EMITX     horizontal emittance\n    \
 EMITY     vertical emittance\n     DP        relative momentum spread\n     DP0       relative momentum offset dp/p0\n     GCUT  \
    cut-off value of the Gaussian tail\nflags:\n     GAUSS/UNIFORM    Gaussian/uniform(default) momentum distribution\n     JITTER\
/NOJITTER  off(default)/on nullifying the incoming centroid offset\n     RFSW/NORFSW      switch on(default)/off the rf-cavities\n\
     RAD/NORAD        synchrotron radiation on/off\n     RADCOD/NORADCOD  off/on compensation of energy loss due to radiation\n   \
  FIXSEED/MOVESEED keep(default)/unkeep the initial random-number seed\n\n   The initial transverse distribution is Gaussian."[p
     $2533,-1],
    ">::",1];
   p1$2533=If[p1$2533==={},1352,-2+p$2533+p1$2533[[1,1]]];
neq=Which["Usage: MEA [end-component] [OUT file plot-spaces]\n\ntracks particles from the entrance to end-component and prints out\
 the statistics at the end. If end-component is omitted, the component end used in the last MEASURE(MEA) (default: end of the beam\
 line) is assumed.\n   If OUT file plot-spaces are attached, it plots phase space distribution on file. The phase-spaces are speci\
fied like as X-PX, \nor X-Y, etc., (up to any numbers).\n   Parameters for the tracking are specified by special-variables and fla\
gs:\n\nseed for the random-number generator:\n     SeedRandom[seed_Real] or SeedRandom[{seeds__Real}]\n\nspecial-variables (can be\
 set with =):\n     NP        number of particles \n     EMITX     horizontal emittance\n     EMITY     vertical emittance\n     D\
P        relative momentum spread\n     DP0       relative momentum offset dp/p0\n     GCUT      cut-off value of the Gaussian tai\
l\nflags:\n     GAUSS/UNIFORM    Gaussian/uniform(default) momentum distribution\n     JITTER/NOJITTER  off(default)/on nullifying\
 the incoming centroid offset\n     RFSW/NORFSW      switch on(default)/off the rf-cavities\n     RAD/NORAD        synchrotron rad\
iation on/off\n     RADCOD/NORADCOD  off/on compensation of energy loss due to radiation\n     FIXSEED/MOVESEED keep(default)/unke\
ep the initial random-number seed\n\n   The initial transverse distribution is Gaussian."[p$2533,4+p$2533]==="Text[",
    lx$2533:=Help2HTML`oa$;p$2533=5+p$2533;p1$2533-=1;p2$2533=5+p1$2533;p0$2533=-9+p$2533;
If[(pe$2533=StringPosition["Usage: MEA [end-component] [OUT file plot-spaces]\n\ntracks particles from the entrance to end-compone\
nt and prints out the statistics at the end. If end-component is omitted, the component end used in the last MEASURE(MEA) (default\
: end of the beam line) is assumed.\n   If OUT file plot-spaces are attached, it plots phase space distribution on file. The phase\
-spaces are specified like as X-PX, \nor X-Y, etc., (up to any numbers).\n   Parameters for the tracking are specified by special-\
variables and flags:\n\nseed for the random-number generator:\n     SeedRandom[seed_Real] or SeedRandom[{seeds__Real}]\n\nspecial-\
variables (can be set with =):\n     NP        number of particles \n     EMITX     horizontal emittance\n     EMITY     vertical \
emittance\n     DP        relative momentum spread\n     DP0       relative momentum offset dp/p0\n     GCUT      cut-off value of\
 the Gaussian tail\nflags:\n     GAUSS/UNIFORM    Gaussian/uniform(default) momentum distribution\n     JITTER/NOJITTER  off(defau\
lt)/on nullifying the incoming centroid offset\n     RFSW/NORFSW      switch on(default)/off the rf-cavities\n     RAD/NORAD      \
  synchrotron radiation on/off\n     RADCOD/NORADCOD  off/on compensation of energy loss due to radiation\n     FIXSEED/MOVESEED k\
eep(default)/unkeep the initial random-number seed\n\n   The initial transverse distribution is Gaussian."[p$2533,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Usage: MEA [end-component] [OUT file plot-spaces]\n\ntracks particles from the entrance to end-component and prin\
ts out the statistics at the end. If end-component is omitted, the component end used in the last MEASURE(MEA) (default: end of th\
e beam line) is assumed.\n   If OUT file plot-spaces are attached, it plots phase space distribution on file. The phase-spaces are\
 specified like as X-PX, \nor X-Y, etc., (up to any numbers).\n   Parameters for the tracking are specified by special-variables a\
nd flags:\n\nseed for the random-number generator:\n     SeedRandom[seed_Real] or SeedRandom[{seeds__Real}]\n\nspecial-variables (\
can be set with =):\n     NP        number of particles \n     EMITX     horizontal emittance\n     EMITY     vertical emittance\n\
     DP        relative momentum spread\n     DP0       relative momentum offset dp/p0\n     GCUT      cut-off value of the Gaussi\
an tail\nflags:\n     GAUSS/UNIFORM    Gaussian/uniform(default) momentum distribution\n     JITTER/NOJITTER  off(default)/on null\
ifying the incoming centroid offset\n     RFSW/NORFSW      switch on(default)/off the rf-cavities\n     RAD/NORAD        synchrotr\
on radiation on/off\n     RADCOD/NORADCOD  off/on compensation of energy loss due to radiation\n     FIXSEED/MOVESEED keep(default\
)/unkeep the initial random-number seed\n\n   The initial transverse distribution is Gaussian."[p$2533+pe$2533[[1,2]],p1$2533]]],
        p1$2533=-2+p$2533+pe$2533[[1,1]]}[[
       1]],
      0],
    1,lx$2533:=Help2HTML`o9$;p2$2533=4+p1$2533;p0$2533=-4+p$2533;0];
  If[(equ$2533=
Help2HTML`o8$["Usage: MEA [end-component] [OUT file plot-spaces]\n\ntracks particles from the entrance to end-component and prints\
 out the statistics at the end. If end-component is omitted, the component end used in the last MEASURE(MEA) (default: end of the \
beam line) is assumed.\n   If OUT file plot-spaces are attached, it plots phase space distribution on file. The phase-spaces are s\
pecified like as X-PX, \nor X-Y, etc., (up to any numbers).\n   Parameters for the tracking are specified by special-variables and\
 flags:\n\nseed for the random-number generator:\n     SeedRandom[seed_Real] or SeedRandom[{seeds__Real}]\n\nspecial-variables (ca\
n be set with =):\n     NP        number of particles \n     EMITX     horizontal emittance\n     EMITY     vertical emittance\n  \
   DP        relative momentum spread\n     DP0       relative momentum offset dp/p0\n     GCUT      cut-off value of the Gaussian\
 tail\nflags:\n     GAUSS/UNIFORM    Gaussian/uniform(default) momentum distribution\n     JITTER/NOJITTER  off(default)/on nullif\
ying the incoming centroid offset\n     RFSW/NORFSW      switch on(default)/off the rf-cavities\n     RAD/NORAD        synchrotron\
 radiation on/off\n     RADCOD/NORADCOD  off/on compensation of energy loss due to radiation\n     FIXSEED/MOVESEED keep(default)/\
unkeep the initial random-number seed\n\n   The initial transverse distribution is Gaussian."[p$2533,p1$2533]])===
    Undefined,
equ$2533="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Usage: MEA [end-component] [OUT file plot-sp\
aces]\n\ntracks particles from the entrance to end-component and prints out the statistics at the end. If end-component is omitted\
, the component end used in the last MEASURE(MEA) (default: end of the beam line) is assumed.\n   If OUT file plot-spaces are atta\
ched, it plots phase space distribution on file. The phase-spaces are specified like as X-PX, \nor X-Y, etc., (up to any numbers).\
\n   Parameters for the tracking are specified by special-variables and flags:\n\nseed for the random-number generator:\n     Seed\
Random[seed_Real] or SeedRandom[{seeds__Real}]\n\nspecial-variables (can be set with =):\n     NP        number of particles \n   \
  EMITX     horizontal emittance\n     EMITY     vertical emittance\n     DP        relative momentum spread\n     DP0       relat\
ive momentum offset dp/p0\n     GCUT      cut-off value of the Gaussian tail\nflags:\n     GAUSS/UNIFORM    Gaussian/uniform(defau\
lt) momentum distribution\n     JITTER/NOJITTER  off(default)/on nullifying the incoming centroid offset\n     RFSW/NORFSW      sw\
itch on(default)/off the rf-cavities\n     RAD/NORAD        synchrotron radiation on/off\n     RADCOD/NORADCOD  off/on compensatio\
n of energy loss due to radiation\n     FIXSEED/MOVESEED keep(default)/unkeep the initial random-number seed\n\n   The initial tra\
nsverse distribution is Gaussian."[p$2533,p1$2533]]=
       equ$2533;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2533},out$2533=lx$2533@Typeset["Usage: MEA [end-component] [OUT file plot-spaces]\n\ntracks particles from the entrance t\
o end-component and prints out the statistics at the end. If end-component is omitted, the component end used in the last MEASURE(\
MEA) (default: end of the beam line) is assumed.\n   If OUT file plot-spaces are attached, it plots phase space distribution on fi\
le. The phase-spaces are specified like as X-PX, \nor X-Y, etc., (up to any numbers).\n   Parameters for the tracking are specifie\
d by special-variables and flags:\n\nseed for the random-number generator:\n     SeedRandom[seed_Real] or SeedRandom[{seeds__Real}\
]\n\nspecial-variables (can be set with =):\n     NP        number of particles \n     EMITX     horizontal emittance\n     EMITY \
    vertical emittance\n     DP        relative momentum spread\n     DP0       relative momentum offset dp/p0\n     GCUT      cut\
-off value of the Gaussian tail\nflags:\n     GAUSS/UNIFORM    Gaussian/uniform(default) momentum distribution\n     JITTER/NOJITT\
ER  off(default)/on nullifying the incoming centroid offset\n     RFSW/NORFSW      switch on(default)/off the rf-cavities\n     RA\
D/NORAD        synchrotron radiation on/off\n     RADCOD/NORADCOD  off/on compensation of energy loss due to radiation\n     FIXSE\
ED/MOVESEED keep(default)/unkeep the initial random-number seed\n\n   The initial transverse distribution is Gaussian."[p$2533,
           p1$2533],Format->Help2HTML`oB$];
        System["mv -f "//out$2533//" "//equ$2533]];
      Exit[]]];
   "Usage: MEA [end-component] [OUT file plot-spaces]\n\ntracks particles from the entrance to end-component and prints out the st\
atistics at the end. If end-component is omitted, the component end used in the last MEASURE(MEA) (default: end of the beam line) \
is assumed.\n   If OUT file plot-spaces are attached, it plots phase space distribution on file. The phase-spaces are specified li\
ke as X-PX, \nor X-Y, etc., (up to any numbers).\n   Parameters for the tracking are specified by special-variables and flags:\n\n\
seed for the random-number generator:\n     SeedRandom[seed_Real] or SeedRandom[{seeds__Real}]\n\nspecial-variables (can be set wi\
th =):\n     NP        number of particles \n     EMITX     horizontal emittance\n     EMITY     vertical emittance\n     DP      \
  relative momentum spread\n     DP0       relative momentum offset dp/p0\n     GCUT      cut-off value of the Gaussian tail\nflag\
s:\n     GAUSS/UNIFORM    Gaussian/uniform(default) momentum distribution\n     JITTER/NOJITTER  off(default)/on nullifying the in\
coming centroid offset\n     RFSW/NORFSW      switch on(default)/off the rf-cavities\n     RAD/NORAD        synchrotron radiation \
on/off\n     RADCOD/NORADCOD  off/on compensation of energy loss due to radiation\n     FIXSEED/MOVESEED keep(default)/unkeep the \
initial random-number seed\n\n   The initial transverse distribution is Gaussian."[1,Max[p0$2533,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2533//"\" />"//
Help2HTML`oy$["Usage: MEA [end-component] [OUT file plot-spaces]\n\ntracks particles from the entrance to end-component and prints\
 out the statistics at the end. If end-component is omitted, the component end used in the last MEASURE(MEA) (default: end of the \
beam line) is assumed.\n   If OUT file plot-spaces are attached, it plots phase space distribution on file. The phase-spaces are s\
pecified like as X-PX, \nor X-Y, etc., (up to any numbers).\n   Parameters for the tracking are specified by special-variables and\
 flags:\n\nseed for the random-number generator:\n     SeedRandom[seed_Real] or SeedRandom[{seeds__Real}]\n\nspecial-variables (ca\
n be set with =):\n     NP        number of particles \n     EMITX     horizontal emittance\n     EMITY     vertical emittance\n  \
   DP        relative momentum spread\n     DP0       relative momentum offset dp/p0\n     GCUT      cut-off value of the Gaussian\
 tail\nflags:\n     GAUSS/UNIFORM    Gaussian/uniform(default) momentum distribution\n     JITTER/NOJITTER  off(default)/on nullif\
ying the incoming centroid offset\n     RFSW/NORFSW      switch on(default)/off the rf-cavities\n     RAD/NORAD        synchrotron\
 radiation on/off\n     RADCOD/NORADCOD  off/on compensation of energy loss due to radiation\n     FIXSEED/MOVESEED keep(default)/\
unkeep the initial random-number seed\n\n   The initial transverse distribution is Gaussian."[p2$2533,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L500>special-variables</A> <A HREF=#L409>TrackParticles</A> <A HREF=#L452>SeedRandom</A> RESULTOFTRACKING</PRE>
<H3><A NAME=L477>
off-momentum-matching</A></H3>
<PRE>If[{},
Help2HTML`oA$["FFS matches the optical functions for an orbit with finite momentum deviation.\n\nExample: \n   DP=0.01;      sets \
the range of momentum to DP0-0.01 < dp/p0 < DP0+0.01 .\n   BX 10 9;      sets the goal of betax to 10 m, at 9 points.\n           \
      in the range above, i.e.,\n                 dp/p0 = {-0.01,-0.0075,-0.005,-0.0025,0,\n                          0.0025,0.005\
,0.0075,0.01} + DP0 .\n   GO starts the matching.\n\nAs this example, the off-momentum points are chosen with equal separation. If\
 the off-momentum point n is an even number, the chosen points are same as the case of n+1, but the on-momentum point (==DP0) is e\
xcluded."],
p$2536=1+p$2536[[1,2]];p1$2536=StringPosition["FFS matches the optical functions for an orbit with finite momentum deviation.\n\nE\
xample: \n   DP=0.01;      sets the range of momentum to DP0-0.01 < dp/p0 < DP0+0.01 .\n   BX 10 9;      sets the goal of betax to\
 10 m, at 9 points.\n                 in the range above, i.e.,\n                 dp/p0 = {-0.01,-0.0075,-0.005,-0.0025,0,\n      \
                    0.0025,0.005,0.0075,0.01} + DP0 .\n   GO starts the matching.\n\nAs this example, the off-momentum points are \
chosen with equal separation. If the off-momentum point n is an even number, the chosen points are same as the case of n+1, but th\
e on-momentum point (==DP0) is excluded."[p$2536,-1],">::",1];
   p1$2536=If[p1$2536==={},633,-2+p$2536+p1$2536[[1,1]]];
neq=Which["FFS matches the optical functions for an orbit with finite momentum deviation.\n\nExample: \n   DP=0.01;      sets the \
range of momentum to DP0-0.01 < dp/p0 < DP0+0.01 .\n   BX 10 9;      sets the goal of betax to 10 m, at 9 points.\n               \
  in the range above, i.e.,\n                 dp/p0 = {-0.01,-0.0075,-0.005,-0.0025,0,\n                          0.0025,0.005,0.0\
075,0.01} + DP0 .\n   GO starts the matching.\n\nAs this example, the off-momentum points are chosen with equal separation. If the\
 off-momentum point n is an even number, the chosen points are same as the case of n+1, but the on-momentum point (==DP0) is exclu\
ded."[p$2536,4+p$2536]==="Text[",
    lx$2536:=Help2HTML`oa$;p$2536=5+p$2536;p1$2536-=1;p2$2536=5+p1$2536;p0$2536=-9+p$2536;If[(pe$2536=StringPosition["FFS matches \
the optical functions for an orbit with finite momentum deviation.\n\nExample: \n   DP=0.01;      sets the range of momentum to DP\
0-0.01 < dp/p0 < DP0+0.01 .\n   BX 10 9;      sets the goal of betax to 10 m, at 9 points.\n                 in the range above, i\
.e.,\n                 dp/p0 = {-0.01,-0.0075,-0.005,-0.0025,0,\n                          0.0025,0.005,0.0075,0.01} + DP0 .\n   G\
O starts the matching.\n\nAs this example, the off-momentum points are chosen with equal separation. If the off-momentum point n i\
s an even number, the chosen points are same as the case of n+1, but the on-momentum point (==DP0) is excluded."[p$2536,-2],";;;"]
        )<=>
       {},
      {Max[0,
-1+ToExpression["FFS matches the optical functions for an orbit with finite momentum deviation.\n\nExample: \n   DP=0.01;      set\
s the range of momentum to DP0-0.01 < dp/p0 < DP0+0.01 .\n   BX 10 9;      sets the goal of betax to 10 m, at 9 points.\n         \
        in the range above, i.e.,\n                 dp/p0 = {-0.01,-0.0075,-0.005,-0.0025,0,\n                          0.0025,0.0\
05,0.0075,0.01} + DP0 .\n   GO starts the matching.\n\nAs this example, the off-momentum points are chosen with equal separation. \
If the off-momentum point n is an even number, the chosen points are same as the case of n+1, but the on-momentum point (==DP0) is\
 excluded."[p$2536+pe$2536[[1,2]],p1$2536]]],
        p1$2536=-2+p$2536+pe$2536[[1,1]]}[[
       1]],
      0],
    1,lx$2536:=Help2HTML`o9$;p2$2536=4+p1$2536;p0$2536=-4+p$2536;0];
  If[(equ$2536=
Help2HTML`o8$["FFS matches the optical functions for an orbit with finite momentum deviation.\n\nExample: \n   DP=0.01;      sets \
the range of momentum to DP0-0.01 < dp/p0 < DP0+0.01 .\n   BX 10 9;      sets the goal of betax to 10 m, at 9 points.\n           \
      in the range above, i.e.,\n                 dp/p0 = {-0.01,-0.0075,-0.005,-0.0025,0,\n                          0.0025,0.005\
,0.0075,0.01} + DP0 .\n   GO starts the matching.\n\nAs this example, the off-momentum points are chosen with equal separation. If\
 the off-momentum point n is an even number, the chosen points are same as the case of n+1, but the on-momentum point (==DP0) is e\
xcluded."[p$2536,p1$2536]])===
    Undefined,
equ$2536="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["FFS matches the optical functions for an orb\
it with finite momentum deviation.\n\nExample: \n   DP=0.01;      sets the range of momentum to DP0-0.01 < dp/p0 < DP0+0.01 .\n   \
BX 10 9;      sets the goal of betax to 10 m, at 9 points.\n                 in the range above, i.e.,\n                 dp/p0 = {\
-0.01,-0.0075,-0.005,-0.0025,0,\n                          0.0025,0.005,0.0075,0.01} + DP0 .\n   GO starts the matching.\n\nAs thi\
s example, the off-momentum points are chosen with equal separation. If the off-momentum point n is an even number, the chosen poi\
nts are same as the case of n+1, but the on-momentum point (==DP0) is excluded."[p$2536,p1$2536]]=
       equ$2536;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2536},out$2536=lx$2536@Typeset["FFS matches the optical functions for an orbit with finite momentum deviation.\n\nExample\
: \n   DP=0.01;      sets the range of momentum to DP0-0.01 < dp/p0 < DP0+0.01 .\n   BX 10 9;      sets the goal of betax to 10 m,\
 at 9 points.\n                 in the range above, i.e.,\n                 dp/p0 = {-0.01,-0.0075,-0.005,-0.0025,0,\n            \
              0.0025,0.005,0.0075,0.01} + DP0 .\n   GO starts the matching.\n\nAs this example, the off-momentum points are chosen\
 with equal separation. If the off-momentum point n is an even number, the chosen points are same as the case of n+1, but the on-m\
omentum point (==DP0) is excluded."[p$2536,p1$2536],Format->Help2HTML`oB$];
        System["mv -f "//out$2536//" "//equ$2536]];
      Exit[]]];
   "FFS matches the optical functions for an orbit with finite momentum deviation.\n\nExample: \n   DP=0.01;      sets the range o\
f momentum to DP0-0.01 < dp/p0 < DP0+0.01 .\n   BX 10 9;      sets the goal of betax to 10 m, at 9 points.\n                 in th\
e range above, i.e.,\n                 dp/p0 = {-0.01,-0.0075,-0.005,-0.0025,0,\n                          0.0025,0.005,0.0075,0.0\
1} + DP0 .\n   GO starts the matching.\n\nAs this example, the off-momentum points are chosen with equal separation. If the off-mo\
mentum point n is an even number, the chosen points are same as the case of n+1, but the on-momentum point (==DP0) is excluded."[
    1,Max[p0$2536,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2536//"\" />"//
Help2HTML`oy$["FFS matches the optical functions for an orbit with finite momentum deviation.\n\nExample: \n   DP=0.01;      sets \
the range of momentum to DP0-0.01 < dp/p0 < DP0+0.01 .\n   BX 10 9;      sets the goal of betax to 10 m, at 9 points.\n           \
      in the range above, i.e.,\n                 dp/p0 = {-0.01,-0.0075,-0.005,-0.0025,0,\n                          0.0025,0.005\
,0.0075,0.01} + DP0 .\n   GO starts the matching.\n\nAs this example, the off-momentum points are chosen with equal separation. If\
 the off-momentum point n is an even number, the chosen points are same as the case of n+1, but the on-momentum point (==DP0) is e\
xcluded."[p2$2536,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L473>matching-function-commands</A> <A HREF=#L506>DP</A> <A HREF=#L507>DP0</A></PRE>
<H3><A NAME=L478>
optical-functions</A></H3>
<PRE>If[{},
Help2HTML`oA$["Available optical functions for matching are:\t\n\nAX      alpha_X\nBX      beta_X\nGMX     gamma_X\nNX      psi_X,\
 the default scale is 1/(2Pi)\nAY      alpha_Y\nBY      beta_Y\nGMY     gamma_Y\nNY      psi_Y, the default scale is 1/(2Pi)\nEX  \
    eta_X   (dispersion_X)\nEPX     eta_Px  (dispersion_PX) \nEY      eta_Y   (dispersion_Y)\nEPY     eta_Py  (dispersion_PY)\nR1 \
     R_1     (see x-y-coupling)\nR2      R_2     (see x-y-coupling)\nR3      R_3     (see x-y-coupling)\nR4      R_4     (see x-y-\
coupling)\nDETR    R_1*R_4 - R_2*R_3 (see x-y-coupling)\nDX      dx\nDPX     dpx\nDY      dy\nDPY     dpy\nDZ      dz\nDDP     del\
ta=dp/p0\nAZ      alpha_Z\nBZ      beta_Z\nGMZ     gamma_Z\nNZ      psi_Z, the default scale is 1/(2Pi)\nZX      zeta_X  (z-disper\
sion_X)\nZPX     zeta_Px (z-dispersion_PX) \nZY      zeta_Y  (z-dispersion_Y)\nZPY     zeta_Py (z-dispersion_PY)\nPEX     eta_x   \
(dispersion_x)\nPEPX    eta_px  (dispersion_px) \nPEY     eta_y   (dispersion_y)\nPEPY    eta_yy  (dispersion_py)\nTRX     trace(T\
_X), only defined at the end of the beam line.\nTRY     trace(T_Y), only defined at the end of the beam line.\nLENG    length of t\
he design orbit\t\n\nIn the above, upper case X, Px, Y, Py represents the x-y decoupled coordinate. EX, EPX, EY, EPY refer the dec\
oupled coordinate, while PEX, PEPX, PEY, PEPY are in the physical coordinate. On the other hand,  DX, DPX, DY, DPY refer the physi\
cal coordinate."],
p$2539=1+p$2539[[1,2]];p1$2539=StringPosition["Available optical functions for matching are:\t\n\nAX      alpha_X\nBX      beta_X\\
nGMX     gamma_X\nNX      psi_X, the default scale is 1/(2Pi)\nAY      alpha_Y\nBY      beta_Y\nGMY     gamma_Y\nNY      psi_Y, th\
e default scale is 1/(2Pi)\nEX      eta_X   (dispersion_X)\nEPX     eta_Px  (dispersion_PX) \nEY      eta_Y   (dispersion_Y)\nEPY \
    eta_Py  (dispersion_PY)\nR1      R_1     (see x-y-coupling)\nR2      R_2     (see x-y-coupling)\nR3      R_3     (see x-y-coup\
ling)\nR4      R_4     (see x-y-coupling)\nDETR    R_1*R_4 - R_2*R_3 (see x-y-coupling)\nDX      dx\nDPX     dpx\nDY      dy\nDPY \
    dpy\nDZ      dz\nDDP     delta=dp/p0\nAZ      alpha_Z\nBZ      beta_Z\nGMZ     gamma_Z\nNZ      psi_Z, the default scale is 1/\
(2Pi)\nZX      zeta_X  (z-dispersion_X)\nZPX     zeta_Px (z-dispersion_PX) \nZY      zeta_Y  (z-dispersion_Y)\nZPY     zeta_Py (z-\
dispersion_PY)\nPEX     eta_x   (dispersion_x)\nPEPX    eta_px  (dispersion_px) \nPEY     eta_y   (dispersion_y)\nPEPY    eta_yy  \
(dispersion_py)\nTRX     trace(T_X), only defined at the end of the beam line.\nTRY     trace(T_Y), only defined at the end of the\
 beam line.\nLENG    length of the design orbit\t\n\nIn the above, upper case X, Px, Y, Py represents the x-y decoupled coordinate\
. EX, EPX, EY, EPY refer the decoupled coordinate, while PEX, PEPX, PEY, PEPY are in the physical coordinate. On the other hand,  \
DX, DPX, DY, DPY refer the physical coordinate."[p$2539,-1],">::",1];
   p1$2539=If[p1$2539==={},1387,-2+p$2539+p1$2539[[1,1]]];
neq=Which["Available optical functions for matching are:\t\n\nAX      alpha_X\nBX      beta_X\nGMX     gamma_X\nNX      psi_X, the\
 default scale is 1/(2Pi)\nAY      alpha_Y\nBY      beta_Y\nGMY     gamma_Y\nNY      psi_Y, the default scale is 1/(2Pi)\nEX      \
eta_X   (dispersion_X)\nEPX     eta_Px  (dispersion_PX) \nEY      eta_Y   (dispersion_Y)\nEPY     eta_Py  (dispersion_PY)\nR1     \
 R_1     (see x-y-coupling)\nR2      R_2     (see x-y-coupling)\nR3      R_3     (see x-y-coupling)\nR4      R_4     (see x-y-coup\
ling)\nDETR    R_1*R_4 - R_2*R_3 (see x-y-coupling)\nDX      dx\nDPX     dpx\nDY      dy\nDPY     dpy\nDZ      dz\nDDP     delta=d\
p/p0\nAZ      alpha_Z\nBZ      beta_Z\nGMZ     gamma_Z\nNZ      psi_Z, the default scale is 1/(2Pi)\nZX      zeta_X  (z-dispersion\
_X)\nZPX     zeta_Px (z-dispersion_PX) \nZY      zeta_Y  (z-dispersion_Y)\nZPY     zeta_Py (z-dispersion_PY)\nPEX     eta_x   (dis\
persion_x)\nPEPX    eta_px  (dispersion_px) \nPEY     eta_y   (dispersion_y)\nPEPY    eta_yy  (dispersion_py)\nTRX     trace(T_X),\
 only defined at the end of the beam line.\nTRY     trace(T_Y), only defined at the end of the beam line.\nLENG    length of the d\
esign orbit\t\n\nIn the above, upper case X, Px, Y, Py represents the x-y decoupled coordinate. EX, EPX, EY, EPY refer the decoupl\
ed coordinate, while PEX, PEPX, PEY, PEPY are in the physical coordinate. On the other hand,  DX, DPX, DY, DPY refer the physical \
coordinate."[p$2539,4+p$2539]==="Text[",
    lx$2539:=Help2HTML`oa$;p$2539=5+p$2539;p1$2539-=1;p2$2539=5+p1$2539;p0$2539=-9+p$2539;If[(pe$2539=
StringPosition["Available optical functions for matching are:\t\n\nAX      alpha_X\nBX      beta_X\nGMX     gamma_X\nNX      psi_X\
, the default scale is 1/(2Pi)\nAY      alpha_Y\nBY      beta_Y\nGMY     gamma_Y\nNY      psi_Y, the default scale is 1/(2Pi)\nEX \
     eta_X   (dispersion_X)\nEPX     eta_Px  (dispersion_PX) \nEY      eta_Y   (dispersion_Y)\nEPY     eta_Py  (dispersion_PY)\nR1\
      R_1     (see x-y-coupling)\nR2      R_2     (see x-y-coupling)\nR3      R_3     (see x-y-coupling)\nR4      R_4     (see x-y\
-coupling)\nDETR    R_1*R_4 - R_2*R_3 (see x-y-coupling)\nDX      dx\nDPX     dpx\nDY      dy\nDPY     dpy\nDZ      dz\nDDP     de\
lta=dp/p0\nAZ      alpha_Z\nBZ      beta_Z\nGMZ     gamma_Z\nNZ      psi_Z, the default scale is 1/(2Pi)\nZX      zeta_X  (z-dispe\
rsion_X)\nZPX     zeta_Px (z-dispersion_PX) \nZY      zeta_Y  (z-dispersion_Y)\nZPY     zeta_Py (z-dispersion_PY)\nPEX     eta_x  \
 (dispersion_x)\nPEPX    eta_px  (dispersion_px) \nPEY     eta_y   (dispersion_y)\nPEPY    eta_yy  (dispersion_py)\nTRX     trace(\
T_X), only defined at the end of the beam line.\nTRY     trace(T_Y), only defined at the end of the beam line.\nLENG    length of \
the design orbit\t\n\nIn the above, upper case X, Px, Y, Py represents the x-y decoupled coordinate. EX, EPX, EY, EPY refer the de\
coupled coordinate, while PEX, PEPX, PEY, PEPY are in the physical coordinate. On the other hand,  DX, DPX, DY, DPY refer the phys\
ical coordinate."[p$2539,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Available optical functions for matching are:\t\n\nAX      alpha_X\nBX      beta_X\nGMX     gamma_X\nNX      psi_\
X, the default scale is 1/(2Pi)\nAY      alpha_Y\nBY      beta_Y\nGMY     gamma_Y\nNY      psi_Y, the default scale is 1/(2Pi)\nEX\
      eta_X   (dispersion_X)\nEPX     eta_Px  (dispersion_PX) \nEY      eta_Y   (dispersion_Y)\nEPY     eta_Py  (dispersion_PY)\nR\
1      R_1     (see x-y-coupling)\nR2      R_2     (see x-y-coupling)\nR3      R_3     (see x-y-coupling)\nR4      R_4     (see x-\
y-coupling)\nDETR    R_1*R_4 - R_2*R_3 (see x-y-coupling)\nDX      dx\nDPX     dpx\nDY      dy\nDPY     dpy\nDZ      dz\nDDP     d\
elta=dp/p0\nAZ      alpha_Z\nBZ      beta_Z\nGMZ     gamma_Z\nNZ      psi_Z, the default scale is 1/(2Pi)\nZX      zeta_X  (z-disp\
ersion_X)\nZPX     zeta_Px (z-dispersion_PX) \nZY      zeta_Y  (z-dispersion_Y)\nZPY     zeta_Py (z-dispersion_PY)\nPEX     eta_x \
  (dispersion_x)\nPEPX    eta_px  (dispersion_px) \nPEY     eta_y   (dispersion_y)\nPEPY    eta_yy  (dispersion_py)\nTRX     trace\
(T_X), only defined at the end of the beam line.\nTRY     trace(T_Y), only defined at the end of the beam line.\nLENG    length of\
 the design orbit\t\n\nIn the above, upper case X, Px, Y, Py represents the x-y decoupled coordinate. EX, EPX, EY, EPY refer the d\
ecoupled coordinate, while PEX, PEPX, PEY, PEPY are in the physical coordinate. On the other hand,  DX, DPX, DY, DPY refer the phy\
sical coordinate."[p$2539+pe$2539[[1,2]],p1$2539]]],
        p1$2539=-2+p$2539+pe$2539[[1,1]]}[[
       1]],
      0],
    1,lx$2539:=Help2HTML`o9$;p2$2539=4+p1$2539;p0$2539=-4+p$2539;0];
  If[(equ$2539=
Help2HTML`o8$["Available optical functions for matching are:\t\n\nAX      alpha_X\nBX      beta_X\nGMX     gamma_X\nNX      psi_X,\
 the default scale is 1/(2Pi)\nAY      alpha_Y\nBY      beta_Y\nGMY     gamma_Y\nNY      psi_Y, the default scale is 1/(2Pi)\nEX  \
    eta_X   (dispersion_X)\nEPX     eta_Px  (dispersion_PX) \nEY      eta_Y   (dispersion_Y)\nEPY     eta_Py  (dispersion_PY)\nR1 \
     R_1     (see x-y-coupling)\nR2      R_2     (see x-y-coupling)\nR3      R_3     (see x-y-coupling)\nR4      R_4     (see x-y-\
coupling)\nDETR    R_1*R_4 - R_2*R_3 (see x-y-coupling)\nDX      dx\nDPX     dpx\nDY      dy\nDPY     dpy\nDZ      dz\nDDP     del\
ta=dp/p0\nAZ      alpha_Z\nBZ      beta_Z\nGMZ     gamma_Z\nNZ      psi_Z, the default scale is 1/(2Pi)\nZX      zeta_X  (z-disper\
sion_X)\nZPX     zeta_Px (z-dispersion_PX) \nZY      zeta_Y  (z-dispersion_Y)\nZPY     zeta_Py (z-dispersion_PY)\nPEX     eta_x   \
(dispersion_x)\nPEPX    eta_px  (dispersion_px) \nPEY     eta_y   (dispersion_y)\nPEPY    eta_yy  (dispersion_py)\nTRX     trace(T\
_X), only defined at the end of the beam line.\nTRY     trace(T_Y), only defined at the end of the beam line.\nLENG    length of t\
he design orbit\t\n\nIn the above, upper case X, Px, Y, Py represents the x-y decoupled coordinate. EX, EPX, EY, EPY refer the dec\
oupled coordinate, while PEX, PEPX, PEY, PEPY are in the physical coordinate. On the other hand,  DX, DPX, DY, DPY refer the physi\
cal coordinate."[p$2539,p1$2539]])===
    Undefined,
equ$2539="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Available optical functions for matching are\
:\t\n\nAX      alpha_X\nBX      beta_X\nGMX     gamma_X\nNX      psi_X, the default scale is 1/(2Pi)\nAY      alpha_Y\nBY      bet\
a_Y\nGMY     gamma_Y\nNY      psi_Y, the default scale is 1/(2Pi)\nEX      eta_X   (dispersion_X)\nEPX     eta_Px  (dispersion_PX)\
 \nEY      eta_Y   (dispersion_Y)\nEPY     eta_Py  (dispersion_PY)\nR1      R_1     (see x-y-coupling)\nR2      R_2     (see x-y-c\
oupling)\nR3      R_3     (see x-y-coupling)\nR4      R_4     (see x-y-coupling)\nDETR    R_1*R_4 - R_2*R_3 (see x-y-coupling)\nDX\
      dx\nDPX     dpx\nDY      dy\nDPY     dpy\nDZ      dz\nDDP     delta=dp/p0\nAZ      alpha_Z\nBZ      beta_Z\nGMZ     gamma_Z\\
nNZ      psi_Z, the default scale is 1/(2Pi)\nZX      zeta_X  (z-dispersion_X)\nZPX     zeta_Px (z-dispersion_PX) \nZY      zeta_Y\
  (z-dispersion_Y)\nZPY     zeta_Py (z-dispersion_PY)\nPEX     eta_x   (dispersion_x)\nPEPX    eta_px  (dispersion_px) \nPEY     e\
ta_y   (dispersion_y)\nPEPY    eta_yy  (dispersion_py)\nTRX     trace(T_X), only defined at the end of the beam line.\nTRY     tra\
ce(T_Y), only defined at the end of the beam line.\nLENG    length of the design orbit\t\n\nIn the above, upper case X, Px, Y, Py \
represents the x-y decoupled coordinate. EX, EPX, EY, EPY refer the decoupled coordinate, while PEX, PEPX, PEY, PEPY are in the ph\
ysical coordinate. On the other hand,  DX, DPX, DY, DPY refer the physical coordinate."[p$2539,p1$2539]]=
       equ$2539;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2539},out$2539=lx$2539@Typeset["Available optical functions for matching are:\t\n\nAX      alpha_X\nBX      beta_X\nGMX  \
   gamma_X\nNX      psi_X, the default scale is 1/(2Pi)\nAY      alpha_Y\nBY      beta_Y\nGMY     gamma_Y\nNY      psi_Y, the defa\
ult scale is 1/(2Pi)\nEX      eta_X   (dispersion_X)\nEPX     eta_Px  (dispersion_PX) \nEY      eta_Y   (dispersion_Y)\nEPY     et\
a_Py  (dispersion_PY)\nR1      R_1     (see x-y-coupling)\nR2      R_2     (see x-y-coupling)\nR3      R_3     (see x-y-coupling)\\
nR4      R_4     (see x-y-coupling)\nDETR    R_1*R_4 - R_2*R_3 (see x-y-coupling)\nDX      dx\nDPX     dpx\nDY      dy\nDPY     dp\
y\nDZ      dz\nDDP     delta=dp/p0\nAZ      alpha_Z\nBZ      beta_Z\nGMZ     gamma_Z\nNZ      psi_Z, the default scale is 1/(2Pi)\\
nZX      zeta_X  (z-dispersion_X)\nZPX     zeta_Px (z-dispersion_PX) \nZY      zeta_Y  (z-dispersion_Y)\nZPY     zeta_Py (z-disper\
sion_PY)\nPEX     eta_x   (dispersion_x)\nPEPX    eta_px  (dispersion_px) \nPEY     eta_y   (dispersion_y)\nPEPY    eta_yy  (dispe\
rsion_py)\nTRX     trace(T_X), only defined at the end of the beam line.\nTRY     trace(T_Y), only defined at the end of the beam \
line.\nLENG    length of the design orbit\t\n\nIn the above, upper case X, Px, Y, Py represents the x-y decoupled coordinate. EX, \
EPX, EY, EPY refer the decoupled coordinate, while PEX, PEPX, PEY, PEPY are in the physical coordinate. On the other hand,  DX, DP\
X, DY, DPY refer the physical coordinate."[p$2539,p1$2539],Format->Help2HTML`oB$];
        System["mv -f "//out$2539//" "//equ$2539]];
      Exit[]]];
   "Available optical functions for matching are:\t\n\nAX      alpha_X\nBX      beta_X\nGMX     gamma_X\nNX      psi_X, the defaul\
t scale is 1/(2Pi)\nAY      alpha_Y\nBY      beta_Y\nGMY     gamma_Y\nNY      psi_Y, the default scale is 1/(2Pi)\nEX      eta_X  \
 (dispersion_X)\nEPX     eta_Px  (dispersion_PX) \nEY      eta_Y   (dispersion_Y)\nEPY     eta_Py  (dispersion_PY)\nR1      R_1   \
  (see x-y-coupling)\nR2      R_2     (see x-y-coupling)\nR3      R_3     (see x-y-coupling)\nR4      R_4     (see x-y-coupling)\n\
DETR    R_1*R_4 - R_2*R_3 (see x-y-coupling)\nDX      dx\nDPX     dpx\nDY      dy\nDPY     dpy\nDZ      dz\nDDP     delta=dp/p0\nA\
Z      alpha_Z\nBZ      beta_Z\nGMZ     gamma_Z\nNZ      psi_Z, the default scale is 1/(2Pi)\nZX      zeta_X  (z-dispersion_X)\nZP\
X     zeta_Px (z-dispersion_PX) \nZY      zeta_Y  (z-dispersion_Y)\nZPY     zeta_Py (z-dispersion_PY)\nPEX     eta_x   (dispersion\
_x)\nPEPX    eta_px  (dispersion_px) \nPEY     eta_y   (dispersion_y)\nPEPY    eta_yy  (dispersion_py)\nTRX     trace(T_X), only d\
efined at the end of the beam line.\nTRY     trace(T_Y), only defined at the end of the beam line.\nLENG    length of the design o\
rbit\t\n\nIn the above, upper case X, Px, Y, Py represents the x-y decoupled coordinate. EX, EPX, EY, EPY refer the decoupled coor\
dinate, while PEX, PEPX, PEY, PEPY are in the physical coordinate. On the other hand,  DX, DPX, DY, DPY refer the physical coordin\
ate."[1,Max[p0$2539,0]]//"<img  class=\"eqs\" SRC=\""//equ$2539//"\" />"//
Help2HTML`oy$["Available optical functions for matching are:\t\n\nAX      alpha_X\nBX      beta_X\nGMX     gamma_X\nNX      psi_X,\
 the default scale is 1/(2Pi)\nAY      alpha_Y\nBY      beta_Y\nGMY     gamma_Y\nNY      psi_Y, the default scale is 1/(2Pi)\nEX  \
    eta_X   (dispersion_X)\nEPX     eta_Px  (dispersion_PX) \nEY      eta_Y   (dispersion_Y)\nEPY     eta_Py  (dispersion_PY)\nR1 \
     R_1     (see x-y-coupling)\nR2      R_2     (see x-y-coupling)\nR3      R_3     (see x-y-coupling)\nR4      R_4     (see x-y-\
coupling)\nDETR    R_1*R_4 - R_2*R_3 (see x-y-coupling)\nDX      dx\nDPX     dpx\nDY      dy\nDPY     dpy\nDZ      dz\nDDP     del\
ta=dp/p0\nAZ      alpha_Z\nBZ      beta_Z\nGMZ     gamma_Z\nNZ      psi_Z, the default scale is 1/(2Pi)\nZX      zeta_X  (z-disper\
sion_X)\nZPX     zeta_Px (z-dispersion_PX) \nZY      zeta_Y  (z-dispersion_Y)\nZPY     zeta_Py (z-dispersion_PY)\nPEX     eta_x   \
(dispersion_x)\nPEPX    eta_px  (dispersion_px) \nPEY     eta_y   (dispersion_y)\nPEPY    eta_yy  (dispersion_py)\nTRX     trace(T\
_X), only defined at the end of the beam line.\nTRY     trace(T_Y), only defined at the end of the beam line.\nLENG    length of t\
he design orbit\t\n\nIn the above, upper case X, Px, Y, Py represents the x-y decoupled coordinate. EX, EPX, EY, EPY refer the dec\
oupled coordinate, while PEX, PEPX, PEY, PEPY are in the physical coordinate. On the other hand,  DX, DPX, DY, DPY refer the physi\
cal coordinate."[p2$2539,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L468>geometric-functions</A> <A HREF=#L51>x-y-coupling</A> <A HREF=#L473>matching-function-commands</A> <A HREF=#L469>GO</A> <A HREF=#L32>CALCULATE(CAL)</A> <A HREF=#L56>DISPLAY(DISP)</A>
 <A HREF=#L550>SHOW</A></PRE>
<H3><A NAME=L479>
ORG</A></H3>
<PRE>If[{},
Help2HTML`oA$["Usage: ORG location, dgx, dgy, dgz, dchi1, dchi2, dch3\n\nsets the origin of the geometrical coordinate relative to\
 the location with a relative shift (dgx, dgy, dgz) and rotation (dchi1, dchi2, dchi3)."],
 p$2542=1+p$2542[[1,2]];p1$2542=StringPosition["Usage: ORG location, dgx, dgy, dgz, dchi1, dchi2, dch3\n\nsets the origin of the g\
eometrical coordinate relative to the location with a relative shift (dgx, dgy, dgz) and rotation (dchi1, dchi2, dchi3)."[p$2542,-1
     ],
    ">::",1];
   p1$2542=If[p1$2542==={},200,-2+p$2542+p1$2542[[1,1]]];
neq=Which["Usage: ORG location, dgx, dgy, dgz, dchi1, dchi2, dch3\n\nsets the origin of the geometrical coordinate relative to the\
 location with a relative shift (dgx, dgy, dgz) and rotation (dchi1, dchi2, dchi3)."[p$2542,4+p$2542]==="Text[",
    lx$2542:=Help2HTML`oa$;p$2542=5+p$2542;p1$2542-=1;p2$2542=5+p1$2542;p0$2542=-9+p$2542;
If[(pe$2542=StringPosition["Usage: ORG location, dgx, dgy, dgz, dchi1, dchi2, dch3\n\nsets the origin of the geometrical coordinat\
e relative to the location with a relative shift (dgx, dgy, dgz) and rotation (dchi1, dchi2, dchi3)."[p$2542,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Usage: ORG location, dgx, dgy, dgz, dchi1, dchi2, dch3\n\nsets the origin of the geometrical coordinate relative \
to the location with a relative shift (dgx, dgy, dgz) and rotation (dchi1, dchi2, dchi3)."[p$2542+pe$2542[[1,2]],p1$2542]]],
        p1$2542=-2+p$2542+pe$2542[[1,1]]}[[
       1]],
      0],
    1,lx$2542:=Help2HTML`o9$;p2$2542=4+p1$2542;p0$2542=-4+p$2542;0];
  If[(equ$2542=
Help2HTML`o8$["Usage: ORG location, dgx, dgy, dgz, dchi1, dchi2, dch3\n\nsets the origin of the geometrical coordinate relative to\
 the location with a relative shift (dgx, dgy, dgz) and rotation (dchi1, dchi2, dchi3)."[p$2542,p1$2542]])===
    Undefined,
equ$2542="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Usage: ORG location, dgx, dgy, dgz, dchi1, d\
chi2, dch3\n\nsets the origin of the geometrical coordinate relative to the location with a relative shift (dgx, dgy, dgz) and rot\
ation (dchi1, dchi2, dchi3)."[p$2542,p1$2542]]=
       equ$2542;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2542},out$2542=lx$2542@Typeset["Usage: ORG location, dgx, dgy, dgz, dchi1, dchi2, dch3\n\nsets the origin of the geometri\
cal coordinate relative to the location with a relative shift (dgx, dgy, dgz) and rotation (dchi1, dchi2, dchi3)."[p$2542,p1$2542],
          Format->Help2HTML`oB$];
        System["mv -f "//out$2542//" "//equ$2542]];
      Exit[]]];
   "Usage: ORG location, dgx, dgy, dgz, dchi1, dchi2, dch3\n\nsets the origin of the geometrical coordinate relative to the locati\
on with a relative shift (dgx, dgy, dgz) and rotation (dchi1, dchi2, dchi3)."[1,Max[p0$2542,0]]//"<img  class=\"eqs\" SRC=\""//
   equ$2542//"\" />"//
Help2HTML`oy$["Usage: ORG location, dgx, dgy, dgz, dchi1, dchi2, dch3\n\nsets the origin of the geometrical coordinate relative to\
 the location with a relative shift (dgx, dgy, dgz) and rotation (dchi1, dchi2, dchi3)."[p2$2542,-1]]
]</PRE>
<H3><A NAME=L480>
OUTPUT(OUT)</A></H3>
<PRE>If[{},
Help2HTML`oA$["OUT {filename | file-number} switches the output stream to the specified file or the file-number. The file is writt\
en from the beginning."],
p$2544=1+p$2544[[1,2]];p1$2544=StringPosition["OUT {filename | file-number} switches the output stream to the specified file or th\
e file-number. The file is written from the beginning."[p$2544,-1],">::",1];
   p1$2544=If[p1$2544==={},137,-2+p$2544+p1$2544[[1,1]]];
neq=Which["OUT {filename | file-number} switches the output stream to the specified file or the file-number. The file is written f\
rom the beginning."[p$2544,4+p$2544]==="Text[",
    lx$2544:=Help2HTML`oa$;p$2544=5+p$2544;p1$2544-=1;p2$2544=5+p1$2544;p0$2544=-9+p$2544;
If[(pe$2544=StringPosition["OUT {filename | file-number} switches the output stream to the specified file or the file-number. The \
file is written from the beginning."[p$2544,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["OUT {filename | file-number} switches the output stream to the specified file or the file-number. The file is wri\
tten from the beginning."[p$2544+pe$2544[[1,2]],p1$2544]]],
        p1$2544=-2+p$2544+pe$2544[[1,1]]}[[
       1]],
      0],
    1,lx$2544:=Help2HTML`o9$;p2$2544=4+p1$2544;p0$2544=-4+p$2544;0];
  If[(equ$2544=
Help2HTML`o8$["OUT {filename | file-number} switches the output stream to the specified file or the file-number. The file is writt\
en from the beginning."[p$2544,p1$2544]])===
    Undefined,
equ$2544="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["OUT {filename | file-number} switches the ou\
tput stream to the specified file or the file-number. The file is written from the beginning."[p$2544,p1$2544]]=
       equ$2544;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2544},out$2544=lx$2544@Typeset["OUT {filename | file-number} switches the output stream to the specified file or the file\
-number. The file is written from the beginning."[p$2544,p1$2544],Format->Help2HTML`oB$];
        System["mv -f "//out$2544//" "//equ$2544]];
      Exit[]]];
   "OUT {filename | file-number} switches the output stream to the specified file or the file-number. The file is written from the\
 beginning."[1,Max[p0$2544,0]]//"<img  class=\"eqs\" SRC=\""//equ$2544//"\" />"//
Help2HTML`oy$["OUT {filename | file-number} switches the output stream to the specified file or the file-number. The file is writt\
en from the beginning."[p2$2544,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L555>TERMINATE(TERM)</A> <A HREF=#L34>CLOSE(CLO)</A> <A HREF=#L471>INPUT(IN)</A> <A HREF=#L487>READ</A> <A HREF=#L3>APPEND(APP)</A> <A HREF=#L296>END</A></PRE>
<H3><A NAME=L481>
pattern</A></H3>
<PRE>If[{},
Help2HTML`oA$[" Pattern is a special expression for mathing arguments in function definitions and rules with several forms:\n\n_  \
         matches any single argument.\n__          matches a sequence of 1 or more arguments.\n___         matches a sequence of 0\
 or more arguments.\nx_          matches any single argument, which is names x.\nx__         matches a sequence of 1 or more argum\
ents, which is named x.\nx___        matches a sequence of 0 or more arguments, which is named x.\nx:pattern   a pattern which is \
named x.\npattern:v   a pattern which has a default value v when matching is failed.\npattern..   a non-null sequence of arguments\
 each of which matches pattern.\npattern...  a sequence, which can be null, of arguments each of which matches pattern.\nexpressio\
n  matches expression."],
p$2547=1+p$2547[[1,2]];p1$2547=StringPosition[" Pattern is a special expression for mathing arguments in function definitions and \
rules with several forms:\n\n_           matches any single argument.\n__          matches a sequence of 1 or more arguments.\n___\
         matches a sequence of 0 or more arguments.\nx_          matches any single argument, which is names x.\nx__         match\
es a sequence of 1 or more arguments, which is named x.\nx___        matches a sequence of 0 or more arguments, which is named x.\\
nx:pattern   a pattern which is named x.\npattern:v   a pattern which has a default value v when matching is failed.\npattern..   \
a non-null sequence of arguments each of which matches pattern.\npattern...  a sequence, which can be null, of arguments each of w\
hich matches pattern.\nexpression  matches expression."[p$2547,-1],">::",1];
   p1$2547=If[p1$2547==={},775,-2+p$2547+p1$2547[[1,1]]];
neq=Which[" Pattern is a special expression for mathing arguments in function definitions and rules with several forms:\n\n_      \
     matches any single argument.\n__          matches a sequence of 1 or more arguments.\n___         matches a sequence of 0 or \
more arguments.\nx_          matches any single argument, which is names x.\nx__         matches a sequence of 1 or more arguments\
, which is named x.\nx___        matches a sequence of 0 or more arguments, which is named x.\nx:pattern   a pattern which is name\
d x.\npattern:v   a pattern which has a default value v when matching is failed.\npattern..   a non-null sequence of arguments eac\
h of which matches pattern.\npattern...  a sequence, which can be null, of arguments each of which matches pattern.\nexpression  m\
atches expression."[p$2547,4+p$2547]==="Text[",
    lx$2547:=Help2HTML`oa$;p$2547=5+p$2547;p1$2547-=1;p2$2547=5+p1$2547;p0$2547=-9+p$2547;
If[(pe$2547=StringPosition[" Pattern is a special expression for mathing arguments in function definitions and rules with several \
forms:\n\n_           matches any single argument.\n__          matches a sequence of 1 or more arguments.\n___         matches a \
sequence of 0 or more arguments.\nx_          matches any single argument, which is names x.\nx__         matches a sequence of 1 \
or more arguments, which is named x.\nx___        matches a sequence of 0 or more arguments, which is named x.\nx:pattern   a patt\
ern which is named x.\npattern:v   a pattern which has a default value v when matching is failed.\npattern..   a non-null sequence\
 of arguments each of which matches pattern.\npattern...  a sequence, which can be null, of arguments each of which matches patter\
n.\nexpression  matches expression."[p$2547,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression[" Pattern is a special expression for mathing arguments in function definitions and rules with several forms:\n\n_\
           matches any single argument.\n__          matches a sequence of 1 or more arguments.\n___         matches a sequence of\
 0 or more arguments.\nx_          matches any single argument, which is names x.\nx__         matches a sequence of 1 or more arg\
uments, which is named x.\nx___        matches a sequence of 0 or more arguments, which is named x.\nx:pattern   a pattern which i\
s named x.\npattern:v   a pattern which has a default value v when matching is failed.\npattern..   a non-null sequence of argumen\
ts each of which matches pattern.\npattern...  a sequence, which can be null, of arguments each of which matches pattern.\nexpress\
ion  matches expression."[p$2547+pe$2547[[1,2]],p1$2547]]],
        p1$2547=-2+p$2547+pe$2547[[1,1]]}[[
       1]],
      0],
    1,lx$2547:=Help2HTML`o9$;p2$2547=4+p1$2547;p0$2547=-4+p$2547;0];
  If[(equ$2547=
Help2HTML`o8$[" Pattern is a special expression for mathing arguments in function definitions and rules with several forms:\n\n_  \
         matches any single argument.\n__          matches a sequence of 1 or more arguments.\n___         matches a sequence of 0\
 or more arguments.\nx_          matches any single argument, which is names x.\nx__         matches a sequence of 1 or more argum\
ents, which is named x.\nx___        matches a sequence of 0 or more arguments, which is named x.\nx:pattern   a pattern which is \
named x.\npattern:v   a pattern which has a default value v when matching is failed.\npattern..   a non-null sequence of arguments\
 each of which matches pattern.\npattern...  a sequence, which can be null, of arguments each of which matches pattern.\nexpressio\
n  matches expression."[p$2547,p1$2547]])===
    Undefined,
equ$2547="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[" Pattern is a special expression for mathing\
 arguments in function definitions and rules with several forms:\n\n_           matches any single argument.\n__          matches \
a sequence of 1 or more arguments.\n___         matches a sequence of 0 or more arguments.\nx_          matches any single argumen\
t, which is names x.\nx__         matches a sequence of 1 or more arguments, which is named x.\nx___        matches a sequence of \
0 or more arguments, which is named x.\nx:pattern   a pattern which is named x.\npattern:v   a pattern which has a default value v\
 when matching is failed.\npattern..   a non-null sequence of arguments each of which matches pattern.\npattern...  a sequence, wh\
ich can be null, of arguments each of which matches pattern.\nexpression  matches expression."[p$2547,p1$2547]]=
       equ$2547;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2547},out$2547=lx$2547@Typeset[" Pattern is a special expression for mathing arguments in function definitions and rules \
with several forms:\n\n_           matches any single argument.\n__          matches a sequence of 1 or more arguments.\n___      \
   matches a sequence of 0 or more arguments.\nx_          matches any single argument, which is names x.\nx__         matches a s\
equence of 1 or more arguments, which is named x.\nx___        matches a sequence of 0 or more arguments, which is named x.\nx:pat\
tern   a pattern which is named x.\npattern:v   a pattern which has a default value v when matching is failed.\npattern..   a non-\
null sequence of arguments each of which matches pattern.\npattern...  a sequence, which can be null, of arguments each of which m\
atches pattern.\nexpression  matches expression."[p$2547,p1$2547],Format->Help2HTML`oB$];
        System["mv -f "//out$2547//" "//equ$2547]];
      Exit[]]];
   " Pattern is a special expression for mathing arguments in function definitions and rules with several forms:\n\n_           ma\
tches any single argument.\n__          matches a sequence of 1 or more arguments.\n___         matches a sequence of 0 or more ar\
guments.\nx_          matches any single argument, which is names x.\nx__         matches a sequence of 1 or more arguments, which\
 is named x.\nx___        matches a sequence of 0 or more arguments, which is named x.\nx:pattern   a pattern which is named x.\np\
attern:v   a pattern which has a default value v when matching is failed.\npattern..   a non-null sequence of arguments each of wh\
ich matches pattern.\npattern...  a sequence, which can be null, of arguments each of which matches pattern.\nexpression  matches \
expression."[1,Max[p0$2547,0]]//"<img  class=\"eqs\" SRC=\""//equ$2547//"\" />"//
Help2HTML`oy$[" Pattern is a special expression for mathing arguments in function definitions and rules with several forms:\n\n_  \
         matches any single argument.\n__          matches a sequence of 1 or more arguments.\n___         matches a sequence of 0\
 or more arguments.\nx_          matches any single argument, which is names x.\nx__         matches a sequence of 1 or more argum\
ents, which is named x.\nx___        matches a sequence of 0 or more arguments, which is named x.\nx:pattern   a pattern which is \
named x.\npattern:v   a pattern which has a default value v when matching is failed.\npattern..   a non-null sequence of arguments\
 each of which matches pattern.\npattern...  a sequence, which can be null, of arguments each of which matches pattern.\nexpressio\
n  matches expression."[p2$2547,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L482>MatchQ</A> <A HREF=#L42>defining-functions</A> rules</PRE>
<UL>
<LI>
<H3><A NAME=L482>
MatchQ</A></H3>
<PRE>If[{},Help2HTML`oA$[" MatchQ[x, pat] returns True if x matches pat"],
 p$2550=1+p$2550[[1,2]];p1$2550=StringPosition[" MatchQ[x, pat] returns True if x matches pat"[p$2550,-1],">::",1];
  p1$2550=If[p1$2550==={},45,-2+p$2550+p1$2550[[1,1]]];
  neq=Which[" MatchQ[x, pat] returns True if x matches pat"[p$2550,4+p$2550]==="Text[",
    lx$2550:=Help2HTML`oa$;p$2550=5+p$2550;p1$2550-=1;p2$2550=5+p1$2550;p0$2550=-9+p$2550;
     If[(pe$2550=StringPosition[" MatchQ[x, pat] returns True if x matches pat"[p$2550,-2],";;;"])<=>{},
      {Max[0,-1+ToExpression[" MatchQ[x, pat] returns True if x matches pat"[p$2550+pe$2550[[1,2]],p1$2550]]],
       p1$2550=-2+p$2550+pe$2550[[1,1]]}[[1]],
      0],
    1,lx$2550:=Help2HTML`o9$;p2$2550=4+p1$2550;p0$2550=-4+p$2550;0];
  If[(equ$2550=Help2HTML`o8$[" MatchQ[x, pat] returns True if x matches pat"[p$2550,p1$2550]])===Undefined,
   equ$2550="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$[" MatchQ[x, pat] returns True if x matches pat"[p$2550,p1$2550]]=equ$2550;LaTeX`ob$+=neq,
     --LaTeX`ob$;With[{lx$2550},
       out$2550=lx$2550@Typeset[" MatchQ[x, pat] returns True if x matches pat"[p$2550,p1$2550],Format->Help2HTML`oB$];
        System["mv -f "//out$2550//" "//equ$2550]];
      Exit[]]];
   " MatchQ[x, pat] returns True if x matches pat"[1,Max[p0$2550,0]]//"<img  class=\"eqs\" SRC=\""//equ$2550//"\" />"//
   Help2HTML`oy$[" MatchQ[x, pat] returns True if x matches pat"[p2$2550,-1]]
]</PRE>
</UL>
<H3><A NAME=L483>
physical-constants</A></H3>
<PRE><img  class="eqs" SRC="SADHelp_img/equ_213.svg" />
</PRE>
<PRE>See also:
 <A HREF=#L31>constants</A> <A HREF=#L246>expression</A> <A HREF=#L500>special-variables</A></PRE>
<H3><A NAME=L484>
PRINT(PRI)</A></H3>
<PRE>If[{},Help2HTML`oA$["PRI expression evaluates expression and prints out the result."],
 p$2555=1+p$2555[[1,2]];p1$2555=StringPosition["PRI expression evaluates expression and prints out the result."[p$2555,-1],">::",
    1];
   p1$2555=If[p1$2555==={},62,-2+p$2555+p1$2555[[1,1]]];
  neq=Which["PRI expression evaluates expression and prints out the result."[p$2555,4+p$2555]==="Text[",
    lx$2555:=Help2HTML`oa$;p$2555=5+p$2555;p1$2555-=1;p2$2555=5+p1$2555;p0$2555=-9+p$2555;
     If[(pe$2555=StringPosition["PRI expression evaluates expression and prints out the result."[p$2555,-2],";;;"])<=>{},
      {Max[0,-1+ToExpression["PRI expression evaluates expression and prints out the result."[p$2555+pe$2555[[1,2]],p1$2555]]],
       p1$2555=-2+p$2555+pe$2555[[1,1]]}[[1]],
      0],
    1,lx$2555:=Help2HTML`o9$;p2$2555=4+p1$2555;p0$2555=-4+p$2555;0];
  If[(equ$2555=Help2HTML`o8$["PRI expression evaluates expression and prints out the result."[p$2555,p1$2555]])===Undefined,
   equ$2555="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["PRI expression evaluates expression and prints out the result."[p$2555,p1$2555]]=equ$2555;
      LaTeX`ob$+=neq,
     --LaTeX`ob$;With[{lx$2555},out$2555=lx$2555@Typeset["PRI expression evaluates expression and prints out the result."[p$2555,
           p1$2555],Format->Help2HTML`oB$];
        System["mv -f "//out$2555//" "//equ$2555]];
      Exit[]]];
   "PRI expression evaluates expression and prints out the result."[1,Max[p0$2555,0]]//"<img  class=\"eqs\" SRC=\""//equ$2555//
   "\" />"//Help2HTML`oy$["PRI expression evaluates expression and prints out the result."[p2$2555,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L246>expression</A> <A HREF=#L434>Print</A></PRE>
<H3><A NAME=L485>
QUIT</A></H3>
<PRE>If[{},Help2HTML`oA$["Exits FFS and return to SAD/MAIN level, without saving the values of the elements."],
 p$2558=1+p$2558[[1,2]];
  p1$2558=StringPosition["Exits FFS and return to SAD/MAIN level, without saving the values of the elements."[p$2558,-1],">::",1];
  p1$2558=If[p1$2558==={},82,-2+p$2558+p1$2558[[1,1]]];
  neq=Which["Exits FFS and return to SAD/MAIN level, without saving the values of the elements."[p$2558,4+p$2558]==="Text[",
    lx$2558:=Help2HTML`oa$;p$2558=5+p$2558;p1$2558-=1;p2$2558=5+p1$2558;p0$2558=-9+p$2558;
     If[(pe$2558=StringPosition["Exits FFS and return to SAD/MAIN level, without saving the values of the elements."[p$2558,-2],
         ";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression["Exits FFS and return to SAD/MAIN level, without saving the values of the elements."[p$2558+pe$2558[[1,2]],
           p1$2558]]],
        p1$2558=-2+p$2558+pe$2558[[1,1]]}[[
       1]],
      0],
    1,lx$2558:=Help2HTML`o9$;p2$2558=4+p1$2558;p0$2558=-4+p$2558;0];
  If[(equ$2558=Help2HTML`o8$["Exits FFS and return to SAD/MAIN level, without saving the values of the elements."[p$2558,p1$2558]]
     )===
    Undefined,
   equ$2558="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "Exits FFS and return to SAD/MAIN level, without saving the values of the elements."[p$2558,p1$2558]]=
       equ$2558;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$2558},out$2558=lx$2558@Typeset["Exits FFS and return to SAD/MAIN level, without saving the values of the elements."[
           p$2558,p1$2558],Format->Help2HTML`oB$];
        System["mv -f "//out$2558//" "//equ$2558]];
      Exit[]]];
   "Exits FFS and return to SAD/MAIN level, without saving the values of the elements."[1,Max[p0$2558,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2558//"\" />"//
   Help2HTML`oy$["Exits FFS and return to SAD/MAIN level, without saving the values of the elements."[p2$2558,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L553>STOP</A> <A HREF=#L548>SAVE</A> <A HREF=#L2>ABORT</A> <A HREF=#L558>USE</A> <A HREF=#L561>VISIT</A> <A HREF=#L14>BYE</A></PRE>
<H3><A NAME=L486>
RADINT</A></H3>
<PRE>If[{},
 Help2HTML`oA$["RADINT prints out the radiation integrals involving the x-coupling for all components of the beam line."],
 p$2561=1+p$2561[[1,2]];
  p1$2561=StringPosition["RADINT prints out the radiation integrals involving the x-coupling for all components of the beam line."[
     p$2561,-1],
    ">::",1];
   p1$2561=If[p1$2561==={},103,-2+p$2561+p1$2561[[1,1]]];
  neq=Which["RADINT prints out the radiation integrals involving the x-coupling for all components of the beam line."[p$2561,
      4+p$2561]===
     "Text[",
    lx$2561:=Help2HTML`oa$;p$2561=5+p$2561;p1$2561-=1;p2$2561=5+p1$2561;p0$2561=-9+p$2561;If[(pe$2561=StringPosition[
         "RADINT prints out the radiation integrals involving the x-coupling for all components of the beam line."[p$2561,-2],";;;"
         ])<=>
       {},
      {Max[0,
        -1+ToExpression["RADINT prints out the radiation integrals involving the x-coupling for all components of the beam line."[
            p$2561+pe$2561[[1,2]],
           p1$2561]]],
        p1$2561=-2+p$2561+pe$2561[[1,1]]}[[
       1]],
      0],
    1,lx$2561:=Help2HTML`o9$;p2$2561=4+p1$2561;p0$2561=-4+p$2561;0];
  If[(equ$2561=
     Help2HTML`o8$["RADINT prints out the radiation integrals involving the x-coupling for all components of the beam line."[p$2561
       ,p1$2561]])===
    Undefined,
   equ$2561="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "RADINT prints out the radiation integrals involving the x-coupling for all components of the beam line."[p$2561,p1$2561]]=
       equ$2561;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$2561},out$2561=lx$2561@Typeset[
          "RADINT prints out the radiation integrals involving the x-coupling for all components of the beam line."[p$2561,p1$2561
           ],Format->Help2HTML`oB$];
        System["mv -f "//out$2561//" "//equ$2561]];
      Exit[]]];
   "RADINT prints out the radiation integrals involving the x-coupling for all components of the beam line."[1,Max[p0$2561,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2561//"\" />"//
   Help2HTML`oy$["RADINT prints out the radiation integrals involving the x-coupling for all components of the beam line."[p2$2561,
     -1]]
]</PRE>
<H3><A NAME=L487>
READ</A></H3>
<PRE>If[{},
Help2HTML`oA$["READ {filename | file-number} switches the input stream to the specified file or the file-number. The original stre\
am is kept and to be returned by TERMINATE(TERM). The input file is rewound."],
p$2563=1+p$2563[[1,2]];p1$2563=StringPosition["READ {filename | file-number} switches the input stream to the specified file or th\
e file-number. The original stream is kept and to be returned by TERMINATE(TERM). The input file is rewound."[p$2563,-1],">::",1];
  p1$2563=If[p1$2563==={},191,-2+p$2563+p1$2563[[1,1]]];
neq=Which["READ {filename | file-number} switches the input stream to the specified file or the file-number. The original stream i\
s kept and to be returned by TERMINATE(TERM). The input file is rewound."[p$2563,4+p$2563]==="Text[",
    lx$2563:=Help2HTML`oa$;p$2563=5+p$2563;p1$2563-=1;p2$2563=5+p1$2563;p0$2563=-9+p$2563;
If[(pe$2563=StringPosition["READ {filename | file-number} switches the input stream to the specified file or the file-number. The \
original stream is kept and to be returned by TERMINATE(TERM). The input file is rewound."[p$2563,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["READ {filename | file-number} switches the input stream to the specified file or the file-number. The original st\
ream is kept and to be returned by TERMINATE(TERM). The input file is rewound."[p$2563+pe$2563[[1,2]],p1$2563]]],
        p1$2563=-2+p$2563+pe$2563[[1,1]]}[[
       1]],
      0],
    1,lx$2563:=Help2HTML`o9$;p2$2563=4+p1$2563;p0$2563=-4+p$2563;0];
  If[(equ$2563=
Help2HTML`o8$["READ {filename | file-number} switches the input stream to the specified file or the file-number. The original stre\
am is kept and to be returned by TERMINATE(TERM). The input file is rewound."[p$2563,p1$2563]])===
    Undefined,
equ$2563="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["READ {filename | file-number} switches the i\
nput stream to the specified file or the file-number. The original stream is kept and to be returned by TERMINATE(TERM). The input\
 file is rewound."[p$2563,p1$2563]]=
       equ$2563;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2563},out$2563=lx$2563@Typeset["READ {filename | file-number} switches the input stream to the specified file or the file\
-number. The original stream is kept and to be returned by TERMINATE(TERM). The input file is rewound."[p$2563,p1$2563],
          Format->Help2HTML`oB$];
        System["mv -f "//out$2563//" "//equ$2563]];
      Exit[]]];
   "READ {filename | file-number} switches the input stream to the specified file or the file-number. The original stream is kept \
and to be returned by TERMINATE(TERM). The input file is rewound."[1,Max[p0$2563,0]]//"<img  class=\"eqs\" SRC=\""//equ$2563//
   "\" />"//
Help2HTML`oy$["READ {filename | file-number} switches the input stream to the specified file or the file-number. The original stre\
am is kept and to be returned by TERMINATE(TERM). The input file is rewound."[p2$2563,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L555>TERMINATE(TERM)</A> <A HREF=#L34>CLOSE(CLO)</A> <A HREF=#L471>INPUT(IN)</A> <A HREF=#L480>OUTPUT(OUT)</A> <A HREF=#L3>APPEND(APP)</A> <A HREF=#L296>END</A></PRE>
<H3><A NAME=L488>
RECOVER(REC)</A></H3>
<PRE>If[{},
 Help2HTML`oA$[
  "REC exchanges the values of FREEd elements with those when the last GO command was issued. FIXed elements are not affected."],
 p$2566=1+p$2566[[1,2]];
  p1$2566=StringPosition[
    "REC exchanges the values of FREEd elements with those when the last GO command was issued. FIXed elements are not affected."[
     p$2566,-1],
    ">::",1];
   p1$2566=If[p1$2566==={},123,-2+p$2566+p1$2566[[1,1]]];
  neq=Which[
     "REC exchanges the values of FREEd elements with those when the last GO command was issued. FIXed elements are not affected."[
      p$2566,4+p$2566]===
     "Text[",
    lx$2566:=Help2HTML`oa$;p$2566=5+p$2566;p1$2566-=1;p2$2566=5+p1$2566;p0$2566=-9+p$2566;If[(pe$2566=StringPosition[
         "REC exchanges the values of FREEd elements with those when the last GO command was issued. FIXed elements are not affect\
ed."[p$2566,-2],";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression[
          "REC exchanges the values of FREEd elements with those when the last GO command was issued. FIXed elements are not affec\
ted."[p$2566+pe$2566[[1,2]],p1$2566]]],
        p1$2566=-2+p$2566+pe$2566[[1,1]]}[[
       1]],
      0],
    1,lx$2566:=Help2HTML`o9$;p2$2566=4+p1$2566;p0$2566=-4+p$2566;0];
  If[(equ$2566=
     Help2HTML`o8$[
      "REC exchanges the values of FREEd elements with those when the last GO command was issued. FIXed elements are not affected."
      [p$2566,p1$2566]])===
    Undefined,
   equ$2566="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "REC exchanges the values of FREEd elements with those when the last GO command was issued. FIXed elements are not affecte\
d."[p$2566,p1$2566]]=
       equ$2566;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$2566},out$2566=lx$2566@Typeset[
          "REC exchanges the values of FREEd elements with those when the last GO command was issued. FIXed elements are not affec\
ted."[p$2566,p1$2566],Format->Help2HTML`oB$];
        System["mv -f "//out$2566//" "//equ$2566]];
      Exit[]]];
  "REC exchanges the values of FREEd elements with those when the last GO command was issued. FIXed elements are not affected."[1,
    Max[p0$2566,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2566//"\" />"//
   Help2HTML`oy$[
    "REC exchanges the values of FREEd elements with those when the last GO command was issued. FIXed elements are not affected."[
     p2$2566,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L469>GO</A> <A HREF=#L466>FREE</A> <A HREF=#L465>FIX</A> <A HREF=#L494>RESET</A> <A HREF=#L548>SAVE</A></PRE>
<H3><A NAME=L489>
REFERENCE(REF)</A></H3>
<PRE>If[{},Help2HTML`oA$["REFERENCE(REF) sets the current optics as the reference optics."],
 p$2569=1+p$2569[[1,2]];p1$2569=StringPosition["REFERENCE(REF) sets the current optics as the reference optics."[p$2569,-1],">::",
    1];
   p1$2569=If[p1$2569==={},63,-2+p$2569+p1$2569[[1,1]]];
  neq=Which["REFERENCE(REF) sets the current optics as the reference optics."[p$2569,4+p$2569]==="Text[",
    lx$2569:=Help2HTML`oa$;p$2569=5+p$2569;p1$2569-=1;p2$2569=5+p1$2569;p0$2569=-9+p$2569;
     If[(pe$2569=StringPosition["REFERENCE(REF) sets the current optics as the reference optics."[p$2569,-2],";;;"])<=>{},
      {Max[0,-1+ToExpression["REFERENCE(REF) sets the current optics as the reference optics."[p$2569+pe$2569[[1,2]],p1$2569]]],
       p1$2569=-2+p$2569+pe$2569[[1,1]]}[[1]],
      0],
    1,lx$2569:=Help2HTML`o9$;p2$2569=4+p1$2569;p0$2569=-4+p$2569;0];
  If[(equ$2569=Help2HTML`o8$["REFERENCE(REF) sets the current optics as the reference optics."[p$2569,p1$2569]])===Undefined,
   equ$2569="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["REFERENCE(REF) sets the current optics as the reference optics."[p$2569,p1$2569]]=equ$2569;
      LaTeX`ob$+=neq,
     --LaTeX`ob$;With[{lx$2569},out$2569=lx$2569@Typeset["REFERENCE(REF) sets the current optics as the reference optics."[p$2569,
           p1$2569],Format->Help2HTML`oB$];
        System["mv -f "//out$2569//" "//equ$2569]];
      Exit[]]];
   "REFERENCE(REF) sets the current optics as the reference optics."[1,Max[p0$2569,0]]//"<img  class=\"eqs\" SRC=\""//equ$2569//
   "\" />"//Help2HTML`oy$["REFERENCE(REF) sets the current optics as the reference optics."[p2$2569,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L490>reference-optics</A></PRE>
<UL>
<LI>
<H3><A NAME=L490>
reference-optics</A></H3>
<PRE>If[{},
Help2HTML`oA$["Optics stored as a reference. Can be refered by DISP REF (mode), DRAW, Twiss, OpticsPlot. Set automatically by the \
first CALC or GO after USE. Can be updated by REFERENCE(REF)."],
p$2572=1+p$2572[[1,2]];p1$2572=StringPosition["Optics stored as a reference. Can be refered by DISP REF (mode), DRAW, Twiss, Optic\
sPlot. Set automatically by the first CALC or GO after USE. Can be updated by REFERENCE(REF)."[p$2572,-1],">::",1];
   p1$2572=If[p1$2572==={},176,-2+p$2572+p1$2572[[1,1]]];
neq=Which["Optics stored as a reference. Can be refered by DISP REF (mode), DRAW, Twiss, OpticsPlot. Set automatically by the firs\
t CALC or GO after USE. Can be updated by REFERENCE(REF)."[p$2572,4+p$2572]==="Text[",
    lx$2572:=Help2HTML`oa$;p$2572=5+p$2572;p1$2572-=1;p2$2572=5+p1$2572;p0$2572=-9+p$2572;
If[(pe$2572=StringPosition["Optics stored as a reference. Can be refered by DISP REF (mode), DRAW, Twiss, OpticsPlot. Set automati\
cally by the first CALC or GO after USE. Can be updated by REFERENCE(REF)."[p$2572,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Optics stored as a reference. Can be refered by DISP REF (mode), DRAW, Twiss, OpticsPlot. Set automatically by th\
e first CALC or GO after USE. Can be updated by REFERENCE(REF)."[p$2572+pe$2572[[1,2]],p1$2572]]],
        p1$2572=-2+p$2572+pe$2572[[1,1]]}[[
       1]],
      0],
    1,lx$2572:=Help2HTML`o9$;p2$2572=4+p1$2572;p0$2572=-4+p$2572;0];
  If[(equ$2572=
Help2HTML`o8$["Optics stored as a reference. Can be refered by DISP REF (mode), DRAW, Twiss, OpticsPlot. Set automatically by the \
first CALC or GO after USE. Can be updated by REFERENCE(REF)."[p$2572,p1$2572]])===
    Undefined,
equ$2572="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Optics stored as a reference. Can be refered\
 by DISP REF (mode), DRAW, Twiss, OpticsPlot. Set automatically by the first CALC or GO after USE. Can be updated by REFERENCE(REF\
)."[p$2572,p1$2572]]=
       equ$2572;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2572},out$2572=lx$2572@Typeset["Optics stored as a reference. Can be refered by DISP REF (mode), DRAW, Twiss, OpticsPlot.\
 Set automatically by the first CALC or GO after USE. Can be updated by REFERENCE(REF)."[p$2572,p1$2572],Format->Help2HTML`oB$];
        System["mv -f "//out$2572//" "//equ$2572]];
      Exit[]]];
   "Optics stored as a reference. Can be refered by DISP REF (mode), DRAW, Twiss, OpticsPlot. Set automatically by the first CALC \
or GO after USE. Can be updated by REFERENCE(REF)."[1,Max[p0$2572,0]]//"<img  class=\"eqs\" SRC=\""//equ$2572//"\" />"//
   Help2HTML`oy$["Optics stored as a reference. Can be refered by DISP REF (mode), DRAW, Twiss, OpticsPlot. Set automatically by t\
he first CALC or GO after USE. Can be updated by REFERENCE(REF)."[p2$2572,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L489>REFERENCE(REF)</A> <A HREF=#L56>DISPLAY(DISP)</A> <A HREF=#L72>DRAW</A> <A HREF=#L410>Twiss</A> <A HREF=#L423>OpticsPlot</A></PRE>
</UL>
<H3><A NAME=L491>
REJECT(REJ)</A></H3>
<PRE>If[{},
Help2HTML`oA$["Usage: (1) REJ matching-function-pattern [matching-function-pattern1..]\n       (2) REJ TOTAL\n       (3) REJ TOTAL\
FIT\n\nrejects the matching-functions which match matching-function-pattern at the current FIT location. If TOTAL or TOTALFIT is g\
iven, the entire matching conditions in all locations are rejected, then output parameters by CALCULATE are reset when TOTAL is gi\
ven."],
p$2575=1+p$2575[[1,2]];p1$2575=StringPosition["Usage: (1) REJ matching-function-pattern [matching-function-pattern1..]\n       (2)\
 REJ TOTAL\n       (3) REJ TOTALFIT\n\nrejects the matching-functions which match matching-function-pattern at the current FIT loc\
ation. If TOTAL or TOTALFIT is given, the entire matching conditions in all locations are rejected, then output parameters by CALC\
ULATE are reset when TOTAL is given."[p$2575,-1],">::",1];
   p1$2575=If[p1$2575==={},375,-2+p$2575+p1$2575[[1,1]]];
neq=Which["Usage: (1) REJ matching-function-pattern [matching-function-pattern1..]\n       (2) REJ TOTAL\n       (3) REJ TOTALFIT\\
n\nrejects the matching-functions which match matching-function-pattern at the current FIT location. If TOTAL or TOTALFIT is given\
, the entire matching conditions in all locations are rejected, then output parameters by CALCULATE are reset when TOTAL is given."
     [p$2575,4+p$2575]==="Text[",
    lx$2575:=Help2HTML`oa$;p$2575=5+p$2575;p1$2575-=1;p2$2575=5+p1$2575;p0$2575=-9+p$2575;If[(pe$2575=StringPosition["Usage: (1) R\
EJ matching-function-pattern [matching-function-pattern1..]\n       (2) REJ TOTAL\n       (3) REJ TOTALFIT\n\nrejects the matching\
-functions which match matching-function-pattern at the current FIT location. If TOTAL or TOTALFIT is given, the entire matching c\
onditions in all locations are rejected, then output parameters by CALCULATE are reset when TOTAL is given."[p$2575,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Usage: (1) REJ matching-function-pattern [matching-function-pattern1..]\n       (2) REJ TOTAL\n       (3) REJ TOT\
ALFIT\n\nrejects the matching-functions which match matching-function-pattern at the current FIT location. If TOTAL or TOTALFIT is\
 given, the entire matching conditions in all locations are rejected, then output parameters by CALCULATE are reset when TOTAL is \
given."[p$2575+pe$2575[[1,2]],p1$2575]]],
        p1$2575=-2+p$2575+pe$2575[[1,1]]}[[
       1]],
      0],
    1,lx$2575:=Help2HTML`o9$;p2$2575=4+p1$2575;p0$2575=-4+p$2575;0];
  If[(equ$2575=
Help2HTML`o8$["Usage: (1) REJ matching-function-pattern [matching-function-pattern1..]\n       (2) REJ TOTAL\n       (3) REJ TOTAL\
FIT\n\nrejects the matching-functions which match matching-function-pattern at the current FIT location. If TOTAL or TOTALFIT is g\
iven, the entire matching conditions in all locations are rejected, then output parameters by CALCULATE are reset when TOTAL is gi\
ven."[p$2575,p1$2575]])===
    Undefined,
equ$2575="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Usage: (1) REJ matching-function-pattern [ma\
tching-function-pattern1..]\n       (2) REJ TOTAL\n       (3) REJ TOTALFIT\n\nrejects the matching-functions which match matching-\
function-pattern at the current FIT location. If TOTAL or TOTALFIT is given, the entire matching conditions in all locations are r\
ejected, then output parameters by CALCULATE are reset when TOTAL is given."[p$2575,p1$2575]]=
       equ$2575;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2575},out$2575=lx$2575@Typeset["Usage: (1) REJ matching-function-pattern [matching-function-pattern1..]\n       (2) REJ T\
OTAL\n       (3) REJ TOTALFIT\n\nrejects the matching-functions which match matching-function-pattern at the current FIT location.\
 If TOTAL or TOTALFIT is given, the entire matching conditions in all locations are rejected, then output parameters by CALCULATE \
are reset when TOTAL is given."[p$2575,p1$2575],Format->Help2HTML`oB$];
        System["mv -f "//out$2575//" "//equ$2575]];
      Exit[]]];
   "Usage: (1) REJ matching-function-pattern [matching-function-pattern1..]\n       (2) REJ TOTAL\n       (3) REJ TOTALFIT\n\nreje\
cts the matching-functions which match matching-function-pattern at the current FIT location. If TOTAL or TOTALFIT is given, the e\
ntire matching conditions in all locations are rejected, then output parameters by CALCULATE are reset when TOTAL is given."[1,
    Max[p0$2575,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2575//"\" />"//
Help2HTML`oy$["Usage: (1) REJ matching-function-pattern [matching-function-pattern1..]\n       (2) REJ TOTAL\n       (3) REJ TOTAL\
FIT\n\nrejects the matching-functions which match matching-function-pattern at the current FIT location. If TOTAL or TOTALFIT is g\
iven, the entire matching conditions in all locations are rejected, then output parameters by CALCULATE are reset when TOTAL is gi\
ven."[p2$2575,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L473>matching-function-commands</A> <A HREF=#L463>FIT</A> <A HREF=#L562>wildcards</A></PRE>
<H3><A NAME=L492>
RENUMBER(RENUM)</A></H3>
<PRE>If[{},Help2HTML`oA$["RENUM comp renumbers the component number starting from a component comp."],
 p$2578=1+p$2578[[1,2]];p1$2578=
   StringPosition["RENUM comp renumbers the component number starting from a component comp."[p$2578,-1],">::",1];
  p1$2578=If[p1$2578==={},73,-2+p$2578+p1$2578[[1,1]]];
  neq=Which["RENUM comp renumbers the component number starting from a component comp."[p$2578,4+p$2578]==="Text[",
    lx$2578:=Help2HTML`oa$;p$2578=5+p$2578;p1$2578-=1;p2$2578=5+p1$2578;p0$2578=-9+p$2578;
     If[(pe$2578=StringPosition["RENUM comp renumbers the component number starting from a component comp."[p$2578,-2],";;;"])<=>{}
       ,
      {Max[0,
        -1+ToExpression["RENUM comp renumbers the component number starting from a component comp."[p$2578+pe$2578[[1,2]],p1$2578]]
        ],p1$2578=-2+p$2578+pe$2578[[1,1]]}[[
       1]],
      0],
    1,lx$2578:=Help2HTML`o9$;p2$2578=4+p1$2578;p0$2578=-4+p$2578;0];
  If[(equ$2578=Help2HTML`o8$["RENUM comp renumbers the component number starting from a component comp."[p$2578,p1$2578]])===
    Undefined,
   equ$2578="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "RENUM comp renumbers the component number starting from a component comp."[p$2578,p1$2578]]=
       equ$2578;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$2578},out$2578=lx$2578@Typeset["RENUM comp renumbers the component number starting from a component comp."[p$2578,
           p1$2578],Format->Help2HTML`oB$];
        System["mv -f "//out$2578//" "//equ$2578]];
      Exit[]]];
   "RENUM comp renumbers the component number starting from a component comp."[1,Max[p0$2578,0]]//"<img  class=\"eqs\" SRC=\""//
   equ$2578//"\" />"//Help2HTML`oy$["RENUM comp renumbers the component number starting from a component comp."[p2$2578,-1]]
 ]
</PRE>
<PRE>See also:
 <A HREF=#L30>components</A></PRE>
<H3><A NAME=L493>
REPEAT(REP)</A></H3>
<PRE>If[{},
Help2HTML`oA$["Usage: REP [n] body UNTIL [expr1]\n\nexecutes commands in body n times until expr1 gives nonzero. The number n can \
be any expression which gives a number. If n is omitted, infinity is assumed. If expr1 is omitted, False(==0) is assumed."],
 p$2581=1+p$2581[[1,2]];
p1$2581=StringPosition["Usage: REP [n] body UNTIL [expr1]\n\nexecutes commands in body n times until expr1 gives nonzero. The numb\
er n can be any expression which gives a number. If n is omitted, infinity is assumed. If expr1 is omitted, False(==0) is assumed."
    [p$2581,-1],">::",1];
   p1$2581=If[p1$2581==={},234,-2+p$2581+p1$2581[[1,1]]];
neq=Which["Usage: REP [n] body UNTIL [expr1]\n\nexecutes commands in body n times until expr1 gives nonzero. The number n can be a\
ny expression which gives a number. If n is omitted, infinity is assumed. If expr1 is omitted, False(==0) is assumed."[p$2581,
      4+p$2581]===
     "Text[",
lx$2581:=Help2HTML`oa$;p$2581=5+p$2581;p1$2581-=1;p2$2581=5+p1$2581;p0$2581=-9+p$2581;If[(pe$2581=StringPosition["Usage: REP [n] b\
ody UNTIL [expr1]\n\nexecutes commands in body n times until expr1 gives nonzero. The number n can be any expression which gives a\
 number. If n is omitted, infinity is assumed. If expr1 is omitted, False(==0) is assumed."[p$2581,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Usage: REP [n] body UNTIL [expr1]\n\nexecutes commands in body n times until expr1 gives nonzero. The number n ca\
n be any expression which gives a number. If n is omitted, infinity is assumed. If expr1 is omitted, False(==0) is assumed."[p$2581
            +pe$2581[[1,2]],
           p1$2581]]],
        p1$2581=-2+p$2581+pe$2581[[1,1]]}[[
       1]],
      0],
    1,lx$2581:=Help2HTML`o9$;p2$2581=4+p1$2581;p0$2581=-4+p$2581;0];
  If[(equ$2581=
Help2HTML`o8$["Usage: REP [n] body UNTIL [expr1]\n\nexecutes commands in body n times until expr1 gives nonzero. The number n can \
be any expression which gives a number. If n is omitted, infinity is assumed. If expr1 is omitted, False(==0) is assumed."[p$2581,
       p1$2581]])===
    Undefined,
equ$2581="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Usage: REP [n] body UNTIL [expr1]\n\nexecute\
s commands in body n times until expr1 gives nonzero. The number n can be any expression which gives a number. If n is omitted, in\
finity is assumed. If expr1 is omitted, False(==0) is assumed."[p$2581,p1$2581]]=
       equ$2581;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2581},out$2581=lx$2581@Typeset["Usage: REP [n] body UNTIL [expr1]\n\nexecutes commands in body n times until expr1 gives \
nonzero. The number n can be any expression which gives a number. If n is omitted, infinity is assumed. If expr1 is omitted, False\
(==0) is assumed."[p$2581,p1$2581],Format->Help2HTML`oB$];
        System["mv -f "//out$2581//" "//equ$2581]];
      Exit[]]];
   "Usage: REP [n] body UNTIL [expr1]\n\nexecutes commands in body n times until expr1 gives nonzero. The number n can be any expr\
ession which gives a number. If n is omitted, infinity is assumed. If expr1 is omitted, False(==0) is assumed."[1,Max[p0$2581,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2581//"\" />"//
Help2HTML`oy$["Usage: REP [n] body UNTIL [expr1]\n\nexecutes commands in body n times until expr1 gives nonzero. The number n can \
be any expression which gives a number. If n is omitted, infinity is assumed. If expr1 is omitted, False(==0) is assumed."[p2$2581,
     -1]]
]</PRE>
<PRE>See also:
 <A HREF=#L557>UNTIL</A></PRE>
<H3><A NAME=L494>
RESET</A></H3>
<PRE>If[{},
Help2HTML`oA$["Usage: RESET [ALL] [element-pattern]\n\nrestores the value of the elements. What are restored are the value of the \
default keyword of all elements, the values of the non-default keywords which have been changed manually or by the matching. If AL\
L is given, it resets all keywords. If element-pattern is given, reset is limited to the elements which match the pattern."],
 p$2584=1+p$2584[[1,2]];
p1$2584=StringPosition["Usage: RESET [ALL] [element-pattern]\n\nrestores the value of the elements. What are restored are the valu\
e of the default keyword of all elements, the values of the non-default keywords which have been changed manually or by the matchi\
ng. If ALL is given, it resets all keywords. If element-pattern is given, reset is limited to the elements which match the pattern\
."[p$2584,-1],">::",1];
   p1$2584=If[p1$2584==={},365,-2+p$2584+p1$2584[[1,1]]];
neq=Which["Usage: RESET [ALL] [element-pattern]\n\nrestores the value of the elements. What are restored are the value of the defa\
ult keyword of all elements, the values of the non-default keywords which have been changed manually or by the matching. If ALL is\
 given, it resets all keywords. If element-pattern is given, reset is limited to the elements which match the pattern."[p$2584,
      4+p$2584]===
     "Text[",
lx$2584:=Help2HTML`oa$;p$2584=5+p$2584;p1$2584-=1;p2$2584=5+p1$2584;p0$2584=-9+p$2584;If[(pe$2584=StringPosition["Usage: RESET [AL\
L] [element-pattern]\n\nrestores the value of the elements. What are restored are the value of the default keyword of all elements\
, the values of the non-default keywords which have been changed manually or by the matching. If ALL is given, it resets all keywo\
rds. If element-pattern is given, reset is limited to the elements which match the pattern."[p$2584,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Usage: RESET [ALL] [element-pattern]\n\nrestores the value of the elements. What are restored are the value of th\
e default keyword of all elements, the values of the non-default keywords which have been changed manually or by the matching. If \
ALL is given, it resets all keywords. If element-pattern is given, reset is limited to the elements which match the pattern."[p
            $2584+pe$2584[[1,2]],
           p1$2584]]],
        p1$2584=-2+p$2584+pe$2584[[1,1]]}[[
       1]],
      0],
    1,lx$2584:=Help2HTML`o9$;p2$2584=4+p1$2584;p0$2584=-4+p$2584;0];
  If[(equ$2584=
Help2HTML`o8$["Usage: RESET [ALL] [element-pattern]\n\nrestores the value of the elements. What are restored are the value of the \
default keyword of all elements, the values of the non-default keywords which have been changed manually or by the matching. If AL\
L is given, it resets all keywords. If element-pattern is given, reset is limited to the elements which match the pattern."[p$2584,
       p1$2584]])===
    Undefined,
equ$2584="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Usage: RESET [ALL] [element-pattern]\n\nrest\
ores the value of the elements. What are restored are the value of the default keyword of all elements, the values of the non-defa\
ult keywords which have been changed manually or by the matching. If ALL is given, it resets all keywords. If element-pattern is g\
iven, reset is limited to the elements which match the pattern."[p$2584,p1$2584]]=
       equ$2584;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2584},out$2584=lx$2584@Typeset["Usage: RESET [ALL] [element-pattern]\n\nrestores the value of the elements. What are rest\
ored are the value of the default keyword of all elements, the values of the non-default keywords which have been changed manually\
 or by the matching. If ALL is given, it resets all keywords. If element-pattern is given, reset is limited to the elements which \
match the pattern."[p$2584,p1$2584],Format->Help2HTML`oB$];
        System["mv -f "//out$2584//" "//equ$2584]];
      Exit[]]];
   "Usage: RESET [ALL] [element-pattern]\n\nrestores the value of the elements. What are restored are the value of the default key\
word of all elements, the values of the non-default keywords which have been changed manually or by the matching. If ALL is given,\
 it resets all keywords. If element-pattern is given, reset is limited to the elements which match the pattern."[1,Max[p0$2584,0]
    ]//
   "<img  class=\"eqs\" SRC=\""//equ$2584//"\" />"//
Help2HTML`oy$["Usage: RESET [ALL] [element-pattern]\n\nrestores the value of the elements. What are restored are the value of the \
default keyword of all elements, the values of the non-default keywords which have been changed manually or by the matching. If AL\
L is given, it resets all keywords. If element-pattern is given, reset is limited to the elements which match the pattern."[p2$2584
     ,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L548>SAVE</A> <A HREF=#L558>USE</A> <A HREF=#L561>VISIT</A> <A HREF=#L562>wildcards</A> <A HREF=#L488>RECOVER(REC)</A></PRE>
<H3><A NAME=L495>
RESUME(RES)</A></H3>
<PRE>If[{},Help2HTML`oA$["Resumes reading from the previous input stream suspended by SUSPEND(SUSP) or END."],
 p$2587=1+p$2587[[1,2]];
  p1$2587=StringPosition["Resumes reading from the previous input stream suspended by SUSPEND(SUSP) or END."[p$2587,-1],">::",1];
  p1$2587=If[p1$2587==={},81,-2+p$2587+p1$2587[[1,1]]];
  neq=Which["Resumes reading from the previous input stream suspended by SUSPEND(SUSP) or END."[p$2587,4+p$2587]==="Text[",
    lx$2587:=Help2HTML`oa$;p$2587=5+p$2587;p1$2587-=1;p2$2587=5+p1$2587;p0$2587=-9+p$2587;
     If[(pe$2587=StringPosition["Resumes reading from the previous input stream suspended by SUSPEND(SUSP) or END."[p$2587,-2],
         ";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression["Resumes reading from the previous input stream suspended by SUSPEND(SUSP) or END."[p$2587+pe$2587[[1,2]],
           p1$2587]]],
        p1$2587=-2+p$2587+pe$2587[[1,1]]}[[
       1]],
      0],
    1,lx$2587:=Help2HTML`o9$;p2$2587=4+p1$2587;p0$2587=-4+p$2587;0];
  If[(equ$2587=Help2HTML`o8$["Resumes reading from the previous input stream suspended by SUSPEND(SUSP) or END."[p$2587,p1$2587]]
     )===
    Undefined,
   equ$2587="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "Resumes reading from the previous input stream suspended by SUSPEND(SUSP) or END."[p$2587,p1$2587]]=
       equ$2587;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$2587},out$2587=lx$2587@Typeset["Resumes reading from the previous input stream suspended by SUSPEND(SUSP) or END."[
           p$2587,p1$2587],Format->Help2HTML`oB$];
        System["mv -f "//out$2587//" "//equ$2587]];
      Exit[]]];
   "Resumes reading from the previous input stream suspended by SUSPEND(SUSP) or END."[1,Max[p0$2587,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2587//"\" />"//
   Help2HTML`oy$["Resumes reading from the previous input stream suspended by SUSPEND(SUSP) or END."[p2$2587,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L554>SUSPEND(SUSP)</A> <A HREF=#L296>END</A></PRE>
<H3><A NAME=L496>
REVERSE(REV)</A></H3>
<PRE>If[{},Help2HTML`oA$["REV changes the sign of AX, AY, EPX, EPY, R2, R3, DPX, DPY at the\nentrance of the beam line."],
 p$2590=1+p$2590[[1,2]];
  p1$2590=StringPosition["REV changes the sign of AX, AY, EPX, EPY, R2, R3, DPX, DPY at the\nentrance of the beam line."[p$2590,-1
     ],
    ">::",1];
   p1$2590=If[p1$2590==={},92,-2+p$2590+p1$2590[[1,1]]];
  neq=Which["REV changes the sign of AX, AY, EPX, EPY, R2, R3, DPX, DPY at the\nentrance of the beam line."[p$2590,4+p$2590]===
     "Text[",
    lx$2590:=Help2HTML`oa$;p$2590=5+p$2590;p1$2590-=1;p2$2590=5+p1$2590;p0$2590=-9+p$2590;If[(pe$2590=StringPosition[
         "REV changes the sign of AX, AY, EPX, EPY, R2, R3, DPX, DPY at the\nentrance of the beam line."[p$2590,-2],";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression["REV changes the sign of AX, AY, EPX, EPY, R2, R3, DPX, DPY at the\nentrance of the beam line."[p$2590+
            pe$2590[[1,2]],
           p1$2590]]],
        p1$2590=-2+p$2590+pe$2590[[1,1]]}[[
       1]],
      0],
    1,lx$2590:=Help2HTML`o9$;p2$2590=4+p1$2590;p0$2590=-4+p$2590;0];
  If[(equ$2590=
     Help2HTML`o8$["REV changes the sign of AX, AY, EPX, EPY, R2, R3, DPX, DPY at the\nentrance of the beam line."[p$2590,p1$2590]]
     )===
    Undefined,
   equ$2590="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "REV changes the sign of AX, AY, EPX, EPY, R2, R3, DPX, DPY at the\nentrance of the beam line."[p$2590,p1$2590]]=
       equ$2590;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$2590},out$2590=lx$2590@Typeset[
          "REV changes the sign of AX, AY, EPX, EPY, R2, R3, DPX, DPY at the\nentrance of the beam line."[p$2590,p1$2590],
          Format->Help2HTML`oB$];
        System["mv -f "//out$2590//" "//equ$2590]];
      Exit[]]];
   "REV changes the sign of AX, AY, EPX, EPY, R2, R3, DPX, DPY at the\nentrance of the beam line."[1,Max[p0$2590,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2590//"\" />"//
   Help2HTML`oy$["REV changes the sign of AX, AY, EPX, EPY, R2, R3, DPX, DPY at the\nentrance of the beam line."[p2$2590,-1]]
 ]
</PRE>
<PRE>See also:
 <A HREF=#L473>matching-function-commands</A></PRE>
<H3><A NAME=L497>
set-value-of-element</A></H3>
<PRE>If[{},
Help2HTML`oA$["Usage: element-pattern [keyword] [{MIN | MAX | MINMAX | MAXMIN}] value\n\nsets value to the specified keyword of th\
e elements which match element-pattern. If keyword is omitted, the default-keyword is assumed. keyword can be a wildcard to apply \
all matching keywords.\n   If MIN, MAX, MINMAX, MAXMIN are specified, it sets the limit of the default-keyword. Both MINMAX and MA\
XMIN means MIN=-Abs[value] and MAX=+Abs[value].\n   If the keyword is not the default-keyword, it affects both the current and the\
 saved value."],
p$2593=1+p$2593[[1,2]];p1$2593=StringPosition["Usage: element-pattern [keyword] [{MIN | MAX | MINMAX | MAXMIN}] value\n\nsets valu\
e to the specified keyword of the elements which match element-pattern. If keyword is omitted, the default-keyword is assumed. key\
word can be a wildcard to apply all matching keywords.\n   If MIN, MAX, MINMAX, MAXMIN are specified, it sets the limit of the def\
ault-keyword. Both MINMAX and MAXMIN means MIN=-Abs[value] and MAX=+Abs[value].\n   If the keyword is not the default-keyword, it \
affects both the current and the saved value."[p$2593,-1],">::",1];
   p1$2593=If[p1$2593==={},514,-2+p$2593+p1$2593[[1,1]]];
neq=Which["Usage: element-pattern [keyword] [{MIN | MAX | MINMAX | MAXMIN}] value\n\nsets value to the specified keyword of the el\
ements which match element-pattern. If keyword is omitted, the default-keyword is assumed. keyword can be a wildcard to apply all \
matching keywords.\n   If MIN, MAX, MINMAX, MAXMIN are specified, it sets the limit of the default-keyword. Both MINMAX and MAXMIN\
 means MIN=-Abs[value] and MAX=+Abs[value].\n   If the keyword is not the default-keyword, it affects both the current and the sav\
ed value."[p$2593,4+p$2593]==="Text[",
    lx$2593:=Help2HTML`oa$;p$2593=5+p$2593;p1$2593-=1;p2$2593=5+p1$2593;p0$2593=-9+p$2593;If[(pe$2593=
StringPosition["Usage: element-pattern [keyword] [{MIN | MAX | MINMAX | MAXMIN}] value\n\nsets value to the specified keyword of t\
he elements which match element-pattern. If keyword is omitted, the default-keyword is assumed. keyword can be a wildcard to apply\
 all matching keywords.\n   If MIN, MAX, MINMAX, MAXMIN are specified, it sets the limit of the default-keyword. Both MINMAX and M\
AXMIN means MIN=-Abs[value] and MAX=+Abs[value].\n   If the keyword is not the default-keyword, it affects both the current and th\
e saved value."[p$2593,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Usage: element-pattern [keyword] [{MIN | MAX | MINMAX | MAXMIN}] value\n\nsets value to the specified keyword of \
the elements which match element-pattern. If keyword is omitted, the default-keyword is assumed. keyword can be a wildcard to appl\
y all matching keywords.\n   If MIN, MAX, MINMAX, MAXMIN are specified, it sets the limit of the default-keyword. Both MINMAX and \
MAXMIN means MIN=-Abs[value] and MAX=+Abs[value].\n   If the keyword is not the default-keyword, it affects both the current and t\
he saved value."[p$2593+pe$2593[[1,2]],p1$2593]]],
        p1$2593=-2+p$2593+pe$2593[[1,1]]}[[
       1]],
      0],
    1,lx$2593:=Help2HTML`o9$;p2$2593=4+p1$2593;p0$2593=-4+p$2593;0];
  If[(equ$2593=
Help2HTML`o8$["Usage: element-pattern [keyword] [{MIN | MAX | MINMAX | MAXMIN}] value\n\nsets value to the specified keyword of th\
e elements which match element-pattern. If keyword is omitted, the default-keyword is assumed. keyword can be a wildcard to apply \
all matching keywords.\n   If MIN, MAX, MINMAX, MAXMIN are specified, it sets the limit of the default-keyword. Both MINMAX and MA\
XMIN means MIN=-Abs[value] and MAX=+Abs[value].\n   If the keyword is not the default-keyword, it affects both the current and the\
 saved value."[p$2593,p1$2593]])===
    Undefined,
equ$2593="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Usage: element-pattern [keyword] [{MIN | MAX\
 | MINMAX | MAXMIN}] value\n\nsets value to the specified keyword of the elements which match element-pattern. If keyword is omitt\
ed, the default-keyword is assumed. keyword can be a wildcard to apply all matching keywords.\n   If MIN, MAX, MINMAX, MAXMIN are \
specified, it sets the limit of the default-keyword. Both MINMAX and MAXMIN means MIN=-Abs[value] and MAX=+Abs[value].\n   If the \
keyword is not the default-keyword, it affects both the current and the saved value."[p$2593,p1$2593]]=
       equ$2593;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2593},out$2593=lx$2593@Typeset["Usage: element-pattern [keyword] [{MIN | MAX | MINMAX | MAXMIN}] value\n\nsets value to t\
he specified keyword of the elements which match element-pattern. If keyword is omitted, the default-keyword is assumed. keyword c\
an be a wildcard to apply all matching keywords.\n   If MIN, MAX, MINMAX, MAXMIN are specified, it sets the limit of the default-k\
eyword. Both MINMAX and MAXMIN means MIN=-Abs[value] and MAX=+Abs[value].\n   If the keyword is not the default-keyword, it affect\
s both the current and the saved value."[p$2593,p1$2593],Format->Help2HTML`oB$];
        System["mv -f "//out$2593//" "//equ$2593]];
      Exit[]]];
   "Usage: element-pattern [keyword] [{MIN | MAX | MINMAX | MAXMIN}] value\n\nsets value to the specified keyword of the elements \
which match element-pattern. If keyword is omitted, the default-keyword is assumed. keyword can be a wildcard to apply all matchin\
g keywords.\n   If MIN, MAX, MINMAX, MAXMIN are specified, it sets the limit of the default-keyword. Both MINMAX and MAXMIN means \
MIN=-Abs[value] and MAX=+Abs[value].\n   If the keyword is not the default-keyword, it affects both the current and the saved valu\
e."[1,Max[p0$2593,0]]//"<img  class=\"eqs\" SRC=\""//equ$2593//"\" />"//
Help2HTML`oy$["Usage: element-pattern [keyword] [{MIN | MAX | MINMAX | MAXMIN}] value\n\nsets value to the specified keyword of th\
e elements which match element-pattern. If keyword is omitted, the default-keyword is assumed. keyword can be a wildcard to apply \
all matching keywords.\n   If MIN, MAX, MINMAX, MAXMIN are specified, it sets the limit of the default-keyword. Both MINMAX and MA\
XMIN means MIN=-Abs[value] and MAX=+Abs[value].\n   If the keyword is not the default-keyword, it affects both the current and the\
 saved value."[p2$2593,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L4>ATTRIBUTE(ATTR)</A> <A HREF=#L548>SAVE</A> <A HREF=#L75>elements</A> <A HREF=#L113>default-keyword</A> <A HREF=#L562>wildcards</A> <A HREF=#L387>Element</A></PRE>
<UL>
<LI>
<H3><A NAME=L498>
keywords</A></H3>
<PRE>If[{},
Help2HTML`oA$["Available keywords are:\t\n\ntype    keywords\nDRIFT   L RADIUS\nBEND    L ROTATE DROTATE DX DY ANGLE K0 K1 E1 E2 A\
E1 AE2 F1 FB1 FB2 FRINGE DISFRIN DISRAD EPS RANKICK\nQUAD    L ROTATE DX DY K1 F1 F2 FRINGE DISFRIN DISRAD EPS\nSEXT    L ROTATE D\
X DY K2 DISFRIN DISRAD\nOCT     L ROTATE DX DY K3 DISFRIN DISRAD\nDECA    L ROTATE DX DY K4 DISFRIN DISRAD\nDODECA  L ROTATE DX DY\
 K5 DISFRIN DISRAD\nMULT    L DX DY DZ CHI1 CHI2 ROTATE(=CHI3) K0..K21 SK0..SK21 DISFRIN F1 F2 FRINGE DISRAD EPS VOLT DVOLT HARM P\
HI DPHI FREQ RADIUS ANGLE E1 E2 AE1 AE2 DROTATE\nSOL     BZ DX DY DZ DPX DPY BOUND GEO CHI1 CHI2 CHI3 DBZ DISFRIN\nCAVI    L ROTAT\
E DX DY VOLT DVOLT V1 V20 V11 V02 FREQ PHI HARM RANVOLT RANPHASE DISFRIN FRINGE\nTCAVI   L ROTATE DX DY K0 V1 FREQ PHI HARM RANKIC\
K RANPHASE\nCOORD   DX DY CHI1 CHI2 CHI3 DIR\nMARK    AX BX AY BY EX EPX EY EPY R1 R2 R3 R4 DETR DX DPX DY DPY DZ DDP AZ BZ NZ ZX \
ZPX ZY ZPY EMITX EMITY DP AZ SIGZ GEO OFFSET\nAPERT   DX1 DX2 DY1 DY2 DP AX AY DX DY"],
 p$2596=1+p$2596[[1,2]];p1$2596=StringPosition["Available keywords are:\t\n\ntype    keywords\nDRIFT   L RADIUS\nBEND    L ROTATE \
DROTATE DX DY ANGLE K0 K1 E1 E2 AE1 AE2 F1 FB1 FB2 FRINGE DISFRIN DISRAD EPS RANKICK\nQUAD    L ROTATE DX DY K1 F1 F2 FRINGE DISFR\
IN DISRAD EPS\nSEXT    L ROTATE DX DY K2 DISFRIN DISRAD\nOCT     L ROTATE DX DY K3 DISFRIN DISRAD\nDECA    L ROTATE DX DY K4 DISFR\
IN DISRAD\nDODECA  L ROTATE DX DY K5 DISFRIN DISRAD\nMULT    L DX DY DZ CHI1 CHI2 ROTATE(=CHI3) K0..K21 SK0..SK21 DISFRIN F1 F2 FR\
INGE DISRAD EPS VOLT DVOLT HARM PHI DPHI FREQ RADIUS ANGLE E1 E2 AE1 AE2 DROTATE\nSOL     BZ DX DY DZ DPX DPY BOUND GEO CHI1 CHI2 \
CHI3 DBZ DISFRIN\nCAVI    L ROTATE DX DY VOLT DVOLT V1 V20 V11 V02 FREQ PHI HARM RANVOLT RANPHASE DISFRIN FRINGE\nTCAVI   L ROTATE\
 DX DY K0 V1 FREQ PHI HARM RANKICK RANPHASE\nCOORD   DX DY CHI1 CHI2 CHI3 DIR\nMARK    AX BX AY BY EX EPX EY EPY R1 R2 R3 R4 DETR \
DX DPX DY DPY DZ DDP AZ BZ NZ ZX ZPX ZY ZPY EMITX EMITY DP AZ SIGZ GEO OFFSET\nAPERT   DX1 DX2 DY1 DY2 DP AX AY DX DY"[p$2596,-1],
    ">::",1];
   p1$2596=If[p1$2596==={},962,-2+p$2596+p1$2596[[1,1]]];
neq=Which["Available keywords are:\t\n\ntype    keywords\nDRIFT   L RADIUS\nBEND    L ROTATE DROTATE DX DY ANGLE K0 K1 E1 E2 AE1 A\
E2 F1 FB1 FB2 FRINGE DISFRIN DISRAD EPS RANKICK\nQUAD    L ROTATE DX DY K1 F1 F2 FRINGE DISFRIN DISRAD EPS\nSEXT    L ROTATE DX DY\
 K2 DISFRIN DISRAD\nOCT     L ROTATE DX DY K3 DISFRIN DISRAD\nDECA    L ROTATE DX DY K4 DISFRIN DISRAD\nDODECA  L ROTATE DX DY K5 \
DISFRIN DISRAD\nMULT    L DX DY DZ CHI1 CHI2 ROTATE(=CHI3) K0..K21 SK0..SK21 DISFRIN F1 F2 FRINGE DISRAD EPS VOLT DVOLT HARM PHI D\
PHI FREQ RADIUS ANGLE E1 E2 AE1 AE2 DROTATE\nSOL     BZ DX DY DZ DPX DPY BOUND GEO CHI1 CHI2 CHI3 DBZ DISFRIN\nCAVI    L ROTATE DX\
 DY VOLT DVOLT V1 V20 V11 V02 FREQ PHI HARM RANVOLT RANPHASE DISFRIN FRINGE\nTCAVI   L ROTATE DX DY K0 V1 FREQ PHI HARM RANKICK RA\
NPHASE\nCOORD   DX DY CHI1 CHI2 CHI3 DIR\nMARK    AX BX AY BY EX EPX EY EPY R1 R2 R3 R4 DETR DX DPX DY DPY DZ DDP AZ BZ NZ ZX ZPX \
ZY ZPY EMITX EMITY DP AZ SIGZ GEO OFFSET\nAPERT   DX1 DX2 DY1 DY2 DP AX AY DX DY"[p$2596,4+p$2596]==="Text[",
    lx$2596:=Help2HTML`oa$;p$2596=5+p$2596;p1$2596-=1;p2$2596=5+p1$2596;p0$2596=-9+p$2596;
If[(pe$2596=StringPosition["Available keywords are:\t\n\ntype    keywords\nDRIFT   L RADIUS\nBEND    L ROTATE DROTATE DX DY ANGLE \
K0 K1 E1 E2 AE1 AE2 F1 FB1 FB2 FRINGE DISFRIN DISRAD EPS RANKICK\nQUAD    L ROTATE DX DY K1 F1 F2 FRINGE DISFRIN DISRAD EPS\nSEXT \
   L ROTATE DX DY K2 DISFRIN DISRAD\nOCT     L ROTATE DX DY K3 DISFRIN DISRAD\nDECA    L ROTATE DX DY K4 DISFRIN DISRAD\nDODECA  L\
 ROTATE DX DY K5 DISFRIN DISRAD\nMULT    L DX DY DZ CHI1 CHI2 ROTATE(=CHI3) K0..K21 SK0..SK21 DISFRIN F1 F2 FRINGE DISRAD EPS VOLT\
 DVOLT HARM PHI DPHI FREQ RADIUS ANGLE E1 E2 AE1 AE2 DROTATE\nSOL     BZ DX DY DZ DPX DPY BOUND GEO CHI1 CHI2 CHI3 DBZ DISFRIN\nCA\
VI    L ROTATE DX DY VOLT DVOLT V1 V20 V11 V02 FREQ PHI HARM RANVOLT RANPHASE DISFRIN FRINGE\nTCAVI   L ROTATE DX DY K0 V1 FREQ PH\
I HARM RANKICK RANPHASE\nCOORD   DX DY CHI1 CHI2 CHI3 DIR\nMARK    AX BX AY BY EX EPX EY EPY R1 R2 R3 R4 DETR DX DPX DY DPY DZ DDP\
 AZ BZ NZ ZX ZPX ZY ZPY EMITX EMITY DP AZ SIGZ GEO OFFSET\nAPERT   DX1 DX2 DY1 DY2 DP AX AY DX DY"[p$2596,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Available keywords are:\t\n\ntype    keywords\nDRIFT   L RADIUS\nBEND    L ROTATE DROTATE DX DY ANGLE K0 K1 E1 E2\
 AE1 AE2 F1 FB1 FB2 FRINGE DISFRIN DISRAD EPS RANKICK\nQUAD    L ROTATE DX DY K1 F1 F2 FRINGE DISFRIN DISRAD EPS\nSEXT    L ROTATE\
 DX DY K2 DISFRIN DISRAD\nOCT     L ROTATE DX DY K3 DISFRIN DISRAD\nDECA    L ROTATE DX DY K4 DISFRIN DISRAD\nDODECA  L ROTATE DX \
DY K5 DISFRIN DISRAD\nMULT    L DX DY DZ CHI1 CHI2 ROTATE(=CHI3) K0..K21 SK0..SK21 DISFRIN F1 F2 FRINGE DISRAD EPS VOLT DVOLT HARM\
 PHI DPHI FREQ RADIUS ANGLE E1 E2 AE1 AE2 DROTATE\nSOL     BZ DX DY DZ DPX DPY BOUND GEO CHI1 CHI2 CHI3 DBZ DISFRIN\nCAVI    L ROT\
ATE DX DY VOLT DVOLT V1 V20 V11 V02 FREQ PHI HARM RANVOLT RANPHASE DISFRIN FRINGE\nTCAVI   L ROTATE DX DY K0 V1 FREQ PHI HARM RANK\
ICK RANPHASE\nCOORD   DX DY CHI1 CHI2 CHI3 DIR\nMARK    AX BX AY BY EX EPX EY EPY R1 R2 R3 R4 DETR DX DPX DY DPY DZ DDP AZ BZ NZ Z\
X ZPX ZY ZPY EMITX EMITY DP AZ SIGZ GEO OFFSET\nAPERT   DX1 DX2 DY1 DY2 DP AX AY DX DY"[p$2596+pe$2596[[1,2]],p1$2596]]],
        p1$2596=-2+p$2596+pe$2596[[1,1]]}[[
       1]],
      0],
    1,lx$2596:=Help2HTML`o9$;p2$2596=4+p1$2596;p0$2596=-4+p$2596;0];
  If[(equ$2596=
Help2HTML`o8$["Available keywords are:\t\n\ntype    keywords\nDRIFT   L RADIUS\nBEND    L ROTATE DROTATE DX DY ANGLE K0 K1 E1 E2 A\
E1 AE2 F1 FB1 FB2 FRINGE DISFRIN DISRAD EPS RANKICK\nQUAD    L ROTATE DX DY K1 F1 F2 FRINGE DISFRIN DISRAD EPS\nSEXT    L ROTATE D\
X DY K2 DISFRIN DISRAD\nOCT     L ROTATE DX DY K3 DISFRIN DISRAD\nDECA    L ROTATE DX DY K4 DISFRIN DISRAD\nDODECA  L ROTATE DX DY\
 K5 DISFRIN DISRAD\nMULT    L DX DY DZ CHI1 CHI2 ROTATE(=CHI3) K0..K21 SK0..SK21 DISFRIN F1 F2 FRINGE DISRAD EPS VOLT DVOLT HARM P\
HI DPHI FREQ RADIUS ANGLE E1 E2 AE1 AE2 DROTATE\nSOL     BZ DX DY DZ DPX DPY BOUND GEO CHI1 CHI2 CHI3 DBZ DISFRIN\nCAVI    L ROTAT\
E DX DY VOLT DVOLT V1 V20 V11 V02 FREQ PHI HARM RANVOLT RANPHASE DISFRIN FRINGE\nTCAVI   L ROTATE DX DY K0 V1 FREQ PHI HARM RANKIC\
K RANPHASE\nCOORD   DX DY CHI1 CHI2 CHI3 DIR\nMARK    AX BX AY BY EX EPX EY EPY R1 R2 R3 R4 DETR DX DPX DY DPY DZ DDP AZ BZ NZ ZX \
ZPX ZY ZPY EMITX EMITY DP AZ SIGZ GEO OFFSET\nAPERT   DX1 DX2 DY1 DY2 DP AX AY DX DY"[p$2596,p1$2596]])===
    Undefined,
equ$2596="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Available keywords are:\t\n\ntype    keyword\
s\nDRIFT   L RADIUS\nBEND    L ROTATE DROTATE DX DY ANGLE K0 K1 E1 E2 AE1 AE2 F1 FB1 FB2 FRINGE DISFRIN DISRAD EPS RANKICK\nQUAD  \
  L ROTATE DX DY K1 F1 F2 FRINGE DISFRIN DISRAD EPS\nSEXT    L ROTATE DX DY K2 DISFRIN DISRAD\nOCT     L ROTATE DX DY K3 DISFRIN D\
ISRAD\nDECA    L ROTATE DX DY K4 DISFRIN DISRAD\nDODECA  L ROTATE DX DY K5 DISFRIN DISRAD\nMULT    L DX DY DZ CHI1 CHI2 ROTATE(=CH\
I3) K0..K21 SK0..SK21 DISFRIN F1 F2 FRINGE DISRAD EPS VOLT DVOLT HARM PHI DPHI FREQ RADIUS ANGLE E1 E2 AE1 AE2 DROTATE\nSOL     BZ\
 DX DY DZ DPX DPY BOUND GEO CHI1 CHI2 CHI3 DBZ DISFRIN\nCAVI    L ROTATE DX DY VOLT DVOLT V1 V20 V11 V02 FREQ PHI HARM RANVOLT RAN\
PHASE DISFRIN FRINGE\nTCAVI   L ROTATE DX DY K0 V1 FREQ PHI HARM RANKICK RANPHASE\nCOORD   DX DY CHI1 CHI2 CHI3 DIR\nMARK    AX BX\
 AY BY EX EPX EY EPY R1 R2 R3 R4 DETR DX DPX DY DPY DZ DDP AZ BZ NZ ZX ZPX ZY ZPY EMITX EMITY DP AZ SIGZ GEO OFFSET\nAPERT   DX1 D\
X2 DY1 DY2 DP AX AY DX DY"[p$2596,p1$2596]]=
       equ$2596;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2596},out$2596=lx$2596@Typeset["Available keywords are:\t\n\ntype    keywords\nDRIFT   L RADIUS\nBEND    L ROTATE DROTATE\
 DX DY ANGLE K0 K1 E1 E2 AE1 AE2 F1 FB1 FB2 FRINGE DISFRIN DISRAD EPS RANKICK\nQUAD    L ROTATE DX DY K1 F1 F2 FRINGE DISFRIN DISR\
AD EPS\nSEXT    L ROTATE DX DY K2 DISFRIN DISRAD\nOCT     L ROTATE DX DY K3 DISFRIN DISRAD\nDECA    L ROTATE DX DY K4 DISFRIN DISR\
AD\nDODECA  L ROTATE DX DY K5 DISFRIN DISRAD\nMULT    L DX DY DZ CHI1 CHI2 ROTATE(=CHI3) K0..K21 SK0..SK21 DISFRIN F1 F2 FRINGE DI\
SRAD EPS VOLT DVOLT HARM PHI DPHI FREQ RADIUS ANGLE E1 E2 AE1 AE2 DROTATE\nSOL     BZ DX DY DZ DPX DPY BOUND GEO CHI1 CHI2 CHI3 DB\
Z DISFRIN\nCAVI    L ROTATE DX DY VOLT DVOLT V1 V20 V11 V02 FREQ PHI HARM RANVOLT RANPHASE DISFRIN FRINGE\nTCAVI   L ROTATE DX DY \
K0 V1 FREQ PHI HARM RANKICK RANPHASE\nCOORD   DX DY CHI1 CHI2 CHI3 DIR\nMARK    AX BX AY BY EX EPX EY EPY R1 R2 R3 R4 DETR DX DPX \
DY DPY DZ DDP AZ BZ NZ ZX ZPX ZY ZPY EMITX EMITY DP AZ SIGZ GEO OFFSET\nAPERT   DX1 DX2 DY1 DY2 DP AX AY DX DY"[p$2596,p1$2596],
          Format->Help2HTML`oB$];
        System["mv -f "//out$2596//" "//equ$2596]];
      Exit[]]];
   "Available keywords are:\t\n\ntype    keywords\nDRIFT   L RADIUS\nBEND    L ROTATE DROTATE DX DY ANGLE K0 K1 E1 E2 AE1 AE2 F1 F\
B1 FB2 FRINGE DISFRIN DISRAD EPS RANKICK\nQUAD    L ROTATE DX DY K1 F1 F2 FRINGE DISFRIN DISRAD EPS\nSEXT    L ROTATE DX DY K2 DIS\
FRIN DISRAD\nOCT     L ROTATE DX DY K3 DISFRIN DISRAD\nDECA    L ROTATE DX DY K4 DISFRIN DISRAD\nDODECA  L ROTATE DX DY K5 DISFRIN\
 DISRAD\nMULT    L DX DY DZ CHI1 CHI2 ROTATE(=CHI3) K0..K21 SK0..SK21 DISFRIN F1 F2 FRINGE DISRAD EPS VOLT DVOLT HARM PHI DPHI FRE\
Q RADIUS ANGLE E1 E2 AE1 AE2 DROTATE\nSOL     BZ DX DY DZ DPX DPY BOUND GEO CHI1 CHI2 CHI3 DBZ DISFRIN\nCAVI    L ROTATE DX DY VOL\
T DVOLT V1 V20 V11 V02 FREQ PHI HARM RANVOLT RANPHASE DISFRIN FRINGE\nTCAVI   L ROTATE DX DY K0 V1 FREQ PHI HARM RANKICK RANPHASE\\
nCOORD   DX DY CHI1 CHI2 CHI3 DIR\nMARK    AX BX AY BY EX EPX EY EPY R1 R2 R3 R4 DETR DX DPX DY DPY DZ DDP AZ BZ NZ ZX ZPX ZY ZPY \
EMITX EMITY DP AZ SIGZ GEO OFFSET\nAPERT   DX1 DX2 DY1 DY2 DP AX AY DX DY"[1,Max[p0$2596,0]]//"<img  class=\"eqs\" SRC=\""//
   equ$2596//"\" />"//
Help2HTML`oy$["Available keywords are:\t\n\ntype    keywords\nDRIFT   L RADIUS\nBEND    L ROTATE DROTATE DX DY ANGLE K0 K1 E1 E2 A\
E1 AE2 F1 FB1 FB2 FRINGE DISFRIN DISRAD EPS RANKICK\nQUAD    L ROTATE DX DY K1 F1 F2 FRINGE DISFRIN DISRAD EPS\nSEXT    L ROTATE D\
X DY K2 DISFRIN DISRAD\nOCT     L ROTATE DX DY K3 DISFRIN DISRAD\nDECA    L ROTATE DX DY K4 DISFRIN DISRAD\nDODECA  L ROTATE DX DY\
 K5 DISFRIN DISRAD\nMULT    L DX DY DZ CHI1 CHI2 ROTATE(=CHI3) K0..K21 SK0..SK21 DISFRIN F1 F2 FRINGE DISRAD EPS VOLT DVOLT HARM P\
HI DPHI FREQ RADIUS ANGLE E1 E2 AE1 AE2 DROTATE\nSOL     BZ DX DY DZ DPX DPY BOUND GEO CHI1 CHI2 CHI3 DBZ DISFRIN\nCAVI    L ROTAT\
E DX DY VOLT DVOLT V1 V20 V11 V02 FREQ PHI HARM RANVOLT RANPHASE DISFRIN FRINGE\nTCAVI   L ROTATE DX DY K0 V1 FREQ PHI HARM RANKIC\
K RANPHASE\nCOORD   DX DY CHI1 CHI2 CHI3 DIR\nMARK    AX BX AY BY EX EPX EY EPY R1 R2 R3 R4 DETR DX DPX DY DPY DZ DDP AZ BZ NZ ZX \
ZPX ZY ZPY EMITX EMITY DP AZ SIGZ GEO OFFSET\nAPERT   DX1 DX2 DY1 DY2 DP AX AY DX DY"[p2$2596,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L113>default-keyword</A> <A HREF=#L497>set-value-of-element</A> <A HREF=#L387>Element</A></PRE>
<LI>
<H3><A NAME=L499>
default-keyword</A></H3>
<PRE>If[{},
Help2HTML`oA$["The default and available non-default variable keywords are:\n\ntype    default-keyword  non-default variable keywo\
rd\nDRIFT   L                -\nBEND    ANGLE            K1,K0,E1,E2\nQUAD    K1               ROTATE\nSEXT    K2               RO\
TATE\nOCT     K3               ROTATE\nDECA    K4               ROTATE\nDODECA  K5               ROTATE\nMULT    K1               \
K0,K2..K21,SK0,SK1,SK2..SK21,ROTATE,ANGLE\nMARK    -                AX,BX,EX,EPX,AY,BY,EY,EPY,R1,R2,R3,R4,DETR,\n                 \
        DX,DPX,DY,DPY,DZ,DDP,AZ,BZ,ZX,ZPX,ZY,ZPY"],
p$2599=1+p$2599[[1,2]];p1$2599=StringPosition["The default and available non-default variable keywords are:\n\ntype    default-key\
word  non-default variable keyword\nDRIFT   L                -\nBEND    ANGLE            K1,K0,E1,E2\nQUAD    K1               ROT\
ATE\nSEXT    K2               ROTATE\nOCT     K3               ROTATE\nDECA    K4               ROTATE\nDODECA  K5               R\
OTATE\nMULT    K1               K0,K2..K21,SK0,SK1,SK2..SK21,ROTATE,ANGLE\nMARK    -                AX,BX,EX,EPX,AY,BY,EY,EPY,R1,R\
2,R3,R4,DETR,\n                         DX,DPX,DY,DPY,DZ,DDP,AZ,BZ,ZX,ZPX,ZY,ZPY"[p$2599,-1],">::",1];
   p1$2599=If[p1$2599==={},541,-2+p$2599+p1$2599[[1,1]]];
neq=Which["The default and available non-default variable keywords are:\n\ntype    default-keyword  non-default variable keyword\n\
DRIFT   L                -\nBEND    ANGLE            K1,K0,E1,E2\nQUAD    K1               ROTATE\nSEXT    K2               ROTATE\
\nOCT     K3               ROTATE\nDECA    K4               ROTATE\nDODECA  K5               ROTATE\nMULT    K1               K0,K\
2..K21,SK0,SK1,SK2..SK21,ROTATE,ANGLE\nMARK    -                AX,BX,EX,EPX,AY,BY,EY,EPY,R1,R2,R3,R4,DETR,\n                     \
    DX,DPX,DY,DPY,DZ,DDP,AZ,BZ,ZX,ZPX,ZY,ZPY"[p$2599,4+p$2599]==="Text[",
    lx$2599:=Help2HTML`oa$;p$2599=5+p$2599;p1$2599-=1;p2$2599=5+p1$2599;p0$2599=-9+p$2599;
If[(pe$2599=StringPosition["The default and available non-default variable keywords are:\n\ntype    default-keyword  non-default v\
ariable keyword\nDRIFT   L                -\nBEND    ANGLE            K1,K0,E1,E2\nQUAD    K1               ROTATE\nSEXT    K2    \
           ROTATE\nOCT     K3               ROTATE\nDECA    K4               ROTATE\nDODECA  K5               ROTATE\nMULT    K1  \
             K0,K2..K21,SK0,SK1,SK2..SK21,ROTATE,ANGLE\nMARK    -                AX,BX,EX,EPX,AY,BY,EY,EPY,R1,R2,R3,R4,DETR,\n    \
                     DX,DPX,DY,DPY,DZ,DDP,AZ,BZ,ZX,ZPX,ZY,ZPY"[p$2599,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["The default and available non-default variable keywords are:\n\ntype    default-keyword  non-default variable key\
word\nDRIFT   L                -\nBEND    ANGLE            K1,K0,E1,E2\nQUAD    K1               ROTATE\nSEXT    K2               \
ROTATE\nOCT     K3               ROTATE\nDECA    K4               ROTATE\nDODECA  K5               ROTATE\nMULT    K1             \
  K0,K2..K21,SK0,SK1,SK2..SK21,ROTATE,ANGLE\nMARK    -                AX,BX,EX,EPX,AY,BY,EY,EPY,R1,R2,R3,R4,DETR,\n               \
          DX,DPX,DY,DPY,DZ,DDP,AZ,BZ,ZX,ZPX,ZY,ZPY"[p$2599+pe$2599[[1,2]],p1$2599]]],
        p1$2599=-2+p$2599+pe$2599[[1,1]]}[[
       1]],
      0],
    1,lx$2599:=Help2HTML`o9$;p2$2599=4+p1$2599;p0$2599=-4+p$2599;0];
  If[(equ$2599=
Help2HTML`o8$["The default and available non-default variable keywords are:\n\ntype    default-keyword  non-default variable keywo\
rd\nDRIFT   L                -\nBEND    ANGLE            K1,K0,E1,E2\nQUAD    K1               ROTATE\nSEXT    K2               RO\
TATE\nOCT     K3               ROTATE\nDECA    K4               ROTATE\nDODECA  K5               ROTATE\nMULT    K1               \
K0,K2..K21,SK0,SK1,SK2..SK21,ROTATE,ANGLE\nMARK    -                AX,BX,EX,EPX,AY,BY,EY,EPY,R1,R2,R3,R4,DETR,\n                 \
        DX,DPX,DY,DPY,DZ,DDP,AZ,BZ,ZX,ZPX,ZY,ZPY"[p$2599,p1$2599]])===
    Undefined,
equ$2599="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["The default and available non-default variab\
le keywords are:\n\ntype    default-keyword  non-default variable keyword\nDRIFT   L                -\nBEND    ANGLE            K1\
,K0,E1,E2\nQUAD    K1               ROTATE\nSEXT    K2               ROTATE\nOCT     K3               ROTATE\nDECA    K4          \
     ROTATE\nDODECA  K5               ROTATE\nMULT    K1               K0,K2..K21,SK0,SK1,SK2..SK21,ROTATE,ANGLE\nMARK    -       \
         AX,BX,EX,EPX,AY,BY,EY,EPY,R1,R2,R3,R4,DETR,\n                         DX,DPX,DY,DPY,DZ,DDP,AZ,BZ,ZX,ZPX,ZY,ZPY"[p$2599,
         p1$2599]]=
       equ$2599;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2599},out$2599=lx$2599@Typeset["The default and available non-default variable keywords are:\n\ntype    default-keyword  \
non-default variable keyword\nDRIFT   L                -\nBEND    ANGLE            K1,K0,E1,E2\nQUAD    K1               ROTATE\nS\
EXT    K2               ROTATE\nOCT     K3               ROTATE\nDECA    K4               ROTATE\nDODECA  K5               ROTATE\\
nMULT    K1               K0,K2..K21,SK0,SK1,SK2..SK21,ROTATE,ANGLE\nMARK    -                AX,BX,EX,EPX,AY,BY,EY,EPY,R1,R2,R3,R\
4,DETR,\n                         DX,DPX,DY,DPY,DZ,DDP,AZ,BZ,ZX,ZPX,ZY,ZPY"[p$2599,p1$2599],Format->Help2HTML`oB$];
        System["mv -f "//out$2599//" "//equ$2599]];
      Exit[]]];
   "The default and available non-default variable keywords are:\n\ntype    default-keyword  non-default variable keyword\nDRIFT  \
 L                -\nBEND    ANGLE            K1,K0,E1,E2\nQUAD    K1               ROTATE\nSEXT    K2               ROTATE\nOCT  \
   K3               ROTATE\nDECA    K4               ROTATE\nDODECA  K5               ROTATE\nMULT    K1               K0,K2..K21,\
SK0,SK1,SK2..SK21,ROTATE,ANGLE\nMARK    -                AX,BX,EX,EPX,AY,BY,EY,EPY,R1,R2,R3,R4,DETR,\n                         DX,\
DPX,DY,DPY,DZ,DDP,AZ,BZ,ZX,ZPX,ZY,ZPY"[1,Max[p0$2599,0]]//"<img  class=\"eqs\" SRC=\""//equ$2599//"\" />"//
Help2HTML`oy$["The default and available non-default variable keywords are:\n\ntype    default-keyword  non-default variable keywo\
rd\nDRIFT   L                -\nBEND    ANGLE            K1,K0,E1,E2\nQUAD    K1               ROTATE\nSEXT    K2               RO\
TATE\nOCT     K3               ROTATE\nDECA    K4               ROTATE\nDODECA  K5               ROTATE\nMULT    K1               \
K0,K2..K21,SK0,SK1,SK2..SK21,ROTATE,ANGLE\nMARK    -                AX,BX,EX,EPX,AY,BY,EY,EPY,R1,R2,R3,R4,DETR,\n                 \
        DX,DPX,DY,DPY,DZ,DDP,AZ,BZ,ZX,ZPX,ZY,ZPY"[p2$2599,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L136>keywords</A></PRE>
</UL>
<H3><A NAME=L500>
special-variables</A></H3>
<PRE>If[{},
 Help2HTML`oA$["There are several variables which have special rolls in FFS. Some of them are also accessible in the MAIN level."],
 p$2602=1+p$2602[[1,2]];
  p1$2602=StringPosition[
    "There are several variables which have special rolls in FFS. Some of them are also accessible in the MAIN level."[p$2602,-1],
    ">::",1];
   p1$2602=If[p1$2602==={},112,-2+p$2602+p1$2602[[1,1]]];
  neq=Which["There are several variables which have special rolls in FFS. Some of them are also accessible in the MAIN level."[p
      $2602,4+p$2602]===
     "Text[",
    lx$2602:=Help2HTML`oa$;p$2602=5+p$2602;p1$2602-=1;p2$2602=5+p1$2602;p0$2602=-9+p$2602;If[(pe$2602=StringPosition[
         "There are several variables which have special rolls in FFS. Some of them are also accessible in the MAIN level."[p$2602,
          -2],
         ";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression[
          "There are several variables which have special rolls in FFS. Some of them are also accessible in the MAIN level."[p$2602
            +pe$2602[[1,2]],
           p1$2602]]],
        p1$2602=-2+p$2602+pe$2602[[1,1]]}[[
       1]],
      0],
    1,lx$2602:=Help2HTML`o9$;p2$2602=4+p1$2602;p0$2602=-4+p$2602;0];
  If[(equ$2602=
     Help2HTML`o8$[
      "There are several variables which have special rolls in FFS. Some of them are also accessible in the MAIN level."[p$2602,
       p1$2602]])===
    Undefined,
   equ$2602="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "There are several variables which have special rolls in FFS. Some of them are also accessible in the MAIN level."[p$2602,
         p1$2602]]=
       equ$2602;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$2602},out$2602=lx$2602@Typeset[
          "There are several variables which have special rolls in FFS. Some of them are also accessible in the MAIN level."[p$2602
           ,p1$2602],Format->Help2HTML`oB$];
        System["mv -f "//out$2602//" "//equ$2602]];
      Exit[]]];
   "There are several variables which have special rolls in FFS. Some of them are also accessible in the MAIN level."[1,
    Max[p0$2602,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2602//"\" />"//
   Help2HTML`oy$["There are several variables which have special rolls in FFS. Some of them are also accessible in the MAIN level."
    [p2$2602,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L31>constants</A> <A HREF=#L246>expression</A> <A HREF=#L300>flags</A></PRE>
<UL>
<LI>
<H3><A NAME=L501>
$Line</A></H3>
<PRE>If[{},
Help2HTML`oA$[" %Line counts the number of the results in FFS Shown with Out[]:= . Out remembers all outputs up to Out[$Line]. $Li\
ne = 0 resets the counter and forgets the outputs."],
p$2605=1+p$2605[[1,2]];p1$2605=StringPosition[" %Line counts the number of the results in FFS Shown with Out[]:= . Out remembers a\
ll outputs up to Out[$Line]. $Line = 0 resets the counter and forgets the outputs."[p$2605,-1],">::",1];
   p1$2605=If[p1$2605==={},165,-2+p$2605+p1$2605[[1,1]]];
neq=Which[" %Line counts the number of the results in FFS Shown with Out[]:= . Out remembers all outputs up to Out[$Line]. $Line =\
 0 resets the counter and forgets the outputs."[p$2605,4+p$2605]==="Text[",
    lx$2605:=Help2HTML`oa$;p$2605=5+p$2605;p1$2605-=1;p2$2605=5+p1$2605;p0$2605=-9+p$2605;
If[(pe$2605=StringPosition[" %Line counts the number of the results in FFS Shown with Out[]:= . Out remembers all outputs up to Ou\
t[$Line]. $Line = 0 resets the counter and forgets the outputs."[p$2605,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression[" %Line counts the number of the results in FFS Shown with Out[]:= . Out remembers all outputs up to Out[$Line]. $\
Line = 0 resets the counter and forgets the outputs."[p$2605+pe$2605[[1,2]],p1$2605]]],
        p1$2605=-2+p$2605+pe$2605[[1,1]]}[[
       1]],
      0],
    1,lx$2605:=Help2HTML`o9$;p2$2605=4+p1$2605;p0$2605=-4+p$2605;0];
  If[(equ$2605=
Help2HTML`o8$[" %Line counts the number of the results in FFS Shown with Out[]:= . Out remembers all outputs up to Out[$Line]. $Li\
ne = 0 resets the counter and forgets the outputs."[p$2605,p1$2605]])===
    Undefined,
equ$2605="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[" %Line counts the number of the results in F\
FS Shown with Out[]:= . Out remembers all outputs up to Out[$Line]. $Line = 0 resets the counter and forgets the outputs."[p$2605,
         p1$2605]]=
       equ$2605;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2605},out$2605=lx$2605@Typeset[" %Line counts the number of the results in FFS Shown with Out[]:= . Out remembers all out\
puts up to Out[$Line]. $Line = 0 resets the counter and forgets the outputs."[p$2605,p1$2605],Format->Help2HTML`oB$];
        System["mv -f "//out$2605//" "//equ$2605]];
      Exit[]]];
   " %Line counts the number of the results in FFS Shown with Out[]:= . Out remembers all outputs up to Out[$Line]. $Line = 0 rese\
ts the counter and forgets the outputs."[1,Max[p0$2605,0]]//"<img  class=\"eqs\" SRC=\""//equ$2605//"\" />"//
Help2HTML`oy$[" %Line counts the number of the results in FFS Shown with Out[]:= . Out remembers all outputs up to Out[$Line]. $Li\
ne = 0 resets the counter and forgets the outputs."[p2$2605,-1]]
]</PRE>
<LI>
<H3><A NAME=L502>
CASE</A></H3>
<PRE>If[{},
 Help2HTML`oA$[
  "CASE is a character-string to be attached with TITLE to issue the CASE command of TopDrawer in DRAW or GEO commands."],
 p$2607=1+p$2607[[1,2]];
  p1$2607=StringPosition[
    "CASE is a character-string to be attached with TITLE to issue the CASE command of TopDrawer in DRAW or GEO commands."[p$2607,
     -1],
    ">::",1];
   p1$2607=If[p1$2607==={},116,-2+p$2607+p1$2607[[1,1]]];
  neq=Which["CASE is a character-string to be attached with TITLE to issue the CASE command of TopDrawer in DRAW or GEO commands."[
      p$2607,4+p$2607]===
     "Text[",
    lx$2607:=Help2HTML`oa$;p$2607=5+p$2607;p1$2607-=1;p2$2607=5+p1$2607;p0$2607=-9+p$2607;If[(pe$2607=StringPosition[
         "CASE is a character-string to be attached with TITLE to issue the CASE command of TopDrawer in DRAW or GEO commands."[p
          $2607,-2],
         ";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression[
          "CASE is a character-string to be attached with TITLE to issue the CASE command of TopDrawer in DRAW or GEO commands."[
            p$2607+pe$2607[[1,2]],
           p1$2607]]],
        p1$2607=-2+p$2607+pe$2607[[1,1]]}[[
       1]],
      0],
    1,lx$2607:=Help2HTML`o9$;p2$2607=4+p1$2607;p0$2607=-4+p$2607;0];
  If[(equ$2607=
     Help2HTML`o8$[
      "CASE is a character-string to be attached with TITLE to issue the CASE command of TopDrawer in DRAW or GEO commands."[p$2607
       ,p1$2607]])===
    Undefined,
   equ$2607="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "CASE is a character-string to be attached with TITLE to issue the CASE command of TopDrawer in DRAW or GEO commands."[p
         $2607,p1$2607]]=
       equ$2607;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$2607},out$2607=lx$2607@Typeset[
          "CASE is a character-string to be attached with TITLE to issue the CASE command of TopDrawer in DRAW or GEO commands."[
           p$2607,p1$2607],Format->Help2HTML`oB$];
        System["mv -f "//out$2607//" "//equ$2607]];
      Exit[]]];
  "CASE is a character-string to be attached with TITLE to issue the CASE command of TopDrawer in DRAW or GEO commands."[1,
    Max[p0$2607,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2607//"\" />"//
   Help2HTML`oy$[
    "CASE is a character-string to be attached with TITLE to issue the CASE command of TopDrawer in DRAW or GEO commands."[p2$2607,
     -1]]
]</PRE>
<PRE>See also:
 <A HREF=#L547>TITLE</A> <A HREF=#L72>DRAW</A> <A HREF=#L245>GEO</A></PRE>
<LI>
<H3><A NAME=L503>
CHARGE</A></H3>
<PRE>If[{},Help2HTML`oA$["CHARGE contains the charge of the particle. The default is +1."],
 p$2610=1+p$2610[[1,2]];p1$2610=StringPosition["CHARGE contains the charge of the particle. The default is +1."[p$2610,-1],">::",
    1];
   p1$2610=If[p1$2610==={},62,-2+p$2610+p1$2610[[1,1]]];
  neq=Which["CHARGE contains the charge of the particle. The default is +1."[p$2610,4+p$2610]==="Text[",
    lx$2610:=Help2HTML`oa$;p$2610=5+p$2610;p1$2610-=1;p2$2610=5+p1$2610;p0$2610=-9+p$2610;
     If[(pe$2610=StringPosition["CHARGE contains the charge of the particle. The default is +1."[p$2610,-2],";;;"])<=>{},
      {Max[0,-1+ToExpression["CHARGE contains the charge of the particle. The default is +1."[p$2610+pe$2610[[1,2]],p1$2610]]],
       p1$2610=-2+p$2610+pe$2610[[1,1]]}[[1]],
      0],
    1,lx$2610:=Help2HTML`o9$;p2$2610=4+p1$2610;p0$2610=-4+p$2610;0];
  If[(equ$2610=Help2HTML`o8$["CHARGE contains the charge of the particle. The default is +1."[p$2610,p1$2610]])===Undefined,
   equ$2610="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["CHARGE contains the charge of the particle. The default is +1."[p$2610,p1$2610]]=equ$2610;
      LaTeX`ob$+=neq,
     --LaTeX`ob$;With[{lx$2610},out$2610=lx$2610@Typeset["CHARGE contains the charge of the particle. The default is +1."[p$2610,
           p1$2610],Format->Help2HTML`oB$];
        System["mv -f "//out$2610//" "//equ$2610]];
      Exit[]]];
   "CHARGE contains the charge of the particle. The default is +1."[1,Max[p0$2610,0]]//"<img  class=\"eqs\" SRC=\""//equ$2610//
   "\" />"//Help2HTML`oy$["CHARGE contains the charge of the particle. The default is +1."[p2$2610,-1]]
]</PRE>
<LI>
<H3><A NAME=L504>
CONVERGENCE</A></H3>
<PRE>If[{},
Help2HTML`oA$["CONVERGENCE is the goal of the convergence(==MatchingResidual) in the matching. If MatchingResidual becomes smaller\
 than CONVERGENCE times the effective number of the conditions, the matching by GO terminates. The flag CONV is set when MatchingR\
esidual is smaller than CONVERGENCE after GO or CALCULATE(CAL). The default value is 10^-9."],
 p$2612=1+p$2612[[1,2]];p1$2612=StringPosition["CONVERGENCE is the goal of the convergence(==MatchingResidual) in the matching. If\
 MatchingResidual becomes smaller than CONVERGENCE times the effective number of the conditions, the matching by GO terminates. Th\
e flag CONV is set when MatchingResidual is smaller than CONVERGENCE after GO or CALCULATE(CAL). The default value is 10^-9."[p
     $2612,-1],
    ">::",1];
   p1$2612=If[p1$2612==={},336,-2+p$2612+p1$2612[[1,1]]];
neq=Which["CONVERGENCE is the goal of the convergence(==MatchingResidual) in the matching. If MatchingResidual becomes smaller tha\
n CONVERGENCE times the effective number of the conditions, the matching by GO terminates. The flag CONV is set when MatchingResid\
ual is smaller than CONVERGENCE after GO or CALCULATE(CAL). The default value is 10^-9."[p$2612,4+p$2612]==="Text[",
    lx$2612:=Help2HTML`oa$;p$2612=5+p$2612;p1$2612-=1;p2$2612=5+p1$2612;p0$2612=-9+p$2612;
If[(pe$2612=StringPosition["CONVERGENCE is the goal of the convergence(==MatchingResidual) in the matching. If MatchingResidual be\
comes smaller than CONVERGENCE times the effective number of the conditions, the matching by GO terminates. The flag CONV is set w\
hen MatchingResidual is smaller than CONVERGENCE after GO or CALCULATE(CAL). The default value is 10^-9."[p$2612,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["CONVERGENCE is the goal of the convergence(==MatchingResidual) in the matching. If MatchingResidual becomes small\
er than CONVERGENCE times the effective number of the conditions, the matching by GO terminates. The flag CONV is set when Matchin\
gResidual is smaller than CONVERGENCE after GO or CALCULATE(CAL). The default value is 10^-9."[p$2612+pe$2612[[1,2]],p1$2612]]],
        p1$2612=-2+p$2612+pe$2612[[1,1]]}[[
       1]],
      0],
    1,lx$2612:=Help2HTML`o9$;p2$2612=4+p1$2612;p0$2612=-4+p$2612;0];
  If[(equ$2612=
Help2HTML`o8$["CONVERGENCE is the goal of the convergence(==MatchingResidual) in the matching. If MatchingResidual becomes smaller\
 than CONVERGENCE times the effective number of the conditions, the matching by GO terminates. The flag CONV is set when MatchingR\
esidual is smaller than CONVERGENCE after GO or CALCULATE(CAL). The default value is 10^-9."[p$2612,p1$2612]])===
    Undefined,
equ$2612="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["CONVERGENCE is the goal of the convergence(=\
=MatchingResidual) in the matching. If MatchingResidual becomes smaller than CONVERGENCE times the effective number of the conditi\
ons, the matching by GO terminates. The flag CONV is set when MatchingResidual is smaller than CONVERGENCE after GO or CALCULATE(C\
AL). The default value is 10^-9."[p$2612,p1$2612]]=
       equ$2612;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2612},out$2612=lx$2612@Typeset["CONVERGENCE is the goal of the convergence(==MatchingResidual) in the matching. If Matchi\
ngResidual becomes smaller than CONVERGENCE times the effective number of the conditions, the matching by GO terminates. The flag \
CONV is set when MatchingResidual is smaller than CONVERGENCE after GO or CALCULATE(CAL). The default value is 10^-9."[p$2612,
           p1$2612],Format->Help2HTML`oB$];
        System["mv -f "//out$2612//" "//equ$2612]];
      Exit[]]];
   "CONVERGENCE is the goal of the convergence(==MatchingResidual) in the matching. If MatchingResidual becomes smaller than CONVE\
RGENCE times the effective number of the conditions, the matching by GO terminates. The flag CONV is set when MatchingResidual is \
smaller than CONVERGENCE after GO or CALCULATE(CAL). The default value is 10^-9."[1,Max[p0$2612,0]]//"<img  class=\"eqs\" SRC=\""//
   equ$2612//"\" />"//
Help2HTML`oy$["CONVERGENCE is the goal of the convergence(==MatchingResidual) in the matching. If MatchingResidual becomes smaller\
 than CONVERGENCE times the effective number of the conditions, the matching by GO terminates. The flag CONV is set when MatchingR\
esidual is smaller than CONVERGENCE after GO or CALCULATE(CAL). The default value is 10^-9."[p2$2612,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L469>GO</A> <A HREF=#L528>MatchingResidual</A> <A HREF=#L309>CONV</A></PRE>
<LI>
<H3><A NAME=L505>
DAPWIDTH</A></H3>
<PRE>If[{},
Help2HTML`oA$["DAPWIDTH is the successive width of the x-amplitudes to terminate the tracking assuming that the aperture is enough\
. The default is 7."],
p$2615=1+p$2615[[1,2]];p1$2615=StringPosition["DAPWIDTH is the successive width of the x-amplitudes to terminate the tracking assu\
ming that the aperture is enough. The default is 7."[p$2615,-1],">::",1];
   p1$2615=If[p1$2615==={},134,-2+p$2615+p1$2615[[1,1]]];
neq=Which["DAPWIDTH is the successive width of the x-amplitudes to terminate the tracking assuming that the aperture is enough. Th\
e default is 7."[p$2615,4+p$2615]==="Text[",
    lx$2615:=Help2HTML`oa$;p$2615=5+p$2615;p1$2615-=1;p2$2615=5+p1$2615;p0$2615=-9+p$2615;If[(pe$2615=
StringPosition["DAPWIDTH is the successive width of the x-amplitudes to terminate the tracking assuming that the aperture is enoug\
h. The default is 7."[p$2615,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["DAPWIDTH is the successive width of the x-amplitudes to terminate the tracking assuming that the aperture is enou\
gh. The default is 7."[p$2615+pe$2615[[1,2]],p1$2615]]],
        p1$2615=-2+p$2615+pe$2615[[1,1]]}[[
       1]],
      0],
    1,lx$2615:=Help2HTML`o9$;p2$2615=4+p1$2615;p0$2615=-4+p$2615;0];
  If[(equ$2615=
Help2HTML`o8$["DAPWIDTH is the successive width of the x-amplitudes to terminate the tracking assuming that the aperture is enough\
. The default is 7."[p$2615,p1$2615]])===
    Undefined,
equ$2615="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["DAPWIDTH is the successive width of the x-am\
plitudes to terminate the tracking assuming that the aperture is enough. The default is 7."[p$2615,p1$2615]]=
       equ$2615;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2615},out$2615=lx$2615@Typeset["DAPWIDTH is the successive width of the x-amplitudes to terminate the tracking assuming t\
hat the aperture is enough. The default is 7."[p$2615,p1$2615],Format->Help2HTML`oB$];
        System["mv -f "//out$2615//" "//equ$2615]];
      Exit[]]];
   "DAPWIDTH is the successive width of the x-amplitudes to terminate the tracking assuming that the aperture is enough. The defau\
lt is 7."[1,Max[p0$2615,0]]//"<img  class=\"eqs\" SRC=\""//equ$2615//"\" />"//
Help2HTML`oy$["DAPWIDTH is the successive width of the x-amplitudes to terminate the tracking assuming that the aperture is enough\
. The default is 7."[p2$2615,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L386>DynamicApertureSurvey</A></PRE>
<LI>
<H3><A NAME=L506>
DP</A></H3>
<PRE>If[{},
Help2HTML`oA$["DP represents the relative momentum spread of the beam. It is automatically set by the keyword DP of the MARK eleme\
nt at the beginning of the beam line. The value of EMITY affects the default weight of variables in the matching. In the off-momen\
tum matching, the range DP0 - DP < dp/p0 < DP0 + DP is used for the matching. The assumed momentum-distribution in the BEAMSIZE(BE\
AM), MEASURE(MEA), etc. commands, is Gaussian with the standard deviation DP and the mean DP0 if the flag GAUSS is on, otherwise u\
niform (square) in the range DP0 - DP < dp/p0 < DP0 + DP."],
p$2618=1+p$2618[[1,2]];p1$2618=StringPosition["DP represents the relative momentum spread of the beam. It is automatically set by \
the keyword DP of the MARK element at the beginning of the beam line. The value of EMITY affects the default weight of variables i\
n the matching. In the off-momentum matching, the range DP0 - DP < dp/p0 < DP0 + DP is used for the matching. The assumed momentum\
-distribution in the BEAMSIZE(BEAM), MEASURE(MEA), etc. commands, is Gaussian with the standard deviation DP and the mean DP0 if t\
he flag GAUSS is on, otherwise uniform (square) in the range DP0 - DP < dp/p0 < DP0 + DP."[p$2618,-1],">::",1];
   p1$2618=If[p1$2618==={},562,-2+p$2618+p1$2618[[1,1]]];
neq=Which["DP represents the relative momentum spread of the beam. It is automatically set by the keyword DP of the MARK element a\
t the beginning of the beam line. The value of EMITY affects the default weight of variables in the matching. In the off-momentum \
matching, the range DP0 - DP < dp/p0 < DP0 + DP is used for the matching. The assumed momentum-distribution in the BEAMSIZE(BEAM),\
 MEASURE(MEA), etc. commands, is Gaussian with the standard deviation DP and the mean DP0 if the flag GAUSS is on, otherwise unifo\
rm (square) in the range DP0 - DP < dp/p0 < DP0 + DP."[p$2618,4+p$2618]==="Text[",
    lx$2618:=Help2HTML`oa$;p$2618=5+p$2618;p1$2618-=1;p2$2618=5+p1$2618;p0$2618=-9+p$2618;
If[(pe$2618=StringPosition["DP represents the relative momentum spread of the beam. It is automatically set by the keyword DP of t\
he MARK element at the beginning of the beam line. The value of EMITY affects the default weight of variables in the matching. In \
the off-momentum matching, the range DP0 - DP < dp/p0 < DP0 + DP is used for the matching. The assumed momentum-distribution in th\
e BEAMSIZE(BEAM), MEASURE(MEA), etc. commands, is Gaussian with the standard deviation DP and the mean DP0 if the flag GAUSS is on\
, otherwise uniform (square) in the range DP0 - DP < dp/p0 < DP0 + DP."[p$2618,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["DP represents the relative momentum spread of the beam. It is automatically set by the keyword DP of the MARK ele\
ment at the beginning of the beam line. The value of EMITY affects the default weight of variables in the matching. In the off-mom\
entum matching, the range DP0 - DP < dp/p0 < DP0 + DP is used for the matching. The assumed momentum-distribution in the BEAMSIZE(\
BEAM), MEASURE(MEA), etc. commands, is Gaussian with the standard deviation DP and the mean DP0 if the flag GAUSS is on, otherwise\
 uniform (square) in the range DP0 - DP < dp/p0 < DP0 + DP."[p$2618+pe$2618[[1,2]],p1$2618]]],
        p1$2618=-2+p$2618+pe$2618[[1,1]]}[[
       1]],
      0],
    1,lx$2618:=Help2HTML`o9$;p2$2618=4+p1$2618;p0$2618=-4+p$2618;0];
  If[(equ$2618=
Help2HTML`o8$["DP represents the relative momentum spread of the beam. It is automatically set by the keyword DP of the MARK eleme\
nt at the beginning of the beam line. The value of EMITY affects the default weight of variables in the matching. In the off-momen\
tum matching, the range DP0 - DP < dp/p0 < DP0 + DP is used for the matching. The assumed momentum-distribution in the BEAMSIZE(BE\
AM), MEASURE(MEA), etc. commands, is Gaussian with the standard deviation DP and the mean DP0 if the flag GAUSS is on, otherwise u\
niform (square) in the range DP0 - DP < dp/p0 < DP0 + DP."[p$2618,p1$2618]])===
    Undefined,
equ$2618="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["DP represents the relative momentum spread o\
f the beam. It is automatically set by the keyword DP of the MARK element at the beginning of the beam line. The value of EMITY af\
fects the default weight of variables in the matching. In the off-momentum matching, the range DP0 - DP < dp/p0 < DP0 + DP is used\
 for the matching. The assumed momentum-distribution in the BEAMSIZE(BEAM), MEASURE(MEA), etc. commands, is Gaussian with the stan\
dard deviation DP and the mean DP0 if the flag GAUSS is on, otherwise uniform (square) in the range DP0 - DP < dp/p0 < DP0 + DP."[
         p$2618,p1$2618]]=
       equ$2618;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2618},out$2618=lx$2618@Typeset["DP represents the relative momentum spread of the beam. It is automatically set by the ke\
yword DP of the MARK element at the beginning of the beam line. The value of EMITY affects the default weight of variables in the \
matching. In the off-momentum matching, the range DP0 - DP < dp/p0 < DP0 + DP is used for the matching. The assumed momentum-distr\
ibution in the BEAMSIZE(BEAM), MEASURE(MEA), etc. commands, is Gaussian with the standard deviation DP and the mean DP0 if the fla\
g GAUSS is on, otherwise uniform (square) in the range DP0 - DP < dp/p0 < DP0 + DP."[p$2618,p1$2618],Format->Help2HTML`oB$];
        System["mv -f "//out$2618//" "//equ$2618]];
      Exit[]]];
   "DP represents the relative momentum spread of the beam. It is automatically set by the keyword DP of the MARK element at the b\
eginning of the beam line. The value of EMITY affects the default weight of variables in the matching. In the off-momentum matchin\
g, the range DP0 - DP < dp/p0 < DP0 + DP is used for the matching. The assumed momentum-distribution in the BEAMSIZE(BEAM), MEASUR\
E(MEA), etc. commands, is Gaussian with the standard deviation DP and the mean DP0 if the flag GAUSS is on, otherwise uniform (squ\
are) in the range DP0 - DP < dp/p0 < DP0 + DP."[1,Max[p0$2618,0]]//"<img  class=\"eqs\" SRC=\""//equ$2618//"\" />"//
Help2HTML`oy$["DP represents the relative momentum spread of the beam. It is automatically set by the keyword DP of the MARK eleme\
nt at the beginning of the beam line. The value of EMITY affects the default weight of variables in the matching. In the off-momen\
tum matching, the range DP0 - DP < dp/p0 < DP0 + DP is used for the matching. The assumed momentum-distribution in the BEAMSIZE(BE\
AM), MEASURE(MEA), etc. commands, is Gaussian with the standard deviation DP and the mean DP0 if the flag GAUSS is on, otherwise u\
niform (square) in the range DP0 - DP < dp/p0 < DP0 + DP."[p2$2618,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L507>DP0</A> <A HREF=#L477>off-momentum-matching</A> <A HREF=#L319>GAUSS</A> <A HREF=#L354>UNIFORM</A> <A HREF=#L75>elements</A> <A HREF=#L137>MARK</A></PRE>
<LI>
<H3><A NAME=L507>
DP0</A></H3>
<PRE>If[{},
Help2HTML`oA$[" DP0 represents the central value of the relative momentum offset in the optics calculation, or the center of the m\
omentum distribution of the beam. The on-momentum optics has the relative momentum deviation dp/p0 == DP0, and the off-momentum ca\
lculation is done in the range DP0 - DP < dp/p0 < DP0 + DP.\n DP0 sets the momentum deviation of the closed orbit at the entrance \
for EMIT with RADTAPER."],
p$2621=1+p$2621[[1,2]];p1$2621=StringPosition[" DP0 represents the central value of the relative momentum offset in the optics cal\
culation, or the center of the momentum distribution of the beam. The on-momentum optics has the relative momentum deviation dp/p0\
 == DP0, and the off-momentum calculation is done in the range DP0 - DP < dp/p0 < DP0 + DP.\n DP0 sets the momentum deviation of t\
he closed orbit at the entrance for EMIT with RADTAPER."[p$2621,-1],">::",1];
   p1$2621=If[p1$2621==={},397,-2+p$2621+p1$2621[[1,1]]];
neq=Which[" DP0 represents the central value of the relative momentum offset in the optics calculation, or the center of the momen\
tum distribution of the beam. The on-momentum optics has the relative momentum deviation dp/p0 == DP0, and the off-momentum calcul\
ation is done in the range DP0 - DP < dp/p0 < DP0 + DP.\n DP0 sets the momentum deviation of the closed orbit at the entrance for \
EMIT with RADTAPER."[p$2621,4+p$2621]==="Text[",
    lx$2621:=Help2HTML`oa$;p$2621=5+p$2621;p1$2621-=1;p2$2621=5+p1$2621;p0$2621=-9+p$2621;
If[(pe$2621=StringPosition[" DP0 represents the central value of the relative momentum offset in the optics calculation, or the ce\
nter of the momentum distribution of the beam. The on-momentum optics has the relative momentum deviation dp/p0 == DP0, and the of\
f-momentum calculation is done in the range DP0 - DP < dp/p0 < DP0 + DP.\n DP0 sets the momentum deviation of the closed orbit at \
the entrance for EMIT with RADTAPER."[p$2621,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression[" DP0 represents the central value of the relative momentum offset in the optics calculation, or the center of the\
 momentum distribution of the beam. The on-momentum optics has the relative momentum deviation dp/p0 == DP0, and the off-momentum \
calculation is done in the range DP0 - DP < dp/p0 < DP0 + DP.\n DP0 sets the momentum deviation of the closed orbit at the entranc\
e for EMIT with RADTAPER."[p$2621+pe$2621[[1,2]],p1$2621]]],
        p1$2621=-2+p$2621+pe$2621[[1,1]]}[[
       1]],
      0],
    1,lx$2621:=Help2HTML`o9$;p2$2621=4+p1$2621;p0$2621=-4+p$2621;0];
  If[(equ$2621=
Help2HTML`o8$[" DP0 represents the central value of the relative momentum offset in the optics calculation, or the center of the m\
omentum distribution of the beam. The on-momentum optics has the relative momentum deviation dp/p0 == DP0, and the off-momentum ca\
lculation is done in the range DP0 - DP < dp/p0 < DP0 + DP.\n DP0 sets the momentum deviation of the closed orbit at the entrance \
for EMIT with RADTAPER."[p$2621,p1$2621]])===
    Undefined,
equ$2621="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[" DP0 represents the central value of the rel\
ative momentum offset in the optics calculation, or the center of the momentum distribution of the beam. The on-momentum optics ha\
s the relative momentum deviation dp/p0 == DP0, and the off-momentum calculation is done in the range DP0 - DP < dp/p0 < DP0 + DP.\
\n DP0 sets the momentum deviation of the closed orbit at the entrance for EMIT with RADTAPER."[p$2621,p1$2621]]=
       equ$2621;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2621},out$2621=lx$2621@Typeset[" DP0 represents the central value of the relative momentum offset in the optics calculati\
on, or the center of the momentum distribution of the beam. The on-momentum optics has the relative momentum deviation dp/p0 == DP\
0, and the off-momentum calculation is done in the range DP0 - DP < dp/p0 < DP0 + DP.\n DP0 sets the momentum deviation of the clo\
sed orbit at the entrance for EMIT with RADTAPER."[p$2621,p1$2621],Format->Help2HTML`oB$];
        System["mv -f "//out$2621//" "//equ$2621]];
      Exit[]]];
   " DP0 represents the central value of the relative momentum offset in the optics calculation, or the center of the momentum dis\
tribution of the beam. The on-momentum optics has the relative momentum deviation dp/p0 == DP0, and the off-momentum calculation i\
s done in the range DP0 - DP < dp/p0 < DP0 + DP.\n DP0 sets the momentum deviation of the closed orbit at the entrance for EMIT wi\
th RADTAPER."[1,Max[p0$2621,0]]//"<img  class=\"eqs\" SRC=\""//equ$2621//"\" />"//
Help2HTML`oy$[" DP0 represents the central value of the relative momentum offset in the optics calculation, or the center of the m\
omentum distribution of the beam. The on-momentum optics has the relative momentum deviation dp/p0 == DP0, and the off-momentum ca\
lculation is done in the range DP0 - DP < dp/p0 < DP0 + DP.\n DP0 sets the momentum deviation of the closed orbit at the entrance \
for EMIT with RADTAPER."[p2$2621,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L506>DP</A> <A HREF=#L477>off-momentum-matching</A> <A HREF=#L473>matching-function-commands</A> <A HREF=#L295>EMITTANCE(EMIT)</A> <A HREF=#L341>RADTAPER</A></PRE>
<LI>
<H3><A NAME=L508>
DTSYNCH</A></H3>
<PRE>If[{},
Help2HTML`oA$[" DTSYNCH is the equilibrium arrival time advance (= -c*delta t, in meter) where the synchrotron radiation loss bala\
nces with the RF, calculated by EMIT/Emittance[SaveEMIT->True]. This corresponds to the origin of the RF phase. The default is zer\
o."],
p$2624=1+p$2624[[1,2]];p1$2624=StringPosition[" DTSYNCH is the equilibrium arrival time advance (= -c*delta t, in meter) where the\
 synchrotron radiation loss balances with the RF, calculated by EMIT/Emittance[SaveEMIT->True]. This corresponds to the origin of \
the RF phase. The default is zero."[p$2624,-1],">::",1];
   p1$2624=If[p1$2624==={},247,-2+p$2624+p1$2624[[1,1]]];
neq=Which[" DTSYNCH is the equilibrium arrival time advance (= -c*delta t, in meter) where the synchrotron radiation loss balances\
 with the RF, calculated by EMIT/Emittance[SaveEMIT->True]. This corresponds to the origin of the RF phase. The default is zero."[
      p$2624,4+p$2624]===
     "Text[",
lx$2624:=Help2HTML`oa$;p$2624=5+p$2624;p1$2624-=1;p2$2624=5+p1$2624;p0$2624=-9+p$2624;If[(pe$2624=StringPosition[" DTSYNCH is the \
equilibrium arrival time advance (= -c*delta t, in meter) where the synchrotron radiation loss balances with the RF, calculated by\
 EMIT/Emittance[SaveEMIT->True]. This corresponds to the origin of the RF phase. The default is zero."[p$2624,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression[" DTSYNCH is the equilibrium arrival time advance (= -c*delta t, in meter) where the synchrotron radiation loss ba\
lances with the RF, calculated by EMIT/Emittance[SaveEMIT->True]. This corresponds to the origin of the RF phase. The default is z\
ero."[p$2624+pe$2624[[1,2]],p1$2624]]],
        p1$2624=-2+p$2624+pe$2624[[1,1]]}[[
       1]],
      0],
    1,lx$2624:=Help2HTML`o9$;p2$2624=4+p1$2624;p0$2624=-4+p$2624;0];
  If[(equ$2624=
Help2HTML`o8$[" DTSYNCH is the equilibrium arrival time advance (= -c*delta t, in meter) where the synchrotron radiation loss bala\
nces with the RF, calculated by EMIT/Emittance[SaveEMIT->True]. This corresponds to the origin of the RF phase. The default is zer\
o."[p$2624,p1$2624]])===
    Undefined,
equ$2624="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[" DTSYNCH is the equilibrium arrival time adv\
ance (= -c*delta t, in meter) where the synchrotron radiation loss balances with the RF, calculated by EMIT/Emittance[SaveEMIT->Tr\
ue]. This corresponds to the origin of the RF phase. The default is zero."[p$2624,p1$2624]]=
       equ$2624;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2624},out$2624=lx$2624@Typeset[" DTSYNCH is the equilibrium arrival time advance (= -c*delta t, in meter) where the synch\
rotron radiation loss balances with the RF, calculated by EMIT/Emittance[SaveEMIT->True]. This corresponds to the origin of the RF\
 phase. The default is zero."[p$2624,p1$2624],Format->Help2HTML`oB$];
        System["mv -f "//out$2624//" "//equ$2624]];
      Exit[]]];
   " DTSYNCH is the equilibrium arrival time advance (= -c*delta t, in meter) where the synchrotron radiation loss balances with t\
he RF, calculated by EMIT/Emittance[SaveEMIT->True]. This corresponds to the origin of the RF phase. The default is zero."[1,
    Max[p0$2624,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2624//"\" />"//
Help2HTML`oy$[" DTSYNCH is the equilibrium arrival time advance (= -c*delta t, in meter) where the synchrotron radiation loss bala\
nces with the RF, calculated by EMIT/Emittance[SaveEMIT->True]. This corresponds to the origin of the RF phase. The default is zer\
o."[p2$2624,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L513>EMITX</A> <A HREF=#L515>EMITY</A> <A HREF=#L517>EMITZ</A> <A HREF=#L544>SIGZ</A> <A HREF=#L543>SIGE</A> <A HREF=#L295>EMITTANCE(EMIT)</A> <A HREF=#L389>Emittance</A> <A HREF=#L542>PHICAV</A></PRE>
<LI>
<H3><A NAME=L509>
EFFRFFREQ</A></H3>
<PRE>If[{},
Help2HTML`oA$[" The effective angular frequency weff (= 2 Pi EFFRFFREQ) is obtained using the second derivative\n\n  d^2Vcacc/dt^2\
 == -weff^2 Vcacc ,\n\nehere Vcacc is the total acceleration voltage at the equilibrium phase PHICAV. These quantities Vcacc and i\
ts derivatives are summed over all CAVIs and MULTs.\n It is set by EMITTANCE(EMIT) or Emittance[]. Effective with RING only."],
 p$2627=1+p$2627[[1,2]];
p1$2627=StringPosition[" The effective angular frequency weff (= 2 Pi EFFRFFREQ) is obtained using the second derivative\n\n  d^2V\
cacc/dt^2 == -weff^2 Vcacc ,\n\nehere Vcacc is the total acceleration voltage at the equilibrium phase PHICAV. These quantities Vc\
acc and its derivatives are summed over all CAVIs and MULTs.\n It is set by EMITTANCE(EMIT) or Emittance[]. Effective with RING on\
ly."[p$2627,-1],">::",1];
   p1$2627=If[p1$2627==={},364,-2+p$2627+p1$2627[[1,1]]];
neq=Which[" The effective angular frequency weff (= 2 Pi EFFRFFREQ) is obtained using the second derivative\n\n  d^2Vcacc/dt^2 == \
-weff^2 Vcacc ,\n\nehere Vcacc is the total acceleration voltage at the equilibrium phase PHICAV. These quantities Vcacc and its d\
erivatives are summed over all CAVIs and MULTs.\n It is set by EMITTANCE(EMIT) or Emittance[]. Effective with RING only."[p$2627,
      4+p$2627]===
     "Text[",
lx$2627:=Help2HTML`oa$;p$2627=5+p$2627;p1$2627-=1;p2$2627=5+p1$2627;p0$2627=-9+p$2627;If[(pe$2627=StringPosition[" The effective a\
ngular frequency weff (= 2 Pi EFFRFFREQ) is obtained using the second derivative\n\n  d^2Vcacc/dt^2 == -weff^2 Vcacc ,\n\nehere Vc\
acc is the total acceleration voltage at the equilibrium phase PHICAV. These quantities Vcacc and its derivatives are summed over \
all CAVIs and MULTs.\n It is set by EMITTANCE(EMIT) or Emittance[]. Effective with RING only."[p$2627,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression[" The effective angular frequency weff (= 2 Pi EFFRFFREQ) is obtained using the second derivative\n\n  d^2Vcacc/dt\
^2 == -weff^2 Vcacc ,\n\nehere Vcacc is the total acceleration voltage at the equilibrium phase PHICAV. These quantities Vcacc and\
 its derivatives are summed over all CAVIs and MULTs.\n It is set by EMITTANCE(EMIT) or Emittance[]. Effective with RING only."[p
            $2627+pe$2627[[1,2]],
           p1$2627]]],
        p1$2627=-2+p$2627+pe$2627[[1,1]]}[[
       1]],
      0],
    1,lx$2627:=Help2HTML`o9$;p2$2627=4+p1$2627;p0$2627=-4+p$2627;0];
  If[(equ$2627=
Help2HTML`o8$[" The effective angular frequency weff (= 2 Pi EFFRFFREQ) is obtained using the second derivative\n\n  d^2Vcacc/dt^2\
 == -weff^2 Vcacc ,\n\nehere Vcacc is the total acceleration voltage at the equilibrium phase PHICAV. These quantities Vcacc and i\
ts derivatives are summed over all CAVIs and MULTs.\n It is set by EMITTANCE(EMIT) or Emittance[]. Effective with RING only."[p
       $2627,p1$2627]])===
    Undefined,
equ$2627="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[" The effective angular frequency weff (= 2 P\
i EFFRFFREQ) is obtained using the second derivative\n\n  d^2Vcacc/dt^2 == -weff^2 Vcacc ,\n\nehere Vcacc is the total acceleratio\
n voltage at the equilibrium phase PHICAV. These quantities Vcacc and its derivatives are summed over all CAVIs and MULTs.\n It is\
 set by EMITTANCE(EMIT) or Emittance[]. Effective with RING only."[p$2627,p1$2627]]=
       equ$2627;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2627},out$2627=lx$2627@Typeset[" The effective angular frequency weff (= 2 Pi EFFRFFREQ) is obtained using the second der\
ivative\n\n  d^2Vcacc/dt^2 == -weff^2 Vcacc ,\n\nehere Vcacc is the total acceleration voltage at the equilibrium phase PHICAV. Th\
ese quantities Vcacc and its derivatives are summed over all CAVIs and MULTs.\n It is set by EMITTANCE(EMIT) or Emittance[]. Effec\
tive with RING only."[p$2627,p1$2627],Format->Help2HTML`oB$];
        System["mv -f "//out$2627//" "//equ$2627]];
      Exit[]]];
   " The effective angular frequency weff (= 2 Pi EFFRFFREQ) is obtained using the second derivative\n\n  d^2Vcacc/dt^2 == -weff^2\
 Vcacc ,\n\nehere Vcacc is the total acceleration voltage at the equilibrium phase PHICAV. These quantities Vcacc and its derivati\
ves are summed over all CAVIs and MULTs.\n It is set by EMITTANCE(EMIT) or Emittance[]. Effective with RING only."[1,
    Max[p0$2627,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2627//"\" />"//
Help2HTML`oy$[" The effective angular frequency weff (= 2 Pi EFFRFFREQ) is obtained using the second derivative\n\n  d^2Vcacc/dt^2\
 == -weff^2 Vcacc ,\n\nehere Vcacc is the total acceleration voltage at the equilibrium phase PHICAV. These quantities Vcacc and i\
ts derivatives are summed over all CAVIs and MULTs.\n It is set by EMITTANCE(EMIT) or Emittance[]. Effective with RING only."[p2
     $2627,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L510>EFFVC</A> <A HREF=#L542>PHICAV</A></PRE>
<LI>
<H3><A NAME=L510>
EFFVC</A></H3>
<PRE>If[{},
Help2HTML`oA$[" Effective peak rf voltage EFFVC is given by\n\n  Abs[ weff Vcacc + I dVcacc/dt ] / weff ,\n\nwhere Vcacc, weff are\
 total acceleration voltage at the equilibrium phase PHICAV and the effective RF angular frequency (=2 Pi EFFRFFREQ). DVcacc/dt is\
 the time derivative of Vcacc. The quantity Vcacc and its derivatives are summed over all CAVIs and MULTs.\n It is set by EMITTANC\
E(EMIT) or Emittance[]. The unit is Volt. Effective with RING only."],
p$2630=1+p$2630[[1,2]];p1$2630=StringPosition[" Effective peak rf voltage EFFVC is given by\n\n  Abs[ weff Vcacc + I dVcacc/dt ] /\
 weff ,\n\nwhere Vcacc, weff are total acceleration voltage at the equilibrium phase PHICAV and the effective RF angular frequency\
 (=2 Pi EFFRFFREQ). DVcacc/dt is the time derivative of Vcacc. The quantity Vcacc and its derivatives are summed over all CAVIs an\
d MULTs.\n It is set by EMITTANCE(EMIT) or Emittance[]. The unit is Volt. Effective with RING only."[p$2630,-1],">::",1];
   p1$2630=If[p1$2630==={},437,-2+p$2630+p1$2630[[1,1]]];
neq=Which[" Effective peak rf voltage EFFVC is given by\n\n  Abs[ weff Vcacc + I dVcacc/dt ] / weff ,\n\nwhere Vcacc, weff are tot\
al acceleration voltage at the equilibrium phase PHICAV and the effective RF angular frequency (=2 Pi EFFRFFREQ). DVcacc/dt is the\
 time derivative of Vcacc. The quantity Vcacc and its derivatives are summed over all CAVIs and MULTs.\n It is set by EMITTANCE(EM\
IT) or Emittance[]. The unit is Volt. Effective with RING only."[p$2630,4+p$2630]==="Text[",
    lx$2630:=Help2HTML`oa$;p$2630=5+p$2630;p1$2630-=1;p2$2630=5+p1$2630;p0$2630=-9+p$2630;
If[(pe$2630=StringPosition[" Effective peak rf voltage EFFVC is given by\n\n  Abs[ weff Vcacc + I dVcacc/dt ] / weff ,\n\nwhere Vc\
acc, weff are total acceleration voltage at the equilibrium phase PHICAV and the effective RF angular frequency (=2 Pi EFFRFFREQ).\
 DVcacc/dt is the time derivative of Vcacc. The quantity Vcacc and its derivatives are summed over all CAVIs and MULTs.\n It is se\
t by EMITTANCE(EMIT) or Emittance[]. The unit is Volt. Effective with RING only."[p$2630,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression[" Effective peak rf voltage EFFVC is given by\n\n  Abs[ weff Vcacc + I dVcacc/dt ] / weff ,\n\nwhere Vcacc, weff a\
re total acceleration voltage at the equilibrium phase PHICAV and the effective RF angular frequency (=2 Pi EFFRFFREQ). DVcacc/dt \
is the time derivative of Vcacc. The quantity Vcacc and its derivatives are summed over all CAVIs and MULTs.\n It is set by EMITTA\
NCE(EMIT) or Emittance[]. The unit is Volt. Effective with RING only."[p$2630+pe$2630[[1,2]],p1$2630]]],
        p1$2630=-2+p$2630+pe$2630[[1,1]]}[[
       1]],
      0],
    1,lx$2630:=Help2HTML`o9$;p2$2630=4+p1$2630;p0$2630=-4+p$2630;0];
  If[(equ$2630=
Help2HTML`o8$[" Effective peak rf voltage EFFVC is given by\n\n  Abs[ weff Vcacc + I dVcacc/dt ] / weff ,\n\nwhere Vcacc, weff are\
 total acceleration voltage at the equilibrium phase PHICAV and the effective RF angular frequency (=2 Pi EFFRFFREQ). DVcacc/dt is\
 the time derivative of Vcacc. The quantity Vcacc and its derivatives are summed over all CAVIs and MULTs.\n It is set by EMITTANC\
E(EMIT) or Emittance[]. The unit is Volt. Effective with RING only."[p$2630,p1$2630]])===
    Undefined,
equ$2630="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[" Effective peak rf voltage EFFVC is given by\
\n\n  Abs[ weff Vcacc + I dVcacc/dt ] / weff ,\n\nwhere Vcacc, weff are total acceleration voltage at the equilibrium phase PHICAV\
 and the effective RF angular frequency (=2 Pi EFFRFFREQ). DVcacc/dt is the time derivative of Vcacc. The quantity Vcacc and its d\
erivatives are summed over all CAVIs and MULTs.\n It is set by EMITTANCE(EMIT) or Emittance[]. The unit is Volt. Effective with RI\
NG only."[p$2630,p1$2630]]=
       equ$2630;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2630},out$2630=lx$2630@Typeset[" Effective peak rf voltage EFFVC is given by\n\n  Abs[ weff Vcacc + I dVcacc/dt ] / weff \
,\n\nwhere Vcacc, weff are total acceleration voltage at the equilibrium phase PHICAV and the effective RF angular frequency (=2 P\
i EFFRFFREQ). DVcacc/dt is the time derivative of Vcacc. The quantity Vcacc and its derivatives are summed over all CAVIs and MULT\
s.\n It is set by EMITTANCE(EMIT) or Emittance[]. The unit is Volt. Effective with RING only."[p$2630,p1$2630],
          Format->Help2HTML`oB$];
        System["mv -f "//out$2630//" "//equ$2630]];
      Exit[]]];
   " Effective peak rf voltage EFFVC is given by\n\n  Abs[ weff Vcacc + I dVcacc/dt ] / weff ,\n\nwhere Vcacc, weff are total acce\
leration voltage at the equilibrium phase PHICAV and the effective RF angular frequency (=2 Pi EFFRFFREQ). DVcacc/dt is the time d\
erivative of Vcacc. The quantity Vcacc and its derivatives are summed over all CAVIs and MULTs.\n It is set by EMITTANCE(EMIT) or \
Emittance[]. The unit is Volt. Effective with RING only."[1,Max[p0$2630,0]]//"<img  class=\"eqs\" SRC=\""//equ$2630//"\" />"//
   Help2HTML`oy$[" Effective peak rf voltage EFFVC is given by\n\n  Abs[ weff Vcacc + I dVcacc/dt ] / weff ,\n\nwhere Vcacc, weff \
are total acceleration voltage at the equilibrium phase PHICAV and the effective RF angular frequency (=2 Pi EFFRFFREQ). DVcacc/dt\
 is the time derivative of Vcacc. The quantity Vcacc and its derivatives are summed over all CAVIs and MULTs.\n It is set by EMITT\
ANCE(EMIT) or Emittance[]. The unit is Volt. Effective with RING only."[p2$2630,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L511>EFFVCRATIO</A> <A HREF=#L509>EFFRFFREQ</A> <A HREF=#L542>PHICAV</A></PRE>
<LI>
<H3><A NAME=L511>
EFFVCRATIO</A></H3>
<PRE>If[{},
 Help2HTML`oA$[
  " Ratio of (effective voltage)/(Sum[VOLT_k,{k}]) (default: 1). Set by EMITTANCE(EMIT) or Emittance[]. Effective with RING only."
  ],
 p$2633=1+p$2633[[1,2]];p1$2633=StringPosition[
    " Ratio of (effective voltage)/(Sum[VOLT_k,{k}]) (default: 1). Set by EMITTANCE(EMIT) or Emittance[]. Effective with RING only\
."[p$2633,-1],">::",1];
   p1$2633=If[p1$2633==={},126,-2+p$2633+p1$2633[[1,1]]];
  neq=Which[
     " Ratio of (effective voltage)/(Sum[VOLT_k,{k}]) (default: 1). Set by EMITTANCE(EMIT) or Emittance[]. Effective with RING onl\
y."[p$2633,4+p$2633]==="Text[",
    lx$2633:=Help2HTML`oa$;p$2633=5+p$2633;p1$2633-=1;p2$2633=5+p1$2633;p0$2633=-9+p$2633;If[(pe$2633=StringPosition[
         " Ratio of (effective voltage)/(Sum[VOLT_k,{k}]) (default: 1). Set by EMITTANCE(EMIT) or Emittance[]. Effective with RING\
 only."[p$2633,-2],";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression[
          " Ratio of (effective voltage)/(Sum[VOLT_k,{k}]) (default: 1). Set by EMITTANCE(EMIT) or Emittance[]. Effective with RIN\
G only."[p$2633+pe$2633[[1,2]],p1$2633]]],
        p1$2633=-2+p$2633+pe$2633[[1,1]]}[[
       1]],
      0],
    1,lx$2633:=Help2HTML`o9$;p2$2633=4+p1$2633;p0$2633=-4+p$2633;0];
  If[(equ$2633=
     Help2HTML`o8$[
      " Ratio of (effective voltage)/(Sum[VOLT_k,{k}]) (default: 1). Set by EMITTANCE(EMIT) or Emittance[]. Effective with RING on\
ly."[p$2633,p1$2633]])===
    Undefined,
   equ$2633="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        " Ratio of (effective voltage)/(Sum[VOLT_k,{k}]) (default: 1). Set by EMITTANCE(EMIT) or Emittance[]. Effective with RING \
only."[p$2633,p1$2633]]=
       equ$2633;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$2633},out$2633=lx$2633@Typeset[
          " Ratio of (effective voltage)/(Sum[VOLT_k,{k}]) (default: 1). Set by EMITTANCE(EMIT) or Emittance[]. Effective with RIN\
G only."[p$2633,p1$2633],Format->Help2HTML`oB$];
        System["mv -f "//out$2633//" "//equ$2633]];
      Exit[]]];
  " Ratio of (effective voltage)/(Sum[VOLT_k,{k}]) (default: 1). Set by EMITTANCE(EMIT) or Emittance[]. Effective with RING only."[
    1,Max[p0$2633,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2633//"\" />"//
   Help2HTML`oy$[
    " Ratio of (effective voltage)/(Sum[VOLT_k,{k}]) (default: 1). Set by EMITTANCE(EMIT) or Emittance[]. Effective with RING only\
."[p2$2633,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L542>PHICAV</A> <A HREF=#L510>EFFVC</A></PRE>
<LI>
<H3><A NAME=L512>
ElementValues</A></H3>
<PRE>If[{},
Help2HTML`oA$["ElementValues is a symbol to assign rules to determine values of keywords of elements or components. This is used t\
o give a dependence between keywords of different elements or components, or determine then by a parametric expression.\n\nUseage:\
  ElementValues = { key[elem] :> expr, ...}\n\nwhere\t\n\n   key:      keyword to specify a value (string).\n   elem:     String t\
o specify the elements or components, wildcards are allowed.\n   expr:     an expression which returs a real number to be set to t\
he elements or components.\t\n\nExample:  ElementValues = \n            { \"DX\"[\"QF1\"] :> \"DX\"[\"QD1\"]-0.001,\n             \
 \"DY\"[\"QF2.3\"] :> -\"DY\"[\"QD1.2\"],\n              \"ROTATE\"[\"QF*\"] :> f[x] }\n\nRemarks:\n\t\n1. Iff elem contains \".\"\
, it is recognized as components, otherwise as elements.\n2. In the r.h.s. of the rule, an expression like key[elem] is evaluated \
as either LINE[key, elem] or Element[key, elem], depending on elem has \".\".\n3. The expression expr can be any expression return\
ing a real number.\n4. Later rules overrides the former, if many rules apply on the same keyword of the same element.\n5. The rule\
 given by ElementValues overrides the relation given by COUP_LE command.\n6. Use a[b] in stead of a@b.\n7. ElementValues is cleare\
d by USE. It is hidden by VISIT and restored by BYE."],
p$2636=1+p$2636[[1,2]];p1$2636=StringPosition["ElementValues is a symbol to assign rules to determine values of keywords of elemen\
ts or components. This is used to give a dependence between keywords of different elements or components, or determine then by a p\
arametric expression.\n\nUseage:  ElementValues = { key[elem] :> expr, ...}\n\nwhere\t\n\n   key:      keyword to specify a value \
(string).\n   elem:     String to specify the elements or components, wildcards are allowed.\n   expr:     an expression which ret\
urs a real number to be set to the elements or components.\t\n\nExample:  ElementValues = \n            { \"DX\"[\"QF1\"] :> \"DX\\
"[\"QD1\"]-0.001,\n              \"DY\"[\"QF2.3\"] :> -\"DY\"[\"QD1.2\"],\n              \"ROTATE\"[\"QF*\"] :> f[x] }\n\nRemarks:\
\n\t\n1. Iff elem contains \".\", it is recognized as components, otherwise as elements.\n2. In the r.h.s. of the rule, an express\
ion like key[elem] is evaluated as either LINE[key, elem] or Element[key, elem], depending on elem has \".\".\n3. The expression e\
xpr can be any expression returning a real number.\n4. Later rules overrides the former, if many rules apply on the same keyword o\
f the same element.\n5. The rule given by ElementValues overrides the relation given by COUP_LE command.\n6. Use a[b] in stead of \
a@b.\n7. ElementValues is cleared by USE. It is hidden by VISIT and restored by BYE."[p$2636,-1],">::",1];
   p1$2636=If[p1$2636==={},1287,-2+p$2636+p1$2636[[1,1]]];
neq=Which["ElementValues is a symbol to assign rules to determine values of keywords of elements or components. This is used to gi\
ve a dependence between keywords of different elements or components, or determine then by a parametric expression.\n\nUseage:  El\
ementValues = { key[elem] :> expr, ...}\n\nwhere\t\n\n   key:      keyword to specify a value (string).\n   elem:     String to sp\
ecify the elements or components, wildcards are allowed.\n   expr:     an expression which returs a real number to be set to the e\
lements or components.\t\n\nExample:  ElementValues = \n            { \"DX\"[\"QF1\"] :> \"DX\"[\"QD1\"]-0.001,\n              \"D\
Y\"[\"QF2.3\"] :> -\"DY\"[\"QD1.2\"],\n              \"ROTATE\"[\"QF*\"] :> f[x] }\n\nRemarks:\n\t\n1. Iff elem contains \".\", it\
 is recognized as components, otherwise as elements.\n2. In the r.h.s. of the rule, an expression like key[elem] is evaluated as e\
ither LINE[key, elem] or Element[key, elem], depending on elem has \".\".\n3. The expression expr can be any expression returning \
a real number.\n4. Later rules overrides the former, if many rules apply on the same keyword of the same element.\n5. The rule giv\
en by ElementValues overrides the relation given by COUP_LE command.\n6. Use a[b] in stead of a@b.\n7. ElementValues is cleared by\
 USE. It is hidden by VISIT and restored by BYE."[p$2636,4+p$2636]==="Text[",
    lx$2636:=Help2HTML`oa$;p$2636=5+p$2636;p1$2636-=1;p2$2636=5+p1$2636;p0$2636=-9+p$2636;
If[(pe$2636=StringPosition["ElementValues is a symbol to assign rules to determine values of keywords of elements or components. T\
his is used to give a dependence between keywords of different elements or components, or determine then by a parametric expressio\
n.\n\nUseage:  ElementValues = { key[elem] :> expr, ...}\n\nwhere\t\n\n   key:      keyword to specify a value (string).\n   elem:\
     String to specify the elements or components, wildcards are allowed.\n   expr:     an expression which returs a real number t\
o be set to the elements or components.\t\n\nExample:  ElementValues = \n            { \"DX\"[\"QF1\"] :> \"DX\"[\"QD1\"]-0.001,\n\
              \"DY\"[\"QF2.3\"] :> -\"DY\"[\"QD1.2\"],\n              \"ROTATE\"[\"QF*\"] :> f[x] }\n\nRemarks:\n\t\n1. Iff elem c\
ontains \".\", it is recognized as components, otherwise as elements.\n2. In the r.h.s. of the rule, an expression like key[elem] \
is evaluated as either LINE[key, elem] or Element[key, elem], depending on elem has \".\".\n3. The expression expr can be any expr\
ession returning a real number.\n4. Later rules overrides the former, if many rules apply on the same keyword of the same element.\
\n5. The rule given by ElementValues overrides the relation given by COUP_LE command.\n6. Use a[b] in stead of a@b.\n7. ElementVal\
ues is cleared by USE. It is hidden by VISIT and restored by BYE."[p$2636,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["ElementValues is a symbol to assign rules to determine values of keywords of elements or components. This is used\
 to give a dependence between keywords of different elements or components, or determine then by a parametric expression.\n\nUseag\
e:  ElementValues = { key[elem] :> expr, ...}\n\nwhere\t\n\n   key:      keyword to specify a value (string).\n   elem:     String\
 to specify the elements or components, wildcards are allowed.\n   expr:     an expression which returs a real number to be set to\
 the elements or components.\t\n\nExample:  ElementValues = \n            { \"DX\"[\"QF1\"] :> \"DX\"[\"QD1\"]-0.001,\n           \
   \"DY\"[\"QF2.3\"] :> -\"DY\"[\"QD1.2\"],\n              \"ROTATE\"[\"QF*\"] :> f[x] }\n\nRemarks:\n\t\n1. Iff elem contains \".\
\", it is recognized as components, otherwise as elements.\n2. In the r.h.s. of the rule, an expression like key[elem] is evaluate\
d as either LINE[key, elem] or Element[key, elem], depending on elem has \".\".\n3. The expression expr can be any expression retu\
rning a real number.\n4. Later rules overrides the former, if many rules apply on the same keyword of the same element.\n5. The ru\
le given by ElementValues overrides the relation given by COUP_LE command.\n6. Use a[b] in stead of a@b.\n7. ElementValues is clea\
red by USE. It is hidden by VISIT and restored by BYE."[p$2636+pe$2636[[1,2]],p1$2636]]],
        p1$2636=-2+p$2636+pe$2636[[1,1]]}[[
       1]],
      0],
    1,lx$2636:=Help2HTML`o9$;p2$2636=4+p1$2636;p0$2636=-4+p$2636;0];
  If[(equ$2636=
Help2HTML`o8$["ElementValues is a symbol to assign rules to determine values of keywords of elements or components. This is used t\
o give a dependence between keywords of different elements or components, or determine then by a parametric expression.\n\nUseage:\
  ElementValues = { key[elem] :> expr, ...}\n\nwhere\t\n\n   key:      keyword to specify a value (string).\n   elem:     String t\
o specify the elements or components, wildcards are allowed.\n   expr:     an expression which returs a real number to be set to t\
he elements or components.\t\n\nExample:  ElementValues = \n            { \"DX\"[\"QF1\"] :> \"DX\"[\"QD1\"]-0.001,\n             \
 \"DY\"[\"QF2.3\"] :> -\"DY\"[\"QD1.2\"],\n              \"ROTATE\"[\"QF*\"] :> f[x] }\n\nRemarks:\n\t\n1. Iff elem contains \".\"\
, it is recognized as components, otherwise as elements.\n2. In the r.h.s. of the rule, an expression like key[elem] is evaluated \
as either LINE[key, elem] or Element[key, elem], depending on elem has \".\".\n3. The expression expr can be any expression return\
ing a real number.\n4. Later rules overrides the former, if many rules apply on the same keyword of the same element.\n5. The rule\
 given by ElementValues overrides the relation given by COUP_LE command.\n6. Use a[b] in stead of a@b.\n7. ElementValues is cleare\
d by USE. It is hidden by VISIT and restored by BYE."[p$2636,p1$2636]])===
    Undefined,
equ$2636="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["ElementValues is a symbol to assign rules to\
 determine values of keywords of elements or components. This is used to give a dependence between keywords of different elements \
or components, or determine then by a parametric expression.\n\nUseage:  ElementValues = { key[elem] :> expr, ...}\n\nwhere\t\n\n \
  key:      keyword to specify a value (string).\n   elem:     String to specify the elements or components, wildcards are allowed\
.\n   expr:     an expression which returs a real number to be set to the elements or components.\t\n\nExample:  ElementValues = \\
n            { \"DX\"[\"QF1\"] :> \"DX\"[\"QD1\"]-0.001,\n              \"DY\"[\"QF2.3\"] :> -\"DY\"[\"QD1.2\"],\n              \"\
ROTATE\"[\"QF*\"] :> f[x] }\n\nRemarks:\n\t\n1. Iff elem contains \".\", it is recognized as components, otherwise as elements.\n2\
. In the r.h.s. of the rule, an expression like key[elem] is evaluated as either LINE[key, elem] or Element[key, elem], depending \
on elem has \".\".\n3. The expression expr can be any expression returning a real number.\n4. Later rules overrides the former, if\
 many rules apply on the same keyword of the same element.\n5. The rule given by ElementValues overrides the relation given by COU\
P_LE command.\n6. Use a[b] in stead of a@b.\n7. ElementValues is cleared by USE. It is hidden by VISIT and restored by BYE."[p$2636
         ,p1$2636]]=
       equ$2636;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2636},out$2636=lx$2636@Typeset["ElementValues is a symbol to assign rules to determine values of keywords of elements or \
components. This is used to give a dependence between keywords of different elements or components, or determine then by a paramet\
ric expression.\n\nUseage:  ElementValues = { key[elem] :> expr, ...}\n\nwhere\t\n\n   key:      keyword to specify a value (strin\
g).\n   elem:     String to specify the elements or components, wildcards are allowed.\n   expr:     an expression which returs a \
real number to be set to the elements or components.\t\n\nExample:  ElementValues = \n            { \"DX\"[\"QF1\"] :> \"DX\"[\"QD\
1\"]-0.001,\n              \"DY\"[\"QF2.3\"] :> -\"DY\"[\"QD1.2\"],\n              \"ROTATE\"[\"QF*\"] :> f[x] }\n\nRemarks:\n\t\n\
1. Iff elem contains \".\", it is recognized as components, otherwise as elements.\n2. In the r.h.s. of the rule, an expression li\
ke key[elem] is evaluated as either LINE[key, elem] or Element[key, elem], depending on elem has \".\".\n3. The expression expr ca\
n be any expression returning a real number.\n4. Later rules overrides the former, if many rules apply on the same keyword of the \
same element.\n5. The rule given by ElementValues overrides the relation given by COUP_LE command.\n6. Use a[b] in stead of a@b.\n\
7. ElementValues is cleared by USE. It is hidden by VISIT and restored by BYE."[p$2636,p1$2636],Format->Help2HTML`oB$];
        System["mv -f "//out$2636//" "//equ$2636]];
      Exit[]]];
   "ElementValues is a symbol to assign rules to determine values of keywords of elements or components. This is used to give a de\
pendence between keywords of different elements or components, or determine then by a parametric expression.\n\nUseage:  ElementVa\
lues = { key[elem] :> expr, ...}\n\nwhere\t\n\n   key:      keyword to specify a value (string).\n   elem:     String to specify t\
he elements or components, wildcards are allowed.\n   expr:     an expression which returs a real number to be set to the elements\
 or components.\t\n\nExample:  ElementValues = \n            { \"DX\"[\"QF1\"] :> \"DX\"[\"QD1\"]-0.001,\n              \"DY\"[\"Q\
F2.3\"] :> -\"DY\"[\"QD1.2\"],\n              \"ROTATE\"[\"QF*\"] :> f[x] }\n\nRemarks:\n\t\n1. Iff elem contains \".\", it is rec\
ognized as components, otherwise as elements.\n2. In the r.h.s. of the rule, an expression like key[elem] is evaluated as either L\
INE[key, elem] or Element[key, elem], depending on elem has \".\".\n3. The expression expr can be any expression returning a real \
number.\n4. Later rules overrides the former, if many rules apply on the same keyword of the same element.\n5. The rule given by E\
lementValues overrides the relation given by COUP_LE command.\n6. Use a[b] in stead of a@b.\n7. ElementValues is cleared by USE. I\
t is hidden by VISIT and restored by BYE."[1,Max[p0$2636,0]]//"<img  class=\"eqs\" SRC=\""//equ$2636//"\" />"//
Help2HTML`oy$["ElementValues is a symbol to assign rules to determine values of keywords of elements or components. This is used t\
o give a dependence between keywords of different elements or components, or determine then by a parametric expression.\n\nUseage:\
  ElementValues = { key[elem] :> expr, ...}\n\nwhere\t\n\n   key:      keyword to specify a value (string).\n   elem:     String t\
o specify the elements or components, wildcards are allowed.\n   expr:     an expression which returs a real number to be set to t\
he elements or components.\t\n\nExample:  ElementValues = \n            { \"DX\"[\"QF1\"] :> \"DX\"[\"QD1\"]-0.001,\n             \
 \"DY\"[\"QF2.3\"] :> -\"DY\"[\"QD1.2\"],\n              \"ROTATE\"[\"QF*\"] :> f[x] }\n\nRemarks:\n\t\n1. Iff elem contains \".\"\
, it is recognized as components, otherwise as elements.\n2. In the r.h.s. of the rule, an expression like key[elem] is evaluated \
as either LINE[key, elem] or Element[key, elem], depending on elem has \".\".\n3. The expression expr can be any expression return\
ing a real number.\n4. Later rules overrides the former, if many rules apply on the same keyword of the same element.\n5. The rule\
 given by ElementValues overrides the relation given by COUP_LE command.\n6. Use a[b] in stead of a@b.\n7. ElementValues is cleare\
d by USE. It is hidden by VISIT and restored by BYE."[p2$2636,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L35>COUPLE(COUP)</A></PRE>
<LI>
<H3><A NAME=L513>
EMITX</A></H3>
<PRE>If[{},
Help2HTML`oA$["EMITX is a real variable for the horizontal emittance (not normalized by gamma beta). It is automatically set by th\
e keyword EMITX of the MARK element at the beginning of the beam line. The EMITTANCE(EMIT) command returns its calculated value in\
 EMITX. The value of EMITX affects the default weight of variables in the matching. Accessible in MAIN."],
 p$2639=1+p$2639[[1,2]];p1$2639=
StringPosition["EMITX is a real variable for the horizontal emittance (not normalized by gamma beta). It is automatically set by t\
he keyword EMITX of the MARK element at the beginning of the beam line. The EMITTANCE(EMIT) command returns its calculated value i\
n EMITX. The value of EMITX affects the default weight of variables in the matching. Accessible in MAIN."[p$2639,-1],">::",1];
   p1$2639=If[p1$2639==={},348,-2+p$2639+p1$2639[[1,1]]];
neq=Which["EMITX is a real variable for the horizontal emittance (not normalized by gamma beta). It is automatically set by the ke\
yword EMITX of the MARK element at the beginning of the beam line. The EMITTANCE(EMIT) command returns its calculated value in EMI\
TX. The value of EMITX affects the default weight of variables in the matching. Accessible in MAIN."[p$2639,4+p$2639]==="Text[",
    lx$2639:=Help2HTML`oa$;p$2639=5+p$2639;p1$2639-=1;p2$2639=5+p1$2639;p0$2639=-9+p$2639;
If[(pe$2639=StringPosition["EMITX is a real variable for the horizontal emittance (not normalized by gamma beta). It is automatica\
lly set by the keyword EMITX of the MARK element at the beginning of the beam line. The EMITTANCE(EMIT) command returns its calcul\
ated value in EMITX. The value of EMITX affects the default weight of variables in the matching. Accessible in MAIN."[p$2639,-2],
         ";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["EMITX is a real variable for the horizontal emittance (not normalized by gamma beta). It is automatically set by \
the keyword EMITX of the MARK element at the beginning of the beam line. The EMITTANCE(EMIT) command returns its calculated value \
in EMITX. The value of EMITX affects the default weight of variables in the matching. Accessible in MAIN."[p$2639+pe$2639[[1,2]],
           p1$2639]]],
        p1$2639=-2+p$2639+pe$2639[[1,1]]}[[
       1]],
      0],
    1,lx$2639:=Help2HTML`o9$;p2$2639=4+p1$2639;p0$2639=-4+p$2639;0];
  If[(equ$2639=
Help2HTML`o8$["EMITX is a real variable for the horizontal emittance (not normalized by gamma beta). It is automatically set by th\
e keyword EMITX of the MARK element at the beginning of the beam line. The EMITTANCE(EMIT) command returns its calculated value in\
 EMITX. The value of EMITX affects the default weight of variables in the matching. Accessible in MAIN."[p$2639,p1$2639]])===
    Undefined,
equ$2639="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["EMITX is a real variable for the horizontal \
emittance (not normalized by gamma beta). It is automatically set by the keyword EMITX of the MARK element at the beginning of the\
 beam line. The EMITTANCE(EMIT) command returns its calculated value in EMITX. The value of EMITX affects the default weight of va\
riables in the matching. Accessible in MAIN."[p$2639,p1$2639]]=
       equ$2639;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2639},out$2639=lx$2639@Typeset["EMITX is a real variable for the horizontal emittance (not normalized by gamma beta). It \
is automatically set by the keyword EMITX of the MARK element at the beginning of the beam line. The EMITTANCE(EMIT) command retur\
ns its calculated value in EMITX. The value of EMITX affects the default weight of variables in the matching. Accessible in MAIN."[
           p$2639,p1$2639],Format->Help2HTML`oB$];
        System["mv -f "//out$2639//" "//equ$2639]];
      Exit[]]];
   "EMITX is a real variable for the horizontal emittance (not normalized by gamma beta). It is automatically set by the keyword E\
MITX of the MARK element at the beginning of the beam line. The EMITTANCE(EMIT) command returns its calculated value in EMITX. The\
 value of EMITX affects the default weight of variables in the matching. Accessible in MAIN."[1,Max[p0$2639,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2639//"\" />"//
Help2HTML`oy$["EMITX is a real variable for the horizontal emittance (not normalized by gamma beta). It is automatically set by th\
e keyword EMITX of the MARK element at the beginning of the beam line. The EMITTANCE(EMIT) command returns its calculated value in\
 EMITX. The value of EMITX affects the default weight of variables in the matching. Accessible in MAIN."[p2$2639,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L515>EMITY</A> <A HREF=#L517>EMITZ</A> <A HREF=#L544>SIGZ</A> <A HREF=#L543>SIGE</A> <A HREF=#L506>DP</A> <A HREF=#L75>elements</A> <A HREF=#L137>MARK</A></PRE>
<LI>
<H3><A NAME=L514>
EMITXE</A></H3>
<PRE>If[{},
Help2HTML`oA$["EMITXE specifies the minimum horizontal emittance for EMITTANCE(EMIT) and Emittance[] calculations. It is useful to\
 give emittance determined externally, such as for proton machines."],
p$2642=1+p$2642[[1,2]];p1$2642=StringPosition["EMITXE specifies the minimum horizontal emittance for EMITTANCE(EMIT) and Emittance\
[] calculations. It is useful to give emittance determined externally, such as for proton machines."[p$2642,-1],">::",1];
   p1$2642=If[p1$2642==={},182,-2+p$2642+p1$2642[[1,1]]];
neq=Which["EMITXE specifies the minimum horizontal emittance for EMITTANCE(EMIT) and Emittance[] calculations. It is useful to giv\
e emittance determined externally, such as for proton machines."[p$2642,4+p$2642]==="Text[",
    lx$2642:=Help2HTML`oa$;p$2642=5+p$2642;p1$2642-=1;p2$2642=5+p1$2642;p0$2642=-9+p$2642;
If[(pe$2642=StringPosition["EMITXE specifies the minimum horizontal emittance for EMITTANCE(EMIT) and Emittance[] calculations. It\
 is useful to give emittance determined externally, such as for proton machines."[p$2642,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["EMITXE specifies the minimum horizontal emittance for EMITTANCE(EMIT) and Emittance[] calculations. It is useful \
to give emittance determined externally, such as for proton machines."[p$2642+pe$2642[[1,2]],p1$2642]]],
        p1$2642=-2+p$2642+pe$2642[[1,1]]}[[
       1]],
      0],
    1,lx$2642:=Help2HTML`o9$;p2$2642=4+p1$2642;p0$2642=-4+p$2642;0];
  If[(equ$2642=
Help2HTML`o8$["EMITXE specifies the minimum horizontal emittance for EMITTANCE(EMIT) and Emittance[] calculations. It is useful to\
 give emittance determined externally, such as for proton machines."[p$2642,p1$2642]])===
    Undefined,
equ$2642="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["EMITXE specifies the minimum horizontal emit\
tance for EMITTANCE(EMIT) and Emittance[] calculations. It is useful to give emittance determined externally, such as for proton m\
achines."[p$2642,p1$2642]]=
       equ$2642;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2642},out$2642=lx$2642@Typeset["EMITXE specifies the minimum horizontal emittance for EMITTANCE(EMIT) and Emittance[] cal\
culations. It is useful to give emittance determined externally, such as for proton machines."[p$2642,p1$2642],
          Format->Help2HTML`oB$];
        System["mv -f "//out$2642//" "//equ$2642]];
      Exit[]]];
   "EMITXE specifies the minimum horizontal emittance for EMITTANCE(EMIT) and Emittance[] calculations. It is useful to give emitt\
ance determined externally, such as for proton machines."[1,Max[p0$2642,0]]//"<img  class=\"eqs\" SRC=\""//equ$2642//"\" />"//
   Help2HTML`oy$["EMITXE specifies the minimum horizontal emittance for EMITTANCE(EMIT) and Emittance[] calculations. It is useful\
 to give emittance determined externally, such as for proton machines."[p2$2642,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L516>EMITYE</A> <A HREF=#L518>EMITZE</A></PRE>
<LI>
<H3><A NAME=L515>
EMITY</A></H3>
<PRE>If[{},
Help2HTML`oA$["EMITY is a real variable for the vertical emittance (not normalized by gamma beta). It is automatically set by the \
keyword EMITY of the MARK element at the beginning of the beam line. The EMITTANCE(EMIT) command returns its calculated value in E\
MITY. The value of EMITY affects the default wei\303\267ht of variables in the matching. Accessible in MAIN."],
 p$2645=1+p$2645[[1,2]];
p1$2645=StringPosition["EMITY is a real variable for the vertical emittance (not normalized by gamma beta). It is automatically se\
t by the keyword EMITY of the MARK element at the beginning of the beam line. The EMITTANCE(EMIT) command returns its calculated v\
alue in EMITY. The value of EMITY affects the default wei\303\267ht of variables in the matching. Accessible in MAIN."[p$2645,-1],
    ">::",1];
   p1$2645=If[p1$2645==={},347,-2+p$2645+p1$2645[[1,1]]];
neq=Which["EMITY is a real variable for the vertical emittance (not normalized by gamma beta). It is automatically set by the keyw\
ord EMITY of the MARK element at the beginning of the beam line. The EMITTANCE(EMIT) command returns its calculated value in EMITY\
. The value of EMITY affects the default wei\303\267ht of variables in the matching. Accessible in MAIN."[p$2645,4+p$2645]===
     "Text[",
lx$2645:=Help2HTML`oa$;p$2645=5+p$2645;p1$2645-=1;p2$2645=5+p1$2645;p0$2645=-9+p$2645;If[(pe$2645=StringPosition["EMITY is a real \
variable for the vertical emittance (not normalized by gamma beta). It is automatically set by the keyword EMITY of the MARK eleme\
nt at the beginning of the beam line. The EMITTANCE(EMIT) command returns its calculated value in EMITY. The value of EMITY affect\
s the default wei\303\267ht of variables in the matching. Accessible in MAIN."[p$2645,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["EMITY is a real variable for the vertical emittance (not normalized by gamma beta). It is automatically set by th\
e keyword EMITY of the MARK element at the beginning of the beam line. The EMITTANCE(EMIT) command returns its calculated value in\
 EMITY. The value of EMITY affects the default wei\303\267ht of variables in the matching. Accessible in MAIN."[p$2645+
            pe$2645[[1,2]],
           p1$2645]]],
        p1$2645=-2+p$2645+pe$2645[[1,1]]}[[
       1]],
      0],
    1,lx$2645:=Help2HTML`o9$;p2$2645=4+p1$2645;p0$2645=-4+p$2645;0];
  If[(equ$2645=
Help2HTML`o8$["EMITY is a real variable for the vertical emittance (not normalized by gamma beta). It is automatically set by the \
keyword EMITY of the MARK element at the beginning of the beam line. The EMITTANCE(EMIT) command returns its calculated value in E\
MITY. The value of EMITY affects the default wei\303\267ht of variables in the matching. Accessible in MAIN."[p$2645,p1$2645]])===
    Undefined,
equ$2645="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["EMITY is a real variable for the vertical em\
ittance (not normalized by gamma beta). It is automatically set by the keyword EMITY of the MARK element at the beginning of the b\
eam line. The EMITTANCE(EMIT) command returns its calculated value in EMITY. The value of EMITY affects the default wei\303\267ht \
of variables in the matching. Accessible in MAIN."[p$2645,p1$2645]]=
       equ$2645;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2645},out$2645=lx$2645@Typeset["EMITY is a real variable for the vertical emittance (not normalized by gamma beta). It is\
 automatically set by the keyword EMITY of the MARK element at the beginning of the beam line. The EMITTANCE(EMIT) command returns\
 its calculated value in EMITY. The value of EMITY affects the default wei\303\267ht of variables in the matching. Accessible in M\
AIN."[p$2645,p1$2645],Format->Help2HTML`oB$];
        System["mv -f "//out$2645//" "//equ$2645]];
      Exit[]]];
   "EMITY is a real variable for the vertical emittance (not normalized by gamma beta). It is automatically set by the keyword EMI\
TY of the MARK element at the beginning of the beam line. The EMITTANCE(EMIT) command returns its calculated value in EMITY. The v\
alue of EMITY affects the default wei\303\267ht of variables in the matching. Accessible in MAIN."[1,Max[p0$2645,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2645//"\" />"//
Help2HTML`oy$["EMITY is a real variable for the vertical emittance (not normalized by gamma beta). It is automatically set by the \
keyword EMITY of the MARK element at the beginning of the beam line. The EMITTANCE(EMIT) command returns its calculated value in E\
MITY. The value of EMITY affects the default wei\303\267ht of variables in the matching. Accessible in MAIN."[p2$2645,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L513>EMITX</A> <A HREF=#L517>EMITZ</A> <A HREF=#L544>SIGZ</A> <A HREF=#L543>SIGE</A> <A HREF=#L506>DP</A> <A HREF=#L75>elements</A> <A HREF=#L137>MARK</A></PRE>
<LI>
<H3><A NAME=L516>
EMITYE</A></H3>
<PRE>If[{},
Help2HTML`oA$["EMITYE specifies the minimum vertical emittance for EMITTANCE(EMIT) and Emittance[] calculations. It is useful to g\
ive emittance determined externally, such as for proton machines."],
p$2648=1+p$2648[[1,2]];p1$2648=StringPosition["EMITYE specifies the minimum vertical emittance for EMITTANCE(EMIT) and Emittance[]\
 calculations. It is useful to give emittance determined externally, such as for proton machines."[p$2648,-1],">::",1];
   p1$2648=If[p1$2648==={},180,-2+p$2648+p1$2648[[1,1]]];
neq=Which["EMITYE specifies the minimum vertical emittance for EMITTANCE(EMIT) and Emittance[] calculations. It is useful to give \
emittance determined externally, such as for proton machines."[p$2648,4+p$2648]==="Text[",
    lx$2648:=Help2HTML`oa$;p$2648=5+p$2648;p1$2648-=1;p2$2648=5+p1$2648;p0$2648=-9+p$2648;
If[(pe$2648=StringPosition["EMITYE specifies the minimum vertical emittance for EMITTANCE(EMIT) and Emittance[] calculations. It i\
s useful to give emittance determined externally, such as for proton machines."[p$2648,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["EMITYE specifies the minimum vertical emittance for EMITTANCE(EMIT) and Emittance[] calculations. It is useful to\
 give emittance determined externally, such as for proton machines."[p$2648+pe$2648[[1,2]],p1$2648]]],
        p1$2648=-2+p$2648+pe$2648[[1,1]]}[[
       1]],
      0],
    1,lx$2648:=Help2HTML`o9$;p2$2648=4+p1$2648;p0$2648=-4+p$2648;0];
  If[(equ$2648=
Help2HTML`o8$["EMITYE specifies the minimum vertical emittance for EMITTANCE(EMIT) and Emittance[] calculations. It is useful to g\
ive emittance determined externally, such as for proton machines."[p$2648,p1$2648]])===
    Undefined,
equ$2648="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["EMITYE specifies the minimum vertical emitta\
nce for EMITTANCE(EMIT) and Emittance[] calculations. It is useful to give emittance determined externally, such as for proton mac\
hines."[p$2648,p1$2648]]=
       equ$2648;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2648},out$2648=lx$2648@Typeset["EMITYE specifies the minimum vertical emittance for EMITTANCE(EMIT) and Emittance[] calcu\
lations. It is useful to give emittance determined externally, such as for proton machines."[p$2648,p1$2648],
          Format->Help2HTML`oB$];
        System["mv -f "//out$2648//" "//equ$2648]];
      Exit[]]];
   "EMITYE specifies the minimum vertical emittance for EMITTANCE(EMIT) and Emittance[] calculations. It is useful to give emittan\
ce determined externally, such as for proton machines."[1,Max[p0$2648,0]]//"<img  class=\"eqs\" SRC=\""//equ$2648//"\" />"//
   Help2HTML`oy$["EMITYE specifies the minimum vertical emittance for EMITTANCE(EMIT) and Emittance[] calculations. It is useful t\
o give emittance determined externally, such as for proton machines."[p2$2648,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L514>EMITXE</A> <A HREF=#L518>EMITZE</A></PRE>
<LI>
<H3><A NAME=L517>
EMITZ</A></H3>
<PRE>If[{},
Help2HTML`oA$["EMITZ is a real variable for the longitudinal emittance (not normalized by gamma beta). It is automatically set by \
the keyword EMITZ of the MARK element at the beginning of the beam line. The EMITTANCE(EMIT) command returns its calculated value \
in EMITZ. Accessible in MAIN."],
p$2651=1+p$2651[[1,2]];p1$2651=StringPosition["EMITZ is a real variable for the longitudinal emittance (not normalized by gamma be\
ta). It is automatically set by the keyword EMITZ of the MARK element at the beginning of the beam line. The EMITTANCE(EMIT) comma\
nd returns its calculated value in EMITZ. Accessible in MAIN."[p$2651,-1],">::",1];
   p1$2651=If[p1$2651==={},274,-2+p$2651+p1$2651[[1,1]]];
neq=Which["EMITZ is a real variable for the longitudinal emittance (not normalized by gamma beta). It is automatically set by the \
keyword EMITZ of the MARK element at the beginning of the beam line. The EMITTANCE(EMIT) command returns its calculated value in E\
MITZ. Accessible in MAIN."[p$2651,4+p$2651]==="Text[",
    lx$2651:=Help2HTML`oa$;p$2651=5+p$2651;p1$2651-=1;p2$2651=5+p1$2651;p0$2651=-9+p$2651;
If[(pe$2651=StringPosition["EMITZ is a real variable for the longitudinal emittance (not normalized by gamma beta). It is automati\
cally set by the keyword EMITZ of the MARK element at the beginning of the beam line. The EMITTANCE(EMIT) command returns its calc\
ulated value in EMITZ. Accessible in MAIN."[p$2651,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["EMITZ is a real variable for the longitudinal emittance (not normalized by gamma beta). It is automatically set b\
y the keyword EMITZ of the MARK element at the beginning of the beam line. The EMITTANCE(EMIT) command returns its calculated valu\
e in EMITZ. Accessible in MAIN."[p$2651+pe$2651[[1,2]],p1$2651]]],
        p1$2651=-2+p$2651+pe$2651[[1,1]]}[[
       1]],
      0],
    1,lx$2651:=Help2HTML`o9$;p2$2651=4+p1$2651;p0$2651=-4+p$2651;0];
  If[(equ$2651=
Help2HTML`o8$["EMITZ is a real variable for the longitudinal emittance (not normalized by gamma beta). It is automatically set by \
the keyword EMITZ of the MARK element at the beginning of the beam line. The EMITTANCE(EMIT) command returns its calculated value \
in EMITZ. Accessible in MAIN."[p$2651,p1$2651]])===
    Undefined,
equ$2651="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["EMITZ is a real variable for the longitudina\
l emittance (not normalized by gamma beta). It is automatically set by the keyword EMITZ of the MARK element at the beginning of t\
he beam line. The EMITTANCE(EMIT) command returns its calculated value in EMITZ. Accessible in MAIN."[p$2651,p1$2651]]=
       equ$2651;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2651},out$2651=lx$2651@Typeset["EMITZ is a real variable for the longitudinal emittance (not normalized by gamma beta). I\
t is automatically set by the keyword EMITZ of the MARK element at the beginning of the beam line. The EMITTANCE(EMIT) command ret\
urns its calculated value in EMITZ. Accessible in MAIN."[p$2651,p1$2651],Format->Help2HTML`oB$];
        System["mv -f "//out$2651//" "//equ$2651]];
      Exit[]]];
   "EMITZ is a real variable for the longitudinal emittance (not normalized by gamma beta). It is automatically set by the keyword\
 EMITZ of the MARK element at the beginning of the beam line. The EMITTANCE(EMIT) command returns its calculated value in EMITZ. A\
ccessible in MAIN."[1,Max[p0$2651,0]]//"<img  class=\"eqs\" SRC=\""//equ$2651//"\" />"//
Help2HTML`oy$["EMITZ is a real variable for the longitudinal emittance (not normalized by gamma beta). It is automatically set by \
the keyword EMITZ of the MARK element at the beginning of the beam line. The EMITTANCE(EMIT) command returns its calculated value \
in EMITZ. Accessible in MAIN."[p2$2651,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L513>EMITX</A> <A HREF=#L515>EMITY</A> <A HREF=#L544>SIGZ</A> <A HREF=#L543>SIGE</A> <A HREF=#L506>DP</A> <A HREF=#L75>elements</A> <A HREF=#L137>MARK</A></PRE>
<LI>
<H3><A NAME=L518>
EMITZE</A></H3>
<PRE>If[{},
Help2HTML`oA$["EMITZE specifies the minimum longitudinal emittance for EMITTANCE(EMIT) and Emittance[] calculations. It is useful \
to give emittance determined externally, such as for proton machines."],
p$2654=1+p$2654[[1,2]];p1$2654=StringPosition["EMITZE specifies the minimum longitudinal emittance for EMITTANCE(EMIT) and Emittan\
ce[] calculations. It is useful to give emittance determined externally, such as for proton machines."[p$2654,-1],">::",1];
   p1$2654=If[p1$2654==={},184,-2+p$2654+p1$2654[[1,1]]];
neq=Which["EMITZE specifies the minimum longitudinal emittance for EMITTANCE(EMIT) and Emittance[] calculations. It is useful to g\
ive emittance determined externally, such as for proton machines."[p$2654,4+p$2654]==="Text[",
    lx$2654:=Help2HTML`oa$;p$2654=5+p$2654;p1$2654-=1;p2$2654=5+p1$2654;p0$2654=-9+p$2654;
If[(pe$2654=StringPosition["EMITZE specifies the minimum longitudinal emittance for EMITTANCE(EMIT) and Emittance[] calculations. \
It is useful to give emittance determined externally, such as for proton machines."[p$2654,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["EMITZE specifies the minimum longitudinal emittance for EMITTANCE(EMIT) and Emittance[] calculations. It is usefu\
l to give emittance determined externally, such as for proton machines."[p$2654+pe$2654[[1,2]],p1$2654]]],
        p1$2654=-2+p$2654+pe$2654[[1,1]]}[[
       1]],
      0],
    1,lx$2654:=Help2HTML`o9$;p2$2654=4+p1$2654;p0$2654=-4+p$2654;0];
  If[(equ$2654=
Help2HTML`o8$["EMITZE specifies the minimum longitudinal emittance for EMITTANCE(EMIT) and Emittance[] calculations. It is useful \
to give emittance determined externally, such as for proton machines."[p$2654,p1$2654]])===
    Undefined,
equ$2654="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["EMITZE specifies the minimum longitudinal em\
ittance for EMITTANCE(EMIT) and Emittance[] calculations. It is useful to give emittance determined externally, such as for proton\
 machines."[p$2654,p1$2654]]=
       equ$2654;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2654},out$2654=lx$2654@Typeset["EMITZE specifies the minimum longitudinal emittance for EMITTANCE(EMIT) and Emittance[] c\
alculations. It is useful to give emittance determined externally, such as for proton machines."[p$2654,p1$2654],
          Format->Help2HTML`oB$];
        System["mv -f "//out$2654//" "//equ$2654]];
      Exit[]]];
   "EMITZE specifies the minimum longitudinal emittance for EMITTANCE(EMIT) and Emittance[] calculations. It is useful to give emi\
ttance determined externally, such as for proton machines."[1,Max[p0$2654,0]]//"<img  class=\"eqs\" SRC=\""//equ$2654//"\" />"//
   Help2HTML`oy$["EMITZE specifies the minimum longitudinal emittance for EMITTANCE(EMIT) and Emittance[] calculations. It is usef\
ul to give emittance determined externally, such as for proton machines."[p2$2654,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L514>EMITXE</A> <A HREF=#L516>EMITYE</A></PRE>
<LI>
<H3><A NAME=L519>
ExponentOfResidual</A></H3>
<PRE>If[{},Help2HTML`oA$["The exponent to calculate MatchinResidual. The default is 2."],
 p$2657=1+p$2657[[1,2]];p1$2657=StringPosition["The exponent to calculate MatchinResidual. The default is 2."[p$2657,-1],">::",1];
  p1$2657=If[p1$2657==={},60,-2+p$2657+p1$2657[[1,1]]];
  neq=Which["The exponent to calculate MatchinResidual. The default is 2."[p$2657,4+p$2657]==="Text[",
    lx$2657:=Help2HTML`oa$;p$2657=5+p$2657;p1$2657-=1;p2$2657=5+p1$2657;p0$2657=-9+p$2657;
     If[(pe$2657=StringPosition["The exponent to calculate MatchinResidual. The default is 2."[p$2657,-2],";;;"])<=>{},
      {Max[0,-1+ToExpression["The exponent to calculate MatchinResidual. The default is 2."[p$2657+pe$2657[[1,2]],p1$2657]]],
       p1$2657=-2+p$2657+pe$2657[[1,1]]}[[1]],
      0],
    1,lx$2657:=Help2HTML`o9$;p2$2657=4+p1$2657;p0$2657=-4+p$2657;0];
  If[(equ$2657=Help2HTML`o8$["The exponent to calculate MatchinResidual. The default is 2."[p$2657,p1$2657]])===Undefined,
   equ$2657="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["The exponent to calculate MatchinResidual. The default is 2."[p$2657,p1$2657]]=equ$2657;
      LaTeX`ob$+=neq,
     --LaTeX`ob$;With[{lx$2657},out$2657=lx$2657@Typeset["The exponent to calculate MatchinResidual. The default is 2."[p$2657,
           p1$2657],Format->Help2HTML`oB$];
        System["mv -f "//out$2657//" "//equ$2657]];
      Exit[]]];
   "The exponent to calculate MatchinResidual. The default is 2."[1,Max[p0$2657,0]]//"<img  class=\"eqs\" SRC=\""//equ$2657//
   "\" />"//Help2HTML`oy$["The exponent to calculate MatchinResidual. The default is 2."[p2$2657,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L528>MatchingResidual</A> <A HREF=#L469>GO</A></PRE>
<LI>
<H3><A NAME=L520>
FFS$NumericalDerivative</A></H3>
<PRE>If[{},
Help2HTML`oA$["If False (default), the calculation of response matrix for each matching variables uses analytical expressions as m\
uch as possible. If True, performs numerical differentiation during the matching by GO. It is useful for some variables and matchi\
ng functions in some cases. It is slow, so should be avoided for off-momentum-matching for a large beam line."],
 p$2660=1+p$2660[[1,2]];
p1$2660=StringPosition["If False (default), the calculation of response matrix for each matching variables uses analytical express\
ions as much as possible. If True, performs numerical differentiation during the matching by GO. It is useful for some variables a\
nd matching functions in some cases. It is slow, so should be avoided for off-momentum-matching for a large beam line."[p$2660,-1],
    ">::",1];
   p1$2660=If[p1$2660==={},354,-2+p$2660+p1$2660[[1,1]]];
neq=Which["If False (default), the calculation of response matrix for each matching variables uses analytical expressions as much \
as possible. If True, performs numerical differentiation during the matching by GO. It is useful for some variables and matching f\
unctions in some cases. It is slow, so should be avoided for off-momentum-matching for a large beam line."[p$2660,4+p$2660]===
     "Text[",
lx$2660:=Help2HTML`oa$;p$2660=5+p$2660;p1$2660-=1;p2$2660=5+p1$2660;p0$2660=-9+p$2660;If[(pe$2660=StringPosition["If False (defaul\
t), the calculation of response matrix for each matching variables uses analytical expressions as much as possible. If True, perfo\
rms numerical differentiation during the matching by GO. It is useful for some variables and matching functions in some cases. It \
is slow, so should be avoided for off-momentum-matching for a large beam line."[p$2660,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["If False (default), the calculation of response matrix for each matching variables uses analytical expressions as\
 much as possible. If True, performs numerical differentiation during the matching by GO. It is useful for some variables and matc\
hing functions in some cases. It is slow, so should be avoided for off-momentum-matching for a large beam line."[p$2660+
            pe$2660[[1,2]],
           p1$2660]]],
        p1$2660=-2+p$2660+pe$2660[[1,1]]}[[
       1]],
      0],
    1,lx$2660:=Help2HTML`o9$;p2$2660=4+p1$2660;p0$2660=-4+p$2660;0];
  If[(equ$2660=
Help2HTML`o8$["If False (default), the calculation of response matrix for each matching variables uses analytical expressions as m\
uch as possible. If True, performs numerical differentiation during the matching by GO. It is useful for some variables and matchi\
ng functions in some cases. It is slow, so should be avoided for off-momentum-matching for a large beam line."[p$2660,p1$2660]])===
    Undefined,
equ$2660="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["If False (default), the calculation of respo\
nse matrix for each matching variables uses analytical expressions as much as possible. If True, performs numerical differentiatio\
n during the matching by GO. It is useful for some variables and matching functions in some cases. It is slow, so should be avoide\
d for off-momentum-matching for a large beam line."[p$2660,p1$2660]]=
       equ$2660;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2660},out$2660=lx$2660@Typeset["If False (default), the calculation of response matrix for each matching variables uses a\
nalytical expressions as much as possible. If True, performs numerical differentiation during the matching by GO. It is useful for\
 some variables and matching functions in some cases. It is slow, so should be avoided for off-momentum-matching for a large beam \
line."[p$2660,p1$2660],Format->Help2HTML`oB$];
        System["mv -f "//out$2660//" "//equ$2660]];
      Exit[]]];
   "If False (default), the calculation of response matrix for each matching variables uses analytical expressions as much as poss\
ible. If True, performs numerical differentiation during the matching by GO. It is useful for some variables and matching function\
s in some cases. It is slow, so should be avoided for off-momentum-matching for a large beam line."[1,Max[p0$2660,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2660//"\" />"//
Help2HTML`oy$["If False (default), the calculation of response matrix for each matching variables uses analytical expressions as m\
uch as possible. If True, performs numerical differentiation during the matching by GO. It is useful for some variables and matchi\
ng functions in some cases. It is slow, so should be avoided for off-momentum-matching for a large beam line."[p2$2660,-1]]
 ]
</PRE>
<PRE>See also:
 <A HREF=#L469>GO</A> <A HREF=#L477>off-momentum-matching</A></PRE>
<LI>
<H3><A NAME=L521>
FitFunction</A></H3>
<PRE>If[{},
Help2HTML`oA$["FitFunction is a symbol to assign user-defined functions for matching with the GO command. \n\nUsage:   FitFunction\
 := fun, \n\nwhere fun is a function that returns a real number or a list of real numbers, to be matched to zero by GO. The goal o\
f GO is to make fun zero or a list of zeros, together with built-in matching conditions. Thus the sum of fun^2 is added to Matchin\
gResidual. GO also evaluates FitFunction to obtain the derivatives numerically. The function fun can refer the value of variables \
by Element or LINE functions, and the optical functions at DP0 by Twiss. The algorithm of matching is same as that for built-in co\
nditions, but it is slower because of the numerical differentiation, when the beam line is long and the number of variables large.\
\n\nExample:  FitFunction := {Twiss[\"BX\",\"$$$\"]-20, Twiss[\"BY\",\"$$$\"]-20};\n\nwhich puts the same goal as\n\n   FIT $$$ BX\
 20 BY 20 .\n\n   FitFunction is cleared by USE. It is also hidden by VISIT and restored by BYE."],
 p$2663=1+p$2663[[1,2]];p1$2663=StringPosition["FitFunction is a symbol to assign user-defined functions for matching with the GO \
command. \n\nUsage:   FitFunction := fun, \n\nwhere fun is a function that returns a real number or a list of real numbers, to be \
matched to zero by GO. The goal of GO is to make fun zero or a list of zeros, together with built-in matching conditions. Thus the\
 sum of fun^2 is added to MatchingResidual. GO also evaluates FitFunction to obtain the derivatives numerically. The function fun \
can refer the value of variables by Element or LINE functions, and the optical functions at DP0 by Twiss. The algorithm of matchin\
g is same as that for built-in conditions, but it is slower because of the numerical differentiation, when the beam line is long a\
nd the number of variables large.\n\nExample:  FitFunction := {Twiss[\"BX\",\"$$$\"]-20, Twiss[\"BY\",\"$$$\"]-20};\n\nwhich puts \
the same goal as\n\n   FIT $$$ BX 20 BY 20 .\n\n   FitFunction is cleared by USE. It is also hidden by VISIT and restored by BYE."[
     p$2663,-1],
    ">::",1];
   p1$2663=If[p1$2663==={},971,-2+p$2663+p1$2663[[1,1]]];
neq=Which["FitFunction is a symbol to assign user-defined functions for matching with the GO command. \n\nUsage:   FitFunction := \
fun, \n\nwhere fun is a function that returns a real number or a list of real numbers, to be matched to zero by GO. The goal of GO\
 is to make fun zero or a list of zeros, together with built-in matching conditions. Thus the sum of fun^2 is added to MatchingRes\
idual. GO also evaluates FitFunction to obtain the derivatives numerically. The function fun can refer the value of variables by E\
lement or LINE functions, and the optical functions at DP0 by Twiss. The algorithm of matching is same as that for built-in condit\
ions, but it is slower because of the numerical differentiation, when the beam line is long and the number of variables large.\n\n\
Example:  FitFunction := {Twiss[\"BX\",\"$$$\"]-20, Twiss[\"BY\",\"$$$\"]-20};\n\nwhich puts the same goal as\n\n   FIT $$$ BX 20 \
BY 20 .\n\n   FitFunction is cleared by USE. It is also hidden by VISIT and restored by BYE."[p$2663,4+p$2663]==="Text[",
    lx$2663:=Help2HTML`oa$;p$2663=5+p$2663;p1$2663-=1;p2$2663=5+p1$2663;p0$2663=-9+p$2663;
If[(pe$2663=StringPosition["FitFunction is a symbol to assign user-defined functions for matching with the GO command. \n\nUsage: \
  FitFunction := fun, \n\nwhere fun is a function that returns a real number or a list of real numbers, to be matched to zero by G\
O. The goal of GO is to make fun zero or a list of zeros, together with built-in matching conditions. Thus the sum of fun^2 is add\
ed to MatchingResidual. GO also evaluates FitFunction to obtain the derivatives numerically. The function fun can refer the value \
of variables by Element or LINE functions, and the optical functions at DP0 by Twiss. The algorithm of matching is same as that fo\
r built-in conditions, but it is slower because of the numerical differentiation, when the beam line is long and the number of var\
iables large.\n\nExample:  FitFunction := {Twiss[\"BX\",\"$$$\"]-20, Twiss[\"BY\",\"$$$\"]-20};\n\nwhich puts the same goal as\n\n\
   FIT $$$ BX 20 BY 20 .\n\n   FitFunction is cleared by USE. It is also hidden by VISIT and restored by BYE."[p$2663,-2],";;;"]
        )<=>
       {},
      {Max[0,
-1+ToExpression["FitFunction is a symbol to assign user-defined functions for matching with the GO command. \n\nUsage:   FitFuncti\
on := fun, \n\nwhere fun is a function that returns a real number or a list of real numbers, to be matched to zero by GO. The goal\
 of GO is to make fun zero or a list of zeros, together with built-in matching conditions. Thus the sum of fun^2 is added to Match\
ingResidual. GO also evaluates FitFunction to obtain the derivatives numerically. The function fun can refer the value of variable\
s by Element or LINE functions, and the optical functions at DP0 by Twiss. The algorithm of matching is same as that for built-in \
conditions, but it is slower because of the numerical differentiation, when the beam line is long and the number of variables larg\
e.\n\nExample:  FitFunction := {Twiss[\"BX\",\"$$$\"]-20, Twiss[\"BY\",\"$$$\"]-20};\n\nwhich puts the same goal as\n\n   FIT $$$ \
BX 20 BY 20 .\n\n   FitFunction is cleared by USE. It is also hidden by VISIT and restored by BYE."[p$2663+pe$2663[[1,2]],p1$2663]]
        ],p1$2663=-2+p$2663+pe$2663[[1,1]]}[[
       1]],
      0],
    1,lx$2663:=Help2HTML`o9$;p2$2663=4+p1$2663;p0$2663=-4+p$2663;0];
  If[(equ$2663=
Help2HTML`o8$["FitFunction is a symbol to assign user-defined functions for matching with the GO command. \n\nUsage:   FitFunction\
 := fun, \n\nwhere fun is a function that returns a real number or a list of real numbers, to be matched to zero by GO. The goal o\
f GO is to make fun zero or a list of zeros, together with built-in matching conditions. Thus the sum of fun^2 is added to Matchin\
gResidual. GO also evaluates FitFunction to obtain the derivatives numerically. The function fun can refer the value of variables \
by Element or LINE functions, and the optical functions at DP0 by Twiss. The algorithm of matching is same as that for built-in co\
nditions, but it is slower because of the numerical differentiation, when the beam line is long and the number of variables large.\
\n\nExample:  FitFunction := {Twiss[\"BX\",\"$$$\"]-20, Twiss[\"BY\",\"$$$\"]-20};\n\nwhich puts the same goal as\n\n   FIT $$$ BX\
 20 BY 20 .\n\n   FitFunction is cleared by USE. It is also hidden by VISIT and restored by BYE."[p$2663,p1$2663]])===
    Undefined,
equ$2663="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["FitFunction is a symbol to assign user-defin\
ed functions for matching with the GO command. \n\nUsage:   FitFunction := fun, \n\nwhere fun is a function that returns a real nu\
mber or a list of real numbers, to be matched to zero by GO. The goal of GO is to make fun zero or a list of zeros, together with \
built-in matching conditions. Thus the sum of fun^2 is added to MatchingResidual. GO also evaluates FitFunction to obtain the deri\
vatives numerically. The function fun can refer the value of variables by Element or LINE functions, and the optical functions at \
DP0 by Twiss. The algorithm of matching is same as that for built-in conditions, but it is slower because of the numerical differe\
ntiation, when the beam line is long and the number of variables large.\n\nExample:  FitFunction := {Twiss[\"BX\",\"$$$\"]-20, Twi\
ss[\"BY\",\"$$$\"]-20};\n\nwhich puts the same goal as\n\n   FIT $$$ BX 20 BY 20 .\n\n   FitFunction is cleared by USE. It is also\
 hidden by VISIT and restored by BYE."[p$2663,p1$2663]]=
       equ$2663;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2663},out$2663=lx$2663@Typeset["FitFunction is a symbol to assign user-defined functions for matching with the GO command\
. \n\nUsage:   FitFunction := fun, \n\nwhere fun is a function that returns a real number or a list of real numbers, to be matched\
 to zero by GO. The goal of GO is to make fun zero or a list of zeros, together with built-in matching conditions. Thus the sum of\
 fun^2 is added to MatchingResidual. GO also evaluates FitFunction to obtain the derivatives numerically. The function fun can ref\
er the value of variables by Element or LINE functions, and the optical functions at DP0 by Twiss. The algorithm of matching is sa\
me as that for built-in conditions, but it is slower because of the numerical differentiation, when the beam line is long and the \
number of variables large.\n\nExample:  FitFunction := {Twiss[\"BX\",\"$$$\"]-20, Twiss[\"BY\",\"$$$\"]-20};\n\nwhich puts the sam\
e goal as\n\n   FIT $$$ BX 20 BY 20 .\n\n   FitFunction is cleared by USE. It is also hidden by VISIT and restored by BYE."[p$2663,
           p1$2663],Format->Help2HTML`oB$];
        System["mv -f "//out$2663//" "//equ$2663]];
      Exit[]]];
   "FitFunction is a symbol to assign user-defined functions for matching with the GO command. \n\nUsage:   FitFunction := fun, \n\
\nwhere fun is a function that returns a real number or a list of real numbers, to be matched to zero by GO. The goal of GO is to \
make fun zero or a list of zeros, together with built-in matching conditions. Thus the sum of fun^2 is added to MatchingResidual. \
GO also evaluates FitFunction to obtain the derivatives numerically. The function fun can refer the value of variables by Element \
or LINE functions, and the optical functions at DP0 by Twiss. The algorithm of matching is same as that for built-in conditions, b\
ut it is slower because of the numerical differentiation, when the beam line is long and the number of variables large.\n\nExample\
:  FitFunction := {Twiss[\"BX\",\"$$$\"]-20, Twiss[\"BY\",\"$$$\"]-20};\n\nwhich puts the same goal as\n\n   FIT $$$ BX 20 BY 20 .\
\n\n   FitFunction is cleared by USE. It is also hidden by VISIT and restored by BYE."[1,Max[p0$2663,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2663//"\" />"//
Help2HTML`oy$["FitFunction is a symbol to assign user-defined functions for matching with the GO command. \n\nUsage:   FitFunction\
 := fun, \n\nwhere fun is a function that returns a real number or a list of real numbers, to be matched to zero by GO. The goal o\
f GO is to make fun zero or a list of zeros, together with built-in matching conditions. Thus the sum of fun^2 is added to Matchin\
gResidual. GO also evaluates FitFunction to obtain the derivatives numerically. The function fun can refer the value of variables \
by Element or LINE functions, and the optical functions at DP0 by Twiss. The algorithm of matching is same as that for built-in co\
nditions, but it is slower because of the numerical differentiation, when the beam line is long and the number of variables large.\
\n\nExample:  FitFunction := {Twiss[\"BX\",\"$$$\"]-20, Twiss[\"BY\",\"$$$\"]-20};\n\nwhich puts the same goal as\n\n   FIT $$$ BX\
 20 BY 20 .\n\n   FitFunction is cleared by USE. It is also hidden by VISIT and restored by BYE."[p2$2663,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L469>GO</A> <A HREF=#L466>FREE</A> <A HREF=#L528>MatchingResidual</A> <A HREF=#L507>DP0</A> <A HREF=#L387>Element</A> <A HREF=#L398>LINE</A> <A HREF=#L410>Twiss</A></PRE>
<LI>
<H3><A NAME=L522>
FSHIFT</A></H3>
<PRE>If[{},
Help2HTML`oA$["FSHIFT is the relative shift df/f0 of the revolution (or rf) frequency in a ring. This is valid in EMITTANCE(EMIT),\
 the particle-tracking, and CAL/GO with CALC6D. For CAL/GO with CALC4D, DP0 should be used instead."],
 p$2666=1+p$2666[[1,2]];p1$2666=
StringPosition["FSHIFT is the relative shift df/f0 of the revolution (or rf) frequency in a ring. This is valid in EMITTANCE(EMIT)\
, the particle-tracking, and CAL/GO with CALC6D. For CAL/GO with CALC4D, DP0 should be used instead."[p$2666,-1],">::",1];
   p1$2666=If[p1$2666==={},214,-2+p$2666+p1$2666[[1,1]]];
neq=Which["FSHIFT is the relative shift df/f0 of the revolution (or rf) frequency in a ring. This is valid in EMITTANCE(EMIT), the\
 particle-tracking, and CAL/GO with CALC6D. For CAL/GO with CALC4D, DP0 should be used instead."[p$2666,4+p$2666]==="Text[",
    lx$2666:=Help2HTML`oa$;p$2666=5+p$2666;p1$2666-=1;p2$2666=5+p1$2666;p0$2666=-9+p$2666;
If[(pe$2666=StringPosition["FSHIFT is the relative shift df/f0 of the revolution (or rf) frequency in a ring. This is valid in EMI\
TTANCE(EMIT), the particle-tracking, and CAL/GO with CALC6D. For CAL/GO with CALC4D, DP0 should be used instead."[p$2666,-2],";;;"]
        )<=>
       {},
      {Max[0,
-1+ToExpression["FSHIFT is the relative shift df/f0 of the revolution (or rf) frequency in a ring. This is valid in EMITTANCE(EMIT\
), the particle-tracking, and CAL/GO with CALC6D. For CAL/GO with CALC4D, DP0 should be used instead."[p$2666+pe$2666[[1,2]],
           p1$2666]]],
        p1$2666=-2+p$2666+pe$2666[[1,1]]}[[
       1]],
      0],
    1,lx$2666:=Help2HTML`o9$;p2$2666=4+p1$2666;p0$2666=-4+p$2666;0];
  If[(equ$2666=
Help2HTML`o8$["FSHIFT is the relative shift df/f0 of the revolution (or rf) frequency in a ring. This is valid in EMITTANCE(EMIT),\
 the particle-tracking, and CAL/GO with CALC6D. For CAL/GO with CALC4D, DP0 should be used instead."[p$2666,p1$2666]])===
    Undefined,
equ$2666="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["FSHIFT is the relative shift df/f0 of the re\
volution (or rf) frequency in a ring. This is valid in EMITTANCE(EMIT), the particle-tracking, and CAL/GO with CALC6D. For CAL/GO \
with CALC4D, DP0 should be used instead."[p$2666,p1$2666]]=
       equ$2666;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2666},out$2666=lx$2666@Typeset["FSHIFT is the relative shift df/f0 of the revolution (or rf) frequency in a ring. This is\
 valid in EMITTANCE(EMIT), the particle-tracking, and CAL/GO with CALC6D. For CAL/GO with CALC4D, DP0 should be used instead."[p
           $2666,p1$2666],Format->Help2HTML`oB$];
        System["mv -f "//out$2666//" "//equ$2666]];
      Exit[]]];
   "FSHIFT is the relative shift df/f0 of the revolution (or rf) frequency in a ring. This is valid in EMITTANCE(EMIT), the partic\
le-tracking, and CAL/GO with CALC6D. For CAL/GO with CALC4D, DP0 should be used instead."[1,Max[p0$2666,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2666//"\" />"//
Help2HTML`oy$["FSHIFT is the relative shift df/f0 of the revolution (or rf) frequency in a ring. This is valid in EMITTANCE(EMIT),\
 the particle-tracking, and CAL/GO with CALC6D. For CAL/GO with CALC4D, DP0 should be used instead."[p2$2666,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L295>EMITTANCE(EMIT)</A> <A HREF=#L32>CALCULATE(CAL)</A> <A HREF=#L469>GO</A> <A HREF=#L304>CALC6D</A> <A HREF=#L303>CALC4D</A> <A HREF=#L507>DP0</A></PRE>
<LI>
<H3><A NAME=L523>
GCUT</A></H3>
<PRE>If[{},
 Help2HTML`oA$["GCUT specifies the cut-off value of Gaussian distribution in unit of the standard deviation. Accessible in MAIN."],
 p$2669=1+p$2669[[1,2]];
  p1$2669=StringPosition[
    "GCUT specifies the cut-off value of Gaussian distribution in unit of the standard deviation. Accessible in MAIN."[p$2669,-1],
    ">::",1];
   p1$2669=If[p1$2669==={},112,-2+p$2669+p1$2669[[1,1]]];
  neq=Which["GCUT specifies the cut-off value of Gaussian distribution in unit of the standard deviation. Accessible in MAIN."[p
      $2669,4+p$2669]===
     "Text[",
    lx$2669:=Help2HTML`oa$;p$2669=5+p$2669;p1$2669-=1;p2$2669=5+p1$2669;p0$2669=-9+p$2669;If[(pe$2669=StringPosition[
         "GCUT specifies the cut-off value of Gaussian distribution in unit of the standard deviation. Accessible in MAIN."[p$2669,
          -2],
         ";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression[
          "GCUT specifies the cut-off value of Gaussian distribution in unit of the standard deviation. Accessible in MAIN."[p$2669
            +pe$2669[[1,2]],
           p1$2669]]],
        p1$2669=-2+p$2669+pe$2669[[1,1]]}[[
       1]],
      0],
    1,lx$2669:=Help2HTML`o9$;p2$2669=4+p1$2669;p0$2669=-4+p$2669;0];
  If[(equ$2669=
     Help2HTML`o8$[
      "GCUT specifies the cut-off value of Gaussian distribution in unit of the standard deviation. Accessible in MAIN."[p$2669,
       p1$2669]])===
    Undefined,
   equ$2669="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "GCUT specifies the cut-off value of Gaussian distribution in unit of the standard deviation. Accessible in MAIN."[p$2669,
         p1$2669]]=
       equ$2669;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$2669},out$2669=lx$2669@Typeset[
          "GCUT specifies the cut-off value of Gaussian distribution in unit of the standard deviation. Accessible in MAIN."[p$2669
           ,p1$2669],Format->Help2HTML`oB$];
        System["mv -f "//out$2669//" "//equ$2669]];
      Exit[]]];
   "GCUT specifies the cut-off value of Gaussian distribution in unit of the standard deviation. Accessible in MAIN."[1,
    Max[p0$2669,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2669//"\" />"//
   Help2HTML`oy$["GCUT specifies the cut-off value of Gaussian distribution in unit of the standard deviation. Accessible in MAIN."
    [p2$2669,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L549>SEED</A> <A HREF=#L319>GAUSS</A> <A HREF=#L450>GaussRandom</A></PRE>
<LI>
<H3><A NAME=L524>
InitialOrbits</A></H3>
<PRE>If[{},
Help2HTML`oA$["Usage: InitialOrbits = { {x1, px1, y1, py1, z1, dp1}, ...};\n\nor     InitialOrbits = { {ax1, bx1, nx1, ay1, by1, n\
y1,\n          ex1, epx1, ey1, epy1, r11, r21, r31, r41,\n          x1, px1, y1, py1, z1, dp1, 0, 0, 0, 0, 0, 0, 0}, ...};\n\nspec\
ifies initial conditions of a number of orbits for the optics calculation by CALCULATE(CAL) and GO. Those coordinates are offset f\
rom the central orbit. If six numbers are given, only the offsets of the orbits are affected. If 27 numbers are given, all Twiss p\
arameters are set (values for non-orbit params are used directly. Orbits are giving offsets.)\n  If InitialOrbits are given, the o\
ff-momentum matching and finite-amplitude matching is disabled.\n  InitialOrbits is also necessary to calculate optics with wake f\
ield."],
p$2672=1+p$2672[[1,2]];p1$2672=StringPosition["Usage: InitialOrbits = { {x1, px1, y1, py1, z1, dp1}, ...};\n\nor     InitialOrbits\
 = { {ax1, bx1, nx1, ay1, by1, ny1,\n          ex1, epx1, ey1, epy1, r11, r21, r31, r41,\n          x1, px1, y1, py1, z1, dp1, 0, \
0, 0, 0, 0, 0, 0}, ...};\n\nspecifies initial conditions of a number of orbits for the optics calculation by CALCULATE(CAL) and GO\
. Those coordinates are offset from the central orbit. If six numbers are given, only the offsets of the orbits are affected. If 2\
7 numbers are given, all Twiss parameters are set (values for non-orbit params are used directly. Orbits are giving offsets.)\n  I\
f InitialOrbits are given, the off-momentum matching and finite-amplitude matching is disabled.\n  InitialOrbits is also necessary\
 to calculate optics with wake field."[p$2672,-1],">::",1];
   p1$2672=If[p1$2672==={},762,-2+p$2672+p1$2672[[1,1]]];
neq=Which["Usage: InitialOrbits = { {x1, px1, y1, py1, z1, dp1}, ...};\n\nor     InitialOrbits = { {ax1, bx1, nx1, ay1, by1, ny1,\\
n          ex1, epx1, ey1, epy1, r11, r21, r31, r41,\n          x1, px1, y1, py1, z1, dp1, 0, 0, 0, 0, 0, 0, 0}, ...};\n\nspecifie\
s initial conditions of a number of orbits for the optics calculation by CALCULATE(CAL) and GO. Those coordinates are offset from \
the central orbit. If six numbers are given, only the offsets of the orbits are affected. If 27 numbers are given, all Twiss param\
eters are set (values for non-orbit params are used directly. Orbits are giving offsets.)\n  If InitialOrbits are given, the off-m\
omentum matching and finite-amplitude matching is disabled.\n  InitialOrbits is also necessary to calculate optics with wake field\
."[p$2672,4+p$2672]==="Text[",
    lx$2672:=Help2HTML`oa$;p$2672=5+p$2672;p1$2672-=1;p2$2672=5+p1$2672;p0$2672=-9+p$2672;If[(pe$2672=StringPosition["Usage: Initi\
alOrbits = { {x1, px1, y1, py1, z1, dp1}, ...};\n\nor     InitialOrbits = { {ax1, bx1, nx1, ay1, by1, ny1,\n          ex1, epx1, e\
y1, epy1, r11, r21, r31, r41,\n          x1, px1, y1, py1, z1, dp1, 0, 0, 0, 0, 0, 0, 0}, ...};\n\nspecifies initial conditions of\
 a number of orbits for the optics calculation by CALCULATE(CAL) and GO. Those coordinates are offset from the central orbit. If s\
ix numbers are given, only the offsets of the orbits are affected. If 27 numbers are given, all Twiss parameters are set (values f\
or non-orbit params are used directly. Orbits are giving offsets.)\n  If InitialOrbits are given, the off-momentum matching and fi\
nite-amplitude matching is disabled.\n  InitialOrbits is also necessary to calculate optics with wake field."[p$2672,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Usage: InitialOrbits = { {x1, px1, y1, py1, z1, dp1}, ...};\n\nor     InitialOrbits = { {ax1, bx1, nx1, ay1, by1,\
 ny1,\n          ex1, epx1, ey1, epy1, r11, r21, r31, r41,\n          x1, px1, y1, py1, z1, dp1, 0, 0, 0, 0, 0, 0, 0}, ...};\n\nsp\
ecifies initial conditions of a number of orbits for the optics calculation by CALCULATE(CAL) and GO. Those coordinates are offset\
 from the central orbit. If six numbers are given, only the offsets of the orbits are affected. If 27 numbers are given, all Twiss\
 parameters are set (values for non-orbit params are used directly. Orbits are giving offsets.)\n  If InitialOrbits are given, the\
 off-momentum matching and finite-amplitude matching is disabled.\n  InitialOrbits is also necessary to calculate optics with wake\
 field."[p$2672+pe$2672[[1,2]],p1$2672]]],
        p1$2672=-2+p$2672+pe$2672[[1,1]]}[[
       1]],
      0],
    1,lx$2672:=Help2HTML`o9$;p2$2672=4+p1$2672;p0$2672=-4+p$2672;0];
  If[(equ$2672=
Help2HTML`o8$["Usage: InitialOrbits = { {x1, px1, y1, py1, z1, dp1}, ...};\n\nor     InitialOrbits = { {ax1, bx1, nx1, ay1, by1, n\
y1,\n          ex1, epx1, ey1, epy1, r11, r21, r31, r41,\n          x1, px1, y1, py1, z1, dp1, 0, 0, 0, 0, 0, 0, 0}, ...};\n\nspec\
ifies initial conditions of a number of orbits for the optics calculation by CALCULATE(CAL) and GO. Those coordinates are offset f\
rom the central orbit. If six numbers are given, only the offsets of the orbits are affected. If 27 numbers are given, all Twiss p\
arameters are set (values for non-orbit params are used directly. Orbits are giving offsets.)\n  If InitialOrbits are given, the o\
ff-momentum matching and finite-amplitude matching is disabled.\n  InitialOrbits is also necessary to calculate optics with wake f\
ield."[p$2672,p1$2672]])===
    Undefined,
equ$2672="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Usage: InitialOrbits = { {x1, px1, y1, py1, \
z1, dp1}, ...};\n\nor     InitialOrbits = { {ax1, bx1, nx1, ay1, by1, ny1,\n          ex1, epx1, ey1, epy1, r11, r21, r31, r41,\n \
         x1, px1, y1, py1, z1, dp1, 0, 0, 0, 0, 0, 0, 0}, ...};\n\nspecifies initial conditions of a number of orbits for the opti\
cs calculation by CALCULATE(CAL) and GO. Those coordinates are offset from the central orbit. If six numbers are given, only the o\
ffsets of the orbits are affected. If 27 numbers are given, all Twiss parameters are set (values for non-orbit params are used dir\
ectly. Orbits are giving offsets.)\n  If InitialOrbits are given, the off-momentum matching and finite-amplitude matching is disab\
led.\n  InitialOrbits is also necessary to calculate optics with wake field."[p$2672,p1$2672]]=
       equ$2672;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2672},out$2672=lx$2672@Typeset["Usage: InitialOrbits = { {x1, px1, y1, py1, z1, dp1}, ...};\n\nor     InitialOrbits = { {\
ax1, bx1, nx1, ay1, by1, ny1,\n          ex1, epx1, ey1, epy1, r11, r21, r31, r41,\n          x1, px1, y1, py1, z1, dp1, 0, 0, 0, \
0, 0, 0, 0}, ...};\n\nspecifies initial conditions of a number of orbits for the optics calculation by CALCULATE(CAL) and GO. Thos\
e coordinates are offset from the central orbit. If six numbers are given, only the offsets of the orbits are affected. If 27 numb\
ers are given, all Twiss parameters are set (values for non-orbit params are used directly. Orbits are giving offsets.)\n  If Init\
ialOrbits are given, the off-momentum matching and finite-amplitude matching is disabled.\n  InitialOrbits is also necessary to ca\
lculate optics with wake field."[p$2672,p1$2672],Format->Help2HTML`oB$];
        System["mv -f "//out$2672//" "//equ$2672]];
      Exit[]]];
   "Usage: InitialOrbits = { {x1, px1, y1, py1, z1, dp1}, ...};\n\nor     InitialOrbits = { {ax1, bx1, nx1, ay1, by1, ny1,\n      \
    ex1, epx1, ey1, epy1, r11, r21, r31, r41,\n          x1, px1, y1, py1, z1, dp1, 0, 0, 0, 0, 0, 0, 0}, ...};\n\nspecifies initi\
al conditions of a number of orbits for the optics calculation by CALCULATE(CAL) and GO. Those coordinates are offset from the cen\
tral orbit. If six numbers are given, only the offsets of the orbits are affected. If 27 numbers are given, all Twiss parameters a\
re set (values for non-orbit params are used directly. Orbits are giving offsets.)\n  If InitialOrbits are given, the off-momentum\
 matching and finite-amplitude matching is disabled.\n  InitialOrbits is also necessary to calculate optics with wake field."[1,
    Max[p0$2672,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2672//"\" />"//
Help2HTML`oy$["Usage: InitialOrbits = { {x1, px1, y1, py1, z1, dp1}, ...};\n\nor     InitialOrbits = { {ax1, bx1, nx1, ay1, by1, n\
y1,\n          ex1, epx1, ey1, epy1, r11, r21, r31, r41,\n          x1, px1, y1, py1, z1, dp1, 0, 0, 0, 0, 0, 0, 0}, ...};\n\nspec\
ifies initial conditions of a number of orbits for the optics calculation by CALCULATE(CAL) and GO. Those coordinates are offset f\
rom the central orbit. If six numbers are given, only the offsets of the orbits are affected. If 27 numbers are given, all Twiss p\
arameters are set (values for non-orbit params are used directly. Orbits are giving offsets.)\n  If InitialOrbits are given, the o\
ff-momentum matching and finite-amplitude matching is disabled.\n  InitialOrbits is also necessary to calculate optics with wake f\
ield."[p2$2672,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L32>CALCULATE(CAL)</A> <A HREF=#L469>GO</A> <A HREF=#L477>off-momentum-matching</A> <A HREF=#L527>MatchingAmplitude</A></PRE>
<LI>
<H3><A NAME=L525>
LOSSAMPL</A></H3>
<PRE>If[{},
 Help2HTML`oA$[
  "LOSSAMPL is the transverse amplitude beyond which a particle is judged to have been lost. The default is 1 m. Accessible in MAI\
N."],
 p$2675=1+p$2675[[1,2]];p1$2675=StringPosition[
    "LOSSAMPL is the transverse amplitude beyond which a particle is judged to have been lost. The default is 1 m. Accessible in M\
AIN."[p$2675,-1],">::",1];
   p1$2675=If[p1$2675==={},129,-2+p$2675+p1$2675[[1,1]]];
  neq=Which[
     "LOSSAMPL is the transverse amplitude beyond which a particle is judged to have been lost. The default is 1 m. Accessible in \
MAIN."[p$2675,4+p$2675]==="Text[",
    lx$2675:=Help2HTML`oa$;p$2675=5+p$2675;p1$2675-=1;p2$2675=5+p1$2675;p0$2675=-9+p$2675;If[(pe$2675=
        StringPosition[
         "LOSSAMPL is the transverse amplitude beyond which a particle is judged to have been lost. The default is 1 m. Accessible\
 in MAIN."[p$2675,-2],";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression[
          "LOSSAMPL is the transverse amplitude beyond which a particle is judged to have been lost. The default is 1 m. Accessibl\
e in MAIN."[p$2675+pe$2675[[1,2]],p1$2675]]],
        p1$2675=-2+p$2675+pe$2675[[1,1]]}[[
       1]],
      0],
    1,lx$2675:=Help2HTML`o9$;p2$2675=4+p1$2675;p0$2675=-4+p$2675;0];
  If[(equ$2675=
     Help2HTML`o8$[
      "LOSSAMPL is the transverse amplitude beyond which a particle is judged to have been lost. The default is 1 m. Accessible in\
 MAIN."[p$2675,p1$2675]])===
    Undefined,
   equ$2675="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "LOSSAMPL is the transverse amplitude beyond which a particle is judged to have been lost. The default is 1 m. Accessible \
in MAIN."[p$2675,p1$2675]]=
       equ$2675;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$2675},out$2675=lx$2675@Typeset[
          "LOSSAMPL is the transverse amplitude beyond which a particle is judged to have been lost. The default is 1 m. Accessibl\
e in MAIN."[p$2675,p1$2675],Format->Help2HTML`oB$];
        System["mv -f "//out$2675//" "//equ$2675]];
      Exit[]]];
  "LOSSAMPL is the transverse amplitude beyond which a particle is judged to have been lost. The default is 1 m. Accessible in MAI\
N."[1,Max[p0$2675,0]]//"<img  class=\"eqs\" SRC=\""//equ$2675//"\" />"//
   Help2HTML`oy$[
    "LOSSAMPL is the transverse amplitude beyond which a particle is judged to have been lost. The default is 1 m. Accessible in M\
AIN."[p2$2675,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L526>LOSSDZ</A> <A HREF=#L76>APERT</A></PRE>
<LI>
<H3><A NAME=L526>
LOSSDZ</A></H3>
<PRE>If[{},
Help2HTML`oA$["LOSSDZ is the longitudinal position z beyond which a particle is judged to have been lost. The default is 100 m. Ac\
cessible in MAIN. LOSSDZ is effective only when SPAC is ON."],
p$2678=1+p$2678[[1,2]];p1$2678=StringPosition["LOSSDZ is the longitudinal position z beyond which a particle is judged to have bee\
n lost. The default is 100 m. Accessible in MAIN. LOSSDZ is effective only when SPAC is ON."[p$2678,-1],">::",1];
   p1$2678=If[p1$2678==={},174,-2+p$2678+p1$2678[[1,1]]];
neq=Which["LOSSDZ is the longitudinal position z beyond which a particle is judged to have been lost. The default is 100 m. Access\
ible in MAIN. LOSSDZ is effective only when SPAC is ON."[p$2678,4+p$2678]==="Text[",
    lx$2678:=Help2HTML`oa$;p$2678=5+p$2678;p1$2678-=1;p2$2678=5+p1$2678;p0$2678=-9+p$2678;
If[(pe$2678=StringPosition["LOSSDZ is the longitudinal position z beyond which a particle is judged to have been lost. The default\
 is 100 m. Accessible in MAIN. LOSSDZ is effective only when SPAC is ON."[p$2678,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["LOSSDZ is the longitudinal position z beyond which a particle is judged to have been lost. The default is 100 m. \
Accessible in MAIN. LOSSDZ is effective only when SPAC is ON."[p$2678+pe$2678[[1,2]],p1$2678]]],
        p1$2678=-2+p$2678+pe$2678[[1,1]]}[[
       1]],
      0],
    1,lx$2678:=Help2HTML`o9$;p2$2678=4+p1$2678;p0$2678=-4+p$2678;0];
  If[(equ$2678=
Help2HTML`o8$["LOSSDZ is the longitudinal position z beyond which a particle is judged to have been lost. The default is 100 m. Ac\
cessible in MAIN. LOSSDZ is effective only when SPAC is ON."[p$2678,p1$2678]])===
    Undefined,
equ$2678="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["LOSSDZ is the longitudinal position z beyond\
 which a particle is judged to have been lost. The default is 100 m. Accessible in MAIN. LOSSDZ is effective only when SPAC is ON."
        [p$2678,p1$2678]]=
       equ$2678;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2678},out$2678=lx$2678@Typeset["LOSSDZ is the longitudinal position z beyond which a particle is judged to have been lost\
. The default is 100 m. Accessible in MAIN. LOSSDZ is effective only when SPAC is ON."[p$2678,p1$2678],Format->Help2HTML`oB$];
        System["mv -f "//out$2678//" "//equ$2678]];
      Exit[]]];
   "LOSSDZ is the longitudinal position z beyond which a particle is judged to have been lost. The default is 100 m. Accessible in\
 MAIN. LOSSDZ is effective only when SPAC is ON."[1,Max[p0$2678,0]]//"<img  class=\"eqs\" SRC=\""//equ$2678//"\" />"//
   Help2HTML`oy$["LOSSDZ is the longitudinal position z beyond which a particle is judged to have been lost. The default is 100 m.\
 Accessible in MAIN. LOSSDZ is effective only when SPAC is ON."[p2$2678,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L525>LOSSAMPL</A> <A HREF=#L76>APERT</A> <A HREF=#L348>SPAC</A></PRE>
<LI>
<H3><A NAME=L527>
MatchingAmplitude</A></H3>
<PRE>If[{},
Help2HTML`oA$["MatchingAmplitude is a list of amplitudes for the finite-amplitude matching.\n\nUsage: MatchingAmplitude := { {dp1,\
x1,y1}, ..};\n\nwhere dp1 is the momentum deviation to be matched, x1 and y1 are the horizontal and vertical amplitudes at the beg\
inning of the beam line, normalized by Sqrt of the sum of the emittance, i.e., Sqrt[(EMITX+EMITY)]. Three orbits are chosen in eac\
h dimension. The initial conditions of the orbit is chosen as\n\n   {X,Px,Y,Py} =\n   { {x1,0,0,0}, {-x1/2,Sqrt[3]/2 x1,0,0}, {-x1\
/2,-Sqrt[3]/2 x1,0,0},\n     {0,0,y1,0}, {0,0,-y1/2,Sqrt[3]/2 y1}, {0,0,-y1/2,Sqrt[3]/2 y1} },\n\nand when x1==0 or y1==0 correspo\
nding orbits are excluded. The above are labeled {x1,x2,x3,y1,y2,y3} in the output of CALCULATE(CAL) or GO, and also labeled 1 to \
6 in the second element of FFS[\"CALC\"] and FFS[\"GO\"].\n\n    This matching is done when dp1 is within the off-momentum range g\
iven by DP, i.e., Abs[dp1] < DP. If dp1 is in the range, the nearest zero- amplitude optics is chosen. The maching conditions for \
the finite- amplitude optics are same as those for the zero-amplitude one.\n   Th orbit with finte initial condition never close a\
fter one revolution, but FFS simply ignores it and obtain the periodic optics around the open\norbit."],
 p$2681=1+p$2681[[1,2]];p1$2681=
StringPosition["MatchingAmplitude is a list of amplitudes for the finite-amplitude matching.\n\nUsage: MatchingAmplitude := { {dp1\
,x1,y1}, ..};\n\nwhere dp1 is the momentum deviation to be matched, x1 and y1 are the horizontal and vertical amplitudes at the be\
ginning of the beam line, normalized by Sqrt of the sum of the emittance, i.e., Sqrt[(EMITX+EMITY)]. Three orbits are chosen in ea\
ch dimension. The initial conditions of the orbit is chosen as\n\n   {X,Px,Y,Py} =\n   { {x1,0,0,0}, {-x1/2,Sqrt[3]/2 x1,0,0}, {-x\
1/2,-Sqrt[3]/2 x1,0,0},\n     {0,0,y1,0}, {0,0,-y1/2,Sqrt[3]/2 y1}, {0,0,-y1/2,Sqrt[3]/2 y1} },\n\nand when x1==0 or y1==0 corresp\
onding orbits are excluded. The above are labeled {x1,x2,x3,y1,y2,y3} in the output of CALCULATE(CAL) or GO, and also labeled 1 to\
 6 in the second element of FFS[\"CALC\"] and FFS[\"GO\"].\n\n    This matching is done when dp1 is within the off-momentum range \
given by DP, i.e., Abs[dp1] < DP. If dp1 is in the range, the nearest zero- amplitude optics is chosen. The maching conditions for\
 the finite- amplitude optics are same as those for the zero-amplitude one.\n   Th orbit with finte initial condition never close \
after one revolution, but FFS simply ignores it and obtain the periodic optics around the open\norbit."[p$2681,-1],">::",1];
   p1$2681=If[p1$2681==={},1238,-2+p$2681+p1$2681[[1,1]]];
neq=Which["MatchingAmplitude is a list of amplitudes for the finite-amplitude matching.\n\nUsage: MatchingAmplitude := { {dp1,x1,y\
1}, ..};\n\nwhere dp1 is the momentum deviation to be matched, x1 and y1 are the horizontal and vertical amplitudes at the beginni\
ng of the beam line, normalized by Sqrt of the sum of the emittance, i.e., Sqrt[(EMITX+EMITY)]. Three orbits are chosen in each di\
mension. The initial conditions of the orbit is chosen as\n\n   {X,Px,Y,Py} =\n   { {x1,0,0,0}, {-x1/2,Sqrt[3]/2 x1,0,0}, {-x1/2,-\
Sqrt[3]/2 x1,0,0},\n     {0,0,y1,0}, {0,0,-y1/2,Sqrt[3]/2 y1}, {0,0,-y1/2,Sqrt[3]/2 y1} },\n\nand when x1==0 or y1==0 correspondin\
g orbits are excluded. The above are labeled {x1,x2,x3,y1,y2,y3} in the output of CALCULATE(CAL) or GO, and also labeled 1 to 6 in\
 the second element of FFS[\"CALC\"] and FFS[\"GO\"].\n\n    This matching is done when dp1 is within the off-momentum range given\
 by DP, i.e., Abs[dp1] < DP. If dp1 is in the range, the nearest zero- amplitude optics is chosen. The maching conditions for the \
finite- amplitude optics are same as those for the zero-amplitude one.\n   Th orbit with finte initial condition never close after\
 one revolution, but FFS simply ignores it and obtain the periodic optics around the open\norbit."[p$2681,4+p$2681]==="Text[",
    lx$2681:=Help2HTML`oa$;p$2681=5+p$2681;p1$2681-=1;p2$2681=5+p1$2681;p0$2681=-9+p$2681;
If[(pe$2681=StringPosition["MatchingAmplitude is a list of amplitudes for the finite-amplitude matching.\n\nUsage: MatchingAmplitu\
de := { {dp1,x1,y1}, ..};\n\nwhere dp1 is the momentum deviation to be matched, x1 and y1 are the horizontal and vertical amplitud\
es at the beginning of the beam line, normalized by Sqrt of the sum of the emittance, i.e., Sqrt[(EMITX+EMITY)]. Three orbits are \
chosen in each dimension. The initial conditions of the orbit is chosen as\n\n   {X,Px,Y,Py} =\n   { {x1,0,0,0}, {-x1/2,Sqrt[3]/2 \
x1,0,0}, {-x1/2,-Sqrt[3]/2 x1,0,0},\n     {0,0,y1,0}, {0,0,-y1/2,Sqrt[3]/2 y1}, {0,0,-y1/2,Sqrt[3]/2 y1} },\n\nand when x1==0 or y\
1==0 corresponding orbits are excluded. The above are labeled {x1,x2,x3,y1,y2,y3} in the output of CALCULATE(CAL) or GO, and also \
labeled 1 to 6 in the second element of FFS[\"CALC\"] and FFS[\"GO\"].\n\n    This matching is done when dp1 is within the off-mom\
entum range given by DP, i.e., Abs[dp1] < DP. If dp1 is in the range, the nearest zero- amplitude optics is chosen. The maching co\
nditions for the finite- amplitude optics are same as those for the zero-amplitude one.\n   Th orbit with finte initial condition \
never close after one revolution, but FFS simply ignores it and obtain the periodic optics around the open\norbit."[p$2681,-2],
         ";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["MatchingAmplitude is a list of amplitudes for the finite-amplitude matching.\n\nUsage: MatchingAmplitude := { {dp\
1,x1,y1}, ..};\n\nwhere dp1 is the momentum deviation to be matched, x1 and y1 are the horizontal and vertical amplitudes at the b\
eginning of the beam line, normalized by Sqrt of the sum of the emittance, i.e., Sqrt[(EMITX+EMITY)]. Three orbits are chosen in e\
ach dimension. The initial conditions of the orbit is chosen as\n\n   {X,Px,Y,Py} =\n   { {x1,0,0,0}, {-x1/2,Sqrt[3]/2 x1,0,0}, {-\
x1/2,-Sqrt[3]/2 x1,0,0},\n     {0,0,y1,0}, {0,0,-y1/2,Sqrt[3]/2 y1}, {0,0,-y1/2,Sqrt[3]/2 y1} },\n\nand when x1==0 or y1==0 corres\
ponding orbits are excluded. The above are labeled {x1,x2,x3,y1,y2,y3} in the output of CALCULATE(CAL) or GO, and also labeled 1 t\
o 6 in the second element of FFS[\"CALC\"] and FFS[\"GO\"].\n\n    This matching is done when dp1 is within the off-momentum range\
 given by DP, i.e., Abs[dp1] < DP. If dp1 is in the range, the nearest zero- amplitude optics is chosen. The maching conditions fo\
r the finite- amplitude optics are same as those for the zero-amplitude one.\n   Th orbit with finte initial condition never close\
 after one revolution, but FFS simply ignores it and obtain the periodic optics around the open\norbit."[p$2681+pe$2681[[1,2]],
           p1$2681]]],
        p1$2681=-2+p$2681+pe$2681[[1,1]]}[[
       1]],
      0],
    1,lx$2681:=Help2HTML`o9$;p2$2681=4+p1$2681;p0$2681=-4+p$2681;0];
  If[(equ$2681=
Help2HTML`o8$["MatchingAmplitude is a list of amplitudes for the finite-amplitude matching.\n\nUsage: MatchingAmplitude := { {dp1,\
x1,y1}, ..};\n\nwhere dp1 is the momentum deviation to be matched, x1 and y1 are the horizontal and vertical amplitudes at the beg\
inning of the beam line, normalized by Sqrt of the sum of the emittance, i.e., Sqrt[(EMITX+EMITY)]. Three orbits are chosen in eac\
h dimension. The initial conditions of the orbit is chosen as\n\n   {X,Px,Y,Py} =\n   { {x1,0,0,0}, {-x1/2,Sqrt[3]/2 x1,0,0}, {-x1\
/2,-Sqrt[3]/2 x1,0,0},\n     {0,0,y1,0}, {0,0,-y1/2,Sqrt[3]/2 y1}, {0,0,-y1/2,Sqrt[3]/2 y1} },\n\nand when x1==0 or y1==0 correspo\
nding orbits are excluded. The above are labeled {x1,x2,x3,y1,y2,y3} in the output of CALCULATE(CAL) or GO, and also labeled 1 to \
6 in the second element of FFS[\"CALC\"] and FFS[\"GO\"].\n\n    This matching is done when dp1 is within the off-momentum range g\
iven by DP, i.e., Abs[dp1] < DP. If dp1 is in the range, the nearest zero- amplitude optics is chosen. The maching conditions for \
the finite- amplitude optics are same as those for the zero-amplitude one.\n   Th orbit with finte initial condition never close a\
fter one revolution, but FFS simply ignores it and obtain the periodic optics around the open\norbit."[p$2681,p1$2681]])===
    Undefined,
equ$2681="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["MatchingAmplitude is a list of amplitudes fo\
r the finite-amplitude matching.\n\nUsage: MatchingAmplitude := { {dp1,x1,y1}, ..};\n\nwhere dp1 is the momentum deviation to be m\
atched, x1 and y1 are the horizontal and vertical amplitudes at the beginning of the beam line, normalized by Sqrt of the sum of t\
he emittance, i.e., Sqrt[(EMITX+EMITY)]. Three orbits are chosen in each dimension. The initial conditions of the orbit is chosen \
as\n\n   {X,Px,Y,Py} =\n   { {x1,0,0,0}, {-x1/2,Sqrt[3]/2 x1,0,0}, {-x1/2,-Sqrt[3]/2 x1,0,0},\n     {0,0,y1,0}, {0,0,-y1/2,Sqrt[3]\
/2 y1}, {0,0,-y1/2,Sqrt[3]/2 y1} },\n\nand when x1==0 or y1==0 corresponding orbits are excluded. The above are labeled {x1,x2,x3,\
y1,y2,y3} in the output of CALCULATE(CAL) or GO, and also labeled 1 to 6 in the second element of FFS[\"CALC\"] and FFS[\"GO\"].\n\
\n    This matching is done when dp1 is within the off-momentum range given by DP, i.e., Abs[dp1] < DP. If dp1 is in the range, th\
e nearest zero- amplitude optics is chosen. The maching conditions for the finite- amplitude optics are same as those for the zero\
-amplitude one.\n   Th orbit with finte initial condition never close after one revolution, but FFS simply ignores it and obtain t\
he periodic optics around the open\norbit."[p$2681,p1$2681]]=
       equ$2681;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2681},out$2681=lx$2681@Typeset["MatchingAmplitude is a list of amplitudes for the finite-amplitude matching.\n\nUsage: Ma\
tchingAmplitude := { {dp1,x1,y1}, ..};\n\nwhere dp1 is the momentum deviation to be matched, x1 and y1 are the horizontal and vert\
ical amplitudes at the beginning of the beam line, normalized by Sqrt of the sum of the emittance, i.e., Sqrt[(EMITX+EMITY)]. Thre\
e orbits are chosen in each dimension. The initial conditions of the orbit is chosen as\n\n   {X,Px,Y,Py} =\n   { {x1,0,0,0}, {-x1\
/2,Sqrt[3]/2 x1,0,0}, {-x1/2,-Sqrt[3]/2 x1,0,0},\n     {0,0,y1,0}, {0,0,-y1/2,Sqrt[3]/2 y1}, {0,0,-y1/2,Sqrt[3]/2 y1} },\n\nand wh\
en x1==0 or y1==0 corresponding orbits are excluded. The above are labeled {x1,x2,x3,y1,y2,y3} in the output of CALCULATE(CAL) or \
GO, and also labeled 1 to 6 in the second element of FFS[\"CALC\"] and FFS[\"GO\"].\n\n    This matching is done when dp1 is withi\
n the off-momentum range given by DP, i.e., Abs[dp1] < DP. If dp1 is in the range, the nearest zero- amplitude optics is chosen. T\
he maching conditions for the finite- amplitude optics are same as those for the zero-amplitude one.\n   Th orbit with finte initi\
al condition never close after one revolution, but FFS simply ignores it and obtain the periodic optics around the open\norbit."[
           p$2681,p1$2681],Format->Help2HTML`oB$];
        System["mv -f "//out$2681//" "//equ$2681]];
      Exit[]]];
   "MatchingAmplitude is a list of amplitudes for the finite-amplitude matching.\n\nUsage: MatchingAmplitude := { {dp1,x1,y1}, ..}\
;\n\nwhere dp1 is the momentum deviation to be matched, x1 and y1 are the horizontal and vertical amplitudes at the beginning of t\
he beam line, normalized by Sqrt of the sum of the emittance, i.e., Sqrt[(EMITX+EMITY)]. Three orbits are chosen in each dimension\
. The initial conditions of the orbit is chosen as\n\n   {X,Px,Y,Py} =\n   { {x1,0,0,0}, {-x1/2,Sqrt[3]/2 x1,0,0}, {-x1/2,-Sqrt[3]\
/2 x1,0,0},\n     {0,0,y1,0}, {0,0,-y1/2,Sqrt[3]/2 y1}, {0,0,-y1/2,Sqrt[3]/2 y1} },\n\nand when x1==0 or y1==0 corresponding orbit\
s are excluded. The above are labeled {x1,x2,x3,y1,y2,y3} in the output of CALCULATE(CAL) or GO, and also labeled 1 to 6 in the se\
cond element of FFS[\"CALC\"] and FFS[\"GO\"].\n\n    This matching is done when dp1 is within the off-momentum range given by DP,\
 i.e., Abs[dp1] < DP. If dp1 is in the range, the nearest zero- amplitude optics is chosen. The maching conditions for the finite-\
 amplitude optics are same as those for the zero-amplitude one.\n   Th orbit with finte initial condition never close after one re\
volution, but FFS simply ignores it and obtain the periodic optics around the open\norbit."[1,Max[p0$2681,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2681//"\" />"//
Help2HTML`oy$["MatchingAmplitude is a list of amplitudes for the finite-amplitude matching.\n\nUsage: MatchingAmplitude := { {dp1,\
x1,y1}, ..};\n\nwhere dp1 is the momentum deviation to be matched, x1 and y1 are the horizontal and vertical amplitudes at the beg\
inning of the beam line, normalized by Sqrt of the sum of the emittance, i.e., Sqrt[(EMITX+EMITY)]. Three orbits are chosen in eac\
h dimension. The initial conditions of the orbit is chosen as\n\n   {X,Px,Y,Py} =\n   { {x1,0,0,0}, {-x1/2,Sqrt[3]/2 x1,0,0}, {-x1\
/2,-Sqrt[3]/2 x1,0,0},\n     {0,0,y1,0}, {0,0,-y1/2,Sqrt[3]/2 y1}, {0,0,-y1/2,Sqrt[3]/2 y1} },\n\nand when x1==0 or y1==0 correspo\
nding orbits are excluded. The above are labeled {x1,x2,x3,y1,y2,y3} in the output of CALCULATE(CAL) or GO, and also labeled 1 to \
6 in the second element of FFS[\"CALC\"] and FFS[\"GO\"].\n\n    This matching is done when dp1 is within the off-momentum range g\
iven by DP, i.e., Abs[dp1] < DP. If dp1 is in the range, the nearest zero- amplitude optics is chosen. The maching conditions for \
the finite- amplitude optics are same as those for the zero-amplitude one.\n   Th orbit with finte initial condition never close a\
fter one revolution, but FFS simply ignores it and obtain the periodic optics around the open\norbit."[p2$2681,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L506>DP</A> <A HREF=#L513>EMITX</A> <A HREF=#L515>EMITY</A> <A HREF=#L477>off-momentum-matching</A> <A HREF=#L32>CALCULATE(CAL)</A> <A HREF=#L469>GO</A></PRE>
<LI>
<H3><A NAME=L528>
MatchingResidual</A></H3>
<PRE>If[{},
Help2HTML`oA$["MatchingResidual holds the convergence in the last GO or CALCULATE(CAL) commands. It is calculated by\n\n     sw*(S\
um[(w_i*df_i)^ExponentOfResidual,{i}]/sw)^(2/ExponentOfResidual)\n     +penalty\n where w_i is the weight of the i-th condition, d\
f_i is the difference of the i-th function from the goal, penalty is an additional big number  (typically 10), when the optics is \
unstable or closed orbit is not found in the case of CELL. The parameter sw is defined as\n\n     sw=Sum[(OffMomentumWeight/2/woff\
)^2,{i}]\n with\n\n     woff = 1                               for on-momentum optics\n          = Sqrt[number-of-momentum-points]\
 for off-momentum optics.\n The weight of the function is lighter in the case of off-momentum-matching so that all off-momentum de\
viations functions weight equal to the on-momentum one. However, the relative weight for the off-momentum part can be changed by s\
etting OffMomentumWeight. \n   The weight of each function at each point with each momentum can be specified by defining the FitWe\
ight function."],
p$2684=1+p$2684[[1,2]];p1$2684=StringPosition["MatchingResidual holds the convergence in the last GO or CALCULATE(CAL) commands. I\
t is calculated by\n\n     sw*(Sum[(w_i*df_i)^ExponentOfResidual,{i}]/sw)^(2/ExponentOfResidual)\n     +penalty\n where w_i is the\
 weight of the i-th condition, df_i is the difference of the i-th function from the goal, penalty is an additional big number  (ty\
pically 10), when the optics is unstable or closed orbit is not found in the case of CELL. The parameter sw is defined as\n\n     \
sw=Sum[(OffMomentumWeight/2/woff)^2,{i}]\n with\n\n     woff = 1                               for on-momentum optics\n          =\
 Sqrt[number-of-momentum-points] for off-momentum optics.\n The weight of the function is lighter in the case of off-momentum-matc\
hing so that all off-momentum deviations functions weight equal to the on-momentum one. However, the relative weight for the off-m\
omentum part can be changed by setting OffMomentumWeight. \n   The weight of each function at each point with each momentum can be\
 specified by defining the FitWeight function."[p$2684,-1],">::",1];
   p1$2684=If[p1$2684==={},1027,-2+p$2684+p1$2684[[1,1]]];
neq=Which["MatchingResidual holds the convergence in the last GO or CALCULATE(CAL) commands. It is calculated by\n\n     sw*(Sum[(\
w_i*df_i)^ExponentOfResidual,{i}]/sw)^(2/ExponentOfResidual)\n     +penalty\n where w_i is the weight of the i-th condition, df_i \
is the difference of the i-th function from the goal, penalty is an additional big number  (typically 10), when the optics is unst\
able or closed orbit is not found in the case of CELL. The parameter sw is defined as\n\n     sw=Sum[(OffMomentumWeight/2/woff)^2,\
{i}]\n with\n\n     woff = 1                               for on-momentum optics\n          = Sqrt[number-of-momentum-points] for\
 off-momentum optics.\n The weight of the function is lighter in the case of off-momentum-matching so that all off-momentum deviat\
ions functions weight equal to the on-momentum one. However, the relative weight for the off-momentum part can be changed by setti\
ng OffMomentumWeight. \n   The weight of each function at each point with each momentum can be specified by defining the FitWeight\
 function."[p$2684,4+p$2684]==="Text[",
    lx$2684:=Help2HTML`oa$;p$2684=5+p$2684;p1$2684-=1;p2$2684=5+p1$2684;p0$2684=-9+p$2684;If[(pe$2684=
StringPosition["MatchingResidual holds the convergence in the last GO or CALCULATE(CAL) commands. It is calculated by\n\n     sw*(\
Sum[(w_i*df_i)^ExponentOfResidual,{i}]/sw)^(2/ExponentOfResidual)\n     +penalty\n where w_i is the weight of the i-th condition, \
df_i is the difference of the i-th function from the goal, penalty is an additional big number  (typically 10), when the optics is\
 unstable or closed orbit is not found in the case of CELL. The parameter sw is defined as\n\n     sw=Sum[(OffMomentumWeight/2/wof\
f)^2,{i}]\n with\n\n     woff = 1                               for on-momentum optics\n          = Sqrt[number-of-momentum-points\
] for off-momentum optics.\n The weight of the function is lighter in the case of off-momentum-matching so that all off-momentum d\
eviations functions weight equal to the on-momentum one. However, the relative weight for the off-momentum part can be changed by \
setting OffMomentumWeight. \n   The weight of each function at each point with each momentum can be specified by defining the FitW\
eight function."[p$2684,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["MatchingResidual holds the convergence in the last GO or CALCULATE(CAL) commands. It is calculated by\n\n     sw*\
(Sum[(w_i*df_i)^ExponentOfResidual,{i}]/sw)^(2/ExponentOfResidual)\n     +penalty\n where w_i is the weight of the i-th condition,\
 df_i is the difference of the i-th function from the goal, penalty is an additional big number  (typically 10), when the optics i\
s unstable or closed orbit is not found in the case of CELL. The parameter sw is defined as\n\n     sw=Sum[(OffMomentumWeight/2/wo\
ff)^2,{i}]\n with\n\n     woff = 1                               for on-momentum optics\n          = Sqrt[number-of-momentum-point\
s] for off-momentum optics.\n The weight of the function is lighter in the case of off-momentum-matching so that all off-momentum \
deviations functions weight equal to the on-momentum one. However, the relative weight for the off-momentum part can be changed by\
 setting OffMomentumWeight. \n   The weight of each function at each point with each momentum can be specified by defining the Fit\
Weight function."[p$2684+pe$2684[[1,2]],p1$2684]]],
        p1$2684=-2+p$2684+pe$2684[[1,1]]}[[
       1]],
      0],
    1,lx$2684:=Help2HTML`o9$;p2$2684=4+p1$2684;p0$2684=-4+p$2684;0];
  If[(equ$2684=
Help2HTML`o8$["MatchingResidual holds the convergence in the last GO or CALCULATE(CAL) commands. It is calculated by\n\n     sw*(S\
um[(w_i*df_i)^ExponentOfResidual,{i}]/sw)^(2/ExponentOfResidual)\n     +penalty\n where w_i is the weight of the i-th condition, d\
f_i is the difference of the i-th function from the goal, penalty is an additional big number  (typically 10), when the optics is \
unstable or closed orbit is not found in the case of CELL. The parameter sw is defined as\n\n     sw=Sum[(OffMomentumWeight/2/woff\
)^2,{i}]\n with\n\n     woff = 1                               for on-momentum optics\n          = Sqrt[number-of-momentum-points]\
 for off-momentum optics.\n The weight of the function is lighter in the case of off-momentum-matching so that all off-momentum de\
viations functions weight equal to the on-momentum one. However, the relative weight for the off-momentum part can be changed by s\
etting OffMomentumWeight. \n   The weight of each function at each point with each momentum can be specified by defining the FitWe\
ight function."[p$2684,p1$2684]])===
    Undefined,
equ$2684="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["MatchingResidual holds the convergence in th\
e last GO or CALCULATE(CAL) commands. It is calculated by\n\n     sw*(Sum[(w_i*df_i)^ExponentOfResidual,{i}]/sw)^(2/ExponentOfResi\
dual)\n     +penalty\n where w_i is the weight of the i-th condition, df_i is the difference of the i-th function from the goal, p\
enalty is an additional big number  (typically 10), when the optics is unstable or closed orbit is not found in the case of CELL. \
The parameter sw is defined as\n\n     sw=Sum[(OffMomentumWeight/2/woff)^2,{i}]\n with\n\n     woff = 1                           \
    for on-momentum optics\n          = Sqrt[number-of-momentum-points] for off-momentum optics.\n The weight of the function is l\
ighter in the case of off-momentum-matching so that all off-momentum deviations functions weight equal to the on-momentum one. How\
ever, the relative weight for the off-momentum part can be changed by setting OffMomentumWeight. \n   The weight of each function \
at each point with each momentum can be specified by defining the FitWeight function."[p$2684,p1$2684]]=
       equ$2684;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2684},out$2684=lx$2684@Typeset["MatchingResidual holds the convergence in the last GO or CALCULATE(CAL) commands. It is c\
alculated by\n\n     sw*(Sum[(w_i*df_i)^ExponentOfResidual,{i}]/sw)^(2/ExponentOfResidual)\n     +penalty\n where w_i is the weigh\
t of the i-th condition, df_i is the difference of the i-th function from the goal, penalty is an additional big number  (typicall\
y 10), when the optics is unstable or closed orbit is not found in the case of CELL. The parameter sw is defined as\n\n     sw=Sum\
[(OffMomentumWeight/2/woff)^2,{i}]\n with\n\n     woff = 1                               for on-momentum optics\n          = Sqrt[\
number-of-momentum-points] for off-momentum optics.\n The weight of the function is lighter in the case of off-momentum-matching s\
o that all off-momentum deviations functions weight equal to the on-momentum one. However, the relative weight for the off-momentu\
m part can be changed by setting OffMomentumWeight. \n   The weight of each function at each point with each momentum can be speci\
fied by defining the FitWeight function."[p$2684,p1$2684],Format->Help2HTML`oB$];
        System["mv -f "//out$2684//" "//equ$2684]];
      Exit[]]];
   "MatchingResidual holds the convergence in the last GO or CALCULATE(CAL) commands. It is calculated by\n\n     sw*(Sum[(w_i*df_\
i)^ExponentOfResidual,{i}]/sw)^(2/ExponentOfResidual)\n     +penalty\n where w_i is the weight of the i-th condition, df_i is the \
difference of the i-th function from the goal, penalty is an additional big number  (typically 10), when the optics is unstable or\
 closed orbit is not found in the case of CELL. The parameter sw is defined as\n\n     sw=Sum[(OffMomentumWeight/2/woff)^2,{i}]\n \
with\n\n     woff = 1                               for on-momentum optics\n          = Sqrt[number-of-momentum-points] for off-mo\
mentum optics.\n The weight of the function is lighter in the case of off-momentum-matching so that all off-momentum deviations fu\
nctions weight equal to the on-momentum one. However, the relative weight for the off-momentum part can be changed by setting OffM\
omentumWeight. \n   The weight of each function at each point with each momentum can be specified by defining the FitWeight functi\
on."[1,Max[p0$2684,0]]//"<img  class=\"eqs\" SRC=\""//equ$2684//"\" />"//
Help2HTML`oy$["MatchingResidual holds the convergence in the last GO or CALCULATE(CAL) commands. It is calculated by\n\n     sw*(S\
um[(w_i*df_i)^ExponentOfResidual,{i}]/sw)^(2/ExponentOfResidual)\n     +penalty\n where w_i is the weight of the i-th condition, d\
f_i is the difference of the i-th function from the goal, penalty is an additional big number  (typically 10), when the optics is \
unstable or closed orbit is not found in the case of CELL. The parameter sw is defined as\n\n     sw=Sum[(OffMomentumWeight/2/woff\
)^2,{i}]\n with\n\n     woff = 1                               for on-momentum optics\n          = Sqrt[number-of-momentum-points]\
 for off-momentum optics.\n The weight of the function is lighter in the case of off-momentum-matching so that all off-momentum de\
viations functions weight equal to the on-momentum one. However, the relative weight for the off-momentum part can be changed by s\
etting OffMomentumWeight. \n   The weight of each function at each point with each momentum can be specified by defining the FitWe\
ight function."[p2$2684,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L519>ExponentOfResidual</A> <A HREF=#L504>CONVERGENCE</A> <A HREF=#L536>OffMomentumWeight</A> <A HREF=#L477>off-momentum-matching</A> <A HREF=#L395>FitWeight</A></PRE>
<LI>
<H3><A NAME=L529>
MASS</A></H3>
<PRE>If[{},Help2HTML`oA$["MASS is the rest mass of the particle in eV. The default is the electron mass."],
 p$2687=1+p$2687[[1,2]];p1$2687=
   StringPosition["MASS is the rest mass of the particle in eV. The default is the electron mass."[p$2687,-1],">::",1];
  p1$2687=If[p1$2687==={},78,-2+p$2687+p1$2687[[1,1]]];
  neq=Which["MASS is the rest mass of the particle in eV. The default is the electron mass."[p$2687,4+p$2687]==="Text[",
    lx$2687:=Help2HTML`oa$;p$2687=5+p$2687;p1$2687-=1;p2$2687=5+p1$2687;p0$2687=-9+p$2687;
     If[(pe$2687=StringPosition["MASS is the rest mass of the particle in eV. The default is the electron mass."[p$2687,-2],";;;"]
        )<=>
       {},
      {Max[0,
        -1+ToExpression["MASS is the rest mass of the particle in eV. The default is the electron mass."[p$2687+pe$2687[[1,2]],
           p1$2687]]],
        p1$2687=-2+p$2687+pe$2687[[1,1]]}[[
       1]],
      0],
    1,lx$2687:=Help2HTML`o9$;p2$2687=4+p1$2687;p0$2687=-4+p$2687;0];
  If[(equ$2687=Help2HTML`o8$["MASS is the rest mass of the particle in eV. The default is the electron mass."[p$2687,p1$2687]])===
    Undefined,
   equ$2687="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "MASS is the rest mass of the particle in eV. The default is the electron mass."[p$2687,p1$2687]]=
       equ$2687;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$2687},out$2687=lx$2687@Typeset["MASS is the rest mass of the particle in eV. The default is the electron mass."[p
           $2687,p1$2687],Format->Help2HTML`oB$];
        System["mv -f "//out$2687//" "//equ$2687]];
      Exit[]]];
   "MASS is the rest mass of the particle in eV. The default is the electron mass."[1,Max[p0$2687,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2687//"\" />"//
   Help2HTML`oy$["MASS is the rest mass of the particle in eV. The default is the electron mass."[p2$2687,-1]]
]</PRE>
<LI>
<H3><A NAME=L530>
MINCOUP</A></H3>
<PRE>If[{},
Help2HTML`oA$["MINCOUP is the minimum emittance ratio to be assumed in the calculation of intrabeam effects in EMITTANCE(EMIT) and\
 Emittance[]. Emittances Max[EMITk, MINCOUP*(EMITX+EMITY)] (k=X,Y) are assumed in the intrabeam calculation. Accessible in MAIN."],
 p$2689=1+p$2689[[1,2]];
p1$2689=StringPosition["MINCOUP is the minimum emittance ratio to be assumed in the calculation of intrabeam effects in EMITTANCE(\
EMIT) and Emittance[]. Emittances Max[EMITk, MINCOUP*(EMITX+EMITY)] (k=X,Y) are assumed in the intrabeam calculation. Accessible i\
n MAIN."[p$2689,-1],">::",1];
   p1$2689=If[p1$2689==={},243,-2+p$2689+p1$2689[[1,1]]];
neq=Which["MINCOUP is the minimum emittance ratio to be assumed in the calculation of intrabeam effects in EMITTANCE(EMIT) and Emi\
ttance[]. Emittances Max[EMITk, MINCOUP*(EMITX+EMITY)] (k=X,Y) are assumed in the intrabeam calculation. Accessible in MAIN."[p
      $2689,4+p$2689]===
     "Text[",
lx$2689:=Help2HTML`oa$;p$2689=5+p$2689;p1$2689-=1;p2$2689=5+p1$2689;p0$2689=-9+p$2689;If[(pe$2689=StringPosition["MINCOUP is the m\
inimum emittance ratio to be assumed in the calculation of intrabeam effects in EMITTANCE(EMIT) and Emittance[]. Emittances Max[EM\
ITk, MINCOUP*(EMITX+EMITY)] (k=X,Y) are assumed in the intrabeam calculation. Accessible in MAIN."[p$2689,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["MINCOUP is the minimum emittance ratio to be assumed in the calculation of intrabeam effects in EMITTANCE(EMIT) a\
nd Emittance[]. Emittances Max[EMITk, MINCOUP*(EMITX+EMITY)] (k=X,Y) are assumed in the intrabeam calculation. Accessible in MAIN."
          [p$2689+pe$2689[[1,2]],p1$2689]]],
        p1$2689=-2+p$2689+pe$2689[[1,1]]}[[
       1]],
      0],
    1,lx$2689:=Help2HTML`o9$;p2$2689=4+p1$2689;p0$2689=-4+p$2689;0];
  If[(equ$2689=
Help2HTML`o8$["MINCOUP is the minimum emittance ratio to be assumed in the calculation of intrabeam effects in EMITTANCE(EMIT) and\
 Emittance[]. Emittances Max[EMITk, MINCOUP*(EMITX+EMITY)] (k=X,Y) are assumed in the intrabeam calculation. Accessible in MAIN."[
       p$2689,p1$2689]])===
    Undefined,
equ$2689="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["MINCOUP is the minimum emittance ratio to be\
 assumed in the calculation of intrabeam effects in EMITTANCE(EMIT) and Emittance[]. Emittances Max[EMITk, MINCOUP*(EMITX+EMITY)] \
(k=X,Y) are assumed in the intrabeam calculation. Accessible in MAIN."[p$2689,p1$2689]]=
       equ$2689;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2689},out$2689=lx$2689@Typeset["MINCOUP is the minimum emittance ratio to be assumed in the calculation of intrabeam effe\
cts in EMITTANCE(EMIT) and Emittance[]. Emittances Max[EMITk, MINCOUP*(EMITX+EMITY)] (k=X,Y) are assumed in the intrabeam calculat\
ion. Accessible in MAIN."[p$2689,p1$2689],Format->Help2HTML`oB$];
        System["mv -f "//out$2689//" "//equ$2689]];
      Exit[]]];
   "MINCOUP is the minimum emittance ratio to be assumed in the calculation of intrabeam effects in EMITTANCE(EMIT) and Emittance[\
]. Emittances Max[EMITk, MINCOUP*(EMITX+EMITY)] (k=X,Y) are assumed in the intrabeam calculation. Accessible in MAIN."[1,
    Max[p0$2689,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2689//"\" />"//
Help2HTML`oy$["MINCOUP is the minimum emittance ratio to be assumed in the calculation of intrabeam effects in EMITTANCE(EMIT) and\
 Emittance[]. Emittances Max[EMITk, MINCOUP*(EMITX+EMITY)] (k=X,Y) are assumed in the intrabeam calculation. Accessible in MAIN."[
     p2$2689,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L295>EMITTANCE(EMIT)</A> <A HREF=#L389>Emittance</A> <A HREF=#L325>INTRA</A> <A HREF=#L55>equilibrium-beam-envelope</A></PRE>
<LI>
<H3><A NAME=L531>
MOMENTUM</A></H3>
<PRE>If[{},Help2HTML`oA$["MOMENTUM is the nominal momentum of the beam line at the entrance in eV/c. Accessible in MAIN."],
 p$2692=1+p$2692[[1,2]];
  p1$2692=StringPosition["MOMENTUM is the nominal momentum of the beam line at the entrance in eV/c. Accessible in MAIN."[p$2692,-1
     ],
    ">::",1];
   p1$2692=If[p1$2692==={},94,-2+p$2692+p1$2692[[1,1]]];
  neq=Which["MOMENTUM is the nominal momentum of the beam line at the entrance in eV/c. Accessible in MAIN."[p$2692,4+p$2692]===
     "Text[",
    lx$2692:=Help2HTML`oa$;p$2692=5+p$2692;p1$2692-=1;p2$2692=5+p1$2692;p0$2692=-9+p$2692;If[(pe$2692=StringPosition[
         "MOMENTUM is the nominal momentum of the beam line at the entrance in eV/c. Accessible in MAIN."[p$2692,-2],";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression["MOMENTUM is the nominal momentum of the beam line at the entrance in eV/c. Accessible in MAIN."[p$2692+
            pe$2692[[1,2]],
           p1$2692]]],
        p1$2692=-2+p$2692+pe$2692[[1,1]]}[[
       1]],
      0],
    1,lx$2692:=Help2HTML`o9$;p2$2692=4+p1$2692;p0$2692=-4+p$2692;0];
  If[(equ$2692=
     Help2HTML`o8$["MOMENTUM is the nominal momentum of the beam line at the entrance in eV/c. Accessible in MAIN."[p$2692,p1$2692]
      ])===
    Undefined,
   equ$2692="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "MOMENTUM is the nominal momentum of the beam line at the entrance in eV/c. Accessible in MAIN."[p$2692,p1$2692]]=
       equ$2692;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$2692},out$2692=lx$2692@Typeset[
          "MOMENTUM is the nominal momentum of the beam line at the entrance in eV/c. Accessible in MAIN."[p$2692,p1$2692],
          Format->Help2HTML`oB$];
        System["mv -f "//out$2692//" "//equ$2692]];
      Exit[]]];
   "MOMENTUM is the nominal momentum of the beam line at the entrance in eV/c. Accessible in MAIN."[1,Max[p0$2692,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2692//"\" />"//
   Help2HTML`oy$["MOMENTUM is the nominal momentum of the beam line at the entrance in eV/c. Accessible in MAIN."[p2$2692,-1]]
 ]
</PRE>
<LI>
<H3><A NAME=L532>
NBUNCH</A></H3>
<PRE>If[{},Help2HTML`oA$["NBUNCH is the number of bunches for the calculation of WakeFunction. Accessible in MAIN."],
 p$2694=1+p$2694[[1,2]];
  p1$2694=StringPosition["NBUNCH is the number of bunches for the calculation of WakeFunction. Accessible in MAIN."[p$2694,-1],
    ">::",1];
   p1$2694=If[p1$2694==={},88,-2+p$2694+p1$2694[[1,1]]];
  neq=Which["NBUNCH is the number of bunches for the calculation of WakeFunction. Accessible in MAIN."[p$2694,4+p$2694]==="Text[",
    lx$2694:=Help2HTML`oa$;p$2694=5+p$2694;p1$2694-=1;p2$2694=5+p1$2694;p0$2694=-9+p$2694;
     If[(pe$2694=StringPosition["NBUNCH is the number of bunches for the calculation of WakeFunction. Accessible in MAIN."[p$2694,
          -2],
         ";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression["NBUNCH is the number of bunches for the calculation of WakeFunction. Accessible in MAIN."[p$2694+pe$2694[[
             1,2]],
           p1$2694]]],
        p1$2694=-2+p$2694+pe$2694[[1,1]]}[[
       1]],
      0],
    1,lx$2694:=Help2HTML`o9$;p2$2694=4+p1$2694;p0$2694=-4+p$2694;0];
  If[(equ$2694=
     Help2HTML`o8$["NBUNCH is the number of bunches for the calculation of WakeFunction. Accessible in MAIN."[p$2694,p1$2694]])===
    Undefined,
   equ$2694="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "NBUNCH is the number of bunches for the calculation of WakeFunction. Accessible in MAIN."[p$2694,p1$2694]]=
       equ$2694;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$2694},out$2694=lx$2694@Typeset[
          "NBUNCH is the number of bunches for the calculation of WakeFunction. Accessible in MAIN."[p$2694,p1$2694],
          Format->Help2HTML`oB$];
        System["mv -f "//out$2694//" "//equ$2694]];
      Exit[]]];
   "NBUNCH is the number of bunches for the calculation of WakeFunction. Accessible in MAIN."[1,Max[p0$2694,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2694//"\" />"//
   Help2HTML`oy$["NBUNCH is the number of bunches for the calculation of WakeFunction. Accessible in MAIN."[p2$2694,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L540>PBUNCH</A></PRE>
<LI>
<H3><A NAME=L533>
NetResidual</A></H3>
<PRE>If[{},Help2HTML`oA$["The net residual of convergence except the penalty for unstable optics."],
 p$2697=1+p$2697[[1,2]];p1$2697=StringPosition["The net residual of convergence except the penalty for unstable optics."[p$2697,-1
     ],
    ">::",1];
   p1$2697=If[p1$2697==={},71,-2+p$2697+p1$2697[[1,1]]];
  neq=Which["The net residual of convergence except the penalty for unstable optics."[p$2697,4+p$2697]==="Text[",
    lx$2697:=Help2HTML`oa$;p$2697=5+p$2697;p1$2697-=1;p2$2697=5+p1$2697;p0$2697=-9+p$2697;
     If[(pe$2697=StringPosition["The net residual of convergence except the penalty for unstable optics."[p$2697,-2],";;;"])<=>{},
      {Max[0,
        -1+ToExpression["The net residual of convergence except the penalty for unstable optics."[p$2697+pe$2697[[1,2]],p1$2697]]],
       p1$2697=-2+p$2697+pe$2697[[1,1]]}[[1]],
      0],
    1,lx$2697:=Help2HTML`o9$;p2$2697=4+p1$2697;p0$2697=-4+p$2697;0];
  If[(equ$2697=Help2HTML`o8$["The net residual of convergence except the penalty for unstable optics."[p$2697,p1$2697]])===
    Undefined,
   equ$2697="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "The net residual of convergence except the penalty for unstable optics."[p$2697,p1$2697]]=
       equ$2697;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$2697},out$2697=lx$2697@Typeset["The net residual of convergence except the penalty for unstable optics."[p$2697,
           p1$2697],Format->Help2HTML`oB$];
        System["mv -f "//out$2697//" "//equ$2697]];
      Exit[]]];
   "The net residual of convergence except the penalty for unstable optics."[1,Max[p0$2697,0]]//"<img  class=\"eqs\" SRC=\""//
   equ$2697//"\" />"//Help2HTML`oy$["The net residual of convergence except the penalty for unstable optics."[p2$2697,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L528>MatchingResidual</A> StablilityLevel</PRE>
<LI>
<H3><A NAME=L534>
NP</A></H3>
<PRE>If[{},Help2HTML`oA$["NP is the number of particles in the tracking. Accessible in MAIN."],
 p$2700=1+p$2700[[1,2]];p1$2700=StringPosition["NP is the number of particles in the tracking. Accessible in MAIN."[p$2700,-1],
    ">::",1];
   p1$2700=If[p1$2700==={},66,-2+p$2700+p1$2700[[1,1]]];
  neq=Which["NP is the number of particles in the tracking. Accessible in MAIN."[p$2700,4+p$2700]==="Text[",
    lx$2700:=Help2HTML`oa$;p$2700=5+p$2700;p1$2700-=1;p2$2700=5+p1$2700;p0$2700=-9+p$2700;
     If[(pe$2700=StringPosition["NP is the number of particles in the tracking. Accessible in MAIN."[p$2700,-2],";;;"])<=>{},
      {Max[0,-1+ToExpression["NP is the number of particles in the tracking. Accessible in MAIN."[p$2700+pe$2700[[1,2]],p1$2700]]],
       p1$2700=-2+p$2700+pe$2700[[1,1]]}[[1]],
      0],
    1,lx$2700:=Help2HTML`o9$;p2$2700=4+p1$2700;p0$2700=-4+p$2700;0];
  If[(equ$2700=Help2HTML`o8$["NP is the number of particles in the tracking. Accessible in MAIN."[p$2700,p1$2700]])===Undefined,
   equ$2700="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["NP is the number of particles in the tracking. Accessible in MAIN."[p$2700,p1$2700]]=equ$2700;
      LaTeX`ob$+=neq,
     --LaTeX`ob$;With[{lx$2700},out$2700=lx$2700@Typeset["NP is the number of particles in the tracking. Accessible in MAIN."[p
           $2700,p1$2700],Format->Help2HTML`oB$];
        System["mv -f "//out$2700//" "//equ$2700]];
      Exit[]]];
   "NP is the number of particles in the tracking. Accessible in MAIN."[1,Max[p0$2700,0]]//"<img  class=\"eqs\" SRC=\""//equ$2700//
   "\" />"//Help2HTML`oy$["NP is the number of particles in the tracking. Accessible in MAIN."[p2$2700,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L476>MEASURE(MEA)</A></PRE>
<LI>
<H3><A NAME=L535>
NPARA</A></H3>
<PRE>If[{},
Help2HTML`oA$["NPARA specifies the maximum number of parallel processes for various calculations such as CALC, GO, TrackParticles,\
 DynamicApertureSurve, etc."],
p$2703=1+p$2703[[1,2]];p1$2703=StringPosition["NPARA specifies the maximum number of parallel processes for various calculations s\
uch as CALC, GO, TrackParticles, DynamicApertureSurve, etc."[p$2703,-1],">::",1];
   p1$2703=If[p1$2703==={},142,-2+p$2703+p1$2703[[1,1]]];
neq=Which["NPARA specifies the maximum number of parallel processes for various calculations such as CALC, GO, TrackParticles, Dyn\
amicApertureSurve, etc."[p$2703,4+p$2703]==="Text[",
    lx$2703:=Help2HTML`oa$;p$2703=5+p$2703;p1$2703-=1;p2$2703=5+p1$2703;p0$2703=-9+p$2703;
If[(pe$2703=StringPosition["NPARA specifies the maximum number of parallel processes for various calculations such as CALC, GO, Tr\
ackParticles, DynamicApertureSurve, etc."[p$2703,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["NPARA specifies the maximum number of parallel processes for various calculations such as CALC, GO, TrackParticle\
s, DynamicApertureSurve, etc."[p$2703+pe$2703[[1,2]],p1$2703]]],
        p1$2703=-2+p$2703+pe$2703[[1,1]]}[[
       1]],
      0],
    1,lx$2703:=Help2HTML`o9$;p2$2703=4+p1$2703;p0$2703=-4+p$2703;0];
  If[(equ$2703=
Help2HTML`o8$["NPARA specifies the maximum number of parallel processes for various calculations such as CALC, GO, TrackParticles,\
 DynamicApertureSurve, etc."[p$2703,p1$2703]])===
    Undefined,
equ$2703="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["NPARA specifies the maximum number of parall\
el processes for various calculations such as CALC, GO, TrackParticles, DynamicApertureSurve, etc."[p$2703,p1$2703]]=
       equ$2703;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2703},out$2703=lx$2703@Typeset["NPARA specifies the maximum number of parallel processes for various calculations such as\
 CALC, GO, TrackParticles, DynamicApertureSurve, etc."[p$2703,p1$2703],Format->Help2HTML`oB$];
        System["mv -f "//out$2703//" "//equ$2703]];
      Exit[]]];
   "NPARA specifies the maximum number of parallel processes for various calculations such as CALC, GO, TrackParticles, DynamicApe\
rtureSurve, etc."[1,Max[p0$2703,0]]//"<img  class=\"eqs\" SRC=\""//equ$2703//"\" />"//
Help2HTML`oy$["NPARA specifies the maximum number of parallel processes for various calculations such as CALC, GO, TrackParticles,\
 DynamicApertureSurve, etc."[p2$2703,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L32>CALCULATE(CAL)</A> <A HREF=#L469>GO</A> <A HREF=#L409>TrackParticles</A> <A HREF=#L386>DynamicApertureSurvey</A></PRE>
<LI>
<H3><A NAME=L536>
OffMomentumWeight</A></H3>
<PRE>If[{},Help2HTML`oA$["Relative weight of the off-momentum deviation for the off-momentum matching. The default is 1."],
 p$2706=1+p$2706[[1,2]];
  p1$2706=StringPosition["Relative weight of the off-momentum deviation for the off-momentum matching. The default is 1."[p$2706,-1
     ],
    ">::",1];
   p1$2706=If[p1$2706==={},94,-2+p$2706+p1$2706[[1,1]]];
  neq=Which["Relative weight of the off-momentum deviation for the off-momentum matching. The default is 1."[p$2706,4+p$2706]===
     "Text[",
    lx$2706:=Help2HTML`oa$;p$2706=5+p$2706;p1$2706-=1;p2$2706=5+p1$2706;p0$2706=-9+p$2706;If[(pe$2706=StringPosition[
         "Relative weight of the off-momentum deviation for the off-momentum matching. The default is 1."[p$2706,-2],";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression["Relative weight of the off-momentum deviation for the off-momentum matching. The default is 1."[p$2706+
            pe$2706[[1,2]],
           p1$2706]]],
        p1$2706=-2+p$2706+pe$2706[[1,1]]}[[
       1]],
      0],
    1,lx$2706:=Help2HTML`o9$;p2$2706=4+p1$2706;p0$2706=-4+p$2706;0];
  If[(equ$2706=
     Help2HTML`o8$["Relative weight of the off-momentum deviation for the off-momentum matching. The default is 1."[p$2706,p1$2706]
      ])===
    Undefined,
   equ$2706="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "Relative weight of the off-momentum deviation for the off-momentum matching. The default is 1."[p$2706,p1$2706]]=
       equ$2706;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$2706},out$2706=lx$2706@Typeset[
          "Relative weight of the off-momentum deviation for the off-momentum matching. The default is 1."[p$2706,p1$2706],
          Format->Help2HTML`oB$];
        System["mv -f "//out$2706//" "//equ$2706]];
      Exit[]]];
   "Relative weight of the off-momentum deviation for the off-momentum matching. The default is 1."[1,Max[p0$2706,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2706//"\" />"//
   Help2HTML`oy$["Relative weight of the off-momentum deviation for the off-momentum matching. The default is 1."[p2$2706,-1]]
 ]
</PRE>
<PRE>See also:
 <A HREF=#L519>ExponentOfResidual</A> <A HREF=#L504>CONVERGENCE</A> <A HREF=#L528>MatchingResidual</A> <A HREF=#L477>off-momentum-matching</A> <A HREF=#L395>FitWeight</A></PRE>
<LI>
<H3><A NAME=L537>
OMEGA0</A></H3>
<PRE>If[{},Help2HTML`oA$["OMEGA0 is 2*Pi*SpeedOfLight/LINE[\"s\",\"$$$\"] . Accessible in MAIN."],
 p$2709=1+p$2709[[1,2]];p1$2709=StringPosition["OMEGA0 is 2*Pi*SpeedOfLight/LINE[\"s\",\"$$$\"] . Accessible in MAIN."[p$2709,-1],
    ">::",1];
   p1$2709=If[p1$2709==={},65,-2+p$2709+p1$2709[[1,1]]];
  neq=Which["OMEGA0 is 2*Pi*SpeedOfLight/LINE[\"s\",\"$$$\"] . Accessible in MAIN."[p$2709,4+p$2709]==="Text[",
    lx$2709:=Help2HTML`oa$;p$2709=5+p$2709;p1$2709-=1;p2$2709=5+p1$2709;p0$2709=-9+p$2709;
     If[(pe$2709=StringPosition["OMEGA0 is 2*Pi*SpeedOfLight/LINE[\"s\",\"$$$\"] . Accessible in MAIN."[p$2709,-2],";;;"])<=>{},
      {Max[0,
        -1+ToExpression["OMEGA0 is 2*Pi*SpeedOfLight/LINE[\"s\",\"$$$\"] . Accessible in MAIN."[p$2709+pe$2709[[1,2]],p1$2709]]],
       p1$2709=-2+p$2709+pe$2709[[1,1]]}[[1]],
      0],
    1,lx$2709:=Help2HTML`o9$;p2$2709=4+p1$2709;p0$2709=-4+p$2709;0];
  If[(equ$2709=Help2HTML`o8$["OMEGA0 is 2*Pi*SpeedOfLight/LINE[\"s\",\"$$$\"] . Accessible in MAIN."[p$2709,p1$2709]])===
    Undefined,
   equ$2709="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "OMEGA0 is 2*Pi*SpeedOfLight/LINE[\"s\",\"$$$\"] . Accessible in MAIN."[p$2709,p1$2709]]=
       equ$2709;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$2709},out$2709=lx$2709@Typeset["OMEGA0 is 2*Pi*SpeedOfLight/LINE[\"s\",\"$$$\"] . Accessible in MAIN."[p$2709,
           p1$2709],Format->Help2HTML`oB$];
        System["mv -f "//out$2709//" "//equ$2709]];
      Exit[]]];
   "OMEGA0 is 2*Pi*SpeedOfLight/LINE[\"s\",\"$$$\"] . Accessible in MAIN."[1,Max[p0$2709,0]]//"<img  class=\"eqs\" SRC=\""//
   equ$2709//"\" />"//Help2HTML`oy$["OMEGA0 is 2*Pi*SpeedOfLight/LINE[\"s\",\"$$$\"] . Accessible in MAIN."[p2$2709,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L545>SpeedOfLight</A> <A HREF=#L398>LINE</A></PRE>
<LI>
<H3><A NAME=L538>
OpticsEpilog</A></H3>
<PRE>If[{},
Help2HTML`oA$["OpticsEpilog is a variable to assign a user-defined function which is to be executed every time after an optics cal\
culation is done in CALCULATE(CAL) or GO commands. In GO, OpticsEpilog is called at the end of each iteration. This function is us\
eful, for instance, for setting parameters which depends on the result of optics calculation itself."],
 p$2712=1+p$2712[[1,2]];p1$2712=
StringPosition["OpticsEpilog is a variable to assign a user-defined function which is to be executed every time after an optics ca\
lculation is done in CALCULATE(CAL) or GO commands. In GO, OpticsEpilog is called at the end of each iteration. This function is u\
seful, for instance, for setting parameters which depends on the result of optics calculation itself."[p$2712,-1],">::",1];
   p1$2712=If[p1$2712==={},345,-2+p$2712+p1$2712[[1,1]]];
neq=Which["OpticsEpilog is a variable to assign a user-defined function which is to be executed every time after an optics calcula\
tion is done in CALCULATE(CAL) or GO commands. In GO, OpticsEpilog is called at the end of each iteration. This function is useful\
, for instance, for setting parameters which depends on the result of optics calculation itself."[p$2712,4+p$2712]==="Text[",
    lx$2712:=Help2HTML`oa$;p$2712=5+p$2712;p1$2712-=1;p2$2712=5+p1$2712;p0$2712=-9+p$2712;
If[(pe$2712=StringPosition["OpticsEpilog is a variable to assign a user-defined function which is to be executed every time after \
an optics calculation is done in CALCULATE(CAL) or GO commands. In GO, OpticsEpilog is called at the end of each iteration. This f\
unction is useful, for instance, for setting parameters which depends on the result of optics calculation itself."[p$2712,-2],";;;"
         ])<=>
       {},
      {Max[0,
-1+ToExpression["OpticsEpilog is a variable to assign a user-defined function which is to be executed every time after an optics c\
alculation is done in CALCULATE(CAL) or GO commands. In GO, OpticsEpilog is called at the end of each iteration. This function is \
useful, for instance, for setting parameters which depends on the result of optics calculation itself."[p$2712+pe$2712[[1,2]],
           p1$2712]]],
        p1$2712=-2+p$2712+pe$2712[[1,1]]}[[
       1]],
      0],
    1,lx$2712:=Help2HTML`o9$;p2$2712=4+p1$2712;p0$2712=-4+p$2712;0];
  If[(equ$2712=
Help2HTML`o8$["OpticsEpilog is a variable to assign a user-defined function which is to be executed every time after an optics cal\
culation is done in CALCULATE(CAL) or GO commands. In GO, OpticsEpilog is called at the end of each iteration. This function is us\
eful, for instance, for setting parameters which depends on the result of optics calculation itself."[p$2712,p1$2712]])===
    Undefined,
equ$2712="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["OpticsEpilog is a variable to assign a user-\
defined function which is to be executed every time after an optics calculation is done in CALCULATE(CAL) or GO commands. In GO, O\
pticsEpilog is called at the end of each iteration. This function is useful, for instance, for setting parameters which depends on\
 the result of optics calculation itself."[p$2712,p1$2712]]=
       equ$2712;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2712},out$2712=lx$2712@Typeset["OpticsEpilog is a variable to assign a user-defined function which is to be executed ever\
y time after an optics calculation is done in CALCULATE(CAL) or GO commands. In GO, OpticsEpilog is called at the end of each iter\
ation. This function is useful, for instance, for setting parameters which depends on the result of optics calculation itself."[p
           $2712,p1$2712],Format->Help2HTML`oB$];
        System["mv -f "//out$2712//" "//equ$2712]];
      Exit[]]];
   "OpticsEpilog is a variable to assign a user-defined function which is to be executed every time after an optics calculation is\
 done in CALCULATE(CAL) or GO commands. In GO, OpticsEpilog is called at the end of each iteration. This function is useful, for i\
nstance, for setting parameters which depends on the result of optics calculation itself."[1,Max[p0$2712,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2712//"\" />"//
Help2HTML`oy$["OpticsEpilog is a variable to assign a user-defined function which is to be executed every time after an optics cal\
culation is done in CALCULATE(CAL) or GO commands. In GO, OpticsEpilog is called at the end of each iteration. This function is us\
eful, for instance, for setting parameters which depends on the result of optics calculation itself."[p2$2712,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L539>OpticsProlog</A></PRE>
<LI>
<H3><A NAME=L539>
OpticsProlog</A></H3>
<PRE>If[{},
Help2HTML`oA$["OpticsProlog is a variable to assign a user-defined function which is to be executed every time before an optics ca\
lculation is done in the CALCULATE(CAL) or GO commands. In GO, OpticsProlog is called at the beginning of each iteration. This fun\
ction is useful, for instance, for setting parameters which depends on the result of optics calculation itself."],
 p$2715=1+p$2715[[1,2]];
p1$2715=StringPosition["OpticsProlog is a variable to assign a user-defined function which is to be executed every time before an \
optics calculation is done in the CALCULATE(CAL) or GO commands. In GO, OpticsProlog is called at the beginning of each iteration.\
 This function is useful, for instance, for setting parameters which depends on the result of optics calculation itself."[p$2715,-1
     ],
    ">::",1];
   p1$2715=If[p1$2715==={},356,-2+p$2715+p1$2715[[1,1]]];
neq=Which["OpticsProlog is a variable to assign a user-defined function which is to be executed every time before an optics calcul\
ation is done in the CALCULATE(CAL) or GO commands. In GO, OpticsProlog is called at the beginning of each iteration. This functio\
n is useful, for instance, for setting parameters which depends on the result of optics calculation itself."[p$2715,4+p$2715]===
     "Text[",
lx$2715:=Help2HTML`oa$;p$2715=5+p$2715;p1$2715-=1;p2$2715=5+p1$2715;p0$2715=-9+p$2715;If[(pe$2715=StringPosition["OpticsProlog is \
a variable to assign a user-defined function which is to be executed every time before an optics calculation is done in the CALCUL\
ATE(CAL) or GO commands. In GO, OpticsProlog is called at the beginning of each iteration. This function is useful, for instance, \
for setting parameters which depends on the result of optics calculation itself."[p$2715,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["OpticsProlog is a variable to assign a user-defined function which is to be executed every time before an optics \
calculation is done in the CALCULATE(CAL) or GO commands. In GO, OpticsProlog is called at the beginning of each iteration. This f\
unction is useful, for instance, for setting parameters which depends on the result of optics calculation itself."[p$2715+
            pe$2715[[1,2]],
           p1$2715]]],
        p1$2715=-2+p$2715+pe$2715[[1,1]]}[[
       1]],
      0],
    1,lx$2715:=Help2HTML`o9$;p2$2715=4+p1$2715;p0$2715=-4+p$2715;0];
  If[(equ$2715=
Help2HTML`o8$["OpticsProlog is a variable to assign a user-defined function which is to be executed every time before an optics ca\
lculation is done in the CALCULATE(CAL) or GO commands. In GO, OpticsProlog is called at the beginning of each iteration. This fun\
ction is useful, for instance, for setting parameters which depends on the result of optics calculation itself."[p$2715,p1$2715]]
     )===
    Undefined,
equ$2715="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["OpticsProlog is a variable to assign a user-\
defined function which is to be executed every time before an optics calculation is done in the CALCULATE(CAL) or GO commands. In \
GO, OpticsProlog is called at the beginning of each iteration. This function is useful, for instance, for setting parameters which\
 depends on the result of optics calculation itself."[p$2715,p1$2715]]=
       equ$2715;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2715},out$2715=lx$2715@Typeset["OpticsProlog is a variable to assign a user-defined function which is to be executed ever\
y time before an optics calculation is done in the CALCULATE(CAL) or GO commands. In GO, OpticsProlog is called at the beginning o\
f each iteration. This function is useful, for instance, for setting parameters which depends on the result of optics calculation \
itself."[p$2715,p1$2715],Format->Help2HTML`oB$];
        System["mv -f "//out$2715//" "//equ$2715]];
      Exit[]]];
   "OpticsProlog is a variable to assign a user-defined function which is to be executed every time before an optics calculation i\
s done in the CALCULATE(CAL) or GO commands. In GO, OpticsProlog is called at the beginning of each iteration. This function is us\
eful, for instance, for setting parameters which depends on the result of optics calculation itself."[1,Max[p0$2715,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2715//"\" />"//
Help2HTML`oy$["OpticsProlog is a variable to assign a user-defined function which is to be executed every time before an optics ca\
lculation is done in the CALCULATE(CAL) or GO commands. In GO, OpticsProlog is called at the beginning of each iteration. This fun\
ction is useful, for instance, for setting parameters which depends on the result of optics calculation itself."[p2$2715,-1]]
 ]
</PRE>
<PRE>See also:
 <A HREF=#L538>OpticsEpilog</A></PRE>
<LI>
<H3><A NAME=L540>
PBUNCH</A></H3>
<PRE>If[{},
Help2HTML`oA$["PBUNCH is the number of particles/bunch for the calculation of the intra-beam and space charge effects in EMITTANCE\
(EMIT), and WakeFunction. Accessible in MAIN."],
p$2718=1+p$2718[[1,2]];p1$2718=StringPosition["PBUNCH is the number of particles/bunch for the calculation of the intra-beam and s\
pace charge effects in EMITTANCE(EMIT), and WakeFunction. Accessible in MAIN."[p$2718,-1],">::",1];
   p1$2718=If[p1$2718==={},160,-2+p$2718+p1$2718[[1,1]]];
neq=Which["PBUNCH is the number of particles/bunch for the calculation of the intra-beam and space charge effects in EMITTANCE(EMI\
T), and WakeFunction. Accessible in MAIN."[p$2718,4+p$2718]==="Text[",
    lx$2718:=Help2HTML`oa$;p$2718=5+p$2718;p1$2718-=1;p2$2718=5+p1$2718;p0$2718=-9+p$2718;
If[(pe$2718=StringPosition["PBUNCH is the number of particles/bunch for the calculation of the intra-beam and space charge effects\
 in EMITTANCE(EMIT), and WakeFunction. Accessible in MAIN."[p$2718,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["PBUNCH is the number of particles/bunch for the calculation of the intra-beam and space charge effects in EMITTAN\
CE(EMIT), and WakeFunction. Accessible in MAIN."[p$2718+pe$2718[[1,2]],p1$2718]]],
        p1$2718=-2+p$2718+pe$2718[[1,1]]}[[
       1]],
      0],
    1,lx$2718:=Help2HTML`o9$;p2$2718=4+p1$2718;p0$2718=-4+p$2718;0];
  If[(equ$2718=
Help2HTML`o8$["PBUNCH is the number of particles/bunch for the calculation of the intra-beam and space charge effects in EMITTANCE\
(EMIT), and WakeFunction. Accessible in MAIN."[p$2718,p1$2718]])===
    Undefined,
equ$2718="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["PBUNCH is the number of particles/bunch for \
the calculation of the intra-beam and space charge effects in EMITTANCE(EMIT), and WakeFunction. Accessible in MAIN."[p$2718,
         p1$2718]]=
       equ$2718;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2718},out$2718=lx$2718@Typeset["PBUNCH is the number of particles/bunch for the calculation of the intra-beam and space c\
harge effects in EMITTANCE(EMIT), and WakeFunction. Accessible in MAIN."[p$2718,p1$2718],Format->Help2HTML`oB$];
        System["mv -f "//out$2718//" "//equ$2718]];
      Exit[]]];
   "PBUNCH is the number of particles/bunch for the calculation of the intra-beam and space charge effects in EMITTANCE(EMIT), and\
 WakeFunction. Accessible in MAIN."[1,Max[p0$2718,0]]//"<img  class=\"eqs\" SRC=\""//equ$2718//"\" />"//
Help2HTML`oy$["PBUNCH is the number of particles/bunch for the calculation of the intra-beam and space charge effects in EMITTANCE\
(EMIT), and WakeFunction. Accessible in MAIN."[p2$2718,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L295>EMITTANCE(EMIT)</A> <A HREF=#L325>INTRA</A> <A HREF=#L357>WSPAC</A> <A HREF=#L413>WakeFunction</A> <A HREF=#L55>equilibrium-beam-envelope</A></PRE>
<LI>
<H3><A NAME=L541>
PhotonList</A></H3>
<PRE>If[{},
Help2HTML`oA$["When PHOTONS is ON (default is OFF), with RAD and FLUC, TrackParticles generates a list of all photons radiated thr\
ough the tracking. The list is assigned to a symbol PhotonList. PhotonList is a list of\n\n{en, gx, gy, gz, nx, ny, nz, xi1, xi2, \
xi3, np, nele}\n\nwhere\n\nen:    photon energy [eV]\ngx:    GX coordinate of the emission point [m]\ngy:    GY coordinate of the \
emission point [m]\ngz:    GZ coordinate of the emission point [m]\nnx:    GX component of the photon direction vector\nny:    GY \
component of the photon direction vector\nnz:    GZ component of the photon direction vector (nx^2+ny^2+nz^2)=1.\nxi1:   Stokes' p\
arameter for polarization 45 degree to the GZ=0 plane.\nxi2:   Stokes' parameter for right-handed polarization\nxi3:   Stokes' par\
ameter for polarization in the GZ=0 plane.\nnp:    particle number\nnele:  component number in the beam line\n\nThe probability of\
 each polarization is given by each Stokes' parameter as (1+xi)/2 . TrackParticles always updates PhotonList. The length of PhtonL\
ist is the number of emitted photons.\n   Remember that the {GX, GY, GZ} = {0, 0, 0} and their directions are {z, -x, -y} at the e\
ntrance of the beam line by default. It is changeable by the GEO command anyway."],
p$2721=1+p$2721[[1,2]];p1$2721=StringPosition["When PHOTONS is ON (default is OFF), with RAD and FLUC, TrackParticles generates a \
list of all photons radiated through the tracking. The list is assigned to a symbol PhotonList. PhotonList is a list of\n\n{en, gx\
, gy, gz, nx, ny, nz, xi1, xi2, xi3, np, nele}\n\nwhere\n\nen:    photon energy [eV]\ngx:    GX coordinate of the emission point [\
m]\ngy:    GY coordinate of the emission point [m]\ngz:    GZ coordinate of the emission point [m]\nnx:    GX component of the pho\
ton direction vector\nny:    GY component of the photon direction vector\nnz:    GZ component of the photon direction vector (nx^2\
+ny^2+nz^2)=1.\nxi1:   Stokes' parameter for polarization 45 degree to the GZ=0 plane.\nxi2:   Stokes' parameter for right-handed \
polarization\nxi3:   Stokes' parameter for polarization in the GZ=0 plane.\nnp:    particle number\nnele:  component number in the\
 beam line\n\nThe probability of each polarization is given by each Stokes' parameter as (1+xi)/2 . TrackParticles always updates \
PhotonList. The length of PhtonList is the number of emitted photons.\n   Remember that the {GX, GY, GZ} = {0, 0, 0} and their dir\
ections are {z, -x, -y} at the entrance of the beam line by default. It is changeable by the GEO command anyway."[p$2721,-1],">::",
    1];
   p1$2721=If[p1$2721==={},1215,-2+p$2721+p1$2721[[1,1]]];
neq=Which["When PHOTONS is ON (default is OFF), with RAD and FLUC, TrackParticles generates a list of all photons radiated through\
 the tracking. The list is assigned to a symbol PhotonList. PhotonList is a list of\n\n{en, gx, gy, gz, nx, ny, nz, xi1, xi2, xi3,\
 np, nele}\n\nwhere\n\nen:    photon energy [eV]\ngx:    GX coordinate of the emission point [m]\ngy:    GY coordinate of the emis\
sion point [m]\ngz:    GZ coordinate of the emission point [m]\nnx:    GX component of the photon direction vector\nny:    GY comp\
onent of the photon direction vector\nnz:    GZ component of the photon direction vector (nx^2+ny^2+nz^2)=1.\nxi1:   Stokes' param\
eter for polarization 45 degree to the GZ=0 plane.\nxi2:   Stokes' parameter for right-handed polarization\nxi3:   Stokes' paramet\
er for polarization in the GZ=0 plane.\nnp:    particle number\nnele:  component number in the beam line\n\nThe probability of eac\
h polarization is given by each Stokes' parameter as (1+xi)/2 . TrackParticles always updates PhotonList. The length of PhtonList \
is the number of emitted photons.\n   Remember that the {GX, GY, GZ} = {0, 0, 0} and their directions are {z, -x, -y} at the entra\
nce of the beam line by default. It is changeable by the GEO command anyway."[p$2721,4+p$2721]==="Text[",
    lx$2721:=Help2HTML`oa$;p$2721=5+p$2721;p1$2721-=1;p2$2721=5+p1$2721;p0$2721=-9+p$2721;
If[(pe$2721=StringPosition["When PHOTONS is ON (default is OFF), with RAD and FLUC, TrackParticles generates a list of all photons\
 radiated through the tracking. The list is assigned to a symbol PhotonList. PhotonList is a list of\n\n{en, gx, gy, gz, nx, ny, n\
z, xi1, xi2, xi3, np, nele}\n\nwhere\n\nen:    photon energy [eV]\ngx:    GX coordinate of the emission point [m]\ngy:    GY coord\
inate of the emission point [m]\ngz:    GZ coordinate of the emission point [m]\nnx:    GX component of the photon direction vecto\
r\nny:    GY component of the photon direction vector\nnz:    GZ component of the photon direction vector (nx^2+ny^2+nz^2)=1.\nxi1\
:   Stokes' parameter for polarization 45 degree to the GZ=0 plane.\nxi2:   Stokes' parameter for right-handed polarization\nxi3: \
  Stokes' parameter for polarization in the GZ=0 plane.\nnp:    particle number\nnele:  component number in the beam line\n\nThe p\
robability of each polarization is given by each Stokes' parameter as (1+xi)/2 . TrackParticles always updates PhotonList. The len\
gth of PhtonList is the number of emitted photons.\n   Remember that the {GX, GY, GZ} = {0, 0, 0} and their directions are {z, -x,\
 -y} at the entrance of the beam line by default. It is changeable by the GEO command anyway."[p$2721,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["When PHOTONS is ON (default is OFF), with RAD and FLUC, TrackParticles generates a list of all photons radiated t\
hrough the tracking. The list is assigned to a symbol PhotonList. PhotonList is a list of\n\n{en, gx, gy, gz, nx, ny, nz, xi1, xi2\
, xi3, np, nele}\n\nwhere\n\nen:    photon energy [eV]\ngx:    GX coordinate of the emission point [m]\ngy:    GY coordinate of th\
e emission point [m]\ngz:    GZ coordinate of the emission point [m]\nnx:    GX component of the photon direction vector\nny:    G\
Y component of the photon direction vector\nnz:    GZ component of the photon direction vector (nx^2+ny^2+nz^2)=1.\nxi1:   Stokes'\
 parameter for polarization 45 degree to the GZ=0 plane.\nxi2:   Stokes' parameter for right-handed polarization\nxi3:   Stokes' p\
arameter for polarization in the GZ=0 plane.\nnp:    particle number\nnele:  component number in the beam line\n\nThe probability \
of each polarization is given by each Stokes' parameter as (1+xi)/2 . TrackParticles always updates PhotonList. The length of Phto\
nList is the number of emitted photons.\n   Remember that the {GX, GY, GZ} = {0, 0, 0} and their directions are {z, -x, -y} at the\
 entrance of the beam line by default. It is changeable by the GEO command anyway."[p$2721+pe$2721[[1,2]],p1$2721]]],
        p1$2721=-2+p$2721+pe$2721[[1,1]]}[[
       1]],
      0],
    1,lx$2721:=Help2HTML`o9$;p2$2721=4+p1$2721;p0$2721=-4+p$2721;0];
  If[(equ$2721=
Help2HTML`o8$["When PHOTONS is ON (default is OFF), with RAD and FLUC, TrackParticles generates a list of all photons radiated thr\
ough the tracking. The list is assigned to a symbol PhotonList. PhotonList is a list of\n\n{en, gx, gy, gz, nx, ny, nz, xi1, xi2, \
xi3, np, nele}\n\nwhere\n\nen:    photon energy [eV]\ngx:    GX coordinate of the emission point [m]\ngy:    GY coordinate of the \
emission point [m]\ngz:    GZ coordinate of the emission point [m]\nnx:    GX component of the photon direction vector\nny:    GY \
component of the photon direction vector\nnz:    GZ component of the photon direction vector (nx^2+ny^2+nz^2)=1.\nxi1:   Stokes' p\
arameter for polarization 45 degree to the GZ=0 plane.\nxi2:   Stokes' parameter for right-handed polarization\nxi3:   Stokes' par\
ameter for polarization in the GZ=0 plane.\nnp:    particle number\nnele:  component number in the beam line\n\nThe probability of\
 each polarization is given by each Stokes' parameter as (1+xi)/2 . TrackParticles always updates PhotonList. The length of PhtonL\
ist is the number of emitted photons.\n   Remember that the {GX, GY, GZ} = {0, 0, 0} and their directions are {z, -x, -y} at the e\
ntrance of the beam line by default. It is changeable by the GEO command anyway."[p$2721,p1$2721]])===
    Undefined,
equ$2721="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["When PHOTONS is ON (default is OFF), with RA\
D and FLUC, TrackParticles generates a list of all photons radiated through the tracking. The list is assigned to a symbol PhotonL\
ist. PhotonList is a list of\n\n{en, gx, gy, gz, nx, ny, nz, xi1, xi2, xi3, np, nele}\n\nwhere\n\nen:    photon energy [eV]\ngx:  \
  GX coordinate of the emission point [m]\ngy:    GY coordinate of the emission point [m]\ngz:    GZ coordinate of the emission po\
int [m]\nnx:    GX component of the photon direction vector\nny:    GY component of the photon direction vector\nnz:    GZ compone\
nt of the photon direction vector (nx^2+ny^2+nz^2)=1.\nxi1:   Stokes' parameter for polarization 45 degree to the GZ=0 plane.\nxi2\
:   Stokes' parameter for right-handed polarization\nxi3:   Stokes' parameter for polarization in the GZ=0 plane.\nnp:    particle\
 number\nnele:  component number in the beam line\n\nThe probability of each polarization is given by each Stokes' parameter as (1\
+xi)/2 . TrackParticles always updates PhotonList. The length of PhtonList is the number of emitted photons.\n   Remember that the\
 {GX, GY, GZ} = {0, 0, 0} and their directions are {z, -x, -y} at the entrance of the beam line by default. It is changeable by th\
e GEO command anyway."[p$2721,p1$2721]]=
       equ$2721;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2721},out$2721=lx$2721@Typeset["When PHOTONS is ON (default is OFF), with RAD and FLUC, TrackParticles generates a list o\
f all photons radiated through the tracking. The list is assigned to a symbol PhotonList. PhotonList is a list of\n\n{en, gx, gy, \
gz, nx, ny, nz, xi1, xi2, xi3, np, nele}\n\nwhere\n\nen:    photon energy [eV]\ngx:    GX coordinate of the emission point [m]\ngy\
:    GY coordinate of the emission point [m]\ngz:    GZ coordinate of the emission point [m]\nnx:    GX component of the photon di\
rection vector\nny:    GY component of the photon direction vector\nnz:    GZ component of the photon direction vector (nx^2+ny^2+\
nz^2)=1.\nxi1:   Stokes' parameter for polarization 45 degree to the GZ=0 plane.\nxi2:   Stokes' parameter for right-handed polari\
zation\nxi3:   Stokes' parameter for polarization in the GZ=0 plane.\nnp:    particle number\nnele:  component number in the beam \
line\n\nThe probability of each polarization is given by each Stokes' parameter as (1+xi)/2 . TrackParticles always updates Photon\
List. The length of PhtonList is the number of emitted photons.\n   Remember that the {GX, GY, GZ} = {0, 0, 0} and their direction\
s are {z, -x, -y} at the entrance of the beam line by default. It is changeable by the GEO command anyway."[p$2721,p1$2721],
          Format->Help2HTML`oB$];
        System["mv -f "//out$2721//" "//equ$2721]];
      Exit[]]];
   "When PHOTONS is ON (default is OFF), with RAD and FLUC, TrackParticles generates a list of all photons radiated through the tr\
acking. The list is assigned to a symbol PhotonList. PhotonList is a list of\n\n{en, gx, gy, gz, nx, ny, nz, xi1, xi2, xi3, np, ne\
le}\n\nwhere\n\nen:    photon energy [eV]\ngx:    GX coordinate of the emission point [m]\ngy:    GY coordinate of the emission po\
int [m]\ngz:    GZ coordinate of the emission point [m]\nnx:    GX component of the photon direction vector\nny:    GY component o\
f the photon direction vector\nnz:    GZ component of the photon direction vector (nx^2+ny^2+nz^2)=1.\nxi1:   Stokes' parameter fo\
r polarization 45 degree to the GZ=0 plane.\nxi2:   Stokes' parameter for right-handed polarization\nxi3:   Stokes' parameter for \
polarization in the GZ=0 plane.\nnp:    particle number\nnele:  component number in the beam line\n\nThe probability of each polar\
ization is given by each Stokes' parameter as (1+xi)/2 . TrackParticles always updates PhotonList. The length of PhtonList is the \
number of emitted photons.\n   Remember that the {GX, GY, GZ} = {0, 0, 0} and their directions are {z, -x, -y} at the entrance of \
the beam line by default. It is changeable by the GEO command anyway."[1,Max[p0$2721,0]]//"<img  class=\"eqs\" SRC=\""//equ$2721//
   "\" />"//
Help2HTML`oy$["When PHOTONS is ON (default is OFF), with RAD and FLUC, TrackParticles generates a list of all photons radiated thr\
ough the tracking. The list is assigned to a symbol PhotonList. PhotonList is a list of\n\n{en, gx, gy, gz, nx, ny, nz, xi1, xi2, \
xi3, np, nele}\n\nwhere\n\nen:    photon energy [eV]\ngx:    GX coordinate of the emission point [m]\ngy:    GY coordinate of the \
emission point [m]\ngz:    GZ coordinate of the emission point [m]\nnx:    GX component of the photon direction vector\nny:    GY \
component of the photon direction vector\nnz:    GZ component of the photon direction vector (nx^2+ny^2+nz^2)=1.\nxi1:   Stokes' p\
arameter for polarization 45 degree to the GZ=0 plane.\nxi2:   Stokes' parameter for right-handed polarization\nxi3:   Stokes' par\
ameter for polarization in the GZ=0 plane.\nnp:    particle number\nnele:  component number in the beam line\n\nThe probability of\
 each polarization is given by each Stokes' parameter as (1+xi)/2 . TrackParticles always updates PhotonList. The length of PhtonL\
ist is the number of emitted photons.\n   Remember that the {GX, GY, GZ} = {0, 0, 0} and their directions are {z, -x, -y} at the e\
ntrance of the beam line by default. It is changeable by the GEO command anyway."[p2$2721,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L332>PHOTONS</A> <A HREF=#L409>TrackParticles</A></PRE>
<LI>
<H3><A NAME=L542>
PHICAV</A></H3>
<PRE>If[{},
Help2HTML`oA$["The equilibrium RF phase (in radian, = 2 Pi EFFRFFREQ DTSYNCH/c) where the synchrotron radiation loss and accelerat\
ion balances. If there are phase, voltage, frequency variations in RF cavities, it is calculated based on \"effective voltage\". E\
ffective with RING only."],
p$2724=1+p$2724[[1,2]];p1$2724=StringPosition["The equilibrium RF phase (in radian, = 2 Pi EFFRFFREQ DTSYNCH/c) where the synchrot\
ron radiation loss and acceleration balances. If there are phase, voltage, frequency variations in RF cavities, it is calculated b\
ased on \"effective voltage\". Effective with RING only."[p$2724,-1],">::",1];
   p1$2724=If[p1$2724==={},267,-2+p$2724+p1$2724[[1,1]]];
neq=Which["The equilibrium RF phase (in radian, = 2 Pi EFFRFFREQ DTSYNCH/c) where the synchrotron radiation loss and acceleration \
balances. If there are phase, voltage, frequency variations in RF cavities, it is calculated based on \"effective voltage\". Effec\
tive with RING only."[p$2724,4+p$2724]==="Text[",
    lx$2724:=Help2HTML`oa$;p$2724=5+p$2724;p1$2724-=1;p2$2724=5+p1$2724;p0$2724=-9+p$2724;
If[(pe$2724=StringPosition["The equilibrium RF phase (in radian, = 2 Pi EFFRFFREQ DTSYNCH/c) where the synchrotron radiation loss \
and acceleration balances. If there are phase, voltage, frequency variations in RF cavities, it is calculated based on \"effective\
 voltage\". Effective with RING only."[p$2724,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["The equilibrium RF phase (in radian, = 2 Pi EFFRFFREQ DTSYNCH/c) where the synchrotron radiation loss and acceler\
ation balances. If there are phase, voltage, frequency variations in RF cavities, it is calculated based on \"effective voltage\".\
 Effective with RING only."[p$2724+pe$2724[[1,2]],p1$2724]]],
        p1$2724=-2+p$2724+pe$2724[[1,1]]}[[
       1]],
      0],
    1,lx$2724:=Help2HTML`o9$;p2$2724=4+p1$2724;p0$2724=-4+p$2724;0];
  If[(equ$2724=
Help2HTML`o8$["The equilibrium RF phase (in radian, = 2 Pi EFFRFFREQ DTSYNCH/c) where the synchrotron radiation loss and accelerat\
ion balances. If there are phase, voltage, frequency variations in RF cavities, it is calculated based on \"effective voltage\". E\
ffective with RING only."[p$2724,p1$2724]])===
    Undefined,
equ$2724="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["The equilibrium RF phase (in radian, = 2 Pi \
EFFRFFREQ DTSYNCH/c) where the synchrotron radiation loss and acceleration balances. If there are phase, voltage, frequency variat\
ions in RF cavities, it is calculated based on \"effective voltage\". Effective with RING only."[p$2724,p1$2724]]=
       equ$2724;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2724},out$2724=lx$2724@Typeset["The equilibrium RF phase (in radian, = 2 Pi EFFRFFREQ DTSYNCH/c) where the synchrotron ra\
diation loss and acceleration balances. If there are phase, voltage, frequency variations in RF cavities, it is calculated based o\
n \"effective voltage\". Effective with RING only."[p$2724,p1$2724],Format->Help2HTML`oB$];
        System["mv -f "//out$2724//" "//equ$2724]];
      Exit[]]];
   "The equilibrium RF phase (in radian, = 2 Pi EFFRFFREQ DTSYNCH/c) where the synchrotron radiation loss and acceleration balance\
s. If there are phase, voltage, frequency variations in RF cavities, it is calculated based on \"effective voltage\". Effective wi\
th RING only."[1,Max[p0$2724,0]]//"<img  class=\"eqs\" SRC=\""//equ$2724//"\" />"//
Help2HTML`oy$["The equilibrium RF phase (in radian, = 2 Pi EFFRFFREQ DTSYNCH/c) where the synchrotron radiation loss and accelerat\
ion balances. If there are phase, voltage, frequency variations in RF cavities, it is calculated based on \"effective voltage\". E\
ffective with RING only."[p2$2724,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L510>EFFVC</A> <A HREF=#L509>EFFRFFREQ</A> <A HREF=#L508>DTSYNCH</A> <A HREF=#L97>CAVI</A> <A HREF=#L139>MULT</A></PRE>
<LI>
<H3><A NAME=L543>
SIGE</A></H3>
<PRE>If[{},
 Help2HTML`oA$[
  " SIGE is the equilibrium momentum spread at the entrance of the beam line calculated by EMIT/Emittance[SaveEMIT->True]."],
 p$2727=1+p$2727[[1,2]];
  p1$2727=StringPosition[
    " SIGE is the equilibrium momentum spread at the entrance of the beam line calculated by EMIT/Emittance[SaveEMIT->True]."[p
     $2727,-1],
    ">::",1];
   p1$2727=If[p1$2727==={},119,-2+p$2727+p1$2727[[1,1]]];
  neq=Which[
     " SIGE is the equilibrium momentum spread at the entrance of the beam line calculated by EMIT/Emittance[SaveEMIT->True]."[p
      $2727,4+p$2727]===
     "Text[",
    lx$2727:=Help2HTML`oa$;p$2727=5+p$2727;p1$2727-=1;p2$2727=5+p1$2727;p0$2727=-9+p$2727;If[(pe$2727=StringPosition[
         " SIGE is the equilibrium momentum spread at the entrance of the beam line calculated by EMIT/Emittance[SaveEMIT->True]."[
          p$2727,-2],
         ";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression[
          " SIGE is the equilibrium momentum spread at the entrance of the beam line calculated by EMIT/Emittance[SaveEMIT->True]."
          [p$2727+pe$2727[[1,2]],p1$2727]]],
        p1$2727=-2+p$2727+pe$2727[[1,1]]}[[
       1]],
      0],
    1,lx$2727:=Help2HTML`o9$;p2$2727=4+p1$2727;p0$2727=-4+p$2727;0];
  If[(equ$2727=
     Help2HTML`o8$[
      " SIGE is the equilibrium momentum spread at the entrance of the beam line calculated by EMIT/Emittance[SaveEMIT->True]."[p
       $2727,p1$2727]])===
    Undefined,
   equ$2727="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        " SIGE is the equilibrium momentum spread at the entrance of the beam line calculated by EMIT/Emittance[SaveEMIT->True]."[
         p$2727,p1$2727]]=
       equ$2727;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$2727},out$2727=lx$2727@Typeset[
          " SIGE is the equilibrium momentum spread at the entrance of the beam line calculated by EMIT/Emittance[SaveEMIT->True]."
          [p$2727,p1$2727],Format->Help2HTML`oB$];
        System["mv -f "//out$2727//" "//equ$2727]];
      Exit[]]];
  " SIGE is the equilibrium momentum spread at the entrance of the beam line calculated by EMIT/Emittance[SaveEMIT->True]."[1,
    Max[p0$2727,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2727//"\" />"//
   Help2HTML`oy$[
    " SIGE is the equilibrium momentum spread at the entrance of the beam line calculated by EMIT/Emittance[SaveEMIT->True]."[p2
     $2727,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L513>EMITX</A> <A HREF=#L515>EMITY</A> <A HREF=#L517>EMITZ</A> <A HREF=#L544>SIGZ</A> <A HREF=#L295>EMITTANCE(EMIT)</A> <A HREF=#L389>Emittance</A></PRE>
<LI>
<H3><A NAME=L544>
SIGZ</A></H3>
<PRE>If[{},
 Help2HTML`oA$[
  " SIGZ is the equilibrium bunch length at the entrance of the beam line calculated by EMIT/Emittance[SaveEMIT->True]."],
 p$2730=1+p$2730[[1,2]];
  p1$2730=StringPosition[
    " SIGZ is the equilibrium bunch length at the entrance of the beam line calculated by EMIT/Emittance[SaveEMIT->True]."[p$2730,
     -1],
    ">::",1];
   p1$2730=If[p1$2730==={},116,-2+p$2730+p1$2730[[1,1]]];
  neq=Which[" SIGZ is the equilibrium bunch length at the entrance of the beam line calculated by EMIT/Emittance[SaveEMIT->True]."[
      p$2730,4+p$2730]===
     "Text[",
    lx$2730:=Help2HTML`oa$;p$2730=5+p$2730;p1$2730-=1;p2$2730=5+p1$2730;p0$2730=-9+p$2730;If[(pe$2730=StringPosition[
         " SIGZ is the equilibrium bunch length at the entrance of the beam line calculated by EMIT/Emittance[SaveEMIT->True]."[p
          $2730,-2],
         ";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression[
          " SIGZ is the equilibrium bunch length at the entrance of the beam line calculated by EMIT/Emittance[SaveEMIT->True]."[
            p$2730+pe$2730[[1,2]],
           p1$2730]]],
        p1$2730=-2+p$2730+pe$2730[[1,1]]}[[
       1]],
      0],
    1,lx$2730:=Help2HTML`o9$;p2$2730=4+p1$2730;p0$2730=-4+p$2730;0];
  If[(equ$2730=
     Help2HTML`o8$[
      " SIGZ is the equilibrium bunch length at the entrance of the beam line calculated by EMIT/Emittance[SaveEMIT->True]."[p$2730
       ,p1$2730]])===
    Undefined,
   equ$2730="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        " SIGZ is the equilibrium bunch length at the entrance of the beam line calculated by EMIT/Emittance[SaveEMIT->True]."[p
         $2730,p1$2730]]=
       equ$2730;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$2730},out$2730=lx$2730@Typeset[
          " SIGZ is the equilibrium bunch length at the entrance of the beam line calculated by EMIT/Emittance[SaveEMIT->True]."[
           p$2730,p1$2730],Format->Help2HTML`oB$];
        System["mv -f "//out$2730//" "//equ$2730]];
      Exit[]]];
  " SIGZ is the equilibrium bunch length at the entrance of the beam line calculated by EMIT/Emittance[SaveEMIT->True]."[1,
    Max[p0$2730,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2730//"\" />"//
   Help2HTML`oy$[
    " SIGZ is the equilibrium bunch length at the entrance of the beam line calculated by EMIT/Emittance[SaveEMIT->True]."[p2$2730,
     -1]]
]</PRE>
<PRE>See also:
 <A HREF=#L513>EMITX</A> <A HREF=#L515>EMITY</A> <A HREF=#L517>EMITZ</A> <A HREF=#L543>SIGE</A> <A HREF=#L295>EMITTANCE(EMIT)</A> <A HREF=#L389>Emittance</A></PRE>
<LI>
<H3><A NAME=L545>
SpeedOfLight</A></H3>
<PRE>If[{},Help2HTML`oA$["SpeedOfLight is 299792458."],
 p$2733=1+p$2733[[1,2]];p1$2733=StringPosition["SpeedOfLight is 299792458."[p$2733,-1],">::",1];
  p1$2733=If[p1$2733==={},26,-2+p$2733+p1$2733[[1,1]]];
  neq=Which["SpeedOfLight is 299792458."[p$2733,4+p$2733]==="Text[",lx$2733:=Help2HTML`oa$;p$2733=5+p$2733;p1$2733-=1;
     p2$2733=5+p1$2733;p0$2733=-9+p$2733;
     If[(pe$2733=StringPosition["SpeedOfLight is 299792458."[p$2733,-2],";;;"])<=>{},{Max[0,-1+ToExpression[
          "SpeedOfLight is 299792458."[p$2733+pe$2733[[1,2]],p1$2733]]],
        p1$2733=-2+p$2733+pe$2733[[1,1]]}[[
       1]],
      0],
    1,lx$2733:=Help2HTML`o9$;p2$2733=4+p1$2733;p0$2733=-4+p$2733;0];
  If[(equ$2733=Help2HTML`o8$["SpeedOfLight is 299792458."[p$2733,p1$2733]])===Undefined,
   equ$2733="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;
    If[Fork[],Help2HTML`o8$["SpeedOfLight is 299792458."[p$2733,p1$2733]]=equ$2733;LaTeX`ob$+=neq,
     --LaTeX`ob$;With[{lx$2733},out$2733=lx$2733@Typeset["SpeedOfLight is 299792458."[p$2733,p1$2733],Format->Help2HTML`oB$];
        System["mv -f "//out$2733//" "//equ$2733]];
      Exit[]]];
   "SpeedOfLight is 299792458."[1,Max[p0$2733,0]]//"<img  class=\"eqs\" SRC=\""//equ$2733//"\" />"//
   Help2HTML`oy$["SpeedOfLight is 299792458."[p2$2733,-1]]
]</PRE>
<LI>
<H3><A NAME=L546>
StabilityLevel</A></H3>
<PRE>If[{},
Help2HTML`oA$["Number of unstable planes in the optics calculations. Equal to zero if all x and y optics are stable for on/off-mom\
entum and finite amplitude matching."],
p$2735=1+p$2735[[1,2]];p1$2735=StringPosition["Number of unstable planes in the optics calculations. Equal to zero if all x and y \
optics are stable for on/off-momentum and finite amplitude matching."[p$2735,-1],">::",1];
   p1$2735=If[p1$2735==={},151,-2+p$2735+p1$2735[[1,1]]];
neq=Which["Number of unstable planes in the optics calculations. Equal to zero if all x and y optics are stable for on/off-momentu\
m and finite amplitude matching."[p$2735,4+p$2735]==="Text[",
    lx$2735:=Help2HTML`oa$;p$2735=5+p$2735;p1$2735-=1;p2$2735=5+p1$2735;p0$2735=-9+p$2735;
If[(pe$2735=StringPosition["Number of unstable planes in the optics calculations. Equal to zero if all x and y optics are stable f\
or on/off-momentum and finite amplitude matching."[p$2735,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Number of unstable planes in the optics calculations. Equal to zero if all x and y optics are stable for on/off-m\
omentum and finite amplitude matching."[p$2735+pe$2735[[1,2]],p1$2735]]],
        p1$2735=-2+p$2735+pe$2735[[1,1]]}[[
       1]],
      0],
    1,lx$2735:=Help2HTML`o9$;p2$2735=4+p1$2735;p0$2735=-4+p$2735;0];
  If[(equ$2735=
Help2HTML`o8$["Number of unstable planes in the optics calculations. Equal to zero if all x and y optics are stable for on/off-mom\
entum and finite amplitude matching."[p$2735,p1$2735]])===
    Undefined,
equ$2735="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Number of unstable planes in the optics calc\
ulations. Equal to zero if all x and y optics are stable for on/off-momentum and finite amplitude matching."[p$2735,p1$2735]]=
       equ$2735;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2735},out$2735=lx$2735@Typeset["Number of unstable planes in the optics calculations. Equal to zero if all x and y optics\
 are stable for on/off-momentum and finite amplitude matching."[p$2735,p1$2735],Format->Help2HTML`oB$];
        System["mv -f "//out$2735//" "//equ$2735]];
      Exit[]]];
   "Number of unstable planes in the optics calculations. Equal to zero if all x and y optics are stable for on/off-momentum and f\
inite amplitude matching."[1,Max[p0$2735,0]]//"<img  class=\"eqs\" SRC=\""//equ$2735//"\" />"//
Help2HTML`oy$["Number of unstable planes in the optics calculations. Equal to zero if all x and y optics are stable for on/off-mom\
entum and finite amplitude matching."[p2$2735,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L533>NetResidual</A> <A HREF=#L528>MatchingResidual</A></PRE>
<LI>
<H3><A NAME=L547>
TITLE</A></H3>
<PRE>If[{},Help2HTML`oA$["TITLE is a character-string to make the title of the plot in DRAW or GEO commands."],
 p$2738=1+p$2738[[1,2]];
  p1$2738=StringPosition["TITLE is a character-string to make the title of the plot in DRAW or GEO commands."[p$2738,-1],">::",1];
  p1$2738=If[p1$2738==={},82,-2+p$2738+p1$2738[[1,1]]];
  neq=Which["TITLE is a character-string to make the title of the plot in DRAW or GEO commands."[p$2738,4+p$2738]==="Text[",
    lx$2738:=Help2HTML`oa$;p$2738=5+p$2738;p1$2738-=1;p2$2738=5+p1$2738;p0$2738=-9+p$2738;
     If[(pe$2738=StringPosition["TITLE is a character-string to make the title of the plot in DRAW or GEO commands."[p$2738,-2],
         ";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression["TITLE is a character-string to make the title of the plot in DRAW or GEO commands."[p$2738+pe$2738[[1,2]],
           p1$2738]]],
        p1$2738=-2+p$2738+pe$2738[[1,1]]}[[
       1]],
      0],
    1,lx$2738:=Help2HTML`o9$;p2$2738=4+p1$2738;p0$2738=-4+p$2738;0];
  If[(equ$2738=Help2HTML`o8$["TITLE is a character-string to make the title of the plot in DRAW or GEO commands."[p$2738,p1$2738]]
     )===
    Undefined,
   equ$2738="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "TITLE is a character-string to make the title of the plot in DRAW or GEO commands."[p$2738,p1$2738]]=
       equ$2738;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$2738},out$2738=lx$2738@Typeset["TITLE is a character-string to make the title of the plot in DRAW or GEO commands."[
           p$2738,p1$2738],Format->Help2HTML`oB$];
        System["mv -f "//out$2738//" "//equ$2738]];
      Exit[]]];
   "TITLE is a character-string to make the title of the plot in DRAW or GEO commands."[1,Max[p0$2738,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2738//"\" />"//
   Help2HTML`oy$["TITLE is a character-string to make the title of the plot in DRAW or GEO commands."[p2$2738,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L502>CASE</A> <A HREF=#L72>DRAW</A> <A HREF=#L245>GEO</A></PRE>
</UL>
<H3><A NAME=L548>
SAVE</A></H3>
<PRE>If[{},
Help2HTML`oA$["Usage: SAVE [element-pattern]\n\nsaves the values of the elements. What are saved are the value of the default keyw\
ord of all elements, the values of the non-default keywords which have been changed manually or by the matching. If ALL is given i\
t resets all keywords. If element-pattern is given, it is only limited to the elements which match the pattern, otherwise all elem\
ents are saved."],
p$2741=1+p$2741[[1,2]];p1$2741=StringPosition["Usage: SAVE [element-pattern]\n\nsaves the values of the elements. What are saved a\
re the value of the default keyword of all elements, the values of the non-default keywords which have been changed manually or by\
 the matching. If ALL is given it resets all keywords. If element-pattern is given, it is only limited to the elements which match\
 the pattern, otherwise all elements are saved."[p$2741,-1],">::",1];
   p1$2741=If[p1$2741==={},388,-2+p$2741+p1$2741[[1,1]]];
neq=Which["Usage: SAVE [element-pattern]\n\nsaves the values of the elements. What are saved are the value of the default keyword \
of all elements, the values of the non-default keywords which have been changed manually or by the matching. If ALL is given it re\
sets all keywords. If element-pattern is given, it is only limited to the elements which match the pattern, otherwise all elements\
 are saved."[p$2741,4+p$2741]==="Text[",
    lx$2741:=Help2HTML`oa$;p$2741=5+p$2741;p1$2741-=1;p2$2741=5+p1$2741;p0$2741=-9+p$2741;If[(pe$2741=
StringPosition["Usage: SAVE [element-pattern]\n\nsaves the values of the elements. What are saved are the value of the default key\
word of all elements, the values of the non-default keywords which have been changed manually or by the matching. If ALL is given \
it resets all keywords. If element-pattern is given, it is only limited to the elements which match the pattern, otherwise all ele\
ments are saved."[p$2741,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Usage: SAVE [element-pattern]\n\nsaves the values of the elements. What are saved are the value of the default ke\
yword of all elements, the values of the non-default keywords which have been changed manually or by the matching. If ALL is given\
 it resets all keywords. If element-pattern is given, it is only limited to the elements which match the pattern, otherwise all el\
ements are saved."[p$2741+pe$2741[[1,2]],p1$2741]]],
        p1$2741=-2+p$2741+pe$2741[[1,1]]}[[
       1]],
      0],
    1,lx$2741:=Help2HTML`o9$;p2$2741=4+p1$2741;p0$2741=-4+p$2741;0];
  If[(equ$2741=
Help2HTML`o8$["Usage: SAVE [element-pattern]\n\nsaves the values of the elements. What are saved are the value of the default keyw\
ord of all elements, the values of the non-default keywords which have been changed manually or by the matching. If ALL is given i\
t resets all keywords. If element-pattern is given, it is only limited to the elements which match the pattern, otherwise all elem\
ents are saved."[p$2741,p1$2741]])===
    Undefined,
equ$2741="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Usage: SAVE [element-pattern]\n\nsaves the v\
alues of the elements. What are saved are the value of the default keyword of all elements, the values of the non-default keywords\
 which have been changed manually or by the matching. If ALL is given it resets all keywords. If element-pattern is given, it is o\
nly limited to the elements which match the pattern, otherwise all elements are saved."[p$2741,p1$2741]]=
       equ$2741;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2741},out$2741=lx$2741@Typeset["Usage: SAVE [element-pattern]\n\nsaves the values of the elements. What are saved are the\
 value of the default keyword of all elements, the values of the non-default keywords which have been changed manually or by the m\
atching. If ALL is given it resets all keywords. If element-pattern is given, it is only limited to the elements which match the p\
attern, otherwise all elements are saved."[p$2741,p1$2741],Format->Help2HTML`oB$];
        System["mv -f "//out$2741//" "//equ$2741]];
      Exit[]]];
   "Usage: SAVE [element-pattern]\n\nsaves the values of the elements. What are saved are the value of the default keyword of all \
elements, the values of the non-default keywords which have been changed manually or by the matching. If ALL is given it resets al\
l keywords. If element-pattern is given, it is only limited to the elements which match the pattern, otherwise all elements are sa\
ved."[1,Max[p0$2741,0]]//"<img  class=\"eqs\" SRC=\""//equ$2741//"\" />"//
Help2HTML`oy$["Usage: SAVE [element-pattern]\n\nsaves the values of the elements. What are saved are the value of the default keyw\
ord of all elements, the values of the non-default keywords which have been changed manually or by the matching. If ALL is given i\
t resets all keywords. If element-pattern is given, it is only limited to the elements which match the pattern, otherwise all elem\
ents are saved."[p2$2741,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L494>RESET</A> <A HREF=#L558>USE</A> <A HREF=#L561>VISIT</A> <A HREF=#L14>BYE</A> <A HREF=#L553>STOP</A> <A HREF=#L485>QUIT</A> <A HREF=#L562>wildcards</A></PRE>
<H3><A NAME=L549>
SEED</A></H3>
<PRE>If[{},Help2HTML`oA$["The SEED command is obsolete. Use SeedRandom[] function instead of SEED."],
 p$2744=1+p$2744[[1,2]];p1$2744=
   StringPosition["The SEED command is obsolete. Use SeedRandom[] function instead of SEED."[p$2744,-1],">::",1];
  p1$2744=If[p1$2744==={},72,-2+p$2744+p1$2744[[1,1]]];
  neq=Which["The SEED command is obsolete. Use SeedRandom[] function instead of SEED."[p$2744,4+p$2744]==="Text[",
    lx$2744:=Help2HTML`oa$;p$2744=5+p$2744;p1$2744-=1;p2$2744=5+p1$2744;p0$2744=-9+p$2744;
     If[(pe$2744=StringPosition["The SEED command is obsolete. Use SeedRandom[] function instead of SEED."[p$2744,-2],";;;"])<=>{},
      {Max[0,
        -1+ToExpression["The SEED command is obsolete. Use SeedRandom[] function instead of SEED."[p$2744+pe$2744[[1,2]],p1$2744]]
        ],p1$2744=-2+p$2744+pe$2744[[1,1]]}[[
       1]],
      0],
    1,lx$2744:=Help2HTML`o9$;p2$2744=4+p1$2744;p0$2744=-4+p$2744;0];
  If[(equ$2744=Help2HTML`o8$["The SEED command is obsolete. Use SeedRandom[] function instead of SEED."[p$2744,p1$2744]])===
    Undefined,
   equ$2744="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "The SEED command is obsolete. Use SeedRandom[] function instead of SEED."[p$2744,p1$2744]]=
       equ$2744;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$2744},out$2744=lx$2744@Typeset["The SEED command is obsolete. Use SeedRandom[] function instead of SEED."[p$2744,
           p1$2744],Format->Help2HTML`oB$];
        System["mv -f "//out$2744//" "//equ$2744]];
      Exit[]]];
   "The SEED command is obsolete. Use SeedRandom[] function instead of SEED."[1,Max[p0$2744,0]]//"<img  class=\"eqs\" SRC=\""//
   equ$2744//"\" />"//Help2HTML`oy$["The SEED command is obsolete. Use SeedRandom[] function instead of SEED."[p2$2744,-1]]
 ]
</PRE>
<PRE>See also:
 <A HREF=#L476>MEASURE(MEA)</A> <A HREF=#L317>FIXSEED</A> <A HREF=#L331>MOVESEED</A> <A HREF=#L452>SeedRandom</A></PRE>
<H3><A NAME=L550>
SHOW</A></H3>
<PRE>If[{},
Help2HTML`oA$["SHOW prints out the current matching conditions.\n\n   FFS[\"SHOW\"] or FFS$SHOW[] returns the current matching con\
ditions as a list. Each element has a form of\n\n{component1, component2, function, goal-value, number-of-momentums, scale},\n\nwh\
ich corresponds to the format of the print-out by SHOW."],
p$2747=1+p$2747[[1,2]];p1$2747=StringPosition["SHOW prints out the current matching conditions.\n\n   FFS[\"SHOW\"] or FFS$SHOW[] \
returns the current matching conditions as a list. Each element has a form of\n\n{component1, component2, function, goal-value, nu\
mber-of-momentums, scale},\n\nwhich corresponds to the format of the print-out by SHOW."[p$2747,-1],">::",1];
   p1$2747=If[p1$2747==={},292,-2+p$2747+p1$2747[[1,1]]];
neq=Which["SHOW prints out the current matching conditions.\n\n   FFS[\"SHOW\"] or FFS$SHOW[] returns the current matching conditi\
ons as a list. Each element has a form of\n\n{component1, component2, function, goal-value, number-of-momentums, scale},\n\nwhich \
corresponds to the format of the print-out by SHOW."[p$2747,4+p$2747]==="Text[",
    lx$2747:=Help2HTML`oa$;p$2747=5+p$2747;p1$2747-=1;p2$2747=5+p1$2747;p0$2747=-9+p$2747;
If[(pe$2747=StringPosition["SHOW prints out the current matching conditions.\n\n   FFS[\"SHOW\"] or FFS$SHOW[] returns the current\
 matching conditions as a list. Each element has a form of\n\n{component1, component2, function, goal-value, number-of-momentums, \
scale},\n\nwhich corresponds to the format of the print-out by SHOW."[p$2747,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["SHOW prints out the current matching conditions.\n\n   FFS[\"SHOW\"] or FFS$SHOW[] returns the current matching c\
onditions as a list. Each element has a form of\n\n{component1, component2, function, goal-value, number-of-momentums, scale},\n\n\
which corresponds to the format of the print-out by SHOW."[p$2747+pe$2747[[1,2]],p1$2747]]],
        p1$2747=-2+p$2747+pe$2747[[1,1]]}[[
       1]],
      0],
    1,lx$2747:=Help2HTML`o9$;p2$2747=4+p1$2747;p0$2747=-4+p$2747;0];
  If[(equ$2747=
Help2HTML`o8$["SHOW prints out the current matching conditions.\n\n   FFS[\"SHOW\"] or FFS$SHOW[] returns the current matching con\
ditions as a list. Each element has a form of\n\n{component1, component2, function, goal-value, number-of-momentums, scale},\n\nwh\
ich corresponds to the format of the print-out by SHOW."[p$2747,p1$2747]])===
    Undefined,
equ$2747="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["SHOW prints out the current matching conditi\
ons.\n\n   FFS[\"SHOW\"] or FFS$SHOW[] returns the current matching conditions as a list. Each element has a form of\n\n{component\
1, component2, function, goal-value, number-of-momentums, scale},\n\nwhich corresponds to the format of the print-out by SHOW."[p
         $2747,p1$2747]]=
       equ$2747;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2747},out$2747=lx$2747@Typeset["SHOW prints out the current matching conditions.\n\n   FFS[\"SHOW\"] or FFS$SHOW[] return\
s the current matching conditions as a list. Each element has a form of\n\n{component1, component2, function, goal-value, number-o\
f-momentums, scale},\n\nwhich corresponds to the format of the print-out by SHOW."[p$2747,p1$2747],Format->Help2HTML`oB$];
        System["mv -f "//out$2747//" "//equ$2747]];
      Exit[]]];
   "SHOW prints out the current matching conditions.\n\n   FFS[\"SHOW\"] or FFS$SHOW[] returns the current matching conditions as \
a list. Each element has a form of\n\n{component1, component2, function, goal-value, number-of-momentums, scale},\n\nwhich corresp\
onds to the format of the print-out by SHOW."[1,Max[p0$2747,0]]//"<img  class=\"eqs\" SRC=\""//equ$2747//"\" />"//
Help2HTML`oy$["SHOW prints out the current matching conditions.\n\n   FFS[\"SHOW\"] or FFS$SHOW[] returns the current matching con\
ditions as a list. Each element has a form of\n\n{component1, component2, function, goal-value, number-of-momentums, scale},\n\nwh\
ich corresponds to the format of the print-out by SHOW."[p2$2747,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L473>matching-function-commands</A> <A HREF=#L463>FIT</A> <A HREF=#L392>FFS</A> <A HREF=#L393>FFS$SHOW</A></PRE>
<H3><A NAME=L551>
SPLIT</A></H3>
<PRE>If[{},
Help2HTML`oA$["Usage: SPLIT component length\n\nsplits the component into two pieces at the point where the distance from the entr\
ance is length. The new components have the same name as the original, and the strengths are proportional to the new lengths. Only\
 magnets and cavities can be split. You should CALCULATE(CAL) after SPLIT to get optical parameters after SPLIT. Matching using SP\
LIT element as a variable may degrade the speed of convergence."],
p$2750=1+p$2750[[1,2]];p1$2750=StringPosition["Usage: SPLIT component length\n\nsplits the component into two pieces at the point \
where the distance from the entrance is length. The new components have the same name as the original, and the strengths are propo\
rtional to the new lengths. Only magnets and cavities can be split. You should CALCULATE(CAL) after SPLIT to get optical parameter\
s after SPLIT. Matching using SPLIT element as a variable may degrade the speed of convergence."[p$2750,-1],">::",1];
   p1$2750=If[p1$2750==={},436,-2+p$2750+p1$2750[[1,1]]];
neq=Which["Usage: SPLIT component length\n\nsplits the component into two pieces at the point where the distance from the entrance\
 is length. The new components have the same name as the original, and the strengths are proportional to the new lengths. Only mag\
nets and cavities can be split. You should CALCULATE(CAL) after SPLIT to get optical parameters after SPLIT. Matching using SPLIT \
element as a variable may degrade the speed of convergence."[p$2750,4+p$2750]==="Text[",
    lx$2750:=Help2HTML`oa$;p$2750=5+p$2750;p1$2750-=1;p2$2750=5+p1$2750;p0$2750=-9+p$2750;
If[(pe$2750=StringPosition["Usage: SPLIT component length\n\nsplits the component into two pieces at the point where the distance \
from the entrance is length. The new components have the same name as the original, and the strengths are proportional to the new \
lengths. Only magnets and cavities can be split. You should CALCULATE(CAL) after SPLIT to get optical parameters after SPLIT. Matc\
hing using SPLIT element as a variable may degrade the speed of convergence."[p$2750,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Usage: SPLIT component length\n\nsplits the component into two pieces at the point where the distance from the en\
trance is length. The new components have the same name as the original, and the strengths are proportional to the new lengths. On\
ly magnets and cavities can be split. You should CALCULATE(CAL) after SPLIT to get optical parameters after SPLIT. Matching using \
SPLIT element as a variable may degrade the speed of convergence."[p$2750+pe$2750[[1,2]],p1$2750]]],
        p1$2750=-2+p$2750+pe$2750[[1,1]]}[[
       1]],
      0],
    1,lx$2750:=Help2HTML`o9$;p2$2750=4+p1$2750;p0$2750=-4+p$2750;0];
  If[(equ$2750=
Help2HTML`o8$["Usage: SPLIT component length\n\nsplits the component into two pieces at the point where the distance from the entr\
ance is length. The new components have the same name as the original, and the strengths are proportional to the new lengths. Only\
 magnets and cavities can be split. You should CALCULATE(CAL) after SPLIT to get optical parameters after SPLIT. Matching using SP\
LIT element as a variable may degrade the speed of convergence."[p$2750,p1$2750]])===
    Undefined,
equ$2750="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Usage: SPLIT component length\n\nsplits the \
component into two pieces at the point where the distance from the entrance is length. The new components have the same name as th\
e original, and the strengths are proportional to the new lengths. Only magnets and cavities can be split. You should CALCULATE(CA\
L) after SPLIT to get optical parameters after SPLIT. Matching using SPLIT element as a variable may degrade the speed of converge\
nce."[p$2750,p1$2750]]=
       equ$2750;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2750},out$2750=lx$2750@Typeset["Usage: SPLIT component length\n\nsplits the component into two pieces at the point where \
the distance from the entrance is length. The new components have the same name as the original, and the strengths are proportiona\
l to the new lengths. Only magnets and cavities can be split. You should CALCULATE(CAL) after SPLIT to get optical parameters afte\
r SPLIT. Matching using SPLIT element as a variable may degrade the speed of convergence."[p$2750,p1$2750],Format->Help2HTML`oB$];
        System["mv -f "//out$2750//" "//equ$2750]];
      Exit[]]];
   "Usage: SPLIT component length\n\nsplits the component into two pieces at the point where the distance from the entrance is len\
gth. The new components have the same name as the original, and the strengths are proportional to the new lengths. Only magnets an\
d cavities can be split. You should CALCULATE(CAL) after SPLIT to get optical parameters after SPLIT. Matching using SPLIT element\
 as a variable may degrade the speed of convergence."[1,Max[p0$2750,0]]//"<img  class=\"eqs\" SRC=\""//equ$2750//"\" />"//
   Help2HTML`oy$["Usage: SPLIT component length\n\nsplits the component into two pieces at the point where the distance from the e\
ntrance is length. The new components have the same name as the original, and the strengths are proportional to the new lengths. O\
nly magnets and cavities can be split. You should CALCULATE(CAL) after SPLIT to get optical parameters after SPLIT. Matching using\
 SPLIT element as a variable may degrade the speed of convergence."[p2$2750,-1]]
]</PRE>
<H3><A NAME=L552>
STATUS(STAT)</A></H3>
<PRE>If[{},
Help2HTML`oA$["STAT shows the current settings of flags, fit points, \nspecial-variables, the region for DISPLAY, seed of the rand\
om number generator, and elapsed CPU time, etc."],
p$2752=1+p$2752[[1,2]];p1$2752=StringPosition["STAT shows the current settings of flags, fit points, \nspecial-variables, the regi\
on for DISPLAY, seed of the random number generator, and elapsed CPU time, etc."[p$2752,-1],">::",1];
   p1$2752=If[p1$2752==={},161,-2+p$2752+p1$2752[[1,1]]];
neq=Which["STAT shows the current settings of flags, fit points, \nspecial-variables, the region for DISPLAY, seed of the random n\
umber generator, and elapsed CPU time, etc."[p$2752,4+p$2752]==="Text[",
    lx$2752:=Help2HTML`oa$;p$2752=5+p$2752;p1$2752-=1;p2$2752=5+p1$2752;p0$2752=-9+p$2752;
If[(pe$2752=StringPosition["STAT shows the current settings of flags, fit points, \nspecial-variables, the region for DISPLAY, see\
d of the random number generator, and elapsed CPU time, etc."[p$2752,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["STAT shows the current settings of flags, fit points, \nspecial-variables, the region for DISPLAY, seed of the ra\
ndom number generator, and elapsed CPU time, etc."[p$2752+pe$2752[[1,2]],p1$2752]]],
        p1$2752=-2+p$2752+pe$2752[[1,1]]}[[
       1]],
      0],
    1,lx$2752:=Help2HTML`o9$;p2$2752=4+p1$2752;p0$2752=-4+p$2752;0];
  If[(equ$2752=
Help2HTML`o8$["STAT shows the current settings of flags, fit points, \nspecial-variables, the region for DISPLAY, seed of the rand\
om number generator, and elapsed CPU time, etc."[p$2752,p1$2752]])===
    Undefined,
equ$2752="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["STAT shows the current settings of flags, fi\
t points, \nspecial-variables, the region for DISPLAY, seed of the random number generator, and elapsed CPU time, etc."[p$2752,
         p1$2752]]=
       equ$2752;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2752},out$2752=lx$2752@Typeset["STAT shows the current settings of flags, fit points, \nspecial-variables, the region for\
 DISPLAY, seed of the random number generator, and elapsed CPU time, etc."[p$2752,p1$2752],Format->Help2HTML`oB$];
        System["mv -f "//out$2752//" "//equ$2752]];
      Exit[]]];
   "STAT shows the current settings of flags, fit points, \nspecial-variables, the region for DISPLAY, seed of the random number g\
enerator, and elapsed CPU time, etc."[1,Max[p0$2752,0]]//"<img  class=\"eqs\" SRC=\""//equ$2752//"\" />"//
Help2HTML`oy$["STAT shows the current settings of flags, fit points, \nspecial-variables, the region for DISPLAY, seed of the rand\
om number generator, and elapsed CPU time, etc."[p2$2752,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L500>special-variables</A> <A HREF=#L300>flags</A></PRE>
<H3><A NAME=L553>
STOP</A></H3>
<PRE>If[{},Help2HTML`oA$["Exits FFS and returns to SAD/MAIN level, with saving the values of the elements."],
 p$2755=1+p$2755[[1,2]];
  p1$2755=StringPosition["Exits FFS and returns to SAD/MAIN level, with saving the values of the elements."[p$2755,-1],">::",1];
  p1$2755=If[p1$2755==={},80,-2+p$2755+p1$2755[[1,1]]];
  neq=Which["Exits FFS and returns to SAD/MAIN level, with saving the values of the elements."[p$2755,4+p$2755]==="Text[",
    lx$2755:=Help2HTML`oa$;p$2755=5+p$2755;p1$2755-=1;p2$2755=5+p1$2755;p0$2755=-9+p$2755;
     If[(pe$2755=StringPosition["Exits FFS and returns to SAD/MAIN level, with saving the values of the elements."[p$2755,-2],";;;"
         ])<=>
       {},
      {Max[0,
        -1+ToExpression["Exits FFS and returns to SAD/MAIN level, with saving the values of the elements."[p$2755+pe$2755[[1,2]],
           p1$2755]]],
        p1$2755=-2+p$2755+pe$2755[[1,1]]}[[
       1]],
      0],
    1,lx$2755:=Help2HTML`o9$;p2$2755=4+p1$2755;p0$2755=-4+p$2755;0];
  If[(equ$2755=Help2HTML`o8$["Exits FFS and returns to SAD/MAIN level, with saving the values of the elements."[p$2755,p1$2755]]
     )===
    Undefined,
   equ$2755="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "Exits FFS and returns to SAD/MAIN level, with saving the values of the elements."[p$2755,p1$2755]]=
       equ$2755;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$2755},out$2755=lx$2755@Typeset["Exits FFS and returns to SAD/MAIN level, with saving the values of the elements."[
           p$2755,p1$2755],Format->Help2HTML`oB$];
        System["mv -f "//out$2755//" "//equ$2755]];
      Exit[]]];
   "Exits FFS and returns to SAD/MAIN level, with saving the values of the elements."[1,Max[p0$2755,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2755//"\" />"//
   Help2HTML`oy$["Exits FFS and returns to SAD/MAIN level, with saving the values of the elements."[p2$2755,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L485>QUIT</A> <A HREF=#L548>SAVE</A> <A HREF=#L2>ABORT</A> <A HREF=#L558>USE</A> <A HREF=#L561>VISIT</A> <A HREF=#L14>BYE</A></PRE>
<H3><A NAME=L554>
SUSPEND(SUSP)</A></H3>
<PRE>If[{},
 Help2HTML`oA$["Suspend reading from the current input stream, and wait for input from the console. Resumes by RESUME(RES)"],
 p$2758=1+p$2758[[1,2]];
  p1$2758=StringPosition[
    "Suspend reading from the current input stream, and wait for input from the console. Resumes by RESUME(RES)"[p$2758,-1],">::",
    1];
   p1$2758=If[p1$2758==={},106,-2+p$2758+p1$2758[[1,1]]];
  neq=Which["Suspend reading from the current input stream, and wait for input from the console. Resumes by RESUME(RES)"[p$2758,
      4+p$2758]===
     "Text[",
    lx$2758:=Help2HTML`oa$;p$2758=5+p$2758;p1$2758-=1;p2$2758=5+p1$2758;p0$2758=-9+p$2758;If[(pe$2758=StringPosition[
         "Suspend reading from the current input stream, and wait for input from the console. Resumes by RESUME(RES)"[p$2758,-2],
         ";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression[
          "Suspend reading from the current input stream, and wait for input from the console. Resumes by RESUME(RES)"[p$2758+
            pe$2758[[1,2]],
           p1$2758]]],
        p1$2758=-2+p$2758+pe$2758[[1,1]]}[[
       1]],
      0],
    1,lx$2758:=Help2HTML`o9$;p2$2758=4+p1$2758;p0$2758=-4+p$2758;0];
  If[(equ$2758=
     Help2HTML`o8$["Suspend reading from the current input stream, and wait for input from the console. Resumes by RESUME(RES)"[p
       $2758,p1$2758]])===
    Undefined,
   equ$2758="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "Suspend reading from the current input stream, and wait for input from the console. Resumes by RESUME(RES)"[p$2758,p1$2758
         ]]=
       equ$2758;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$2758},out$2758=lx$2758@Typeset[
          "Suspend reading from the current input stream, and wait for input from the console. Resumes by RESUME(RES)"[p$2758,
           p1$2758],Format->Help2HTML`oB$];
        System["mv -f "//out$2758//" "//equ$2758]];
      Exit[]]];
   "Suspend reading from the current input stream, and wait for input from the console. Resumes by RESUME(RES)"[1,Max[p0$2758,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2758//"\" />"//
   Help2HTML`oy$["Suspend reading from the current input stream, and wait for input from the console. Resumes by RESUME(RES)"[p2
     $2758,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L495>RESUME(RES)</A> <A HREF=#L296>END</A></PRE>
<H3><A NAME=L555>
TERMINATE(TERM)</A></H3>
<PRE>If[{},
Help2HTML`oA$["   TERM [INPUT(IN)] suspends the current input stream and switches it to the previous input stream.\n   TERM OUTPUT\
(OUT) suspends the current output and switches it to the previous output stream."],
p$2761=1+p$2761[[1,2]];p1$2761=StringPosition["   TERM [INPUT(IN)] suspends the current input stream and switches it to the previo\
us input stream.\n   TERM OUTPUT(OUT) suspends the current output and switches it to the previous output stream."[p$2761,-1],">::",
    1];
   p1$2761=If[p1$2761==={},194,-2+p$2761+p1$2761[[1,1]]];
neq=Which["   TERM [INPUT(IN)] suspends the current input stream and switches it to the previous input stream.\n   TERM OUTPUT(OUT\
) suspends the current output and switches it to the previous output stream."[p$2761,4+p$2761]==="Text[",
    lx$2761:=Help2HTML`oa$;p$2761=5+p$2761;p1$2761-=1;p2$2761=5+p1$2761;p0$2761=-9+p$2761;
If[(pe$2761=StringPosition["   TERM [INPUT(IN)] suspends the current input stream and switches it to the previous input stream.\n \
  TERM OUTPUT(OUT) suspends the current output and switches it to the previous output stream."[p$2761,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["   TERM [INPUT(IN)] suspends the current input stream and switches it to the previous input stream.\n   TERM OUTP\
UT(OUT) suspends the current output and switches it to the previous output stream."[p$2761+pe$2761[[1,2]],p1$2761]]],
        p1$2761=-2+p$2761+pe$2761[[1,1]]}[[
       1]],
      0],
    1,lx$2761:=Help2HTML`o9$;p2$2761=4+p1$2761;p0$2761=-4+p$2761;0];
  If[(equ$2761=
Help2HTML`o8$["   TERM [INPUT(IN)] suspends the current input stream and switches it to the previous input stream.\n   TERM OUTPUT\
(OUT) suspends the current output and switches it to the previous output stream."[p$2761,p1$2761]])===
    Undefined,
equ$2761="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["   TERM [INPUT(IN)] suspends the current inp\
ut stream and switches it to the previous input stream.\n   TERM OUTPUT(OUT) suspends the current output and switches it to the pr\
evious output stream."[p$2761,p1$2761]]=
       equ$2761;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2761},out$2761=lx$2761@Typeset["   TERM [INPUT(IN)] suspends the current input stream and switches it to the previous inp\
ut stream.\n   TERM OUTPUT(OUT) suspends the current output and switches it to the previous output stream."[p$2761,p1$2761],
          Format->Help2HTML`oB$];
        System["mv -f "//out$2761//" "//equ$2761]];
      Exit[]]];
   "   TERM [INPUT(IN)] suspends the current input stream and switches it to the previous input stream.\n   TERM OUTPUT(OUT) suspe\
nds the current output and switches it to the previous output stream."[1,Max[p0$2761,0]]//"<img  class=\"eqs\" SRC=\""//equ$2761//
   "\" />"//
Help2HTML`oy$["   TERM [INPUT(IN)] suspends the current input stream and switches it to the previous input stream.\n   TERM OUTPUT\
(OUT) suspends the current output and switches it to the previous output stream."[p2$2761,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L34>CLOSE(CLO)</A> <A HREF=#L471>INPUT(IN)</A> <A HREF=#L487>READ</A> <A HREF=#L480>OUTPUT(OUT)</A> <A HREF=#L3>APPEND(APP)</A> <A HREF=#L296>END</A></PRE>
<H3><A NAME=L556>
TYPE(T)</A></H3>
<PRE>If[{},
Help2HTML`oA$["Usage: TYPE [element-pattern [element-pattern1..]]\n\nprints out the values of elements which match element-pattern\
 in the SAD MAIN input format. Keywords which have zero values are omitted unless it is the default variable. If non element-patte\
rn is given, all elements are printed out."],
p$2764=1+p$2764[[1,2]];p1$2764=StringPosition["Usage: TYPE [element-pattern [element-pattern1..]]\n\nprints out the values of elem\
ents which match element-pattern in the SAD MAIN input format. Keywords which have zero values are omitted unless it is the defaul\
t variable. If non element-pattern is given, all elements are printed out."[p$2764,-1],">::",1];
   p1$2764=If[p1$2764==={},285,-2+p$2764+p1$2764[[1,1]]];
neq=Which["Usage: TYPE [element-pattern [element-pattern1..]]\n\nprints out the values of elements which match element-pattern in \
the SAD MAIN input format. Keywords which have zero values are omitted unless it is the default variable. If non element-pattern i\
s given, all elements are printed out."[p$2764,4+p$2764]==="Text[",
    lx$2764:=Help2HTML`oa$;p$2764=5+p$2764;p1$2764-=1;p2$2764=5+p1$2764;p0$2764=-9+p$2764;
If[(pe$2764=StringPosition["Usage: TYPE [element-pattern [element-pattern1..]]\n\nprints out the values of elements which match el\
ement-pattern in the SAD MAIN input format. Keywords which have zero values are omitted unless it is the default variable. If non \
element-pattern is given, all elements are printed out."[p$2764,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Usage: TYPE [element-pattern [element-pattern1..]]\n\nprints out the values of elements which match element-patte\
rn in the SAD MAIN input format. Keywords which have zero values are omitted unless it is the default variable. If non element-pat\
tern is given, all elements are printed out."[p$2764+pe$2764[[1,2]],p1$2764]]],
        p1$2764=-2+p$2764+pe$2764[[1,1]]}[[
       1]],
      0],
    1,lx$2764:=Help2HTML`o9$;p2$2764=4+p1$2764;p0$2764=-4+p$2764;0];
  If[(equ$2764=
Help2HTML`o8$["Usage: TYPE [element-pattern [element-pattern1..]]\n\nprints out the values of elements which match element-pattern\
 in the SAD MAIN input format. Keywords which have zero values are omitted unless it is the default variable. If non element-patte\
rn is given, all elements are printed out."[p$2764,p1$2764]])===
    Undefined,
equ$2764="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Usage: TYPE [element-pattern [element-patter\
n1..]]\n\nprints out the values of elements which match element-pattern in the SAD MAIN input format. Keywords which have zero val\
ues are omitted unless it is the default variable. If non element-pattern is given, all elements are printed out."[p$2764,p1$2764]
        ]=
       equ$2764;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2764},out$2764=lx$2764@Typeset["Usage: TYPE [element-pattern [element-pattern1..]]\n\nprints out the values of elements w\
hich match element-pattern in the SAD MAIN input format. Keywords which have zero values are omitted unless it is the default vari\
able. If non element-pattern is given, all elements are printed out."[p$2764,p1$2764],Format->Help2HTML`oB$];
        System["mv -f "//out$2764//" "//equ$2764]];
      Exit[]]];
   "Usage: TYPE [element-pattern [element-pattern1..]]\n\nprints out the values of elements which match element-pattern in the SAD\
 MAIN input format. Keywords which have zero values are omitted unless it is the default variable. If non element-pattern is given\
, all elements are printed out."[1,Max[p0$2764,0]]//"<img  class=\"eqs\" SRC=\""//equ$2764//"\" />"//
Help2HTML`oy$["Usage: TYPE [element-pattern [element-pattern1..]]\n\nprints out the values of elements which match element-pattern\
 in the SAD MAIN input format. Keywords which have zero values are omitted unless it is the default variable. If non element-patte\
rn is given, all elements are printed out."[p2$2764,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L56>DISPLAY(DISP)</A> <A HREF=#L559>VARIABLES(VAR)</A> <A HREF=#L75>elements</A></PRE>
<H3><A NAME=L557>
UNTIL</A></H3>
<PRE>If[{},
Help2HTML`oA$["Usage: REP [n] body UNTIL [expr1]\n\nexecutes commands in body n times until expr1 gives nonzero. The number n can \
be any expression which gives a number. If n is omitted, infinity is assumed. If expr1 is omitted, False(==0) is assumed."],
 p$2767=1+p$2767[[1,2]];
p1$2767=StringPosition["Usage: REP [n] body UNTIL [expr1]\n\nexecutes commands in body n times until expr1 gives nonzero. The numb\
er n can be any expression which gives a number. If n is omitted, infinity is assumed. If expr1 is omitted, False(==0) is assumed."
    [p$2767,-1],">::",1];
   p1$2767=If[p1$2767==={},234,-2+p$2767+p1$2767[[1,1]]];
neq=Which["Usage: REP [n] body UNTIL [expr1]\n\nexecutes commands in body n times until expr1 gives nonzero. The number n can be a\
ny expression which gives a number. If n is omitted, infinity is assumed. If expr1 is omitted, False(==0) is assumed."[p$2767,
      4+p$2767]===
     "Text[",
lx$2767:=Help2HTML`oa$;p$2767=5+p$2767;p1$2767-=1;p2$2767=5+p1$2767;p0$2767=-9+p$2767;If[(pe$2767=StringPosition["Usage: REP [n] b\
ody UNTIL [expr1]\n\nexecutes commands in body n times until expr1 gives nonzero. The number n can be any expression which gives a\
 number. If n is omitted, infinity is assumed. If expr1 is omitted, False(==0) is assumed."[p$2767,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Usage: REP [n] body UNTIL [expr1]\n\nexecutes commands in body n times until expr1 gives nonzero. The number n ca\
n be any expression which gives a number. If n is omitted, infinity is assumed. If expr1 is omitted, False(==0) is assumed."[p$2767
            +pe$2767[[1,2]],
           p1$2767]]],
        p1$2767=-2+p$2767+pe$2767[[1,1]]}[[
       1]],
      0],
    1,lx$2767:=Help2HTML`o9$;p2$2767=4+p1$2767;p0$2767=-4+p$2767;0];
  If[(equ$2767=
Help2HTML`o8$["Usage: REP [n] body UNTIL [expr1]\n\nexecutes commands in body n times until expr1 gives nonzero. The number n can \
be any expression which gives a number. If n is omitted, infinity is assumed. If expr1 is omitted, False(==0) is assumed."[p$2767,
       p1$2767]])===
    Undefined,
equ$2767="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Usage: REP [n] body UNTIL [expr1]\n\nexecute\
s commands in body n times until expr1 gives nonzero. The number n can be any expression which gives a number. If n is omitted, in\
finity is assumed. If expr1 is omitted, False(==0) is assumed."[p$2767,p1$2767]]=
       equ$2767;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2767},out$2767=lx$2767@Typeset["Usage: REP [n] body UNTIL [expr1]\n\nexecutes commands in body n times until expr1 gives \
nonzero. The number n can be any expression which gives a number. If n is omitted, infinity is assumed. If expr1 is omitted, False\
(==0) is assumed."[p$2767,p1$2767],Format->Help2HTML`oB$];
        System["mv -f "//out$2767//" "//equ$2767]];
      Exit[]]];
   "Usage: REP [n] body UNTIL [expr1]\n\nexecutes commands in body n times until expr1 gives nonzero. The number n can be any expr\
ession which gives a number. If n is omitted, infinity is assumed. If expr1 is omitted, False(==0) is assumed."[1,Max[p0$2767,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2767//"\" />"//
Help2HTML`oy$["Usage: REP [n] body UNTIL [expr1]\n\nexecutes commands in body n times until expr1 gives nonzero. The number n can \
be any expression which gives a number. If n is omitted, infinity is assumed. If expr1 is omitted, False(==0) is assumed."[p2$2767,
     -1]]
]</PRE>
<PRE>See also:
 <A HREF=#L493>REPEAT(REP)</A> <A HREF=#L246>expression</A> <A HREF=#L29>command-syntax</A> <A HREF=#L358>functions</A> Do</PRE>
<H3><A NAME=L558>
USE</A></H3>
<PRE>If[{},
Help2HTML`oA$["Usage: USE [[NO]EXPAND] beam-line\n\nswitches the beam line used in FFS to the beam line given by beam-line. beam-l\
ine can be an BeamLine object or the name of a beam line defined in MAIN. All information specific to the current beam line, such \
as matching conditions is lost. If the keyword EXPAND is given (default), the new beam line is expanded, i.e., the values of compo\
nents are refreshed to the saved values.\n   If a BeamLine object is used by USE or VISIT, the new beam line becomes a\nnew LINE i\
n the MAIN level, with a name which is created automatically."],
p$2770=1+p$2770[[1,2]];p1$2770=StringPosition["Usage: USE [[NO]EXPAND] beam-line\n\nswitches the beam line used in FFS to the beam\
 line given by beam-line. beam-line can be an BeamLine object or the name of a beam line defined in MAIN. All information specific\
 to the current beam line, such as matching conditions is lost. If the keyword EXPAND is given (default), the new beam line is exp\
anded, i.e., the values of components are refreshed to the saved values.\n   If a BeamLine object is used by USE or VISIT, the new\
 beam line becomes a\nnew LINE in the MAIN level, with a name which is created automatically."[p$2770,-1],">::",1];
   p1$2770=If[p1$2770==={},562,-2+p$2770+p1$2770[[1,1]]];
neq=Which["Usage: USE [[NO]EXPAND] beam-line\n\nswitches the beam line used in FFS to the beam line given by beam-line. beam-line \
can be an BeamLine object or the name of a beam line defined in MAIN. All information specific to the current beam line, such as m\
atching conditions is lost. If the keyword EXPAND is given (default), the new beam line is expanded, i.e., the values of component\
s are refreshed to the saved values.\n   If a BeamLine object is used by USE or VISIT, the new beam line becomes a\nnew LINE in th\
e MAIN level, with a name which is created automatically."[p$2770,4+p$2770]==="Text[",
    lx$2770:=Help2HTML`oa$;p$2770=5+p$2770;p1$2770-=1;p2$2770=5+p1$2770;p0$2770=-9+p$2770;
If[(pe$2770=StringPosition["Usage: USE [[NO]EXPAND] beam-line\n\nswitches the beam line used in FFS to the beam line given by beam\
-line. beam-line can be an BeamLine object or the name of a beam line defined in MAIN. All information specific to the current bea\
m line, such as matching conditions is lost. If the keyword EXPAND is given (default), the new beam line is expanded, i.e., the va\
lues of components are refreshed to the saved values.\n   If a BeamLine object is used by USE or VISIT, the new beam line becomes \
a\nnew LINE in the MAIN level, with a name which is created automatically."[p$2770,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Usage: USE [[NO]EXPAND] beam-line\n\nswitches the beam line used in FFS to the beam line given by beam-line. beam\
-line can be an BeamLine object or the name of a beam line defined in MAIN. All information specific to the current beam line, suc\
h as matching conditions is lost. If the keyword EXPAND is given (default), the new beam line is expanded, i.e., the values of com\
ponents are refreshed to the saved values.\n   If a BeamLine object is used by USE or VISIT, the new beam line becomes a\nnew LINE\
 in the MAIN level, with a name which is created automatically."[p$2770+pe$2770[[1,2]],p1$2770]]],
        p1$2770=-2+p$2770+pe$2770[[1,1]]}[[
       1]],
      0],
    1,lx$2770:=Help2HTML`o9$;p2$2770=4+p1$2770;p0$2770=-4+p$2770;0];
  If[(equ$2770=
Help2HTML`o8$["Usage: USE [[NO]EXPAND] beam-line\n\nswitches the beam line used in FFS to the beam line given by beam-line. beam-l\
ine can be an BeamLine object or the name of a beam line defined in MAIN. All information specific to the current beam line, such \
as matching conditions is lost. If the keyword EXPAND is given (default), the new beam line is expanded, i.e., the values of compo\
nents are refreshed to the saved values.\n   If a BeamLine object is used by USE or VISIT, the new beam line becomes a\nnew LINE i\
n the MAIN level, with a name which is created automatically."[p$2770,p1$2770]])===
    Undefined,
equ$2770="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Usage: USE [[NO]EXPAND] beam-line\n\nswitche\
s the beam line used in FFS to the beam line given by beam-line. beam-line can be an BeamLine object or the name of a beam line de\
fined in MAIN. All information specific to the current beam line, such as matching conditions is lost. If the keyword EXPAND is gi\
ven (default), the new beam line is expanded, i.e., the values of components are refreshed to the saved values.\n   If a BeamLine \
object is used by USE or VISIT, the new beam line becomes a\nnew LINE in the MAIN level, with a name which is created automaticall\
y."[p$2770,p1$2770]]=
       equ$2770;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2770},out$2770=lx$2770@Typeset["Usage: USE [[NO]EXPAND] beam-line\n\nswitches the beam line used in FFS to the beam line \
given by beam-line. beam-line can be an BeamLine object or the name of a beam line defined in MAIN. All information specific to th\
e current beam line, such as matching conditions is lost. If the keyword EXPAND is given (default), the new beam line is expanded,\
 i.e., the values of components are refreshed to the saved values.\n   If a BeamLine object is used by USE or VISIT, the new beam \
line becomes a\nnew LINE in the MAIN level, with a name which is created automatically."[p$2770,p1$2770],Format->Help2HTML`oB$];
        System["mv -f "//out$2770//" "//equ$2770]];
      Exit[]]];
   "Usage: USE [[NO]EXPAND] beam-line\n\nswitches the beam line used in FFS to the beam line given by beam-line. beam-line can be \
an BeamLine object or the name of a beam line defined in MAIN. All information specific to the current beam line, such as matching\
 conditions is lost. If the keyword EXPAND is given (default), the new beam line is expanded, i.e., the values of components are r\
efreshed to the saved values.\n   If a BeamLine object is used by USE or VISIT, the new beam line becomes a\nnew LINE in the MAIN \
level, with a name which is created automatically."[1,Max[p0$2770,0]]//"<img  class=\"eqs\" SRC=\""//equ$2770//"\" />"//
   Help2HTML`oy$["Usage: USE [[NO]EXPAND] beam-line\n\nswitches the beam line used in FFS to the beam line given by beam-line. bea\
m-line can be an BeamLine object or the name of a beam line defined in MAIN. All information specific to the current beam line, su\
ch as matching conditions is lost. If the keyword EXPAND is given (default), the new beam line is expanded, i.e., the values of co\
mponents are refreshed to the saved values.\n   If a BeamLine object is used by USE or VISIT, the new beam line becomes a\nnew LIN\
E in the MAIN level, with a name which is created automatically."[p2$2770,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L561>VISIT</A> <A HREF=#L14>BYE</A> <A HREF=#L299>EXPAND</A> <A HREF=#L7>BeamLine</A> <A HREF=#L8>BeamLineName</A></PRE>
<H3><A NAME=L559>
VARIABLES(VAR)</A></H3>
<PRE>If[{},
Help2HTML`oA$["VARIABLES displays a list of current matching-variables and their present, previous, saved, minimum, and maximum va\
lues together with the COUPLEd master elements and their coefficients.\n   When executed in the FFS function, it returns the resul\
t as a list.\n\n   Usage:   FFS[\"VAR\"]\n\nreturns a list of nvar elements, where nvar is the number of current matching-variable\
s given by the FREE command. Each element has the form\n\n  {name, keyword, present, previous, saved, minimum, maximum, coupled-ma\
ster-element, coupling-coefficient} ,\n\nwhich corresponds to the output of the VARIABLES(VAR) command."],
 p$2773=1+p$2773[[1,2]];p1$2773=
StringPosition["VARIABLES displays a list of current matching-variables and their present, previous, saved, minimum, and maximum v\
alues together with the COUPLEd master elements and their coefficients.\n   When executed in the FFS function, it returns the resu\
lt as a list.\n\n   Usage:   FFS[\"VAR\"]\n\nreturns a list of nvar elements, where nvar is the number of current matching-variabl\
es given by the FREE command. Each element has the form\n\n  {name, keyword, present, previous, saved, minimum, maximum, coupled-m\
aster-element, coupling-coefficient} ,\n\nwhich corresponds to the output of the VARIABLES(VAR) command."[p$2773,-1],">::",1];
   p1$2773=If[p1$2773==={},597,-2+p$2773+p1$2773[[1,1]]];
neq=Which["VARIABLES displays a list of current matching-variables and their present, previous, saved, minimum, and maximum values\
 together with the COUPLEd master elements and their coefficients.\n   When executed in the FFS function, it returns the result as\
 a list.\n\n   Usage:   FFS[\"VAR\"]\n\nreturns a list of nvar elements, where nvar is the number of current matching-variables gi\
ven by the FREE command. Each element has the form\n\n  {name, keyword, present, previous, saved, minimum, maximum, coupled-master\
-element, coupling-coefficient} ,\n\nwhich corresponds to the output of the VARIABLES(VAR) command."[p$2773,4+p$2773]==="Text[",
    lx$2773:=Help2HTML`oa$;p$2773=5+p$2773;p1$2773-=1;p2$2773=5+p1$2773;p0$2773=-9+p$2773;
If[(pe$2773=StringPosition["VARIABLES displays a list of current matching-variables and their present, previous, saved, minimum, a\
nd maximum values together with the COUPLEd master elements and their coefficients.\n   When executed in the FFS function, it retu\
rns the result as a list.\n\n   Usage:   FFS[\"VAR\"]\n\nreturns a list of nvar elements, where nvar is the number of current matc\
hing-variables given by the FREE command. Each element has the form\n\n  {name, keyword, present, previous, saved, minimum, maximu\
m, coupled-master-element, coupling-coefficient} ,\n\nwhich corresponds to the output of the VARIABLES(VAR) command."[p$2773,-2],
         ";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["VARIABLES displays a list of current matching-variables and their present, previous, saved, minimum, and maximum \
values together with the COUPLEd master elements and their coefficients.\n   When executed in the FFS function, it returns the res\
ult as a list.\n\n   Usage:   FFS[\"VAR\"]\n\nreturns a list of nvar elements, where nvar is the number of current matching-variab\
les given by the FREE command. Each element has the form\n\n  {name, keyword, present, previous, saved, minimum, maximum, coupled-\
master-element, coupling-coefficient} ,\n\nwhich corresponds to the output of the VARIABLES(VAR) command."[p$2773+pe$2773[[1,2]],
           p1$2773]]],
        p1$2773=-2+p$2773+pe$2773[[1,1]]}[[
       1]],
      0],
    1,lx$2773:=Help2HTML`o9$;p2$2773=4+p1$2773;p0$2773=-4+p$2773;0];
  If[(equ$2773=
Help2HTML`o8$["VARIABLES displays a list of current matching-variables and their present, previous, saved, minimum, and maximum va\
lues together with the COUPLEd master elements and their coefficients.\n   When executed in the FFS function, it returns the resul\
t as a list.\n\n   Usage:   FFS[\"VAR\"]\n\nreturns a list of nvar elements, where nvar is the number of current matching-variable\
s given by the FREE command. Each element has the form\n\n  {name, keyword, present, previous, saved, minimum, maximum, coupled-ma\
ster-element, coupling-coefficient} ,\n\nwhich corresponds to the output of the VARIABLES(VAR) command."[p$2773,p1$2773]])===
    Undefined,
equ$2773="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["VARIABLES displays a list of current matchin\
g-variables and their present, previous, saved, minimum, and maximum values together with the COUPLEd master elements and their co\
efficients.\n   When executed in the FFS function, it returns the result as a list.\n\n   Usage:   FFS[\"VAR\"]\n\nreturns a list \
of nvar elements, where nvar is the number of current matching-variables given by the FREE command. Each element has the form\n\n \
 {name, keyword, present, previous, saved, minimum, maximum, coupled-master-element, coupling-coefficient} ,\n\nwhich corresponds \
to the output of the VARIABLES(VAR) command."[p$2773,p1$2773]]=
       equ$2773;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2773},out$2773=lx$2773@Typeset["VARIABLES displays a list of current matching-variables and their present, previous, save\
d, minimum, and maximum values together with the COUPLEd master elements and their coefficients.\n   When executed in the FFS func\
tion, it returns the result as a list.\n\n   Usage:   FFS[\"VAR\"]\n\nreturns a list of nvar elements, where nvar is the number of\
 current matching-variables given by the FREE command. Each element has the form\n\n  {name, keyword, present, previous, saved, mi\
nimum, maximum, coupled-master-element, coupling-coefficient} ,\n\nwhich corresponds to the output of the VARIABLES(VAR) command."[
           p$2773,p1$2773],Format->Help2HTML`oB$];
        System["mv -f "//out$2773//" "//equ$2773]];
      Exit[]]];
   "VARIABLES displays a list of current matching-variables and their present, previous, saved, minimum, and maximum values togeth\
er with the COUPLEd master elements and their coefficients.\n   When executed in the FFS function, it returns the result as a list\
.\n\n   Usage:   FFS[\"VAR\"]\n\nreturns a list of nvar elements, where nvar is the number of current matching-variables given by \
the FREE command. Each element has the form\n\n  {name, keyword, present, previous, saved, minimum, maximum, coupled-master-elemen\
t, coupling-coefficient} ,\n\nwhich corresponds to the output of the VARIABLES(VAR) command."[1,Max[p0$2773,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2773//"\" />"//
Help2HTML`oy$["VARIABLES displays a list of current matching-variables and their present, previous, saved, minimum, and maximum va\
lues together with the COUPLEd master elements and their coefficients.\n   When executed in the FFS function, it returns the resul\
t as a list.\n\n   Usage:   FFS[\"VAR\"]\n\nreturns a list of nvar elements, where nvar is the number of current matching-variable\
s given by the FREE command. Each element has the form\n\n  {name, keyword, present, previous, saved, minimum, maximum, coupled-ma\
ster-element, coupling-coefficient} ,\n\nwhich corresponds to the output of the VARIABLES(VAR) command."[p2$2773,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L466>FREE</A> <A HREF=#L35>COUPLE(COUP)</A> <A HREF=#L392>FFS</A></PRE>
<H3><A NAME=L560>
VARY</A></H3>
<PRE>If[{},
 Help2HTML`oA$[
  "Usage: VARY keyword element-pattern\n\nchanges the default-keyword of the elements which match element-pattern to keyword."],
 p$2776=1+p$2776[[1,2]];
  p1$2776=StringPosition[
    "Usage: VARY keyword element-pattern\n\nchanges the default-keyword of the elements which match element-pattern to keyword."[
     p$2776,-1],
    ">::",1];
   p1$2776=If[p1$2776==={},120,-2+p$2776+p1$2776[[1,1]]];
  neq=Which[
     "Usage: VARY keyword element-pattern\n\nchanges the default-keyword of the elements which match element-pattern to keyword."[
      p$2776,4+p$2776]===
     "Text[",
    lx$2776:=Help2HTML`oa$;p$2776=5+p$2776;p1$2776-=1;p2$2776=5+p1$2776;p0$2776=-9+p$2776;If[(pe$2776=StringPosition[
         "Usage: VARY keyword element-pattern\n\nchanges the default-keyword of the elements which match element-pattern to keywor\
d."[p$2776,-2],";;;"])<=>
       {},
      {Max[0,
        -1+ToExpression[
          "Usage: VARY keyword element-pattern\n\nchanges the default-keyword of the elements which match element-pattern to keywo\
rd."[p$2776+pe$2776[[1,2]],p1$2776]]],
        p1$2776=-2+p$2776+pe$2776[[1,1]]}[[
       1]],
      0],
    1,lx$2776:=Help2HTML`o9$;p2$2776=4+p1$2776;p0$2776=-4+p$2776;0];
  If[(equ$2776=
     Help2HTML`o8$[
      "Usage: VARY keyword element-pattern\n\nchanges the default-keyword of the elements which match element-pattern to keyword."[
       p$2776,p1$2776]])===
    Undefined,
   equ$2776="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$[
        "Usage: VARY keyword element-pattern\n\nchanges the default-keyword of the elements which match element-pattern to keyword\
."[p$2776,p1$2776]]=
       equ$2776;LaTeX`ob$+=neq,
      --LaTeX`ob$;
      With[{lx$2776},out$2776=lx$2776@Typeset[
          "Usage: VARY keyword element-pattern\n\nchanges the default-keyword of the elements which match element-pattern to keywo\
rd."[p$2776,p1$2776],Format->Help2HTML`oB$];
        System["mv -f "//out$2776//" "//equ$2776]];
      Exit[]]];
  "Usage: VARY keyword element-pattern\n\nchanges the default-keyword of the elements which match element-pattern to keyword."[1,
    Max[p0$2776,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2776//"\" />"//
   Help2HTML`oy$[
    "Usage: VARY keyword element-pattern\n\nchanges the default-keyword of the elements which match element-pattern to keyword."[
     p2$2776,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L466>FREE</A> <A HREF=#L75>elements</A> <A HREF=#L562>wildcards</A></PRE>
<H3><A NAME=L561>
VISIT</A></H3>
<PRE>If[{},
Help2HTML`oA$["Usage: VISIT [[NO]EXPAND] beam-line\n\nswitches the beam line used in FFS to the beam line given by beam-line. beam\
-line can be an BeamLine object or the name of a beam line defined in MAIN. All information specific to the current beam line, suc\
h as matching conditions are reserved, and the previous beam line is restored when BYE command is issued. If the keyword EXPAND is\
 given (default), the new beam line is expanded, i.e., the values of components are refreshed to the saved values.\n   If a BeamLi\
ne object is used by USE or VISIT, the new beam line becomes a new LINE in the MAIN level, with a name which is created automatica\
lly."],
p$2779=1+p$2779[[1,2]];p1$2779=StringPosition["Usage: VISIT [[NO]EXPAND] beam-line\n\nswitches the beam line used in FFS to the be\
am line given by beam-line. beam-line can be an BeamLine object or the name of a beam line defined in MAIN. All information specif\
ic to the current beam line, such as matching conditions are reserved, and the previous beam line is restored when BYE command is \
issued. If the keyword EXPAND is given (default), the new beam line is expanded, i.e., the values of components are refreshed to t\
he saved values.\n   If a BeamLine object is used by USE or VISIT, the new beam line becomes a new LINE in the MAIN level, with a \
name which is created automatically."[p$2779,-1],">::",1];
   p1$2779=If[p1$2779==={},636,-2+p$2779+p1$2779[[1,1]]];
neq=Which["Usage: VISIT [[NO]EXPAND] beam-line\n\nswitches the beam line used in FFS to the beam line given by beam-line. beam-lin\
e can be an BeamLine object or the name of a beam line defined in MAIN. All information specific to the current beam line, such as\
 matching conditions are reserved, and the previous beam line is restored when BYE command is issued. If the keyword EXPAND is giv\
en (default), the new beam line is expanded, i.e., the values of components are refreshed to the saved values.\n   If a BeamLine o\
bject is used by USE or VISIT, the new beam line becomes a new LINE in the MAIN level, with a name which is created automatically."
     [p$2779,4+p$2779]==="Text[",
    lx$2779:=Help2HTML`oa$;p$2779=5+p$2779;p1$2779-=1;p2$2779=5+p1$2779;p0$2779=-9+p$2779;If[(pe$2779=StringPosition["Usage: VISIT\
 [[NO]EXPAND] beam-line\n\nswitches the beam line used in FFS to the beam line given by beam-line. beam-line can be an BeamLine ob\
ject or the name of a beam line defined in MAIN. All information specific to the current beam line, such as matching conditions ar\
e reserved, and the previous beam line is restored when BYE command is issued. If the keyword EXPAND is given (default), the new b\
eam line is expanded, i.e., the values of components are refreshed to the saved values.\n   If a BeamLine object is used by USE or\
 VISIT, the new beam line becomes a new LINE in the MAIN level, with a name which is created automatically."[p$2779,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["Usage: VISIT [[NO]EXPAND] beam-line\n\nswitches the beam line used in FFS to the beam line given by beam-line. be\
am-line can be an BeamLine object or the name of a beam line defined in MAIN. All information specific to the current beam line, s\
uch as matching conditions are reserved, and the previous beam line is restored when BYE command is issued. If the keyword EXPAND \
is given (default), the new beam line is expanded, i.e., the values of components are refreshed to the saved values.\n   If a Beam\
Line object is used by USE or VISIT, the new beam line becomes a new LINE in the MAIN level, with a name which is created automati\
cally."[p$2779+pe$2779[[1,2]],p1$2779]]],
        p1$2779=-2+p$2779+pe$2779[[1,1]]}[[
       1]],
      0],
    1,lx$2779:=Help2HTML`o9$;p2$2779=4+p1$2779;p0$2779=-4+p$2779;0];
  If[(equ$2779=
Help2HTML`o8$["Usage: VISIT [[NO]EXPAND] beam-line\n\nswitches the beam line used in FFS to the beam line given by beam-line. beam\
-line can be an BeamLine object or the name of a beam line defined in MAIN. All information specific to the current beam line, suc\
h as matching conditions are reserved, and the previous beam line is restored when BYE command is issued. If the keyword EXPAND is\
 given (default), the new beam line is expanded, i.e., the values of components are refreshed to the saved values.\n   If a BeamLi\
ne object is used by USE or VISIT, the new beam line becomes a new LINE in the MAIN level, with a name which is created automatica\
lly."[p$2779,p1$2779]])===
    Undefined,
equ$2779="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["Usage: VISIT [[NO]EXPAND] beam-line\n\nswitc\
hes the beam line used in FFS to the beam line given by beam-line. beam-line can be an BeamLine object or the name of a beam line \
defined in MAIN. All information specific to the current beam line, such as matching conditions are reserved, and the previous bea\
m line is restored when BYE command is issued. If the keyword EXPAND is given (default), the new beam line is expanded, i.e., the \
values of components are refreshed to the saved values.\n   If a BeamLine object is used by USE or VISIT, the new beam line become\
s a new LINE in the MAIN level, with a name which is created automatically."[p$2779,p1$2779]]=
       equ$2779;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2779},out$2779=lx$2779@Typeset["Usage: VISIT [[NO]EXPAND] beam-line\n\nswitches the beam line used in FFS to the beam lin\
e given by beam-line. beam-line can be an BeamLine object or the name of a beam line defined in MAIN. All information specific to \
the current beam line, such as matching conditions are reserved, and the previous beam line is restored when BYE command is issued\
. If the keyword EXPAND is given (default), the new beam line is expanded, i.e., the values of components are refreshed to the sav\
ed values.\n   If a BeamLine object is used by USE or VISIT, the new beam line becomes a new LINE in the MAIN level, with a name w\
hich is created automatically."[p$2779,p1$2779],Format->Help2HTML`oB$];
        System["mv -f "//out$2779//" "//equ$2779]];
      Exit[]]];
   "Usage: VISIT [[NO]EXPAND] beam-line\n\nswitches the beam line used in FFS to the beam line given by beam-line. beam-line can b\
e an BeamLine object or the name of a beam line defined in MAIN. All information specific to the current beam line, such as matchi\
ng conditions are reserved, and the previous beam line is restored when BYE command is issued. If the keyword EXPAND is given (def\
ault), the new beam line is expanded, i.e., the values of components are refreshed to the saved values.\n   If a BeamLine object i\
s used by USE or VISIT, the new beam line becomes a new LINE in the MAIN level, with a name which is created automatically."[1,
    Max[p0$2779,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2779//"\" />"//
Help2HTML`oy$["Usage: VISIT [[NO]EXPAND] beam-line\n\nswitches the beam line used in FFS to the beam line given by beam-line. beam\
-line can be an BeamLine object or the name of a beam line defined in MAIN. All information specific to the current beam line, suc\
h as matching conditions are reserved, and the previous beam line is restored when BYE command is issued. If the keyword EXPAND is\
 given (default), the new beam line is expanded, i.e., the values of components are refreshed to the saved values.\n   If a BeamLi\
ne object is used by USE or VISIT, the new beam line becomes a new LINE in the MAIN level, with a name which is created automatica\
lly."[p2$2779,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L558>USE</A> <A HREF=#L14>BYE</A> <A HREF=#L299>EXPAND</A> <A HREF=#L7>BeamLine</A> <A HREF=#L8>BeamLineName</A></PRE>
<H3><A NAME=L562>
wildcards</A></H3>
<PRE>If[{},
Help2HTML`oA$["   Many commands and functions accept the wildcards as a specification for the name of elements or components. The \
valid wildcards are:\n\n       *         matches any zero or more characters.\n       %         matches one character.\n       {..\
}      matches any character enclosed.\n       {^..}     matches any character not enclosed.\n       ..|..     alternative pattern\
."],
p$2782=1+p$2782[[1,2]];p1$2782=StringPosition["   Many commands and functions accept the wildcards as a specification for the name\
 of elements or components. The valid wildcards are:\n\n       *         matches any zero or more characters.\n       %         ma\
tches one character.\n       {..}      matches any character enclosed.\n       {^..}     matches any character not enclosed.\n    \
   ..|..     alternative pattern."[p$2782,-1],">::",1];
   p1$2782=If[p1$2782==={},370,-2+p$2782+p1$2782[[1,1]]];
neq=Which["   Many commands and functions accept the wildcards as a specification for the name of elements or components. The vali\
d wildcards are:\n\n       *         matches any zero or more characters.\n       %         matches one character.\n       {..}   \
   matches any character enclosed.\n       {^..}     matches any character not enclosed.\n       ..|..     alternative pattern."[
      p$2782,4+p$2782]===
     "Text[",
lx$2782:=Help2HTML`oa$;p$2782=5+p$2782;p1$2782-=1;p2$2782=5+p1$2782;p0$2782=-9+p$2782;If[(pe$2782=StringPosition["   Many commands\
 and functions accept the wildcards as a specification for the name of elements or components. The valid wildcards are:\n\n       \
*         matches any zero or more characters.\n       %         matches one character.\n       {..}      matches any character en\
closed.\n       {^..}     matches any character not enclosed.\n       ..|..     alternative pattern."[p$2782,-2],";;;"])<=>
       {},
      {Max[0,
-1+ToExpression["   Many commands and functions accept the wildcards as a specification for the name of elements or components. Th\
e valid wildcards are:\n\n       *         matches any zero or more characters.\n       %         matches one character.\n       {\
..}      matches any character enclosed.\n       {^..}     matches any character not enclosed.\n       ..|..     alternative patte\
rn."[p$2782+pe$2782[[1,2]],p1$2782]]],
        p1$2782=-2+p$2782+pe$2782[[1,1]]}[[
       1]],
      0],
    1,lx$2782:=Help2HTML`o9$;p2$2782=4+p1$2782;p0$2782=-4+p$2782;0];
  If[(equ$2782=
Help2HTML`o8$["   Many commands and functions accept the wildcards as a specification for the name of elements or components. The \
valid wildcards are:\n\n       *         matches any zero or more characters.\n       %         matches one character.\n       {..\
}      matches any character enclosed.\n       {^..}     matches any character not enclosed.\n       ..|..     alternative pattern\
."[p$2782,p1$2782]])===
    Undefined,
equ$2782="SADHelp_img/equ_"//++LaTeX`ob$//"."//Help2HTML`oB$;If[Fork[],Help2HTML`o8$["   Many commands and functions accept the wi\
ldcards as a specification for the name of elements or components. The valid wildcards are:\n\n       *         matches any zero o\
r more characters.\n       %         matches one character.\n       {..}      matches any character enclosed.\n       {^..}     ma\
tches any character not enclosed.\n       ..|..     alternative pattern."[p$2782,p1$2782]]=
       equ$2782;LaTeX`ob$+=neq,
      --LaTeX`ob$;
With[{lx$2782},out$2782=lx$2782@Typeset["   Many commands and functions accept the wildcards as a specification for the name of el\
ements or components. The valid wildcards are:\n\n       *         matches any zero or more characters.\n       %         matches \
one character.\n       {..}      matches any character enclosed.\n       {^..}     matches any character not enclosed.\n       ..|\
..     alternative pattern."[p$2782,p1$2782],Format->Help2HTML`oB$];
        System["mv -f "//out$2782//" "//equ$2782]];
      Exit[]]];
   "   Many commands and functions accept the wildcards as a specification for the name of elements or components. The valid wildc\
ards are:\n\n       *         matches any zero or more characters.\n       %         matches one character.\n       {..}      matc\
hes any character enclosed.\n       {^..}     matches any character not enclosed.\n       ..|..     alternative pattern."[1,
    Max[p0$2782,0]]//
   "<img  class=\"eqs\" SRC=\""//equ$2782//"\" />"//
Help2HTML`oy$["   Many commands and functions accept the wildcards as a specification for the name of elements or components. The \
valid wildcards are:\n\n       *         matches any zero or more characters.\n       %         matches one character.\n       {..\
}      matches any character enclosed.\n       {^..}     matches any character not enclosed.\n       ..|..     alternative pattern\
."[p2$2782,-1]]
]</PRE>
<PRE>See also:
 <A HREF=#L75>elements</A> <A HREF=#L30>components</A> <A HREF=#L56>DISPLAY(DISP)</A> <A HREF=#L556>TYPE(T)</A> <A HREF=#L548>SAVE</A> <A HREF=#L494>RESET</A> <A HREF=#L466>FREE</A> <A HREF=#L465>FIX</A> <A HREF=#L4>ATTRIBUTE(ATTR)</A> <A HREF=#L491>REJECT(REJ)</A>
 <A HREF=#L32>CALCULATE(CAL)</A> <A HREF=#L358>functions</A> <A HREF=#L387>Element</A> <A HREF=#L398>LINE</A> <A HREF=#L410>Twiss</A></PRE>
<HR>
</BODY>
