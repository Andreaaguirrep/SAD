c/*   Skeleton output parser for bison,
c     Copyright (C) 1984, 1989, 1990 Bob Corbett and Richard Stallman
c
c     This program is free software; you can redistribute it and/or modify
c     it under the terms of the GNU General Public License as published by
c     the Free Software Foundation; either version 1, or (at your option)
c     any later version.
c
c     This program is distributed in the hope that it will be useful,
c     but WITHOUT ANY WARRANTY; without even the implied warranty of
c     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
c     GNU General Public License for more details.
c
c     You should have received a copy of the GNU General Public License
c     along with this program; if not, write to the Free Software
c     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
c
c     converted into Fortran by N. Yamamoto(KEK), Nov. 1992
c
c/*   This is the parser code that is written into each bison parser
c     when the %semantic_parser declaration is not specified in the grammar.
c     It was written by Richard Stallman by simplifying the hairy parser
c     used when %semantic_parser is specified.  */
c
c/*   Note: there must be only one dollar sign in this file.
c     It is replaced by the list of actions, each action
c     as one case of the switch.  */


c/*   YYINITDEPTH indicates the initial size of the parser's stacks	*/
c/*   YYMAXDEPTH is the maximum size the stacks can grow to
c     (effective only if the built-in stack extension method is used).  */
c
c
      integer function yyparse(yyreturn)
c
c     yyparse function for tables generated by the BISON.
c
      implicit none
c delearation of the tables created by bison/ytabc2f
      include 'y.tab.inc'
c variables for BISON engine.
      integer*4 yystate,yyn,yyerrstatus,yychar,yychar1
      integer*4 yynerrs, YYEOF, NULL, NIL
      parameter (YYEOF = 0 , NULL = 0, NIL=0 )
      integer*4 yyssp,yyvsp,yyss,yyvs,yystacksize
      integer*4 yyssa(0:YYINITDEPTH)
      integer*4 yyreturn, yylex,yylen
c YYSTYPE variables. 
      YYSTYPE yyvsa(0:YYINITDEPTH), yylval, yyval
      logical   yydebug
c
	common /bison/ yytranslate,yyprhs,yyrhs,yyrline
     &	,yyr1,yyr2,yydefact,yydefgoto,yypact
     &	,yypgoto,yytable,yycheck
     $     ,yytname
	character*(80) yytname
c
      yydebug=.false.
      yyss = 0	
      yyvs = 0	
      yystacksize = YYINITDEPTH

      if (yydebug) print *,"Starting parse\n"

      yystate = 0
      yyerrstatus = 0
      yynerrs = 0
      yychar = YYEMPTY

      yyssp = yyss - 1
      yyvsp = yyvs

c     yynewstate:
 20   continue
      yyssp=yyssp+1
      yyssa(yyssp)=yystate

      if (yyssp .ge.  yyss + yystacksize - 1) then
         if( yystacksize .ge. YYMAXDEPTH) then
            call yyerror("parser stack overflow")
            yyparse=2
            return
         end if
         call yyerror( 'yacc stack overflow' )
         yyparse=1
         return
      end if

      if (yydebug)print *, "Entering state %d\n", yystate

c     yybackup:
 30   continue

      yyn = yypact(yystate)
      if (yyn .eq. YYFLAG) goto 40
      if (yychar .eq. YYEMPTY)then
         if (yydebug) print *, "Reading a token: "
         yychar=yylex(yylval,yyval)
      end if
      if (yychar .le. 0) then
c     /* This means end of input. */
         yychar1 = 0
         yychar = YYEOF
c     /* Don't call YYLEX any more */
         if (yydebug) print *, "Now at end of input.\n"
      else
         if(yychar .le. 322) then
            yychar1 = yytranslate(yychar)
         else
            yychar1 = 160
         end if
         if (yydebug) then
c     print *, "Next token is %d (%s)\n", yychar, yytname(yychar1)
            print *, "Next token is ", yychar
c     $           ,yytname(yychar1)
         end if
      end if
      yyn =yyn + yychar1
      if (yyn .lt. 0 .or. yyn .gt. YYLAST
     &     .or. yycheck(yyn) .ne. yychar1)
     &     go to 40

      yyn = yytable(yyn)

c     reduce

      if (yyn .lt.  0) then
         if (yyn .eq. YYFLAG) goto 50
         yyn = -yyn
         goto 60
      else if (yyn .eq. 0) then
         goto 50
      end if

      if (yyn .eq. YYFINAL) then
         yyparse=0
         return
      end if

      if (yydebug)
     &     print *, "Shifting token ", yychar

      if (yychar .ne. YYEOF) yychar = YYEMPTY
      yyvsp=yyvsp+1
      yyvsa(yyvsp) = yylval

c      print *,' new value of yyvsa(',yyvsp,') =',yyvsa(yyvsp),yylval

      if (yyerrstatus .ne. 0) yyerrstatus=yyerrstatus-1

      yystate = yyn
      goto 20

c/*   Do the default action for the current state.  */
c     yydefault:
 40   continue
      yyn = yydefact(yystate)
      if (yyn .eq.  0)	goto 50

c/* Do a reduction.  yyn is the number of a rule to reduce with.  */
c     yyreduce:
 60   continue
      yylen = yyr2(yyn)
      yyval = yyvsa(yyvsp+1-yylen)

c/* implement default value of the action */
c      if (yydebug) then
c         print *,  "Reducing via rule %d (line %d), ", yyn, yyrline(yyn)
c         i=yyprhs(yyn)
c 601     if( yyrhs(i) .gt. 0) then
c     print *, "%s ", yytname(yyrhs(i))
c     print *, " -> %s\n", yytname(yyr1(yyn))
c            i=i+1
c            go to 601
c         end if
c      end if

c$    /* the action file gets copied in in place of this dollarsign */
      include 'y.tab.act'

 1000	continue
c#line423"/usr/local/lib/bison.simple"

      yyvsp=yyvsp - yylen
      yyssp=yyssp - yylen

c      if (yydebug) then
c         ssp1 = yyss - 1
c         print *,"state stack now"
c 602     if (ssp1 .ne. yyssp) then
c            ssp1=ssp1+1
c            print *," %d", yyssa(ssp1)
c            go to 602
c         end if
c      endif

      yyvsp=yyvsp+1
      yyvsa(yyvsp) = yyval

c      print *,' new value of yyvsa(',yyvsp,') =',yyvsa(yyvsp),yylval

      yyn = yyr1(yyn)

      yystate = yypgoto(yyn - YYNTBASE) + yyssa(yyssp)
      if (yystate .ge. 0
     &     .and. yystate .le.  YYLAST
     &     .and. yycheck(yystate) .eq. yyssa(yyssp)) then
         yystate = yytable(yystate)
      else
         yystate = yydefgoto(yyn - YYNTBASE)
      end if
      goto 20

c     yyerrlab:   /* here on detecting error */
 50   continue
      if ( yyerrstatus .eq. 0 ) then
         yynerrs=yynerrs+1
         call yyerror("parse error")
      end if
c     yyerrlab1:   /* here on error raised explicitly by an action */
 70   continue
      if (yyerrstatus .eq. 3)then
         if (yychar .eq.  YYEOF)then
            yyparse= 1
            return
         end if

         if (yydebug)
     $        print *,'Discarding token ', yychar
c     $       , '(',yytname(yychar1),').'
c    $        print *, "Discarding token %d (%s).\n", yychar, yytname(yychar1)
         yychar = YYEMPTY
      end if

      yyerrstatus = 3
      goto 80

c     yyerrdefault:
c     /* current state does not do anything special for the error token. */
 90   continue

c     yyerrpop:
c     /* pop the current state because it cannot handle the error token */
 100  continue
      if (yyssp .eq.  yyss)then
         yyparse= 1
         return
      end if
      yyvsp=yyvsp-1
      yyssp=yyssp-1
      yystate = yyssa(yyssp)

c      if (yydebug)then
c         ssp1 = yyss - 1
c         print *, "Error: state stack now"
c 101     if (ssp1 .ne. yyssp) then
c            ssp1=ssp1+1
c            print *, " %d", yyssa(ssp1)
c            go to 101
c         end if
c      endif

c     yyerrhandle:
 80   continue

      yyn = yypact(yystate)
      if (yyn .eq.  YYFLAG)    goto 90

      yyn=yyn + YYTERROR
      if (yyn .lt. 0 .or. yyn .gt. YYLAST
     &    .or. yycheck(yyn) .ne. YYTERROR) goto 90

      yyn = yytable(yyn)
      if (yyn .lt.  0)then
         if (yyn .eq. YYFLAG) goto 100
         yyn = -yyn
         goto 60
      else if (yyn .eq. 0) then
         goto 100
      end if

      if (yyn .eq.  YYFINAL) then
	yyparse=0
	return
      endif

c      if (yydebug) print *, "Shifting error token, "

      yyvsp=yyvsp+1
      yyvsa(yyvsp) = yylval

c      print *,' new value of yyvsa(',yyvsp,') =',yyvsa(yyvsp),yylval

      yystate = yyn
      goto 20
c
      end
c
       block data bisoncom
       implicit none
c yylex common variables
       integer i
       include 'y.tab.inc'
c
	common /bison/ yytranslate,yyprhs,yyrhs,yyrline
     &	,yyr1,yyr2,yydefact,yydefgoto,yypact
     &	,yypgoto,yytable,yycheck
     &	,yytname
	character*(80) yytname
c
       include 'y.tab.tbl'
c
       end
